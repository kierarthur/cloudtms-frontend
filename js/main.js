// ===== Base URL + helpers =====
const BROKER_BASE_URL = window.BROKER_BASE_URL;
const API = (path)=> `${BROKER_BASE_URL}${path}`;

let SESSION = null;  // {accessToken, user, exp}
let refreshTimer = 0;

// ==== DEBUG SWITCHES (global) ====
// Put this at the very top of main.js so all functions can read them.
window.__LOG_RATES  = true;   // logs for rate staging + rates table + rates tab
window.__LOG_PAYTAB = true;   // logs for payment tab + umbrella prefill
window.__LOG_CONTRACTS = true;

window.__LOG_MODAL  = true;   // logs from modal framework (showModal)
const __LOG_API = true;   // turns on authFetch + rates/hospitals/client POST/PATCH logging

// Default friendly labels (fallbacks if user hasn't set custom labels for a section)
const DEFAULT_COLUMN_LABELS = {
  candidates: {
    first_name: 'First Name',
    last_name: 'Last Name',
    email: 'Email',
    phone: 'Phone',
    postcode: 'Postcode',
    role: 'Role',
    tms_ref: 'TMS Ref',
    job_titles_display: 'Job Titles',
    rev: 'Revision'
  },
  clients: {
    name: 'Client Name',
    primary_invoice_email: 'Invoice Email',
    invoice_address: 'Invoice Address',
    postcode: 'Postcode',
    ap_phone: 'A/P Phone',
    cli_ref: 'Client Ref',
    rev: 'Revision'
  },
  contracts: {
    candidate_display: 'Candidate',
    client_name: 'Client',
    role: 'Role',
    band: 'Band',
    pay_method_snapshot: 'Pay Method',
    default_submission_mode: 'Submission Mode',
    start_date: 'Start',
    end_date: 'End',
    bucket_labels_preview: 'Buckets'
  },
  audit: {
    created_at_utc: 'Created (UTC)',
    last_error: 'Last Error'
  }
};

const GRID_COLUMN_META_DEFAULTS = {
  // Candidate list (drawn from candidates + any summary fields you render)
  candidates: {
    id:                     { selectable: false },
    tms_ref:                { selectable: true },
    first_name:             { selectable: true },
    last_name:              { selectable: true },
    display_name:           { selectable: true },
    email:                  { selectable: true },
    phone:                  { selectable: true },
    mobile:                 { selectable: true },
    address_line1:          { selectable: false },
    address_line2:          { selectable: false },
    address_line3:          { selectable: false },
    town_city:              { selectable: true },
    county:                 { selectable: false },
    postcode:               { selectable: true },
    country:                { selectable: false },
    ni_number:              { selectable: true },
    date_of_birth:          { selectable: true },
    gender:                 { selectable: true },
    nationality:            { selectable: true },
    right_to_work_status:   { selectable: false },
    right_to_work_expiry:   { selectable: false },
    pay_method:             { selectable: true },
    job_titles_display:     { selectable: true },
    umbrella_id:            { selectable: false },
    bank_name:              { selectable: false },
    bank_account_name:      { selectable: true },
    bank_account_number:    { selectable: true },
    bank_sort_code:         { selectable: true },
    umbrella_name:          { selectable: true },
    umbrella_reference:     { selectable: false },
    notes:                  { selectable: true },
    status:                 { selectable: true },
    archived:               { selectable: true },
    active:                 { selectable: true },
    key_norm:               { selectable: false },
    created_at:             { selectable: true },
    updated_at:             { selectable: true },
    rev:                    { selectable: false },
    // derived / summary fields you show:
    roles_display:          { selectable: true },
    primary_role:           { selectable: true },
    bands_display:          { selectable: true },
    last_booking_date:      { selectable: true },
    next_booking_date:      { selectable: true }
  },

  // Clients (public.clients)
  clients: {
    id:                        { selectable: false },
    cli_ref:                   { selectable: true },
    name:                      { selectable: true },
    invoice_address:           { selectable: true },
    primary_invoice_email:     { selectable: true },
    ap_phone:                  { selectable: true },
    vat_chargeable:            { selectable: true },
    payment_terms_days:        { selectable: true },
    created_at:                { selectable: true },
    updated_at:                { selectable: true },
    mileage_charge_rate:       { selectable: true },
    ts_queries_email:          { selectable: true },
    rev:                       { selectable: false },
    // any extra client_settings snapshot fields you show in the grid:
    default_submission_mode:   { selectable: true },
    week_ending_weekday:       { selectable: true },
    pay_reference_required:    { selectable: true },
    invoice_reference_required:{ selectable: true },
    auto_invoice_default:      { selectable: true }
  },

  // Contracts (public.contracts + summary fields)
  contracts: {
    id:                           { selectable: false },
    tms_ref:                      { selectable: true },
    candidate_id:                 { selectable: false },
    client_id:                    { selectable: false },
    candidate_display:            { selectable: true }, // your summary label
    client_name:                  { selectable: true }, // joined from clients.name
    role:                         { selectable: true },
    band:                         { selectable: true },
    display_site:                 { selectable: true },
    ward_hint:                    { selectable: true },
    start_date:                   { selectable: true },
    end_date:                     { selectable: true },
    pay_method_snapshot:          { selectable: true },
    default_submission_mode:      { selectable: true },
    week_ending_weekday_snapshot: { selectable: true },
    auto_invoice:                 { selectable: true },
    require_reference_to_pay:     { selectable: true },
    require_reference_to_invoice: { selectable: true },
    status:                       { selectable: true }, // high-level status you derive (e.g. Active/Unassigned/Completed)
    status_detail:                { selectable: true }, // e.g. next action / next week
    // bucket labels
    bucket_labels_json:           { selectable: false },
    bucket_day:                   { selectable: false },
    bucket_night:                 { selectable: false },
    bucket_sat:                   { selectable: false },
    bucket_sun:                   { selectable: false },
    bucket_bh:                    { selectable: false },
    // convenience label columns you render:
    bucket_label_day:             { selectable: true },
    bucket_label_night:           { selectable: true },
    bucket_label_sat:             { selectable: true },
    bucket_label_sun:             { selectable: true },
    bucket_label_bh:              { selectable: true },
    // rates_json is complex; but you might expose individual buckets:
    paye_day:                     { selectable: true },
    paye_night:                   { selectable: true },
    paye_sat:                     { selectable: true },
    paye_sun:                     { selectable: true },
    paye_bh:                      { selectable: true },
    umb_day:                      { selectable: true },
    umb_night:                    { selectable: true },
    umb_sat:                      { selectable: true },
    umb_sun:                      { selectable: true },
    umb_bh:                       { selectable: true },
    charge_day:                   { selectable: true },
    charge_night:                 { selectable: true },
    charge_sat:                   { selectable: true },
    charge_sun:                   { selectable: true },
    charge_bh:                    { selectable: true },
    // mileage
    mileage_pay_rate:             { selectable: true },
    mileage_charge_rate:          { selectable: true },
    // schedule / hours if ever surfaced:
    std_schedule_json:            { selectable: false },
    std_hours_json:               { selectable: false },
    gh_mon:                       { selectable: false },
    gh_tue:                       { selectable: false },
    gh_wed:                       { selectable: false },
    gh_thu:                       { selectable: false },
    gh_fri:                       { selectable: false },
    gh_sat:                       { selectable: false },
    gh_sun:                       { selectable: false },
    // meta
    created_at:                   { selectable: true },
    updated_at:                   { selectable: true },
    rev:                          { selectable: false }
  },

  // Timesheets (timesheet summary view)
  timesheets: {
    id:                      { selectable: true },
    timesheet_id:            { selectable: true },
    booking_id:              { selectable: true },
    candidate_id:            { selectable: true },
    candidate_display:       { selectable: true },
    client_id:               { selectable: true },
    client_name:             { selectable: true },
    hospital:                { selectable: true },
    ward:                    { selectable: true },
    unit:                    { selectable: true },
    role_code:               { selectable: true },
    band:                    { selectable: true },
    start_utc:               { selectable: true },
    end_utc:                 { selectable: true },
    work_date:               { selectable: true },
    week_ending_date:        { selectable: true },
    submission_mode:         { selectable: true },
    authorised:              { selectable: true },
    authorised_at_utc:       { selectable: true },
    status:                  { selectable: true },   // high-level status string
    processing_status:       { selectable: true },   // ts_fin_processing_status_enum
    fin_basis:               { selectable: true },   // timesheet_fin_basis_enum
    pay_method:              { selectable: true },
    hours_day:               { selectable: true },
    hours_night:             { selectable: true },
    hours_sat:               { selectable: true },
    hours_sun:               { selectable: true },
    hours_bh:                { selectable: true },
    total_hours:             { selectable: true },
    pay_rate_day:            { selectable: true },
    pay_rate_night:          { selectable: true },
    pay_rate_sat:            { selectable: true },
    pay_rate_sun:            { selectable: true },
    pay_rate_bh:             { selectable: true },
    charge_rate_day:         { selectable: true },
    charge_rate_night:       { selectable: true },
    charge_rate_sat:         { selectable: true },
    charge_rate_sun:         { selectable: true },
    charge_rate_bh:          { selectable: true },
    pay_total:               { selectable: true },
    charge_total:            { selectable: true },
    margin_total:            { selectable: true },
    pay_on_hold:             { selectable: true },
    remittance_last_sent_at: { selectable: true },
    created_at:              { selectable: true },
    updated_at:              { selectable: true },

    // NEW: Issues badges column from v_timesheets_summary
    issue_codes:             { selectable: true }
  },

  // Invoices (public.invoices)
  invoices: {
    id:                     { selectable: true },
    type:                   { selectable: true },
    invoice_no:             { selectable: true },
    client_id:              { selectable: true },
    client_name:            { selectable: true }, // joined from clients
    issued_at_utc:          { selectable: true },
    due_at_utc:             { selectable: true },
    paid_at_utc:            { selectable: true },
    status:                 { selectable: true },
    status_date_utc:        { selectable: true },
    currency:               { selectable: true },
    subtotal_ex_vat:        { selectable: true },
    vat_rate_pct:           { selectable: true },
    vat_amount:             { selectable: true },
    total_inc_vat:          { selectable: true },
    credit_note_total:      { selectable: true },
    balance_outstanding:    { selectable: true },
    on_hold:                { selectable: true },
    on_hold_reason:         { selectable: true },
    original_invoice_id:    { selectable: true },
    created_at:             { selectable: true },
    updated_at:             { selectable: true }
  },

  // Umbrellas (public.umbrellas)
  umbrellas: {
    id:             { selectable: false },
    name:           { selectable: true },
    email:          { selectable: true },
    phone:          { selectable: true },
    address_line1:  { selectable: false },
    address_line2:  { selectable: false },
    address_line3:  { selectable: false },
    town_city:      { selectable: false },
    county:         { selectable: false },
    postcode:       { selectable: false },
    country:        { selectable: false },
    bank_name:      { selectable: true },
    bank_account:   { selectable: true },
    bank_sort_code: { selectable: true },
    vat_number:     { selectable: true },
    company_number: { selectable: true },
    active:         { selectable: true },
    created_at:     { selectable: true },
    updated_at:     { selectable: true },
    rev:            { selectable: false }
  },

  // Audit / mail_outbox (public.mail_outbox)
  audit: {
    id:           { selectable: true },
    type:         { selectable: true },
    to:           { selectable: true },
    cc:           { selectable: true },
    subject:      { selectable: true },
    body_html:    { selectable: true },
    body_text:    { selectable: true },
    attachments:  { selectable: true },
    status:       { selectable: true },
    last_error:   { selectable: true },
    provider:     { selectable: true },
    provider_id:  { selectable: true },
    created_at:   { selectable: true },
    updated_at:   { selectable: true },
    sent_at:      { selectable: true },
    failed_at:    { selectable: true },
    attempts:     { selectable: true }
  }
};


// Quick DOM helper
const byId = (id)=>document.getElementById(id);

// ===== Session handling =====
function saveSession(sess){
  SESSION = sess;
  const persist = document.getElementById('rememberMe')?.checked ?? true;
  const store = persist ? localStorage : sessionStorage;
  store.setItem('cloudtms.session', JSON.stringify(sess));
  if (persist) sessionStorage.removeItem('cloudtms.session');
  scheduleRefresh();
  renderUserChip();
}
// FRONTEND â€” loadUserGridPrefs
async function loadUserGridPrefs(section) {
  // If already loaded and shaped correctly, just reuse
  if (window.__gridPrefs && typeof window.__gridPrefs === 'object') {
    if (!window.__gridPrefs.grid || typeof window.__gridPrefs.grid !== 'object') {
      window.__gridPrefs = { grid: {} };
    }
    if (!window.__gridPrefs.grid[section] || typeof window.__gridPrefs.grid[section] !== 'object') {
      window.__gridPrefs.grid[section] = {};
    }
    return window.__gridPrefs;
  }

  // GET once per app session from backend (which applies defaults if needed)
  let prefs;
  try {
    const res = await authFetch(API('/api/users/me/grid-prefs'));
    prefs = (await res.json()) || {};
  } catch (e) {
    console.error('[GRID] failed to load user grid prefs', e);
    prefs = {};
  }

  // Normalise to at least { grid: {} }
  if (!prefs || typeof prefs !== 'object') {
    prefs = { grid: {} };
  }
  if (!prefs.grid || typeof prefs.grid !== 'object') {
    prefs.grid = {};
  }
  // ensure object for this section
  if (!prefs.grid[section] || typeof prefs.grid[section] !== 'object') {
    prefs.grid[section] = {};
  }

  // One-time import from legacy localStorage, if present and no columns yet
  try {
    const legacyKey = 'cloudtms.cols.' + section;
    const legacy = localStorage.getItem(legacyKey);
    if (legacy && !prefs.grid[section].columns) {
      const cols = JSON.parse(legacy);
      if (Array.isArray(cols)) {
        const columns = {};
        cols.forEach((k, i) => {
          columns[k] = { visible: true, order: i };
        });
        prefs.grid[section].columns = columns;
        // Persist immediately so backend has them
        window.__gridPrefs = prefs;
        await saveUserGridPrefsDebounced(section, { columns }, true);
      }
      try { localStorage.removeItem(legacyKey); } catch (_) {}
    }
  } catch (e) {
    console.warn('[GRID] legacy grid prefs import failed', e);
  }

  window.__gridPrefs = prefs;
  return prefs;
}

const __saveTimers = new Map();
async function saveUserGridPrefsDebounced(section, partial, immediate = false) {
  // Ensure global shape
  if (!window.__gridPrefs || typeof window.__gridPrefs !== 'object') {
    window.__gridPrefs = { grid: {} };
  }
  if (!window.__gridPrefs.grid || typeof window.__gridPrefs.grid !== 'object') {
    window.__gridPrefs.grid = {};
  }

  const grid = window.__gridPrefs.grid;
  const existing = (grid[section] && typeof grid[section] === 'object') ? grid[section] : {};
  grid[section] = { ...existing, ...(partial || {}) };

  const key = `grid:${section}`;

  const fire = async () => {
   const body = {
  section,
  prefs: grid[section] || {}
};

    try {
      const res = await authFetch(API('/api/users/me/grid-prefs'), {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body)
      });
      const saved = await res.json().catch(() => null);
      // If server returned a full prefs object with .grid, adopt it as source of truth
      if (saved && typeof saved === 'object' && saved.grid && typeof saved.grid === 'object') {
        window.__gridPrefs = saved;
      }
    } catch (e) {
      console.error('Failed to save grid prefs', e);
    }
  };

  if (immediate) {
    return fire();
  }

  window.__saveTimers = window.__saveTimers || new Map();
  if (window.__saveTimers.has(key)) {
    clearTimeout(window.__saveTimers.get(key));
  }
  window.__saveTimers.set(key, setTimeout(fire, 300));
}

function getVisibleColumnsForSection(section, rows) {
  const defaults = (typeof defaultColumnKeysForSection === 'function')
    ? defaultColumnKeysForSection(section)
    : (typeof defaultColumnsFor === 'function'
        ? defaultColumnsFor(section)
        : []);

  const root = (window.__gridPrefs && window.__gridPrefs.grid) || {};
  const prefsRoot = (root[section] && typeof root[section] === 'object') ? root[section] : {};
  const colPrefs  = prefsRoot.columns      || {};
  const userMeta  = prefsRoot.columns_meta || {};

  const globalMeta =
    (typeof GRID_COLUMN_META_DEFAULTS === 'object' &&
     GRID_COLUMN_META_DEFAULTS[section]) || {};

  // Build catalog of known columns: defaults + first row's keys
  const known = new Set(defaults);
  if (Array.isArray(rows) && rows.length > 0 && rows[0] && typeof rows[0] === 'object') {
    Object.keys(rows[0]).forEach((k) => known.add(k));
  }

  const entries = Array.from(known).map((k) => {
    const p = colPrefs[k] || {};
    const meta = {
      ...(globalMeta[k] || {}),
      ...(userMeta[k]   || {})
    };

    const selectable = (meta.selectable !== false); // default true
    const visible    = (p.visible !== false);       // default true

    const order = (typeof p.order === 'number')
      ? p.order
      : (defaults.indexOf(k) >= 0 ? defaults.indexOf(k) : 9999);

    const width = (typeof p.width === 'number') ? p.width : null;

    return { key: k, selectable, visible, order, width };
  });

  // Only include columns that are globally/user-selectable AND marked visible
  const filtered = entries.filter((e) => e.selectable && e.visible);
  filtered.sort((a, b) => a.order - b.order);

  return filtered.map((e) => e.key);
}

function applyUserGridPrefs(section, tables, cols) {
  const root = (window.__gridPrefs && window.__gridPrefs.grid) || {};
  const prefsRoot = root[section] || {};
  const colPrefs = prefsRoot.columns || {};
  const MIN_W = 80, MAX_W = 600;

  const headTable = (tables && tables.head) ? tables.head : tables;
  const bodyTable = (tables && tables.body) ? tables.body : tables;

  const widthOf = (k) => {
    let w = colPrefs[k]?.width;
    if (typeof w !== 'number' || !(w > 0)) return null; // auto â†’ weâ€™ll measure below
    if (w < MIN_W) w = MIN_W;
    if (w > MAX_W) w = MAX_W;
    return w;
  };

  const setColWidthPx = (colKey, pxOrNull) => {
    if (headTable) {
      const th = headTable.querySelector(
        `thead th[data-col-key="${CSS.escape(colKey)}"]`
      );
      if (th) {
        th.style.width = (pxOrNull == null ? '' : `${pxOrNull}px`);
      }
    }

    if (bodyTable) {
      const tds = bodyTable.querySelectorAll(
        `tbody td[data-col-key="${CSS.escape(colKey)}"]`
      );
      tds.forEach(td => {
        td.style.width = (pxOrNull == null ? '' : `${pxOrNull}px`);
      });
    }
  };

  // ðŸ”‘ NEW: ensure we have a mutable columns prefs object so we can persist
  const ensureColsPrefs = () => {
    window.__gridPrefs = window.__gridPrefs || { grid: {} };
    window.__gridPrefs.grid = window.__gridPrefs.grid || {};
    const g = window.__gridPrefs.grid;
    g[section] = g[section] || {};
    g[section].columns = g[section].columns || {};
    return g[section].columns;
  };

  (cols || []).forEach((k) => {
    let w = widthOf(k);

    // If no saved width, measure the header cellâ€™s current width
    if (w == null && headTable) {
      const th = headTable.querySelector(
        `thead th[data-col-key="${CSS.escape(k)}"]`
      );
      if (th) {
        const rect = th.getBoundingClientRect();
        w = Math.round(rect.width);
        if (w < MIN_W) w = MIN_W;
        if (w > MAX_W) w = MAX_W;

        // Persist this as the columnâ€™s width so future renders stay aligned
        const colsPrefs = ensureColsPrefs();
        colsPrefs[k] = { ...(colsPrefs[k] || {}), width: w };
        // Fire-and-forget; no need to await
        saveUserGridPrefsDebounced(section, { columns: colsPrefs });
      }
    }

    // Now apply the width (either from prefs or measured)
    if (w != null) {
      setColWidthPx(k, w);
    }
  });
}

function wireGridColumnResizing(section, tables) {
  const MIN_W = 80, MAX_W = 600;

  const headTable = (tables && tables.head) ? tables.head : tables;
  const bodyTable = (tables && tables.body) ? tables.body : tables;

  const ensureColsPrefs = () => {
    if (!window.__gridPrefs || typeof window.__gridPrefs !== 'object') {
      window.__gridPrefs = { grid: {} };
    }
    if (!window.__gridPrefs.grid || typeof window.__gridPrefs.grid !== 'object') {
      window.__gridPrefs.grid = {};
    }
    const g = window.__gridPrefs.grid;
    g[section] = g[section] || {};
    g[section].columns = g[section].columns || {};
    return g[section].columns;
  };

  let drag = null;

  const onMove = (ev) => {
    if (!drag) return;
    const dx = (ev.clientX || 0) - drag.startX;
    let w = Math.max(MIN_W, Math.min(MAX_W, drag.startW + dx));
    drag.th.style.width = `${w}px`;
    drag.cells.forEach(td => { td.style.width = `${w}px`; });
  };

  const onUp = () => {
    if (!drag) return;
    const th = drag.th;
    const key = th.dataset.colKey;
    const rect = th.getBoundingClientRect();
    const w = Math.max(MIN_W, Math.min(MAX_W, Math.round(rect.width)));
    const colsPrefs = ensureColsPrefs();
    colsPrefs[key] = { ...(colsPrefs[key] || {}), width: w };
    saveUserGridPrefsDebounced(section, { columns: colsPrefs });
    drag = null;
    document.removeEventListener('mousemove', onMove);
    document.removeEventListener('mouseup', onUp, true);
  };

  if (!headTable) return;

  headTable.querySelectorAll('thead th').forEach((th) => {
    const handle = th.querySelector('.col-resizer');
    if (!handle) return;

    handle.addEventListener('mousedown', (ev) => {
      ev.preventDefault();
      ev.stopPropagation();
      const key = th.dataset.colKey;
      const cells = bodyTable
        ? Array.from(bodyTable.querySelectorAll(`tbody td[data-col-key="${CSS.escape(key)}"]`))
        : [];
      drag = {
        th,
        startX: ev.clientX || 0,
        startW: Math.round(th.getBoundingClientRect().width || MIN_W),
        cells
      };
      document.addEventListener('mousemove', onMove);
      document.addEventListener('mouseup', onUp, true);
    });

    // Double-click handle resets width for this column to auto
    handle.addEventListener('dblclick', (ev) => {
      ev.preventDefault();
      ev.stopPropagation();
      const key = th.dataset.colKey;
      th.style.width = '';
      if (bodyTable) {
        bodyTable
          .querySelectorAll(`tbody td[data-col-key="${CSS.escape(key)}"]`)
          .forEach(td => { td.style.width = ''; });
      }
      const colsPrefs = ensureColsPrefs();
      if (colsPrefs[key]) delete colsPrefs[key].width;
      saveUserGridPrefsDebounced(section, { columns: colsPrefs });
    });
  });
}

// FRONTEND â€” wireGridColumnReorder
function wireGridColumnReorder(section, tables) {
  const headTable = (tables && tables.head) ? tables.head : tables;

  const ensureSectionPrefs = () => {
    if (!window.__gridPrefs || typeof window.__gridPrefs !== 'object') {
      window.__gridPrefs = { grid: {} };
    }
    if (!window.__gridPrefs.grid || typeof window.__gridPrefs.grid !== 'object') {
      window.__gridPrefs.grid = {};
    }
    const g = window.__gridPrefs.grid;
    g[section] = g[section] || {};
    g[section].columns = g[section].columns || {};
    return g[section];
  };

  if (!headTable) return;

  let dragKey = null;

  headTable.querySelectorAll('thead th[data-col-key]').forEach((th) => {
    if (!th.dataset.colKey) return;

    th.addEventListener('dragstart', (ev) => {
      dragKey = th.dataset.colKey;
      if (ev.dataTransfer) {
        ev.dataTransfer.setData('text/plain', dragKey);
        ev.dataTransfer.effectAllowed = 'move';
      }
    });

    th.addEventListener('dragover', (ev) => {
      ev.preventDefault();
      if (ev.dataTransfer) {
        ev.dataTransfer.dropEffect = 'move';
      }
    });

    th.addEventListener('drop', async (ev) => {
      ev.preventDefault();
      const targetKey = th.dataset.colKey;
      if (!dragKey || dragKey === targetKey) return;

      const headers = Array.from(headTable.querySelectorAll('thead th[data-col-key]'));
      const keys = headers.map((h) => h.dataset.colKey);

      const from = keys.indexOf(dragKey);
      const to   = keys.indexOf(targetKey);
      if (from < 0 || to < 0) return;

      // Move dragKey to the index of targetKey
      keys.splice(to, 0, keys.splice(from, 1)[0]);

      const secPrefs = ensureSectionPrefs();
      const colPrefs = { ...(secPrefs.columns || {}) };

      keys.forEach((k, i) => {
        colPrefs[k] = { ...(colPrefs[k] || {}), order: i };
      });

      await saveUserGridPrefsDebounced(section, { columns: colPrefs }, true);

      const data = await loadSection();
      renderSummary(data);
    });
  });
}

// === Shared field error helpers (red highlight + âœ–) =======================

function clearFieldErrors(root) {
  if (!root) return;
  root.querySelectorAll('.field-error, .error').forEach(el => {
    el.classList.remove('field-error');
    el.classList.remove('error');
  });
  root.querySelectorAll('.field-error-msg').forEach(el => el.remove());
  root.querySelectorAll('.field-error-icon').forEach(el => el.remove());
}

function markFieldError(root, fieldName, message) {
  if (!root) return;
  let field = root.querySelector(`[name="${fieldName}"]`);
  if (!field) field = root.querySelector(`#${fieldName}`);
  if (!field) return;

  const row = field.closest('.row') || field.parentElement;
  if (!row) return;

  row.classList.add('field-error');
  row.classList.add('error');
  field.classList.add('field-error');

  const label = row.querySelector('label');
  if (label && !label.querySelector('.field-error-icon')) {
    const icon = document.createElement('span');
    icon.className = 'field-error-icon';
    icon.textContent = 'âœ–';
    icon.style.color = 'red';
    icon.style.marginLeft = '4px';
    label.appendChild(icon);
  }

  if (message) {
    let msg = row.querySelector('.field-error-msg');
    if (!msg) {
      msg = document.createElement('div');
      msg.className = 'field-error-msg';
      msg.style.color = 'red';
      msg.style.fontSize = '0.8em';
      msg.style.marginTop = '4px';
      row.appendChild(msg);
    }
    msg.textContent = message;
  }
}

// === Candidate main tab validation =======================================

function validateCandidateMain(payload) {
  const root = document.querySelector('#tab-main');
  if (!root) return true;

  clearFieldErrors(root);
  let ok = true;

  const first = (payload.first_name || '').trim();
  const last  = (payload.last_name  || '').trim();
  if (!first) {
    ok = false;
    markFieldError(root, 'first_name', 'First name is required');
  }
  if (!last) {
    ok = false;
    markFieldError(root, 'last_name', 'Last name is required');
  }

  // Telephone: required, optional leading +, digits only, >= 11 digits
  const phoneRaw = (payload.phone || '').trim();
  if (!phoneRaw) {
    ok = false;
    markFieldError(root, 'phone', 'Telephone number is required');
  } else {
    const phoneDigits = phoneRaw.replace(/\D/g, '');
    const phonePattern = /^\+?\d+$/;
    if (!phonePattern.test(phoneRaw) || phoneDigits.length < 11) {
      ok = false;
      markFieldError(root, 'phone', 'Telephone must be numbers only (optionally leading +) and at least 11 digits');
    }
  }

  // Email: required, simple email format
  const emailRaw = (payload.email || '').trim();
  if (!emailRaw) {
    ok = false;
    markFieldError(root, 'email', 'Email is required');
  } else {
    const emailPattern = /^[^@\s]+@[^@\s]+\.[^@\s]+$/;
    if (!emailPattern.test(emailRaw)) {
      ok = false;
      markFieldError(root, 'email', 'Please enter a valid email address');
    }
  }

  // NI: optional, but if present must be AA999999A (2 letters, 6 digits, 1 letter)
  const niRaw = (payload.ni_number || '').trim();
  if (niRaw) {
    const normNi = niRaw.replace(/\s+/g, '').toUpperCase();
    const niPattern = /^[A-Z]{2}\d{6}[A-Z]$/;
    if (!niPattern.test(normNi)) {
      ok = false;
      markFieldError(root, 'ni_number', 'Format must be like JR547853B');
    } else {
      payload.ni_number = normNi; // normalise for save
    }
  }

  // Gender: must be selected (not blank option)
  const genderRaw = (payload.gender || '').trim();
  if (!genderRaw) {
    ok = false;
    markFieldError(root, 'gender', 'Please select a gender');
  }

  // Address: either completely blank, or must have line 1 AND postcode
  const address1 = (payload.address_line1 || '').trim();
  const address2 = (payload.address_line2 || '').trim();
  const address3 = (payload.address_line3 || '').trim();
  const town     = (payload.town_city     || '').trim();
  const county   = (payload.county        || '').trim();
  const postcode = (payload.postcode      || '').trim();

  const anyAddress = address1 || address2 || address3 || town || county || postcode;
  if (anyAddress) {
    if (!address1) {
      ok = false;
      markFieldError(root, 'address_line1', 'Address line 1 is required when an address is entered');
    }
    if (!postcode) {
      ok = false;
      markFieldError(root, 'postcode', 'Postcode is required when an address is entered');
    }
  }

  return ok;
}

// === Client main tab validation ==========================================

function validateClientMain(payload) {
  const root = document.querySelector('#tab-main');
  if (!root) return true;

  clearFieldErrors(root);
  let ok = true;

  const name = (payload.name || '').trim();
  if (!name) {
    ok = false;
    markFieldError(root, 'name', 'Client name is required');
  }

  // Primary invoice email: required, simple email format
  const emailRaw = (payload.primary_invoice_email || '').trim();
  if (!emailRaw) {
    ok = false;
    markFieldError(root, 'primary_invoice_email', 'Primary invoice email is required');
  } else {
    const emailPattern = /^[^@\s]+@[^@\s]+\.[^@\s]+$/;
    if (!emailPattern.test(emailRaw)) {
      ok = false;
      markFieldError(root, 'primary_invoice_email', 'Please enter a valid invoice email');
    }
  }

  // A/P phone: blank OR >= 8 digits, numbers only (no letters)
  const apPhoneRaw = (payload.ap_phone || '').trim();
  if (apPhoneRaw) {
    const digitsOnly = /^\d+$/;
    const digits = apPhoneRaw.replace(/\D/g, '');
    if (!digitsOnly.test(apPhoneRaw) || digits.length < 8) {
      ok = false;
      markFieldError(root, 'ap_phone', 'A/P phone must be numbers only and at least 8 digits if entered');
    }
  }

  return ok;
}





async function restoreGridPrefsToDefault(section) {
  try {
    const res = await authFetch(API('/api/users/me/grid-prefs'), {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ section, reset: true })
    });
    const prefs = await res.json().catch(() => null);
    if (prefs && typeof prefs === 'object' && prefs.grid) {
      window.__gridPrefs = prefs;
    } else {
      window.__gridPrefs = prefs || { grid: {} };
    }

    await loadUserGridPrefs(section);
    const data = await loadSection();
    renderSummary(data);
  } catch (e) {
    console.error('[GRID] restoreGridPrefsToDefault failed', e);
  }
}
// FRONTEND â€” attachHeaderContextMenu
function attachHeaderContextMenu(section, tables) {
  const headTable = (tables && tables.head) ? tables.head : tables;
  const bodyTable = (tables && tables.body) ? tables.body : tables;

  let menu = document.createElement('div');
  menu.style.cssText =
    'position:fixed;z-index:10000;background:#0b1528;border:1px solid var(--line);' +
    'padding:6px;border-radius:8px;display:none;min-width:220px;';
  document.body.appendChild(menu);

  const hide = () => { menu.style.display = 'none'; };
  document.addEventListener('click', hide);
  document.addEventListener('keydown', (e) => { if (e.key === 'Escape') hide(); });

  const mkItem = (label, cb) => {
    const it = document.createElement('div');
    it.textContent = label;
    it.style.cssText = 'padding:6px 10px;cursor:pointer;';
    it.addEventListener('click', () => { hide(); cb && cb(); });
    it.addEventListener('mouseover', () => { it.style.background = '#101c36'; });
    it.addEventListener('mouseout',  () => { it.style.background = 'transparent'; });
    return it;
  };

  const ensureSectionPrefs = () => {
    if (!window.__gridPrefs || typeof window.__gridPrefs !== 'object') {
      window.__gridPrefs = { grid: {} };
    }
    if (!window.__gridPrefs.grid || typeof window.__gridPrefs.grid !== 'object') {
      window.__gridPrefs.grid = {};
    }
    const g = window.__gridPrefs.grid;
    g[section] = g[section] || {};
    g[section].columns = g[section].columns || {};
    return g[section];
  };

  const resetAllWidths = () => {
    const sec = ensureSectionPrefs();
    const cols = { ...(sec.columns || {}) };
    Object.keys(cols).forEach((k) => {
      if ('width' in cols[k]) delete cols[k].width;
    });

    if (headTable) {
      headTable.querySelectorAll('thead th[data-col-key]').forEach((th) => {
        th.style.width = '';
      });
    }
    if (bodyTable) {
      bodyTable.querySelectorAll('tbody td[data-col-key]').forEach((td) => {
        td.style.width = '';
      });
    }

    saveUserGridPrefsDebounced(section, { columns: cols }, true);
  };

  const autoWidthThisColumn = (colKey) => {
    if (!headTable) return;
    const th = headTable.querySelector(`thead th[data-col-key="${CSS.escape(colKey)}"]`);
    if (!th) return;

    const cells = bodyTable
      ? bodyTable.querySelectorAll(`tbody td[data-col-key="${CSS.escape(colKey)}"]`)
      : [];

    const measure = (el) => Math.ceil(el.scrollWidth) + 16;
    let maxW = measure(th);
    cells.forEach((td) => { maxW = Math.max(maxW, measure(td)); });

    const w = Math.max(80, Math.min(600, maxW));
    th.style.width = `${w}px`;
    cells.forEach((td) => { td.style.width = `${w}px`; });

    const sec = ensureSectionPrefs();
    const cols = { ...(sec.columns || {}) };
    cols[colKey] = { ...(cols[colKey] || {}), width: w };
    saveUserGridPrefsDebounced(section, { columns: cols }, true);
  };

  if (!headTable) return;

  headTable.addEventListener('contextmenu', (ev) => {
    const th = ev.target && ev.target.closest('th');
    if (!th || !th.dataset || !th.dataset.colKey) return;
    ev.preventDefault();

    const colKey = th.dataset.colKey;
    menu.innerHTML = '';

    // Restore full layout for this section from backend defaults
    menu.appendChild(
      mkItem('Restore layout to default', () => {
        restoreGridPrefsToDefault(section);
      })
    );

    // Reset only widths for this section
    menu.appendChild(
      mkItem('Reset View (Auto widths)', () => resetAllWidths())
    );

    const hr = document.createElement('hr');
    hr.style.border = '1px solid var(' + '--line' + ')';
    menu.appendChild(hr);

    menu.appendChild(
      mkItem('Auto-size this column', () => autoWidthThisColumn(colKey))
    );

    menu.appendChild(
      mkItem('Reset this column width', () => {
        th.style.width = '';
        if (bodyTable) {
          bodyTable
            .querySelectorAll(`tbody td[data-col-key="${CSS.escape(colKey)}"]`)
            .forEach(td => { td.style.width = ''; });
        }

        const sec = ensureSectionPrefs();
        const cols = { ...(sec.columns || {}) };
        if (cols[colKey]) delete cols[colKey].width;
        saveUserGridPrefsDebounced(section, { columns: cols }, true);
      })
    );

    menu.appendChild(
      mkItem('Hide column', async () => {
        const sec = ensureSectionPrefs();
        const cols = { ...(sec.columns || {}) };
        cols[colKey] = { ...(cols[colKey] || {}), visible: false };
        await saveUserGridPrefsDebounced(section, { columns: cols }, true);
        const data = await loadSection();
        renderSummary(data);
      })
    );

    menu.appendChild(
      mkItem('Columnsâ€¦', () => openColumnsDialog(section))
    );

    // Position the context menu
    menu.style.left = `${ev.clientX}px`;
    menu.style.top  = `${ev.clientY}px`;
    menu.style.display = 'block';
  });
}

function openColumnsDialog(section) {
  const rootPrefs =
    (window.__gridPrefs &&
     window.__gridPrefs.grid &&
     window.__gridPrefs.grid[section]) || {};

  const colPrefs  = rootPrefs.columns      || {};
  const userMeta  = rootPrefs.columns_meta || {};
  const globalMeta = (typeof GRID_COLUMN_META_DEFAULTS === 'object' && GRID_COLUMN_META_DEFAULTS[section]) || {};

  const mergeMetaFor = (key) => ({
    ...(globalMeta[key] || {}),
    ...(userMeta[key]   || {})
  });

  const useFriendly = (rootPrefs.use_friendly_labels !== false);
  const labels      = rootPrefs.labels || {};

  // Build master key list: visible columns, defaults, current row keys
  const known = new Set(
    getVisibleColumnsForSection(section, currentRows).concat(defaultColumnsFor(section))
  );
  if (Array.isArray(currentRows) && currentRows[0]) {
    Object.keys(currentRows[0]).forEach(k => known.add(k));
  }

  // Filter out columns that are globally/user marked selectable:false
  const list = Array.from(known).filter(k => {
    const meta = mergeMetaFor(k);
    return meta.selectable !== false;
  });

  const overlay = document.createElement('div');
  overlay.style.cssText =
    'position:fixed;inset:0;background:rgba(0,0,0,0.5);z-index:10000;' +
    'display:flex;align-items:center;justify-content:center;';
  const modal = document.createElement('div');
  modal.style.cssText =
    'background:#0b152a;border:1px solid var(--line);border-radius:10px;' +
    'min-width:480px;max-width:80vw;max-height:80vh;overflow:auto;padding:14px;';
  overlay.appendChild(modal);

  const title = document.createElement('div');
  title.textContent = `Columns â€” ${section}`;
  title.style.cssText = 'font-weight:600;margin-bottom:10px;';
  modal.appendChild(title);

  // Friendly labels toggle
  const lblWrap = document.createElement('label');
  const lblCb = document.createElement('input');
  lblCb.type = 'checkbox';
  lblCb.checked = useFriendly;
  lblWrap.appendChild(lblCb);
  lblWrap.appendChild(document.createTextNode(' Use friendly header labels'));
  lblWrap.style.cssText = 'display:flex;align-items:center;gap:8px;margin-bottom:8px;font-size:12px;';
  modal.appendChild(lblWrap);

  lblCb.addEventListener('change', () => {
    saveUserGridPrefsDebounced(section, { use_friendly_labels: !!lblCb.checked });
  });

  // Table: Visible + Column key + Display name + Order
  const t = document.createElement('table');
  t.style.cssText = 'width:100%;border-collapse:collapse;font-size:12px;';
  t.innerHTML = `
    <thead>
      <tr>
        <th style="text-align:left;padding:6px;border-bottom:1px solid var(--line)">Visible</th>
        <th style="text-align:left;padding:6px;border-bottom:1px solid var(--line)">Column key</th>
        <th style="text-align:left;padding:6px;border-bottom:1px solid var(--line)">Display name</th>
        <th style="text-align:left;padding:6px;border-bottom:1px solid var(--line)">Order</th>
      </tr>
    </thead>
    <tbody></tbody>
  `;
  modal.appendChild(t);
  const tb = t.querySelector('tbody');

  const orderOf = (k) => {
    const cp = colPrefs[k];
    if (cp && typeof cp.order === 'number') return cp.order;
    const idx = defaultColumnsFor(section).indexOf(k);
    return (idx >= 0 ? idx : 9999);
  };

  const rowsModel = list
    .map(k => ({
      key: k,
      visible: (colPrefs[k]?.visible !== false),
      label: labels[k] || k,
      order: orderOf(k)
    }))
    .sort((a, b) => a.order - b.order);

  const persist = () => {
    const columns   = {};
    const labelsOut = {};
    const metaOut   = { ...(rootPrefs.columns_meta || {}) }; // carry existing meta

    rowsModel.forEach((r, idx) => {
      columns[r.key] = { visible: !!r.visible, order: r.order };
      labelsOut[r.key] = String(r.label || r.key);
    });

    saveUserGridPrefsDebounced(section, {
      columns,
      labels: labelsOut,
      columns_meta: metaOut,
      use_friendly_labels: !!lblCb.checked
    });
  };

  const reindex = () => {
    rowsModel.forEach((r, i) => { r.order = i; });
    persist();
    refresh();
  };

  const refresh = () => {
    tb.innerHTML = '';
    rowsModel.sort((a, b) => a.order - b.order).forEach(r => {
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td style="padding:6px"><input type="checkbox" ${r.visible ? 'checked' : ''}></td>
        <td style="padding:6px;font-family:monospace">${r.key}</td>
        <td style="padding:6px"><input type="text" style="width:100%;background:#000;border:1px solid var(--line);color:var(--text);border-radius:6px;padding:4px 8px;font-size:12px;"></td>
        <td style="padding:6px;white-space:nowrap">
          <button class="btn mini" data-move="up">â–²</button>
          <button class="btn mini" data-move="down">â–¼</button>
        </td>
      `;

      const elVisible = tr.querySelector('td:nth-child(1) input');
      const elLabel   = tr.querySelector('td:nth-child(3) input');
      const btnUp     = tr.querySelector('button[data-move="up"]');
      const btnDown   = tr.querySelector('button[data-move="down"]');

      elLabel.value = r.label;

      elVisible.addEventListener('change', () => {
        r.visible = !!elVisible.checked;
        persist();
      });

      elLabel.addEventListener('change', () => {
        r.label = elLabel.value;
        persist();
      });

      btnUp.addEventListener('click', () => {
        const i = rowsModel.indexOf(r);
        if (i > 0) {
          [rowsModel[i - 1], rowsModel[i]] = [rowsModel[i], rowsModel[i - 1]];
          reindex();
        }
      });

      btnDown.addEventListener('click', () => {
        const i = rowsModel.indexOf(r);
        if (i >= 0 && i < rowsModel.length - 1) {
          [rowsModel[i + 1], rowsModel[i]] = [rowsModel[i], rowsModel[i - 1]];
          reindex();
        }
      });

      tb.appendChild(tr);
    });
  };

  refresh();

  // Footer: Reset widths + Close
  const footer = document.createElement('div');
  footer.style.cssText = 'display:flex;justify-content:space-between;gap:8px;margin-top:10px;';
  const left  = document.createElement('div');
  const right = document.createElement('div');
  footer.appendChild(left);
  footer.appendChild(right);

  const btnResetWidths = document.createElement('button');
  btnResetWidths.textContent = 'Reset all widths';
  btnResetWidths.className = 'btn mini';
  btnResetWidths.addEventListener('click', () => {
    const prefsRoot =
      (window.__gridPrefs &&
       window.__gridPrefs.grid &&
       window.__gridPrefs.grid[section]) || {};

    const cols = { ...(prefsRoot.columns || {}) };
    Object.keys(cols).forEach(k => { if ('width' in cols[k]) delete cols[k].width; });
    saveUserGridPrefsDebounced(section, { columns: cols });
  });
  left.appendChild(btnResetWidths);

  const btnClose = document.createElement('button');
  btnClose.textContent = 'Close';
  btnClose.className = 'btn mini';
  btnClose.addEventListener('click', async () => {
    document.body.removeChild(overlay);
    const data = await loadSection();
    renderSummary(data);
  });
  right.appendChild(btnClose);

  modal.appendChild(footer);
  document.body.appendChild(overlay);
}


function loadSession(){
  try {
    const raw = localStorage.getItem('cloudtms.session') || sessionStorage.getItem('cloudtms.session');
    const sess = raw ? JSON.parse(raw) : null;
    if (!sess || !sess.accessToken) return false;
    saveSession(sess);             // mirrors globals & schedules refresh
    return true;
  } catch { return false; }
}


// Get label honoring section prefs toggle and overrides
function getFriendlyHeaderLabel(section, key) {
  const prefs = (window.__gridPrefs && window.__gridPrefs.grid && window.__gridPrefs.grid[section]) || {};
  const useFriendly = prefs.use_friendly_labels !== false; // default ON
  if (!useFriendly) return key;
  const overrides = prefs.labels || {};
  const def = (DEFAULT_COLUMN_LABELS[section] || {});
  return overrides[key] || def[key] || key;
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UPDATED: loadSection()
// - After loading the visible page, triggers background priming of membership
//   (ALL matching ids for current filters) regardless of page size.
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UPDATED: loadSection()
// - Ensures grid prefs are loaded
// - Defaults Contracts status quick filter to "active"
// - After loading the visible page, triggers background priming of membership
//   (ALL matching ids for current filters) regardless of page size.
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function loadSection() {
  window.__listState = window.__listState || {};
  const st = (window.__listState[currentSection] ||= {
    page: 1,
    pageSize: 50,
    total: null,
    hasMore: false,
    filters: null,
    sort: { key: null, dir: 'asc' }
  });

  // Ensure sort object exists (for older sessions where it wasn't seeded)
  if (!st.sort || typeof st.sort !== 'object') {
    st.sort = { key: null, dir: 'asc' };
  }

  // Default Contracts quick-filter to "active" if nothing specified
  if (currentSection === 'contracts') {
    if (!st.filters || typeof st.filters !== 'object') st.filters = {};
    if (!('status' in st.filters) || !st.filters.status) {
      st.filters.status = 'active';
    }
  }

  // Ensure user grid prefs are loaded once per session (per section).
  // These prefs come from tms_users.grid_prefs_json if present, else
  // fall back to DEFAULT_GRID_PREFS on the backend.
  await loadUserGridPrefs(currentSection);

  // Decide whether to use the search endpoints:
  // - ALWAYS for 'candidates' and 'contracts' (so we hit candidates_summary /
  //   contracts search and get all derived fields, including job_titles_display)
  // - For other sections, only if there are filters or an active sort key.
  //
  // NOTE: Timesheets is special: it uses listTimesheetsSummary() against
  // /api/timesheets/summary and does NOT go through the generic /api/search/*
  const hasFilters = !!st.filters && Object.keys(st.filters).length > 0;
  const hasSort    = !!(st.sort && st.sort.key);

  const useSearch =
    (currentSection === 'candidates' || currentSection === 'contracts')
      ? true
      : (hasFilters || hasSort);

  const fetchOne = async (section, page, pageSize) => {
    window.__listState[section].page = page;
    window.__listState[section].pageSize = pageSize;

    // Timesheets always go via the summary endpoint (v_timesheets_summary)
    // using listTimesheetsSummary, not the generic search().
    if (section === 'timesheets') {
      const filters = window.__listState[section].filters || {};
      return await listTimesheetsSummary(filters);
    }

    if (useSearch) {
      // For candidates + contracts this always runs, so candidates come from
      // /api/search/candidates (candidates_summary) and include job_titles_display.
      return await search(section, window.__listState[section].filters || {});
    } else {
      // Legacy/simple list endpoints for non-search sections
      switch (section) {
        case 'candidates': return await listCandidates();   // used only when some other caller asks loadSection with useSearch=false for candidates (not the normal grid path now)
        case 'clients':    return await listClients();
        case 'umbrellas':  return await listUmbrellas();
        case 'settings':   return await getSettings();
        case 'audit':      return await listOutbox();
        default:           return [];
      }
    }
  };

  // PageSize = ALL â†’ fetch all pages sequentially (respecting filters + sort)
  if (st.pageSize === 'ALL') {
    const acc = [];
    let p = 1;
    const chunk = 200;
    let gotMore = true;
    while (gotMore) {
      const rows = await fetchOne(currentSection, p, chunk);
      acc.push(...(rows || []));
      gotMore = Array.isArray(rows) && rows.length === chunk;
      p += 1;
      if (!gotMore) break;
    }
    window.__listState[currentSection].page = 1;
    window.__listState[currentSection].hasMore = false;
    window.__listState[currentSection].total = acc.length;

    try {
      primeSummaryMembership(currentSection, getSummaryFingerprint(currentSection));
    } catch {}
    return acc;
  }

  // Normal paged case
  const page = Number(st.page || 1);
  const ps   = Number(st.pageSize || 50);
  const rows = await fetchOne(currentSection, page, ps);
  const hasMore = Array.isArray(rows) && rows.length === ps;
  window.__listState[currentSection].hasMore = hasMore;

  try {
    primeSummaryMembership(currentSection, getSummaryFingerprint(currentSection));
  } catch {}
  return rows;
}


function clearSession(){
  localStorage.removeItem('cloudtms.session');
  sessionStorage.removeItem('cloudtms.session');
  SESSION = null; renderUserChip();
}
function scheduleRefresh(){
  clearTimeout(refreshTimer);
  if (!SESSION?.exp) return;
  const ms = Math.max(15_000, (SESSION.exp*1000) - Date.now() - 60_000);
  refreshTimer = setTimeout(refreshToken, ms);
}

// Unwrap list/envelope responses into arrays
async function toList(res) {
  if (!res.ok) throw new Error(`Request failed: ${res.status}`);
  const j = await res.json();
  if (Array.isArray(j)) return j;
  if (Array.isArray(j.items)) return j.items;
  if (Array.isArray(j.rows))  return j.rows;
  if (j.data && Array.isArray(j.data)) return j.data;
  return [];
}

// --- helpers for normalising/time validation ---
function _toHHMM(val) {
  if (val == null) return '';
  const s = String(val).trim();
  if (!s) return '';
  // accept HH:MM, HH:MM:SS, H:MM, HHMM
  const m = s.match(/^(\d{1,2}):?(\d{2})(?::(\d{2}))?$/);
  if (!m) return '';
  let hh = Number(m[1]), mm = Number(m[2]);
  if (!Number.isFinite(hh) || !Number.isFinite(mm) || hh < 0 || hh > 23 || mm < 0 || mm > 59) return '';
  return String(hh).padStart(2,'0') + ':' + String(mm).padStart(2,'0');
}

function _toHHMMSS(val) {
  const hm = _toHHMM(val);
  return hm ? hm + ':00' : null; // server likes HH:MM:SS (supabase time)
}

// Build a clean object to send to the API

function normalizeClientSettingsForSave(raw) {
  const src = raw || {};
  const out = {};
  let invalid = false;

  const asBool = (v) => {
    if (v === true) return true;
    if (v === false) return false;
    const s = String(v ?? '').trim().toLowerCase();
    return s === 'true' || s === 'yes' || s === 'y' || s === '1' || s === 'on';
  };

  // â€¦ time + week_ending_weekday logic unchanged â€¦

  // Gates + default submission mode
  if ('pay_reference_required' in src) {
    out.pay_reference_required = asBool(src.pay_reference_required);
  }
  if ('invoice_reference_required' in src) {
    out.invoice_reference_required = asBool(src.invoice_reference_required);
  }
  if ('default_submission_mode' in src) {
    let mode = String(src.default_submission_mode || '').toUpperCase();
    if (mode !== 'ELECTRONIC' && mode !== 'MANUAL') mode = 'ELECTRONIC';
    out.default_submission_mode = mode;
  }

  // Existing â€œextraâ€ flags
  if ('is_nhsp' in src) {
    out.is_nhsp = asBool(src.is_nhsp);
  }
  if ('self_bill_no_invoices_sent' in src) {
    out.self_bill_no_invoices_sent = asBool(src.self_bill_no_invoices_sent);
  }
  if ('daily_calc_of_invoices' in src) {
    out.daily_calc_of_invoices = asBool(src.daily_calc_of_invoices);
  }
  if ('no_timesheet_required' in src) {
    out.no_timesheet_required = asBool(src.no_timesheet_required);
  }
  if ('group_nightsat_sunbh' in src) {
    out.group_nightsat_sunbh = asBool(src.group_nightsat_sunbh);
  }

  // NEW HR / attachment flags
  if ('requires_hr' in src) {
    out.requires_hr = asBool(src.requires_hr);
  }
  if ('autoprocess_hr' in src) {
    out.autoprocess_hr = asBool(src.autoprocess_hr);
  }
  if ('hr_attach_to_invoice' in src) {
    out.hr_attach_to_invoice = asBool(src.hr_attach_to_invoice);
  }
  if ('ts_attach_to_invoice' in src) {
    out.ts_attach_to_invoice = asBool(src.ts_attach_to_invoice);
  }

  return { cleaned: out, invalid };
}


// ===== Auth fetch with refresh retry =====

async function apiPostJson(path, body) {
  const res = await authFetch(API(path), {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body || {})
  });
  if (!res.ok) {
    const txt = await res.text().catch(() => '');
    throw new Error(txt || `Request failed (${res.status})`);
  }
  return res.json().catch(() => ({}));
}

async function apiPatchJson(path, body) {
  const res = await authFetch(API(path), {
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body || {})
  });
  if (!res.ok) {
    const txt = await res.text().catch(() => '');
    throw new Error(txt || `Request failed (${res.status})`);
  }
  return res.json().catch(() => ({}));
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Weekly import helpers
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Weekly resolve helpers (NHSP + HR_WEEKLY)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function postWeeklyResolveMappings(importId, type, payload) {
  const LOG = (typeof window.__LOG_IMPORTS === 'boolean') ? window.__LOG_IMPORTS : true;
  const L   = (...a) => { if (LOG) console.log('[IMPORTS][WEEKLY][RESOLVE]', ...a); };

  if (!importId) {
    throw new Error('Missing importId for postWeeklyResolveMappings');
  }
  if (!type) {
    throw new Error('Missing type for postWeeklyResolveMappings');
  }

  const t = String(type || '').toUpperCase();

  let urlPath;
  if (t === 'NHSP') {
    urlPath = `/api/nhsp/${encodeURIComponent(importId)}/resolve-conflicts`;
  } else if (t === 'HR_WEEKLY') {
    urlPath = `/api/healthroster/autoprocess/${encodeURIComponent(importId)}/resolve-conflicts`;
  } else {
    throw new Error(`Unsupported weekly import type for resolve-conflicts: ${t}`);
  }

  const candidate_mappings = Array.isArray(payload?.candidate_mappings)
    ? payload.candidate_mappings
    : [];

  const client_aliases = Array.isArray(payload?.client_aliases)
    ? payload.client_aliases
    : [];

  if (!candidate_mappings.length && !client_aliases.length) {
    L('no mappings to send; returning early', { importId, type: t });
    return { ok: true, candidate_mappings_applied: 0, client_aliases_applied: 0 };
  }

  if (typeof authFetch !== 'function' || typeof API !== 'function') {
    throw new Error('authFetch/API helper missing in postWeeklyResolveMappings');
  }

  const url = API(urlPath);

  L('posting weekly resolve-conflicts', {
    importId,
    type: t,
    url,
    candidate_mappings_count: candidate_mappings.length,
    client_aliases_count: client_aliases.length
  });

  const res  = await authFetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ candidate_mappings, client_aliases })
  });

  const text = await res.text().catch(() => '');

  if (!res.ok) {
    let msg = text || `Weekly resolve-conflicts failed (${res.status})`;

    // Try to pull a nicer message from JSON
    try {
      if (text) {
        const parsed = JSON.parse(text);
        if (parsed && typeof parsed === 'object') {
          if (parsed.message && typeof parsed.message === 'string') {
            msg = parsed.message;
          } else if (parsed.error && typeof parsed.error === 'string') {
            msg = parsed.error;
          }
        }
      }
    } catch {
      // ignore JSON parse errors, fall back to text/default
    }

    L('resolve-conflicts ERROR', { status: res.status, msg, raw: text });
    throw new Error(msg);
  }

  let json = {};
  try { json = text ? JSON.parse(text) : {}; } catch {
    json = { ok: true };
  }

  L('resolve-conflicts OK', json);
  return json;
}




async function refreshWeeklyImportSummary(type, importId) {
  const LOG = (typeof window.__LOG_IMPORTS === 'boolean') ? window.__LOG_IMPORTS : true;
  const L   = (...a) => { if (LOG) console.log('[IMPORTS][WEEKLY][REFRESH]', ...a); };

  try {
    if (!type || !importId) {
      throw new Error('Missing type or importId for refreshWeeklyImportSummary');
    }

    const t = String(type || '').toUpperCase();
    let url;
    if (t === 'NHSP') {
      url = `/api/nhsp/${encodeURIComponent(importId)}/preview`;
    } else if (t === 'HR_WEEKLY') {
      url = `/api/healthroster/autoprocess/${encodeURIComponent(importId)}/preview`;
    } else {
      throw new Error(`Unsupported weekly import type: ${t}`);
    }

    if (typeof authFetch !== 'function' || typeof API !== 'function') {
      throw new Error('authFetch/API helper missing in refreshWeeklyImportSummary');
    }

    L('fetching preview', { type: t, importId, url: API(url) });
    const res  = await authFetch(API(url));
    const text = await res.text();
    if (!res.ok) {
      throw new Error(text || `Weekly import preview refresh failed (${res.status})`);
    }

    const summaryState = text ? JSON.parse(text) : {};
    if (typeof renderImportSummaryModal === 'function') {
      renderImportSummaryModal(t, summaryState);
    } else {
      throw new Error('renderImportSummaryModal is not defined');
    }
  } catch (e) {
    console.error('[IMPORTS][WEEKLY][REFRESH] failed', e);
    const msg = e?.message || 'Failed to refresh weekly import summary.';
    if (window.__toast) window.__toast(msg); else alert(msg);
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// HR Rota Daily helpers
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function refreshHrRotaSummary(importId) {
  const LOG = (typeof window.__LOG_IMPORTS === 'boolean') ? window.__LOG_IMPORTS : true;
  const L   = (...a) => { if (LOG) console.log('[IMPORTS][HR_ROTA][REFRESH]', ...a); };

  try {
    if (!importId) {
      throw new Error('Missing importId for refreshHrRotaSummary');
    }

    if (typeof authFetch !== 'function' || typeof API !== 'function') {
      throw new Error('authFetch/API helper missing in refreshHrRotaSummary');
    }

    const url = `/api/imports/hr-rota/${encodeURIComponent(importId)}/preview`;
    L('fetching HR rota preview', { importId, url: API(url) });

    const res  = await authFetch(API(url));
    const text = await res.text();
    if (!res.ok) {
      throw new Error(text || `HR rota preview refresh failed (${res.status})`);
    }

    const summaryState = text ? JSON.parse(text) : {};
    if (typeof renderImportSummaryModal === 'function') {
      renderImportSummaryModal('HR_ROTA_DAILY', summaryState);
    } else {
      throw new Error('renderImportSummaryModal is not defined');
    }
  } catch (e) {
    console.error('[IMPORTS][HR_ROTA][REFRESH] failed', e);
    const msg = e?.message || 'Failed to refresh HR rota daily summary.';
    if (window.__toast) window.__toast(msg); else alert(msg);
  }
}

async function postHrRotaResolveMappings(importId, payload) {
  const LOG = (typeof window.__LOG_IMPORTS === 'boolean') ? window.__LOG_IMPORTS : true;
  const L   = (...a) => { if (LOG) console.log('[IMPORTS][HR_ROTA][RESOLVE]', ...a); };

  if (!importId) {
    throw new Error('Missing importId for postHrRotaResolveMappings');
  }

  const body = payload || {};
  const candidate_mappings = Array.isArray(body.candidate_mappings) ? body.candidate_mappings : [];
  const client_aliases     = Array.isArray(body.client_aliases)     ? body.client_aliases     : [];

  if (!candidate_mappings.length && !client_aliases.length) {
    L('no mappings to send; returning early', { importId });
    return { ok: true, candidate_mappings_applied: 0, client_aliases_applied: 0 };
  }

  if (typeof authFetch !== 'function' || typeof API !== 'function') {
    throw new Error('authFetch/API helper missing in postHrRotaResolveMappings');
  }

  const url = `/api/imports/hr-rota/${encodeURIComponent(importId)}/resolve-conflicts`;
  L('posting HR rota resolve-conflicts', {
    importId,
    url: API(url),
    candidate_mappings_count: candidate_mappings.length,
    client_aliases_count: client_aliases.length
  });

  const res  = await authFetch(API(url), {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ candidate_mappings, client_aliases })
  });

  const text = await res.text().catch(() => '');
  if (!res.ok) {
    const msg = text || `HR rota resolve-conflicts failed (${res.status})`;
    throw new Error(msg);
  }

  let json = {};
  try { json = text ? JSON.parse(text) : {}; } catch {}

  L('resolve-conflicts OK', json);
  return json;
}

function openHrRotaAssignCandidateModal(importId, rowIndex) {
  const LOG = (typeof window.__LOG_IMPORTS === 'boolean') ? window.__LOG_IMPORTS : true;
  const L   = (...a) => { if (LOG) console.log('[IMPORTS][HR_ROTA][ASSIGN_CAND]', ...a); };

  try {
    if (!importId && importId !== 0) {
      throw new Error('Missing importId in openHrRotaAssignCandidateModal');
    }

    const st = window.__importSummaryState && window.__importSummaryState['HR_ROTA_DAILY'];
    const rows = st && Array.isArray(st.rows) ? st.rows : [];
    const idx  = Number(rowIndex);
    const row  = (idx >= 0 && idx < rows.length) ? rows[idx] : null;

    if (!row) {
      throw new Error(`Row index ${rowIndex} is out of range for HR_ROTA_DAILY summary`);
    }

    const staffRaw = row.staff_name || row.staff_raw || '';
    const unitRaw  = row.unit || row.hospital_or_trust || row.hospital_norm || '';

    if (typeof openCandidatePicker !== 'function') {
      throw new Error('openCandidatePicker is not defined');
    }

    L('opening Assign Candidate picker', { importId, rowIndex, staffRaw, unitRaw });

    openCandidatePicker(async ({ id, label }) => {
      try {
        const staff_norm =
          row.staff_norm ||
          staffRaw ||
          '';

        const hospital_or_trust =
          unitRaw
            ? unitRaw
            : (row.hospital_or_trust || row.unit || row.hospital_norm || null);

        const payload = {
          candidate_mappings: [
            {
              staff_norm,
              hospital_or_trust,
              candidate_id: id
            }
          ],
          client_aliases: []
        };

        await postHrRotaResolveMappings(importId, payload);

        if (window.__toast) {
          window.__toast(`Candidate ${label} linked. Reclassifying HR rotaâ€¦`);
        }

        await refreshHrRotaSummary(importId);
      } catch (err) {
        console.error('[IMPORTS][HR_ROTA][ASSIGN_CAND] failed', err);
        const msg = err?.message || 'Failed to assign candidate for HR rota row.';
        if (window.__toast) window.__toast(msg); else alert(msg);
      }
    });
  } catch (e) {
    console.error('[IMPORTS][HR_ROTA][ASSIGN_CAND] open failed', e);
    const msg = e?.message || 'Failed to open Assign candidate dialog.';
    if (window.__toast) window.__toast(msg); else alert(msg);
  }
}

function openHrRotaAssignClientModal(importId, rowIndex) {
  const LOG = (typeof window.__LOG_IMPORTS === 'boolean') ? window.__LOG_IMPORTS : true;
  const L   = (...a) => { if (LOG) console.log('[IMPORTS][HR_ROTA][ASSIGN_CLIENT]', ...a); };

  try {
    if (!importId && importId !== 0) {
      throw new Error('Missing importId in openHrRotaAssignClientModal');
    }

    const st = window.__importSummaryState && window.__importSummaryState['HR_ROTA_DAILY'];
    const rows = st && Array.isArray(st.rows) ? st.rows : [];
    const idx  = Number(rowIndex);
    const row  = (idx >= 0 && idx < rows.length) ? rows[idx] : null;

    if (!row) {
      throw new Error(`Row index ${rowIndex} is out of range for HR_ROTA_DAILY summary`);
    }

    const unitRaw =
      row.unit ||
      row.hospital_or_trust ||
      row.hospital_norm ||
      '';

    if (typeof openClientPicker !== 'function') {
      throw new Error('openClientPicker is not defined');
    }

    L('opening Assign Client/Site picker', { importId, rowIndex, unitRaw });

    openClientPicker(async ({ id, label }) => {
      try {
        const hospital_norm =
          row.hospital_norm ||
          unitRaw ||
          '';

        const payload = {
          candidate_mappings: [],
          client_aliases: [
            {
              hospital_norm,
              client_id: id
            }
          ]
        };

        await postHrRotaResolveMappings(importId, payload);

        if (window.__toast) {
          window.__toast(`Client ${label} linked. Reclassifying HR rotaâ€¦`);
        }

        await refreshHrRotaSummary(importId);
      } catch (err) {
        console.error('[IMPORTS][HR_ROTA][ASSIGN_CLIENT] failed', err);
        const msg = err?.message || 'Failed to assign client/site for HR rota row.';
        if (window.__toast) window.__toast(msg); else alert(msg);
      }
    });
  } catch (e) {
    console.error('[IMPORTS][HR_ROTA][ASSIGN_CLIENT] open failed', e);
    const msg = e?.message || 'Failed to open Assign client/site dialog.';
    if (window.__toast) window.__toast(msg); else alert(msg);
  }
}

async function refreshOpenWeeklyImportSummariesAfterContractSave() {
  const LOG = (typeof window.__LOG_IMPORTS === 'boolean') ? window.__LOG_IMPORTS : true;
  const L   = (...a) => { if (LOG) console.log('[IMPORTS][WEEKLY][REFRESH_AFTER_CONTRACT]', ...a); };

  try {
    const state = window.__importSummaryState || null;
    if (!state || typeof refreshWeeklyImportSummary !== 'function') {
      L('no importSummaryState or refreshWeeklyImportSummary not defined; nothing to refresh');
      return;
    }

    const types = ['NHSP', 'HR_WEEKLY'];

    for (const t of types) {
      const st = state[t];
      if (!st || !st.import_id) continue;

      const importId = st.import_id;
      L('auto-refreshing weekly import after contract save', { type: t, importId });

      try {
        await refreshWeeklyImportSummary(t, importId);
      } catch (e) {
        console.warn('[IMPORTS][WEEKLY][REFRESH_AFTER_CONTRACT] single refresh failed', {
          type: t,
          importId,
          err: e?.message || String(e)
        });
      }
    }
  } catch (e) {
    console.warn('[IMPORTS][WEEKLY][REFRESH_AFTER_CONTRACT] wrapper failed', e);
  }
}

async function authFetch(input, init={}){
  const APILOG = (typeof window !== 'undefined' && !!window.__LOG_API) || (typeof __LOG_API !== 'undefined' && !!__LOG_API);
  const headers = new Headers(init.headers || {});
  if (SESSION?.accessToken) headers.set('Authorization', `Bearer ${SESSION.accessToken}`);
  if (APILOG) {
    const safeHeaders = {};
    headers.forEach((v,k)=>{ safeHeaders[k] = (k.toLowerCase()==='authorization') ? '***' : v; });
    const bodyPreview = typeof init.body === 'string' ? (init.body.length > 500 ? init.body.slice(0,500)+'â€¦' : init.body) : init.body;
    console.log('[authFetch] â†’', { url: typeof input==='string'?input:input?.url, method: (init.method||'GET'), headers: safeHeaders, body: bodyPreview });
  }
  let res = await fetch(input, { ...init, headers, credentials: init.credentials || 'omit' });
  if (APILOG) {
    try { const txt = await res.clone().text(); console.log('[authFetch] â†', res.status, res.ok, txt.slice(0,500)); } catch {}
  }
  if (res.status === 401) {
    const ok = await refreshToken();
    if (!ok) throw new Error('Unauthorised');
    headers.set('Authorization', `Bearer ${SESSION.accessToken}`);
    if (APILOG) console.log('[authFetch] retrying after 401');
    res = await fetch(input, { ...init, headers, credentials: init.credentials || 'omit' });
    if (APILOG) {
      try { const txt2 = await res.clone().text(); console.log('[authFetch] â† (retry)', res.status, res.ok, txt2.slice(0,500)); } catch {}
    }
  }
  return res;
}

// ===== Auth API calls =====
async function apiLogin(email, password){
  const res = await fetch(API('/auth/login'), {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    credentials: 'include', // cookie for refresh
    body: JSON.stringify({ email, password })
  });

  let data = {};
  try { data = await res.json(); } catch {}

  if (!res.ok) {
    const msg = data?.error || data?.message || 'Invalid credentials';
    throw new Error(msg);
  }

  const token =
    data.access_token ||
    data.token ||
    data.accessToken;

  if (!token) {
    throw new Error('No access token returned');
  }

  const rawTtl = data.expires_in ?? data.token_ttl_sec ?? data.ttl ?? 3600; // seconds
  const ttl    = Math.max(60, Number(rawTtl) || 3600); // floor at 60s
  const skew   = 30; // renew slightly early

  saveSession({
    accessToken: token,
    user: data.user || data.profile || null,
    exp: Math.floor(Date.now() / 1000) + (ttl - skew)
  });

  if (typeof scheduleRefresh === 'function') {
    scheduleRefresh();
  }

  return data;
}

// single, de-duplicated definition
async function refreshToken(){
  try{
    const res = await fetch(API('/auth/refresh'), {
      method:'POST',
      credentials:'include',
      headers:{'content-type':'application/json'},
      body: JSON.stringify({})
    });
    if (!res.ok) { clearSession(); return false; }

    const data  = await res.json();
    const token = data.access_token || data.token || data.accessToken;
    const ttl   = data.expires_in || data.token_ttl_sec || data.ttl || 3600;

    // Preserve existing user; hydrate if missing id
    let user = SESSION?.user || data.user || null;
    if (!user || !user.id) {
      try {
        const meRes = await fetch(API('/api/me'), { headers: { 'Authorization': `Bearer ${token}` } });
        if (meRes.ok) {
          const meJson = await meRes.json().catch(()=> ({}));
          user = (meJson && (meJson.user || meJson)) || user;
        }
      } catch {}
      // Extra guard: fall back to persisted user if present
      if (!user || !user.id) {
        try {
          const persisted = JSON.parse(localStorage.getItem('cloudtms.session')
                           || sessionStorage.getItem('cloudtms.session') || 'null');
          if (persisted?.user?.id) user = persisted.user;
        } catch {}
      }
    }

    saveSession({
      accessToken: token,
      user,
      exp: Math.floor(Date.now()/1000) + ttl
    });
    return true;
  }catch{
    clearSession();
    return false;
  }
}



async function apiForgot(email){
  const r = await fetch(API('/auth/forgot'), { method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify({ email })});
  if(!r.ok) throw new Error('Failed to request reset');
  return true;
}
async function apiReset(token, newPassword){
  const r = await fetch(API('/auth/reset'), { method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify({ token, new_password: newPassword })});
  if(!r.ok) throw new Error('Failed to reset password');
  return true;
}

// ===== Auth overlays wiring (login / forgot / reset) =====
function openLogin(){ byId('loginOverlay').style.display='grid'; byId('forgotOverlay').style.display='none'; byId('resetOverlay').style.display='none'; }
function openForgot(){ byId('loginOverlay').style.display='none'; byId('forgotOverlay').style.display='grid'; byId('resetOverlay').style.display='none'; }
function openReset(){ byId('loginOverlay').style.display='none'; byId('forgotOverlay').style.display='none'; byId('resetOverlay').style.display='grid'; }

// show/hide password helpers
function toggleVis(inputId, toggleId){
  const inp = byId(inputId), t = byId(toggleId);
  t.onclick = ()=>{ inp.type = inp.type==='password' ? 'text' : 'password'; };
}

function renderUserChip(){
  const chip = byId('userChip');
  if (SESSION?.user) {
    chip.textContent = (SESSION.user.display_name || SESSION.user.email || 'User');
  } else chip.textContent = 'Signed out';
}
function initAuthUI(){
  // Buttons and links
  byId('btnLogout').onclick = ()=>{ clearSession(); openLogin(); };

  toggleVis('loginPassword','toggleLoginPw');
  toggleVis('resetPw1','toggleResetPw1'); toggleVis('resetPw2','toggleResetPw2');

  byId('linkForgot').onclick = openForgot;
  byId('linkBackToLogin').onclick = openLogin;
  byId('linkResetToLogin').onclick = openLogin;

  byId('loginForm').onsubmit = async (e)=>{
    e.preventDefault();
    const email = byId('loginEmail').value.trim();
    const pw = byId('loginPassword').value;
    const err = byId('loginError'); err.style.display='none';
    try{
      await apiLogin(email, pw);
      if (typeof scheduleRefresh === 'function') scheduleRefresh();
      byId('loginOverlay').style.display='none';
      bootstrapApp();
    }catch(ex){
      err.textContent = ex.message || 'Sign in failed'; err.style.display='block';
    }
  };

  byId('forgotForm').onsubmit = async (e)=>{
    e.preventDefault();
    const email = byId('forgotEmail').value.trim();
    byId('forgotError').style.display='none';
    byId('forgotMsg').style.display='none';
    try{
      await apiForgot(email);
      byId('forgotMsg').textContent = 'If that email exists, a reset link has been sent.'; byId('forgotMsg').style.display='block';
    }catch(ex){
      byId('forgotError').textContent = ex.message || 'Could not send reset email'; byId('forgotError').style.display='block';
    }
  };

  byId('resetForm').onsubmit = async (e)=>{
    e.preventDefault();
    const p1 = byId('resetPw1').value, p2 = byId('resetPw2').value;
    const err = byId('resetError'), ok = byId('resetMsg'); err.style.display='none'; ok.style.display='none';
    if (p1.length < 8) { err.textContent='Use at least 8 characters'; err.style.display='block'; return; }
    if (p1 !== p2) { err.textContent='Passwords do not match'; err.style.display='block'; return; }
    const url = new URL(location.href); const token = url.searchParams.get('k') || url.searchParams.get('token');
    if (!token){ err.textContent='Reset token missing. Use the email link again.'; err.style.display='block'; return; }
    try{
      await apiReset(token, p1);
      ok.textContent='Password updated. You can sign in now.'; ok.style.display='block';
    }catch(ex){
      err.textContent = ex.message || 'Reset failed'; err.style.display='block';
    }
  };

  // Open reset overlay automatically if URL carries a token (only if not already signed in)
  const url = new URL(location.href);
  const hasResetToken = url.searchParams.get('k') || url.searchParams.get('token');
  if (hasResetToken && !(typeof getSession === 'function' && getSession()?.accessToken)) openReset();
}
// ===== App state + rendering =====
const sections = [
  {key:'candidates', label:'Candidates', icon:'ðŸ‘¤'},
  {key:'clients', label:'Clients', icon:'ðŸ¥'},
  {key:'contracts', label:'Contracts', icon:'ðŸ“„'},
  {key:'timesheets', label:'Timesheets', icon:'ðŸ—’ï¸'},
 {key:'imports', label:'Imports', icon:'ðŸ“¥'},

  {key:'invoices', label:'Invoices', icon:'ðŸ“„'},
  {key:'umbrellas', label:'Umbrellas', icon:'â˜‚ï¸'},
  {key:'settings', label:'Settings', icon:'âš™ï¸'},
  {key:'audit', label:'Audit', icon:'ðŸ›¡ï¸'}
];

let currentSection = 'candidates';
let currentRows = [];
let currentSelection = null;

// =========================== renderTopNav (kept with reset) ===========================
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// renderTopNav (amended) â€” adds Contracts quick-search branch { q: text }
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderTopNav(){
  const nav = byId('nav'); nav.innerHTML = '';

  // ensure per-section list + selection exist
  window.__listState = window.__listState || {};
  window.__selection = window.__selection || {};

  // helper: common section switch (mirrors original behaviour)
  const switchToSection = (sectionKey) => {
    if (!confirmDiscardChangesIfDirty()) return;

    if ((window.__modalStack?.length || 0) > 0 || modalCtx?.entity) {
      discardAllModalsAndState();
    }

    if (!window.__listState[sectionKey]) {
      window.__listState[sectionKey] = { page: 1, pageSize: 50, total: null, hasMore: false, filters: null };
    }

    // IDs-only selection seed for the new section
    window.__selection[sectionKey] = window.__selection[sectionKey] || { fingerprint:'', ids:new Set() };

    currentSection   = sectionKey;
    currentRows      = [];
    currentSelection = null;

    renderAll();
  };

  // Helper: close any open settings dropdown
  const closeSettingsMenu = () => {
    const m = document.getElementById('__settingsMenu');
    if (m) m.remove();
    const btn = document.querySelector('button.__settingsBtn');
    if (btn) btn.classList.remove('active');
    document.removeEventListener('click', onAnyDocClick, true);
    document.removeEventListener('keydown', onEsc, true);
  };
  const onAnyDocClick = (e) => {
    const menu = document.getElementById('__settingsMenu');
    const anchor = document.querySelector('button.__settingsBtn');
    if (!menu) return;
    if (menu.contains(e.target) || anchor?.contains(e.target)) return;
    closeSettingsMenu();
  };
  const onEsc = (e) => { if (e.key === 'Escape') closeSettingsMenu(); };

  // Build buttons
  sections.forEach(s => {
    const b = document.createElement('button');
    b.innerHTML = `<span class="ico">${s.icon}</span> ${s.label}`;
    if (s.key === currentSection) b.classList.add('active');

    if (s.key === 'imports') {
      // IMPORTS: launch the Imports modal (NHSP / HR weekly / HR rota)
      b.onclick = () => {
        if (!confirmDiscardChangesIfDirty()) return;
        try {
          openImportsModal();          // <-- your existing imports UI entry point
        } catch (e) {
          console.error('[NAV][IMPORTS] openImportsModal failed', e);
          alert(e?.message || 'Failed to open Imports.');
        }
      };
    } else if (s.key !== 'settings') {
      // normal buttons keep the original click behaviour
      b.onclick = () => switchToSection(s.key);
    } else {
      // SETTINGS: small dropdown instead of direct navigation
      b.classList.add('__settingsBtn');
      b.onclick = (ev) => {
        ev.preventDefault();
        // toggle
        const existing = document.getElementById('__settingsMenu');
        if (existing) { closeSettingsMenu(); return; }

        // Build a light menu styled with your palette
        const m = document.createElement('div');
        m.id = '__settingsMenu';
        m.style.position      = 'absolute';
        m.style.zIndex        = '1000';
        m.style.background    = 'var(--panel, #0b1221)';
        m.style.border        = '1px solid var(--line, #334155)';
        m.style.borderRadius  = '10px';
        m.style.boxShadow     = 'var(--shadow, 0 6px 20px rgba(0,0,0,.25))';
        m.style.padding       = '6px';
        m.style.minWidth      = '180px';
        m.style.userSelect    = 'none';

        m.innerHTML = `
          <button type="button" class="menu-item" data-k="global"
                  style="display:flex;gap:8px;align-items:center;width:100%;
                         background:#0b1427;border:1px solid var(--line);color:#fff;
                         padding:8px 10px;border-radius:8px;cursor:pointer;margin:4px 0;">
            ðŸŒ Global settings
          </button>
          <button type="button" class="menu-item" data-k="rates"
                  style="display:flex;gap:8px;align-items:center;width:100%;
                         background:#0b1427;border:1px solid var(--line);color:#fff;
                         padding:8px 10px;border-radius:8px;cursor:pointer;margin:4px 0;">
            ðŸ’± Preset Rates
          </button>
          <button type="button" class="menu-item" data-k="job-titles"
                  style="display:flex;gap:8px;align-items:center;width:100%;
                         background:#0b1427;border:1px solid var(--line);color:#fff;
                         padding:8px 10px;border-radius:8px;cursor:pointer;margin:4px 0;">
            ðŸ· Job Titles
          </button>
        `;

        // Position under the button
        document.body.appendChild(m);
        const r = b.getBoundingClientRect();
        m.style.left = `${Math.round(window.scrollX + r.left)}px`;
        m.style.top  = `${Math.round(window.scrollY + r.bottom + 6)}px`;

        // Wire actions
        m.addEventListener('click', (e) => {
          const it = e.target.closest('.menu-item');
          if (!it) return;
          const k = it.getAttribute('data-k');
          closeSettingsMenu();

          if (k === 'global') {
            // keep current behaviour
            switchToSection('settings');
          } else if (k === 'rates') {
            // Preset Rates manager (parent modal)
            if (!confirmDiscardChangesIfDirty()) return;
            openPresetRatesManager();
          } else if (k === 'job-titles') {
            // New Job Titles manager (side-panel modal)
            if (!confirmDiscardChangesIfDirty()) return;
            openJobTitleSettingsModal();
          }
        });

        // Close on outside click / Esc
        setTimeout(() => {
          document.addEventListener('click', onAnyDocClick, true);
          document.addEventListener('keydown', onEsc, true);
        }, 0);

        // Visual cue
        b.classList.add('active');
      };
    }

    nav.appendChild(b);
  });

  // Quick search: Enter runs a search and resets to page 1
  try {
    const q = byId('quickSearch');
    if (q && !q.__wired) {
      q.addEventListener('keydown', async (e) => {
        if (e.key !== 'Enter') return;
        if (!confirmDiscardChangesIfDirty()) return;

        window.__listState = window.__listState || {};
        window.__selection = window.__selection || {};

        const st  = (window.__listState[currentSection]  ||= { page: 1, pageSize: 50, total: null, hasMore: false, filters: null });
        const sel = (window.__selection[currentSection] ||= { fingerprint:'', ids:new Set() });

        st.page = 1;
        const text = (q.value || '').trim();

        if (!text) {
          st.filters = null;
          sel.fingerprint = JSON.stringify({ section: currentSection, filters: {} });
          sel.ids.clear();
          const data = await loadSection();
          return renderSummary(data);
        }

        // Minimal quick-search filters by section
        let filters = null;
        if (currentSection === 'candidates') {
          if (text.includes('@'))       filters = { email: text };
          else if (text.replace(/\D/g,'').length >= 7) filters = { phone: text };
          else if (text.includes(' ')) {
            const [fn, ln] = text.split(' ').filter(Boolean);
            filters = { first_name: fn || text, last_name: ln || '' };
          } else filters = { first_name: text };
        } else if (currentSection === 'clients' || currentSection === 'umbrellas') {
          filters = { name: text };
        } else if (currentSection === 'contracts') {
          // free-text passthrough for contracts
          filters = { q: text };
        } else {
          const data = await loadSection();
          return renderSummary(data);
        }

        st.filters = filters;
        sel.fingerprint = JSON.stringify({ section: currentSection, filters });
        sel.ids.clear();

        const rows = await search(currentSection, filters);
        renderSummary(rows);
      });
      q.__wired = true;
    }
  } catch {}
}

// NEW: advanced, section-aware search modal
// === UPDATED: Advanced Search â€” add Roles (any) multi-select, use UK date pickers ===
// -----------------------------
// Search presets FE cache (optional but handy)
// -----------------------------
const __PRESETS_CACHE__ = new Map(); // key = `${section}:${kind}|shared=${0/1}|q=...|p=..|ps=..`

function cacheKey(section, kind = 'search', opts = {}) {
  const shared = opts.include_shared ? 1 : 0;
  const q      = opts.q ? String(opts.q) : '';
  const page   = Number.isFinite(opts.page) ? opts.page : 1;
  const ps     = Number.isFinite(opts.page_size) ? opts.page_size : 100;
  return `${section || ''}:${kind || 'search'}|shared=${shared}|q=${q}|p=${page}|ps=${ps}`;
}

function invalidatePresetCache(section, kind = 'search', opts) {
  if (opts) {
    __PRESETS_CACHE__.delete(cacheKey(section, kind, opts));
    return;
  }
  // No opts provided: clear all variants for this (section,kind)
  const prefix = `${section || ''}:${kind || 'search'}|`;
  for (const key of __PRESETS_CACHE__.keys()) {
    if (key.startsWith(prefix)) __PRESETS_CACHE__.delete(key);
  }
}



function getPresetCache(section, kind = 'search', opts) {
  return __PRESETS_CACHE__.get(cacheKey(section, kind, opts)) || null;
}

function setPresetCache(section, kind, rows, opts) {
  __PRESETS_CACHE__.set(
    cacheKey(section, kind, opts),
    Array.isArray(rows) ? rows : []
  );
}
// Quick helper for ownership checks; adapt if you keep user in a different global
function currentUserId(){
  try {
    return (window.SESSION && window.SESSION.user && window.SESSION.user.id)
        || (window.__auth && window.__auth.user && window.__auth.user.id)
        || window.__USER_ID
        || null;
  } catch (_) {
    return null;
  }
}






// -----------------------------
// Preset API wrappers
// -----------------------------
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Child modal â€” Rate preset (create / view / edit)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function computeRatePresetMargins(state){
  const buckets = ['day','night','sat','sun','bh'];
  const out = { bucket:{}, anyNegative:false };
  if (!state || typeof state !== 'object') return out;

  let erniDec = 0;
  try { if (typeof ensureErniMultiplier === 'function') ensureErniMultiplier(); } catch {}

  if (typeof window !== 'undefined' && Number.isFinite(window.__ERNI_MULT__)) {
    erniDec = Math.max(0, Number(window.__ERNI_MULT__) - 1);
  } else if (typeof getCurrentErniMultiplier === 'function') {
    const m = getCurrentErniMultiplier();
    if (Number.isFinite(m)) erniDec = Math.max(0, m - 1);
  } else if (typeof getCurrentErniPct === 'function') {
    const p = getCurrentErniPct();
    if (Number.isFinite(p)) erniDec = Math.max(0, p / 100);
  } else if (Number.isFinite(window?.__erniMultiplier)) {
    erniDec = Math.max(0, Number(window.__erniMultiplier) - 1);
  } else if (Number.isFinite(window?.__erniPct)) {
    erniDec = Math.max(0, Number(window.__erniPct) / 100);
  }

  const num = (v) => { const n = Number(v); return Number.isFinite(n) ? n : NaN; };

  buckets.forEach(b => {
    const paye   = num(state[`paye_${b}`]);
    const umb    = num(state[`umb_${b}`]);
    const charge = num(state[`charge_${b}`]);

    const hasP = !!state.enable_paye && Number.isFinite(paye);
    const hasU = !!state.enable_umbrella && Number.isFinite(umb);
    const hasC = Number.isFinite(charge);

    const marginP = (hasP && hasC) ? (charge - (paye + (paye * erniDec))) : null;
    const marginU = (hasU && hasC) ? (charge - umb) : null;

    const negP = (marginP != null) && (marginP < 0);
    const negU = (marginU != null) && (marginU < 0);
    if (negP || negU) out.anyNegative = true;

    out.bucket[b] = {
      paye:        hasP ? paye   : null,
      umb:         hasU ? umb    : null,
      charge:      hasC ? charge : null,
      marginPaye:  marginP,
      marginUmb:   marginU,
      negPaye:     negP,
      negUmb:      negU
    };
  });

  return out;
}

function openRatePresetPicker(applyCb, opts = {}) {
  const LOG = (typeof window.__LOG_RATES === 'boolean') ? window.__LOG_RATES : true;
  const L   = (...a)=> { if (LOG) console.log('[PRESETS]', ...a); };

  const {
    client_id = null,
    start_date = null,
    defaultScope = (client_id ? 'CLIENT' : 'GLOBAL')
  } = opts;

  let pickerRows = [];
  let pickerSelectedIndex = -1;
  let pickerSelectedId = null;
  let applyInFlight = false; // debounce guard

  const content = () => `
    <div class="tabc" id="ratePresetPicker">
      <div class="row">
        <label>Scope</label>
        <div class="controls">
          <label><input type="radio" name="rp_scope" value="ALL" ${defaultScope==='ALL'?'checked':''}/> All</label>
          <label><input type="radio" name="rp_scope" value="GLOBAL" ${defaultScope==='GLOBAL'?'checked':''}/> Global</label>
          <label ${client_id?'':'title="Pick a client to enable Client presets"'} >
            <input type="radio" name="rp_scope" value="CLIENT" ${defaultScope==='CLIENT'?'checked':''} ${client_id?'':'disabled'}/> Client
          </label>
          <input type="text" id="rp_search" class="input" placeholder="Searchâ€¦" style="margin-left:auto;min-width:200px"/>
        </div>
      </div>
      <div class="hint" style="margin:6px 0 10px">
        Double-click a row to apply. Single-click selects; click <em>Apply</em> to use the selected preset.
      </div>
      <div style="border:1px solid var(--line);border-radius:10px;overflow:hidden">
        <table class="grid" id="rp_table">
          <thead>
            <tr>
              <th style="width:36px"></th>
              <th>Name / Role / Band</th>
              <th>Scope</th>
              <th>Dates</th>
              <th>Charge (D/N/Sa/Su/BH)</th>
              <th>PAYE</th>
              <th>Umbrella</th>
              <th>Mileage</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>`;

  // onApply: just apply the preset and tell saveForFrame we're OK.
  const onApply = async () => {
    if (applyInFlight) return false;
    if (!pickerRows || pickerSelectedIndex < 0) return false;
    const chosen = pickerRows[pickerSelectedIndex];
    if (!chosen) return false;

    applyInFlight = true;
    L('onApply: applying preset row', { chosen });

    try {
      if (typeof applyCb === 'function') {
        await applyCb(chosen);
      }
      // Let saveForFrame() close this child modal normally.
      return { ok: true };
    } catch (e) {
      console.error('[PRESETS] onApply failed', e);
      return false;
    } finally {
      applyInFlight = false;
    }
  };

  showModal(
    'Rate Presets',
    [{ key: 'p', title: 'Presets' }],
    () => content(),
    onApply,
    false,
    async () => {
      const root   = document.getElementById('ratePresetPicker');
      const tbody  = root?.querySelector('#rp_table tbody');
      const search = root?.querySelector('#rp_search');
      const radios = Array.from(root?.querySelectorAll('input[name="rp_scope"]') || []);
      if (!tbody) return;

      // Scope any header/button lookups to THIS picker modal
      const pickerModalEl = root?.closest('.modal');

      const scopeVal = () =>
        (radios.find(r => r.checked)?.value || (client_id ? 'CLIENT' : 'GLOBAL'));

      const pill = (v) => (v == null || v === '' ? '-' : String(v));

      const rateRow = (p) => [
        `D:${pill(p.charge_day)} N:${pill(p.charge_night)} Sa:${pill(p.charge_sat)} Su:${pill(p.charge_sun)} BH:${pill(p.charge_bh)}`,
        `D:${pill(p.umb_day)   } N:${pill(p.umb_night)   } Sa:${pill(p.umb_sat)   } Su:${pill(p.umb_sun)   } BH:${pill(p.umb_bh)   }`,
        `D:${pill(p.paye_day)  } N:${pill(p.paye_night)  } Sa:${pill(p.paye_sat)  } Su:${pill(p.paye_sun)  } BH:${pill(p.paye_bh)  }`
      ];

      const updateApplyState = () => {
        const canApply = !!(pickerRows.length && pickerSelectedIndex >= 0);

        // Only touch THIS pickerâ€™s Save/Apply button
        const btn = pickerModalEl?.querySelector('#btnSave');
        if (btn) {
          btn.disabled = !canApply;
          btn.title = canApply ? '' : 'Select a preset to apply';
        }

        // Only update the picker frame (not the parent contracts frame)
        const fr = window.__getModalFrame?.();
        if (fr?.kind === 'rate-presets-picker' && typeof fr._updateButtons === 'function') {
          fr.__canSave = canApply;
          fr._updateButtons();
        }
      };

      const paint = () => {
        const activeIndex = pickerSelectedIndex;
        const body = pickerRows.map((r, i) => {
          const scope = String(r.scope || (r.client_id ? 'CLIENT' : 'GLOBAL')).toUpperCase();
          const name =
            r.name ||
            [r.role, r.band ? `Band ${r.band}` : ''].filter(Boolean).join(' / ') ||
            'Preset';

          const [chg, umb, paye] = rateRow(r);
          const isActive = (i === activeIndex);
          const cls = isActive ? ' class="active selected"' : '';

          const mileagePay = pill(r.mileage_pay_rate);
          const mileageCharge = pill(r.mileage_charge_rate);
          const mileageTxt =
            (mileagePay === '-' && mileageCharge === '-') ? '-' : `Pay ${mileagePay} / Charge ${mileageCharge}`;

          return `
            <tr data-i="${i}"${cls}>
              <td></td>
              <td>${name}</td>
              <td>${scope}</td>
              <td>${r.from_date || '-'} â†’ ${r.to_date || '-'}</td>
              <td>${chg}</td>
              <td>${paye}</td>
              <td>${umb}</td>
              <td>${mileageTxt}</td>
            </tr>`;
        }).join('');

        tbody.innerHTML =
          body || '<tr><td colspan="8" class="mini" style="text-align:center">No presets found</td></tr>';

        updateApplyState();
      };

      const fetchRows = async () => {
        const scope = scopeVal();
        const qRaw = (search?.value || '').trim();
        const q = qRaw.toLowerCase();
        const cid = client_id ? String(client_id) : null;

        try {
          let rows = [];

          if (scope === 'GLOBAL') {
            // All GLOBAL presets (search handled client-side)
            rows = await listRatePresets({ scope: 'GLOBAL' });
          } else if (scope === 'CLIENT') {
            // All CLIENT presets for this client id
            rows = cid ? await listRatePresets({ scope: 'CLIENT', client_id: cid }) : [];
          } else { // ALL
            const globals = await listRatePresets({ scope: 'GLOBAL' });
            const clientRows = cid ? await listRatePresets({ scope: 'CLIENT', client_id: cid }) : [];
            rows = [...globals, ...clientRows];
          }

          rows = Array.isArray(rows) ? rows : [];

          // Front-end search: match on name / role / band / display_site
          if (q) {
            rows = rows.filter(r => {
              const name = String(r.name || '').toLowerCase();
              const role = String(r.role || '').toLowerCase();
              const band = String(r.band || '').toLowerCase();
              const site = String(r.display_site || '').toLowerCase();
              return (
                name.includes(q) ||
                role.includes(q) ||
                band.includes(q) ||
                site.includes(q)
              );
            });
          }

          // Alphabetical by Name, then Role/Band
          rows.sort((a, b) => {
            const aName = (a.name || a.role || '').toString().toLowerCase();
            const bName = (b.name || b.role || '').toString().toLowerCase();
            if (aName < bName) return -1;
            if (aName > bName) return 1;
            return 0;
          });

          // If you have sortPresetsForView, keep using it; otherwise rows as-is
          pickerRows = (typeof sortPresetsForView === 'function')
            ? sortPresetsForView(scope, rows)
            : rows;

          L('fetchRows: got presets', { scope, q: qRaw, count: pickerRows.length });
        } catch (e) {
          console.error('[PRESETS] fetchRows error', e);
          pickerRows = [];
        }

        // reset selection
        pickerSelectedIndex = -1;
        pickerSelectedId = null;
        paint();
      };

      // Single-click: just select the row; don't repaint tbody
      tbody.addEventListener('click', (e) => {
        const tr = e.target.closest('tr[data-i]');
        if (!tr) return;
        const idx = +tr.getAttribute('data-i');
        if (!Number.isFinite(idx)) return;

        pickerSelectedIndex = idx;
        pickerSelectedId = pickerRows[idx]?.id || null;
        L('row click â†’ select', { idx, id: pickerSelectedId });

        // Toggle selection classes without rebuilding the tbody
        tbody.querySelectorAll('tr.active, tr.selected').forEach(n => n.classList.remove('active','selected'));
        tr.classList.add('active','selected');

        updateApplyState();
      });

      // Double-click: select + programmatically press the pickerâ€™s Apply button
      tbody.addEventListener('dblclick', (e) => {
        let idx = pickerSelectedIndex;
        const tr = e.target.closest('tr[data-i]');
        if (tr && Number.isFinite(+tr.getAttribute('data-i'))) {
          idx = +tr.getAttribute('data-i');
        }
        if (!Number.isFinite(idx) || idx < 0) return;

        pickerSelectedIndex = idx;
        pickerSelectedId = pickerRows[idx]?.id || null;
        L('row dblclick â†’ apply', { idx, id: pickerSelectedId });

        const btn = pickerModalEl?.querySelector('#btnSave');
        if (btn && !btn.disabled) {
          btn.click();   // triggers saveForFrame â†’ onApply â†’ framework closes child properly
        }

        e.preventDefault();
        e.stopPropagation();
      });

      search?.addEventListener('input', fetchRows);
      radios.forEach(r => r.addEventListener('change', fetchRows));

      await fetchRows();

      try {
        const fr = window.__getModalFrame?.();
        if (fr && fr.kind === 'rate-presets-picker' && typeof setFrameMode === 'function') {
          setFrameMode(fr, 'view');
          fr._updateButtons && fr._updateButtons();
        }
      } catch {}
    },
    { kind: 'rate-presets-picker', noParentGate: false }
  );

  setTimeout(() => {
    const fr = window.__getModalFrame?.();
    if (!fr || fr.kind !== 'rate-presets-picker') return;

    if (typeof fr.onReturn === 'function' && !fr.__init__) {
      fr.__init__ = true;
      fr.onReturn(fr);
    }
    fr._onSave = onApply;
  }, 0);
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Parent modal â€” Preset Rates manager
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


function openPresetRatesManager(){
  // Shared state for the manager; child modals can request refresh via this handle
  window.__ratesPresets__ = window.__ratesPresets__ || {};
  const S = window.__ratesPresets__;

  S.scope     = S.scope || 'ALL';     // 'ALL' | 'GLOBAL' | 'CLIENT'
  S.client_id = S.client_id || null;  // when scope === 'CLIENT'
  S.client_label = S.client_label || '';
  S.q         = S.q || '';

  const renderTable = (rows) => {
    const hasRows = Array.isArray(rows) && rows.length;
    if (!hasRows) {
      if (S.scope === 'CLIENT') {
        if (!S.client_id) {
          return `<div class="hint">Pick a client to see client-specific presets.</div>`;
        }
        return `<div class="hint">No presets exist for this client yet.</div>`;
      }
      return `<div class="hint">No presets match the current filter.</div>`;
    }

    const fmtWhen = (iso) => {
      if (!iso) return '';
      try { return (new Date(iso)).toLocaleString(); } catch { return iso; }
    };
    return `
      <table class="grid" id="ratesPresetsTable">
        <thead>
          <tr>
            <th>Name</th>
            <th>Scope</th>
            <th>Client</th>
            <th>Role</th>
            <th>Band</th>
            <th>Last edited</th>
            <th></th>
          </tr>
        </thead>
        <tbody>
          ${rows.map(r => `
            <tr data-id="${r.id}">
              <td>${r.name || ''}</td>
              <td>${(String(r.scope || (r.client_id ? 'CLIENT' : 'GLOBAL')).toUpperCase())}</td>
              <td>${(r.client && r.client.name) ? r.client.name : (r.client_name || '')}</td>
              <td>${r.role || ''}</td>
              <td>${r.band ?? ''}</td>
              <td class="mini">${fmtWhen(r.updated_at)}</td>
              <td class="mini">
                <button
                  type="button"
                  class="icon bin"
                  data-del="${r.id}"
                  title="Delete"
                >ðŸ—‘</button>
              </td>
            </tr>
          `).join('')}
        </tbody>
      </table>
    `;
  };

  const buildBody = (rows=[]) => {
    const scopeAll    = S.scope === 'ALL'    ? 'checked' : '';
    const scopeGlobal = S.scope === 'GLOBAL' ? 'checked' : '';
    const scopeClient = S.scope === 'CLIENT' ? 'checked' : '';

    const clientBadgeInner = S.client_label
      ? `<span class="pill">${S.client_label}</span>`
      : `<span class="mini">No client selected</span>`;

    return `
      <div class="tabc">
        <div class="row">
          <label>Scope</label>
          <div class="controls">
            <label><input type="radio" name="rp_scope" value="ALL" ${scopeAll}/> All</label>
            <label><input type="radio" name="rp_scope" value="GLOBAL" ${scopeGlobal}/> Global</label>
            <label><input type="radio" name="rp_scope" value="CLIENT" ${scopeClient}/> Client</label>
          </div>
        </div>

        <div class="row" id="rp_client_row" style="display:${S.scope==='CLIENT' ? 'block':'none'}">
          <label>Client</label>
          <div class="controls">
            <div class="split">
              <button type="button" class="btn mini" id="rp_pick_client">Pickâ€¦</button>
              <button type="button" class="btn mini" id="rp_clear_client">Clear</button>
              <div id="rp_cli_badge">${clientBadgeInner}</div>
            </div>
          </div>
        </div>

        <div class="row">
          <label>Search</label>
          <div class="controls">
            <input class="input" type="text" id="rp_q" value="${S.q || ''}" placeholder="Filter by name, role, bandâ€¦"/>
          </div>
        </div>

        <div id="rp_table_wrap">${renderTable(rows)}</div>
      </div>
    `;
  };

  const fetchRows = async () => {
    const params = {
      scope: S.scope,
      client_id: (S.scope === 'CLIENT' ? S.client_id : null),
      q: S.q || undefined
    };

    // Avoid noisy calls when client scope is chosen but no client selected yet.
    if (params.scope === 'CLIENT' && !params.client_id) {
      return [];
    }

    const raw = await listRatePresets(params);
    let rows = Array.isArray(raw) ? raw : [];

    // Hard filter: in CLIENT scope we only ever show client-specific rows for this client.
    if (S.scope === 'CLIENT' && S.client_id) {
      const cid = String(S.client_id);
      rows = rows.filter(r => {
        const sc = String(r.scope || (r.client_id ? 'CLIENT' : 'GLOBAL')).toUpperCase();
        return sc === 'CLIENT' && String(r.client_id || '') === cid;
      });
    }

    return sortPresetsForView(S.scope, rows);
  };

  // Keep selected row id in the manager context
  S.selectedId = null;

  showModal(
    'Preset Rates',
    [{ key: 'main', title: 'Presets' }],
    () => '<div class="tabc"><div class="hint">Loadingâ€¦</div></div>',
    async () => true, // no save in parent
    false,
    async () => {
      const rows = await fetchRows();
      const mb = document.getElementById('modalBody');
      if (mb) mb.innerHTML = buildBody(rows);

      // Make sure header Delete stays hidden for this manager
      const delBtn = document.getElementById('btnDelete');
      if (delBtn) {
        delBtn.style.display = 'none';
        delBtn.onclick = null;
      }

      // Inject a scoped "New" button (idempotent) into the real actions bar
      if (!document.getElementById('btnRpNew')) {
        const bar = document.getElementById('btnSave')?.parentElement;
        if (bar) {
          const nb = document.createElement('button');
          nb.id = 'btnRpNew';
          nb.type = 'button';
          nb.className = 'btn';
          nb.textContent = 'New';
          nb.style.marginLeft = 'auto';
          nb.onclick = () => openRatePresetModal({ mode: 'edit' });
          bar.insertBefore(nb, document.getElementById('btnSave'));
        }
      }

      // Clean-up hook so "New" disappears when this frame is not top-most
      try {
        const fr = window.__getModalFrame?.();
        const prevDetach = fr && fr._detachGlobal;
        if (fr) {
          fr._detachGlobal = () => {
            try { document.getElementById('btnRpNew')?.remove(); } catch {}
            if (typeof prevDetach === 'function') { try { prevDetach(); } catch {} }
          };
        }
      } catch {}

      // Expose refresh to child modal
      S.refresh = async () => {
        const newRows = await fetchRows();
        const host = document.getElementById('rp_table_wrap');
        if (!host) return; // parent closed or not mounted
        host.innerHTML = renderTable(newRows);
        S.selectedId = null;
        wireTable();
      };

      function wireTable(){
        const tbl = document.getElementById('ratesPresetsTable');
        if (!tbl) return;

        tbl.addEventListener('click', (e) => {
          const delEl = e.target.closest('button[data-del]');
          if (delEl) {
            const id = delEl.getAttribute('data-del');
            if (!id) return;
            if (!confirm('Delete this preset?')) return;
            (async () => {
              try {
                await deleteRatePreset(id);
                if (S.selectedId === id) S.selectedId = null;
                await S.refresh();
              } catch (err) {
                alert(err?.message || 'Delete failed');
              }
            })();
            e.stopPropagation();
            return;
          }

          const tr = e.target.closest('tr[data-id]');
          if (!tr) return;
          S.selectedId = tr.getAttribute('data-id');
          tbl.querySelectorAll('tr').forEach(n => n.classList.remove('active'));
          tr.classList.add('active');
        });

        tbl.addEventListener('dblclick', (e) => {
          const tr = e.target.closest('tr[data-id]'); if (!tr) return;
          const id = tr.getAttribute('data-id');
          openRatePresetModal({ id, mode:'view' });
        });
      }

      function wireFilters(){
        const radios = Array.from(document.querySelectorAll('input[name="rp_scope"]'));
        radios.forEach(r => r.addEventListener('change', async () => {
          S.scope = r.value;
          const row = document.getElementById('rp_client_row');
          if (row) row.style.display = (S.scope === 'CLIENT' ? 'block':'none');
          await S.refresh();
        }));

        const pick = document.getElementById('rp_pick_client');
        if (pick) pick.onclick = () => {
          openClientPicker(({ id, label }) => {
            S.client_id = id;
            S.client_label = label;
            const badge = document.getElementById('rp_cli_badge');
            if (badge) badge.innerHTML = `<span class="pill">${label}</span>`;
            S.refresh();
          });
        };
        const clr = document.getElementById('rp_clear_client');
        if (clr) clr.onclick = () => {
          S.client_id = null;
          S.client_label = '';
          const badge = document.getElementById('rp_cli_badge');
          if (badge) badge.innerHTML = '<span class="mini">No client selected</span>';
          S.refresh();
        };

        const inpQ = document.getElementById('rp_q');
        if (inpQ && !inpQ.__wired) {
          inpQ.__wired = true;
          let t = 0;
          inpQ.addEventListener('input', () => {
            if (t) clearTimeout(t);
            t = setTimeout(() => { S.q = inpQ.value.trim(); S.refresh(); }, 180);
          });
        }
      }

      wireTable();
      wireFilters();
    },
    { kind:'rates-presets' }
  );

  // Kick the managerâ€™s onReturn so it replaces the â€œLoadingâ€¦â€ stub
  setTimeout(() => {
    const fr = window.__getModalFrame?.();
    if (fr && fr.kind === 'rates-presets' && typeof fr.onReturn === 'function' && !fr.__init__) {
      fr.__init__ = true;
      fr.onReturn();
    }
  }, 0);
}


async function openRatePresetModal({ id, mode } = {}) {
  const isCreate = !id;
  let initialMode = mode || (isCreate ? 'edit' : 'view');
  initialMode = String(initialMode || '').toLowerCase();
  if (initialMode === 'create') initialMode = 'edit';
  if (initialMode !== 'edit' && initialMode !== 'view') {
    initialMode = isCreate ? 'edit' : 'view';
  }

  const st = {
    id: id || null,
    scope: 'GLOBAL',
    client_id: null,
    client_label: '',
    name: '',
    role: '',
    band: '',
    display_site: '',
    bucket_day: 'Day',
    bucket_night: 'Night',
    bucket_sat: 'Sat',
    bucket_sun: 'Sun',
    bucket_bh: 'BH',
    enable_paye: false,
    enable_umbrella: false,
    payMode: 'PAYE', // 'PAYE' | 'UMB' | 'BOTH'
    paye_day: '',
    paye_night: '',
    paye_sat: '',
    paye_sun: '',
    paye_bh: '',
    umb_day: '',
    umb_night: '',
    umb_sat: '',
    umb_sun: '',
    umb_bh: '',
    charge_day: '',
    charge_night: '',
    charge_sat: '',
    charge_sun: '',
    charge_bh: '',
    mileage_pay_rate: '',
    mileage_charge_rate: '',
    use_schedule: false,
    mon_start: '',
    mon_end: '',
    mon_break: '',
    tue_start: '',
    tue_end: '',
    tue_break: '',
    wed_start: '',
    wed_end: '',
    wed_break: '',
    thu_start: '',
    thu_end: '',
    thu_break: '',
    fri_start: '',
    fri_end: '',
    fri_break: '',
    sat_start: '',
    sat_end: '',
    sat_break: '',
    sun_start: '',
    sun_end: '',
    sun_break: ''
  };

  if (id) {
    try {
      const row = await loadRatePreset(id);
      st.id = row.id || id;
      st.scope = (String(row.scope || (row.client_id ? 'CLIENT' : 'GLOBAL')).toUpperCase() === 'CLIENT') ? 'CLIENT' : 'GLOBAL';
      st.client_id = row.client_id || null;
      st.client_label = (row.client && row.client.name) ? row.client.name : (row.client_name || '');
      st.name = row.name || '';
      st.role = row.role || '';
      st.band = (row.band == null ? '' : String(row.band));
      st.display_site = row.display_site || '';

      const L = normaliseBucketLabelsInput(row.bucket_labels_json || null) || labelsDefault();
      st.bucket_day = L.day;
      st.bucket_night = L.night;
      st.bucket_sat = L.sat;
      st.bucket_sun = L.sun;
      st.bucket_bh = L.bh;

      st.enable_paye = !!row.enable_paye;
      st.enable_umbrella = !!row.enable_umbrella;

      if (st.enable_paye && st.enable_umbrella) {
        st.payMode = 'BOTH';
      } else if (st.enable_paye) {
        st.payMode = 'PAYE';
      } else if (st.enable_umbrella) {
        st.payMode = 'UMB';
      } else {
        st.payMode = 'PAYE';
      }

      const put = (k, v) => { if (v === 0 || (v != null && v !== '')) st[k] = String(v); };
      const R = row || {};

      put('paye_day', R.paye_day);
      put('paye_night', R.paye_night);
      put('paye_sat', R.paye_sat);
      put('paye_sun', R.paye_sun);
      put('paye_bh', R.paye_bh);

      put('umb_day', R.umb_day);
      put('umb_night', R.umb_night);
      put('umb_sat', R.umb_sat);
      put('umb_sun', R.umb_sun);
      put('umb_bh', R.umb_bh);

      put('charge_day', R.charge_day);
      put('charge_night', R.charge_night);
      put('charge_sat', R.charge_sat);
      put('charge_sun', R.charge_sun);
      put('charge_bh', R.charge_bh);

      put('mileage_pay_rate', R.mileage_pay_rate);
      put('mileage_charge_rate', R.mileage_charge_rate);

      if (row.std_schedule_json && typeof row.std_schedule_json === 'object') {
        st.use_schedule = true;
        const S = row.std_schedule_json || {};
        const days = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'];
        days.forEach(d => {
          if (S[d]) {
            st[`${d}_start`] = S[d].start || '';
            st[`${d}_end`] = S[d].end || '';
            st[`${d}_break`] = (S[d].break_minutes == null ? '' : String(S[d].break_minutes));
          }
        });
      }
    } catch (e) {
      alert(e?.message || 'Failed to load preset');
      return;
    }
  }

  const buckets = ['day', 'night', 'sat', 'sun', 'bh'];

  function getFieldValue(root, name) {
    if (!root) return '';
    const el = root.querySelector(`[name="${name}"]`);
    return (el && typeof el.value === 'string') ? el.value.trim() : '';
  }

  function parseNumeric(raw) {
    if (raw == null) return null;
    const s = String(raw).trim();
    if (!s) return null;
    const n = Number(s);
    return Number.isFinite(n) ? n : null;
  }

  function parseNumericFromRoot(root, name) {
    return parseNumeric(getFieldValue(root, name));
  }

  function computePresetEligibility(root, st) {
    const result = { margin: null, eligible: false, rateState: null, scope: '', payMode: '', reasons: [] };
    if (!root) return result;

    const rtEl = root.querySelector('#rp_rate_type');
    let scopeVal = (rtEl && rtEl.value) ? String(rtEl.value).toUpperCase() : '';
    if (scopeVal !== 'GLOBAL' && scopeVal !== 'CLIENT') scopeVal = '';
    result.scope = scopeVal;
    if (scopeVal) st.scope = scopeVal;

    const pmEl = root.querySelector('#rp_pay_mode');
    let payModeVal = (pmEl && pmEl.value) ? String(pmEl.value).toUpperCase() : (st.payMode || '');
    if (!['PAYE', 'UMB', 'BOTH'].includes(payModeVal)) payModeVal = '';
    result.payMode = payModeVal;

    const rateState = {
      enable_paye: ['PAYE', 'BOTH'].includes(payModeVal),
      enable_umbrella: ['UMB', 'BOTH'].includes(payModeVal)
    };

    buckets.forEach(b => {
      ['paye', 'umb', 'charge'].forEach(prefix => {
        rateState[`${prefix}_${b}`] = parseNumericFromRoot(root, `${prefix}_${b}`);
      });
    });

    result.rateState = rateState;
    const margin = computeRatePresetMargins(rateState);
    result.margin = margin;

    let eligible = true;

    const nameVal = getFieldValue(root, 'name');
    if (!nameVal) { eligible = false; result.reasons.push('name'); }

    const roleVal = getFieldValue(root, 'role');
    if (!roleVal) { eligible = false; result.reasons.push('role'); }

    if (!scopeVal) { eligible = false; result.reasons.push('scope'); }
    if (scopeVal === 'CLIENT') {
      const cid = st.client_id || '';
      if (!cid) { eligible = false; result.reasons.push('client'); }
    }

    const labelNames = ['bucket_day', 'bucket_night', 'bucket_sat', 'bucket_sun', 'bucket_bh'];
    const anyLabel = labelNames.some(n => !!getFieldValue(root, n));
    if (!anyLabel) { eligible = false; result.reasons.push('labels'); }

    if (!payModeVal) { eligible = false; result.reasons.push('payMode'); }

    const hasCharge = buckets.some(b => Number.isFinite(rateState[`charge_${b}`]));
    if (!hasCharge) { eligible = false; result.reasons.push('rates_charge'); }

    if (payModeVal === 'PAYE') {
      const okRow = buckets.some(
        b => Number.isFinite(rateState[`paye_${b}`]) && Number.isFinite(rateState[`charge_${b}`])
      );
      if (!okRow) { eligible = false; result.reasons.push('rates_paye'); }
    } else if (payModeVal === 'UMB') {
      const okRow = buckets.some(
        b => Number.isFinite(rateState[`umb_${b}`]) && Number.isFinite(rateState[`charge_${b}`])
      );
      if (!okRow) { eligible = false; result.reasons.push('rates_umb'); }
    } else if (payModeVal === 'BOTH') {
      const okRow = buckets.some(
        b =>
          Number.isFinite(rateState[`paye_${b}`]) &&
          Number.isFinite(rateState[`umb_${b}`]) &&
          Number.isFinite(rateState[`charge_${b}`])
      );
      if (!okRow) { eligible = false; result.reasons.push('rates_both'); }
    }

    const useScheduleEl = root.querySelector('#rp_use_schedule');
    const useSchedule = !!useScheduleEl && !!useScheduleEl.checked;
    if (useSchedule) {
      const days = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'];
      const S = {};
      const hhmm = (s) => {
        if (!s) return '';
        const m = String(s).match(/^(\d{1,2}):?(\d{2})$/);
        if (!m) return '';
        const h = +m[1], mi = +m[2];
        if (h < 0 || h > 23 || mi < 0 || mi > 59) return '';
        return String(h).padStart(2, '0') + ':' + String(mi).padStart(2, '0');
      };
      days.forEach(d => {
        const s = hhmm(getFieldValue(root, `${d}_start`));
        const e = hhmm(getFieldValue(root, `${d}_end`));
        const br = getFieldValue(root, `${d}_break`);
        if (s && e) {
          S[d] = { start: s, end: e, break_minutes: Math.max(0, Number(br || 0)) };
        }
      });
      if (Object.keys(S).length === 0) {
        eligible = false;
        result.reasons.push('schedule');
      }
    }

    result.eligible = eligible;
    return result;
  }

  const renderGrid = () => {
    const tempState = {
      enable_paye: ['PAYE', 'BOTH'].includes(st.payMode),
      enable_umbrella: ['UMB', 'BOTH'].includes(st.payMode)
    };
    buckets.forEach(b => {
      tempState[`paye_${b}`] = parseNumeric(st[`paye_${b}`]);
      tempState[`umb_${b}`] = parseNumeric(st[`umb_${b}`]);
      tempState[`charge_${b}`] = parseNumeric(st[`charge_${b}`]);
    });
    const margin = computeRatePresetMargins(tempState);

    const row = (lab, key) => {
      const MP = margin.bucket[key]?.marginPaye;
      const MU = margin.bucket[key]?.marginUmb;
      const negP = margin.bucket[key]?.negPaye;
      const negU = margin.bucket[key]?.negUmb;
      const mTxt = [
        (tempState.enable_paye ? `PAYE: ${MP == null ? 'â€”' : MP.toFixed(2)}${negP ? ' âš ' : ''}` : ''),
        (tempState.enable_umbrella ? `Umb: ${MU == null ? 'â€”' : MU.toFixed(2)}${negU ? ' âš ' : ''}` : '')
      ].filter(Boolean).join(' â€¢ ');

      return `
        <div class="grid-5 rp-rate-row" data-bucket="${key}">
          <div class="split"><span class="lbl">${lab}</span></div>
          <div class="rp-col-paye">
            <input class="input" name="paye_${key}" placeholder="PAYE" value="${st[`paye_${key}`] || ''}"/>
          </div>
          <div class="rp-col-umb">
            <input class="input" name="umb_${key}" placeholder="Umbrella" value="${st[`umb_${key}`] || ''}"/>
          </div>
          <div class="rp-col-charge">
            <input class="input" name="charge_${key}" placeholder="Charge" value="${st[`charge_${key}`] || ''}"/>
          </div>
          <div class="mini" data-role="margin">${mTxt || ''}</div>
        </div>`;
    };

    return `
      <div class="group">
        <div class="row"><label>Rates</label>
          <div class="controls small">
            <div class="grid-5" id="rp_rates_header">
              <div></div>
              <div class="mini rp-col-paye">PAYE</div>
              <div class="mini rp-col-umb">Umbrella</div>
              <div class="mini rp-col-charge">Charge</div>
              <div class="mini">Margin</div>
            </div>
            ${row(st.bucket_day, 'day')}
            ${row(st.bucket_night, 'night')}
            ${row(st.bucket_sat, 'sat')}
            ${row(st.bucket_sun, 'sun')}
            ${row(st.bucket_bh, 'bh')}
            <div class="mini" id="rp_margin_warn" style="margin-top:6px;${margin.anyNegative ? '' : 'display:none'}">Margin can't be negative.</div>
          </div>
        </div>
      </div>
    `;
  };

  const renderSchedule = () => {
    const timeInput = (name, val) => `<input class="input rp-time" name="${name}" value="${val || ''}" placeholder="HH:MM" />`;
    const breakInput = (name, val) => `<input class="input rp-break" type="number" min="0" step="1" name="${name}" value="${val || ''}" placeholder="0" />`;
    const row = (key, label) => `
      <div class="rp-day" data-day="${key}" style="margin-bottom:10px">
        <div class="grid-3">
          <div class="split"><span class="mini">${label} start</span>${timeInput(`${key}_start`, st[`${key}_start`])}</div>
          <div class="split"><span class="mini">${label} end</span>${timeInput(`${key}_end`, st[`${key}_end`])}</div>
          <div class="split"><span class="mini">Break (min)</span>${breakInput(`${key}_break`, st[`${key}_break`])}</div>
        </div>
        <div class="split" style="margin-top:6px">
          <button type="button" class="btn mini rp_copy" data-day="${key}">Copy</button>
          <button type="button" class="btn mini rp_paste" data-day="${key}">Paste</button>
        </div>
      </div>`;
    return `
      <div class="group">
        <label><input type="checkbox" id="rp_use_schedule" ${st.use_schedule ? 'checked' : ''}/> Default shift times</label>
        <div id="rp_sched_block" style="display:${st.use_schedule ? 'block' : 'none'}; margin-top:8px">
          ${row('mon', 'Mon')}${row('tue', 'Tue')}${row('wed', 'Wed')}
          ${row('thu', 'Thu')}${row('fri', 'Fri')}${row('sat', 'Sat')}
          ${row('sun', 'Sun')}
        </div>
      </div>`;
  };

  const renderLabels = () => `
    <div class="group">
      <div class="row"><label>Bucket labels</label>
        <div class="controls small">
          <div class="grid-5" id="rp_labels_grid">
            <div><span class="mini">Standard</span><input class="input" name="bucket_day"   value="${st.bucket_day}"/></div>
            <div><span class="mini">OT1</span>     <input class="input" name="bucket_night" value="${st.bucket_night}"/></div>
            <div><span class="mini">OT2</span>     <input class="input" name="bucket_sat"   value="${st.bucket_sat}"/></div>
            <div><span class="mini">OT3</span>     <input class="input" name="bucket_sun"   value="${st.bucket_sun}"/></div>
            <div><span class="mini">OT4</span>     <input class="input" name="bucket_bh"    value="${st.bucket_bh}"/></div>
          </div>
          <div style="margin-top:8px">
            <span class="mini">Pay mode</span>
            <select class="input" name="rp_pay_mode" id="rp_pay_mode">
              <option value="PAYE" ${st.payMode === 'PAYE' ? 'selected' : ''}>PAYE</option>
              <option value="UMB" ${st.payMode === 'UMB' ? 'selected' : ''}>Umbrella</option>
              <option value="BOTH" ${st.payMode === 'BOTH' ? 'selected' : ''}>PAYE &amp; Umbrella</option>
            </select>
          </div>
        </div>
      </div>
    </div>`;

  const renderTop = () => `
    <div class="group">
      <div class="row">
        <label>Name</label>
        <div class="controls"><input class="input" name="name" value="${st.name}"/></div>
      </div>

      <div class="row">
        <label>Rate type</label>
        <div class="controls">
          <select id="rp_rate_type" class="input">
            <option value="">Please select</option>
            <option value="GLOBAL" ${st.scope === 'GLOBAL' ? 'selected' : ''}>Global</option>
            <option value="CLIENT" ${st.scope === 'CLIENT' ? 'selected' : ''}>Client specific</option>
          </select>
        </div>
      </div>

      <div class="row" id="rp_client_row" style="margin-top:6px; display:${st.scope === 'CLIENT' ? 'block' : 'none'}">
        <label>Client rate</label>
        <div class="controls">
          <div class="split">
            <button type="button" class="btn mini" id="rp_pick_cli_btn">Pickâ€¦</button>
            <button type="button" class="btn mini" id="rp_clear_cli_btn">Clear</button>
            <span class="mini" id="rp_cli_lbl">${st.client_label ? `Chosen: ${st.client_label}` : 'No client chosen'}</span>
          </div>
        </div>
      </div>

      <div class="grid-3">
        <div class="row"><label>Role</label><div class="controls"><input class="input" name="role" value="${st.role}"/></div></div>
        <div class="row"><label>Band</label><div class="controls"><input class="input" name="band" value="${st.band}"/></div></div>
        <div class="row"><label>Display site</label><div class="controls"><input class="input" name="display_site" value="${st.display_site}"/></div></div>
      </div>
    </div>`;

  const renderMileage = () => `
    <div class="group">
      <div class="row"><label>Mileage</label>
        <div class="controls">
          <div class="grid-3">
            <div class="split"><span class="mini">Pay</span>   <input class="input" name="mileage_pay_rate"    value="${st.mileage_pay_rate || ''}" placeholder="0.00"/></div>
            <div class="split"><span class="mini">Charge</span><input class="input" name="mileage_charge_rate" value="${st.mileage_charge_rate || ''}" placeholder="0.00"/></div>
          </div>
        </div>
      </div>
    </div>`;

  const renderer = () => `
    <div class="tabc">
      <div class="form" id="rp_form">
        <div>
          ${renderTop()}
          ${renderLabels()}
          ${renderGrid()}
          ${renderMileage()}
        </div>
        <div>
          ${renderSchedule()}
        </div>
      </div>
    </div>
  `;

  const onSave = async () => {
    const root = document.getElementById('rp_form');
    if (!root) return false;

    const v = (n) => getFieldValue(root, n);

    const rtEl = root.querySelector('#rp_rate_type');
    let scopeVal = (rtEl && rtEl.value) ? String(rtEl.value).toUpperCase() : '';
    const scopeIsClient = (scopeVal === 'CLIENT');
    const scopeIsGlobal = (scopeVal === 'GLOBAL');

    if (!scopeIsClient && !scopeIsGlobal) {
      showModalHint('Select a rate type (Global or Client specific).', 'warn');
      return false;
    }

    const name = v('name');
    if (!name) {
      showModalHint('Name is required.', 'warn');
      return false;
    }

    const clientId = scopeIsClient ? (st.client_id || '') : '';
    if (scopeIsClient && !clientId) {
      showModalHint('Pick a client for a Client scope preset.', 'warn');
      return false;
    }

    const roleVal = v('role');
    if (!roleVal) {
      showModalHint('Role is required.', 'warn');
      return false;
    }

    const pmEl = root.querySelector('#rp_pay_mode');
    let payModeVal = (pmEl && pmEl.value) ? String(pmEl.value).toUpperCase() : (st.payMode || '');
    if (!['PAYE', 'UMB', 'BOTH'].includes(payModeVal)) {
      showModalHint('Choose PAYE, Umbrella or PAYE & Umbrella.', 'warn');
      return false;
    }

    const eligibility = computePresetEligibility(root, st);
    const margin = eligibility.margin || { anyNegative: false };
    if (margin.anyNegative) {
      showModalHint('Margin canâ€™t be negative.', 'warn');
      return false;
    }
    if (!eligibility.eligible) {
      showModalHint('Fill in all required fields (name, role, labels, rates and schedule if used).', 'warn');
      return false;
    }

    const enable_paye = ['PAYE', 'BOTH'].includes(payModeVal);
    const enable_umbrella = ['UMB', 'BOTH'].includes(payModeVal);

    const payload = {
      id: st.id || undefined,
      name,
      scope: scopeIsClient ? 'CLIENT' : 'GLOBAL',
      client_id: scopeIsClient ? st.client_id : null,
      role: roleVal || null,
      band: (v('band') === '' ? null : v('band')),
      display_site: v('display_site') || null,
      enable_paye,
      enable_umbrella
    };

    const labels = {
      day: v('bucket_day'),
      night: v('bucket_night'),
      sat: v('bucket_sat'),
      sun: v('bucket_sun'),
      bh: v('bucket_bh')
    };
    const Lnorm = normaliseBucketLabelsInput(labels);
    if (Lnorm) payload.bucket_labels_json = Lnorm;

    const bucketsList = ['day','night','sat','sun','bh'];
    const push5 = (prefix, enabled) => {
      if (!enabled) return;
      bucketsList.forEach(b => {
        const key = `${prefix}_${b}`;
        const n = parseNumericFromRoot(root, key);
        if (n != null) payload[key] = n;
      });
    };
    push5('paye', enable_paye);
    push5('umb', enable_umbrella);
    push5('charge', true);

    const mileage_pay = parseNumericFromRoot(root, 'mileage_pay_rate');
    const mileage_charge = parseNumericFromRoot(root, 'mileage_charge_rate');
    if (mileage_pay != null && mileage_pay < 0) {
      showModalHint('Mileage pay must be â‰¥ 0', 'warn');
      return false;
    }
    if (mileage_charge != null && mileage_charge < 0) {
      showModalHint('Mileage charge must be â‰¥ 0', 'warn');
      return false;
    }
    if (mileage_pay != null) payload.mileage_pay_rate = mileage_pay;
    if (mileage_charge != null) payload.mileage_charge_rate = mileage_charge;

    const use_schedule = !!document.getElementById('rp_use_schedule')?.checked;
    if (use_schedule) {
      const days = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'];
      const S = {};
      const hhmm = (s) => {
        if (!s) return '';
        const m = String(s).match(/^(\d{1,2}):?(\d{2})$/);
        if (!m) return '';
        const h = +m[1], mi = +m[2];
        if (h < 0 || h > 23 || mi < 0 || mi > 59) return '';
        return String(h).padStart(2, '0') + ':' + String(mi).padStart(2, '0');
      };
      days.forEach(d => {
        const s = hhmm(v(`${d}_start`));
        const e = hhmm(v(`${d}_end`));
        const br = v(`${d}_break`);
        if (s && e) {
          S[d] = { start: s, end: e, break_minutes: Math.max(0, Number(br || 0)) };
        }
      });
      if (Object.keys(S).length) payload.std_schedule_json = S;
    }

    try {
      await saveRatePreset(payload);
      try { window.__ratesPresets__?.refresh && window.__ratesPresets__.refresh(); } catch {}
      return true;
    } catch (e) {
      showModalHint(e?.message || 'Save failed', 'fail');
      return false;
    }
  };

  showModal(
    isCreate ? 'Create preset' : 'Rate preset',
    [{ key: 'main', title: 'Main' }],
    () => renderer(),
    onSave,
    !!st.id,
    () => {
      const root = document.getElementById('rp_form');

      const saveBtn = document.getElementById('btnSave');
      if (saveBtn && initialMode === 'view') {
        saveBtn.disabled = true;
        saveBtn.title = 'Click Edit to make changes';
      }

      const rateTypeSel = root?.querySelector('#rp_rate_type');
      const cliRow = root?.querySelector('#rp_client_row');
      const cliLbl = root?.querySelector('#rp_cli_lbl');
      const btnPick = root?.querySelector('#rp_pick_cli_btn');
      const btnClr = root?.querySelector('#rp_clear_cli_btn');

      const ensureMileagePrefill = async () => {
        const isCreateNow = !st.id;
        if (isCreateNow && st.scope === 'CLIENT' && st.client_id) {
          try {
            const cli = await getClient(st.client_id);
            const ch = Number(cli?.mileage_charge_rate);
            if (Number.isFinite(ch)) {
              const pay = Math.max(0, ch - 0.10);
              const payEl = root.querySelector('[name="mileage_pay_rate"]');
              const chEl = root.querySelector('[name="mileage_charge_rate"]');
              if (chEl && !chEl.value) { chEl.value = String(ch); st.mileage_charge_rate = String(ch); }
              if (payEl && !payEl.value) { payEl.value = pay.toFixed(2); st.mileage_pay_rate = payEl.value; }
            }
          } catch {}
        }
      };

      const toggleColDisplay = (selector, on) => {
        root?.querySelectorAll(selector).forEach(el => {
          el.style.display = on ? '' : 'none';
        });
      };

      function refreshPayModeColumns() {
        const payMode = st.payMode || 'PAYE';
        st.enable_paye = (payMode === 'PAYE' || payMode === 'BOTH');
        st.enable_umbrella = (payMode === 'UMB' || payMode === 'BOTH');

        buckets.forEach(b => {
          const paye = root?.querySelector(`[name="paye_${b}"]`);
          const umb = root?.querySelector(`[name="umb_${b}"]`);
          if (paye) paye.disabled = !st.enable_paye;
          if (umb) umb.disabled = !st.enable_umbrella;
        });

        toggleColDisplay('#rp_form .rp-col-paye', st.enable_paye);
        toggleColDisplay('#rp_form .rp-col-umb', st.enable_umbrella);
      }

      function updatePresetSaveState() {
        const { margin, rateState, eligible } = computePresetEligibility(root, st);

        const warn = root?.querySelector('#rp_margin_warn');
        if (warn) warn.style.display = (margin && margin.anyNegative) ? '' : 'none';

        buckets.forEach(b => {
          const cell = root?.querySelector(`.rp-rate-row[data-bucket="${b}"] [data-role="margin"]`);
          if (!cell) return;
          const bucketMargin = margin?.bucket?.[b] || {};
          const mp = bucketMargin.marginPaye;
          const mu = bucketMargin.marginUmb;
          const negP = bucketMargin.negPaye;
          const negU = bucketMargin.negUmb;
          const parts = [];
          if (rateState.enable_paye) {
            parts.push(`PAYE: ${mp == null || Number.isNaN(mp) ? 'â€”' : mp.toFixed(2)}${negP ? ' âš ' : ''}`);
          }
          if (rateState.enable_umbrella) {
            parts.push(`Umb: ${mu == null || Number.isNaN(mu) ? 'â€”' : mu.toFixed(2)}${negU ? ' âš ' : ''}`);
          }
          cell.textContent = parts.filter(Boolean).join(' â€¢ ');
        });

        const fr = window.__getModalFrame?.();
        const btn = document.getElementById('btnSave');
        const modeNow = fr?.mode || initialMode || 'view';
        const canSave = !!(modeNow === 'edit' && margin && !margin.anyNegative && eligible);
        if (btn) {
          btn.disabled = !canSave;
          if (modeNow !== 'edit') {
            btn.title = 'Click Edit to make changes';
          } else {
            btn.title = canSave ? '' : 'Fill required fields and fix any negative margins';
          }
        }
        if (fr && typeof fr._updateButtons === 'function') {
          fr.__canSave = canSave;
          fr._updateButtons();
        }
      }

      function setPayMode(newMode, opts) {
        const optsNorm = opts || {};
        const clearPrev = !!optsNorm.clearPrev;
        const prevMode = st.payMode || 'PAYE';
        if (!newMode) return;
        const modeNorm = String(newMode).toUpperCase();
        if (!['PAYE', 'UMB', 'BOTH'].includes(modeNorm)) return;

        if (clearPrev && prevMode !== modeNorm) {
          if (prevMode === 'PAYE' && modeNorm === 'UMB') {
            buckets.forEach(b => {
              st[`paye_${b}`] = '';
              const inp = root?.querySelector(`[name="paye_${b}"]`);
              if (inp) inp.value = '';
            });
          } else if (prevMode === 'UMB' && modeNorm === 'PAYE') {
            buckets.forEach(b => {
              st[`umb_${b}`] = '';
              const inp = root?.querySelector(`[name="umb_${b}"]`);
              if (inp) inp.value = '';
            });
          }
        }

        st.payMode = modeNorm;
        refreshPayModeColumns();
        updatePresetSaveState();
      }

      function syncPayModeFromDom(opts) {
        const pmEl = root?.querySelector('#rp_pay_mode');
        const valRaw = pmEl?.value || st.payMode || 'PAYE';
        const val = String(valRaw).toUpperCase();
        const mode = ['PAYE', 'UMB', 'BOTH'].includes(val) ? val : 'PAYE';
        setPayMode(mode, opts);
      }

      function applyScopeFromControl(isInit) {
        if (!rateTypeSel) return;
        const prevScope = st.scope || 'GLOBAL';
        let val = String(rateTypeSel.value || '').toUpperCase();
        if (val !== 'GLOBAL' && val !== 'CLIENT') val = 'GLOBAL';
        const nextScope = val;

        if (nextScope === 'CLIENT') {
          st.scope = 'CLIENT';
          if (cliRow) cliRow.style.display = 'block';
          ensureMileagePrefill();
        } else {
          st.scope = 'GLOBAL';
          if (cliRow) cliRow.style.display = 'none';
          if (!isInit && prevScope === 'CLIENT') {
            st.client_id = null;
            st.client_label = '';
            if (cliLbl) cliLbl.textContent = 'No client chosen';
          }
        }
        updatePresetSaveState();
      }

      if (rateTypeSel) {
        rateTypeSel.addEventListener('change', () => applyScopeFromControl(false));
        applyScopeFromControl(true);
      }

      if (btnPick) {
        btnPick.onclick = () => {
          openClientPicker(({ id, label }) => {
            st.client_id = id;
            st.client_label = label || '';
            if (cliLbl) cliLbl.textContent = label ? `Chosen: ${label}` : 'No client chosen';
            ensureMileagePrefill();
            updatePresetSaveState();
          }, { allowBackdropModal: true });
        };
      }

      if (btnClr) {
        btnClr.onclick = () => {
          st.client_id = null;
          st.client_label = '';
          if (cliLbl) cliLbl.textContent = 'No client chosen';
          updatePresetSaveState();
        };
      }

      const pmSelect = root?.querySelector('#rp_pay_mode');
      if (pmSelect) {
        pmSelect.addEventListener('change', () => syncPayModeFromDom({ clearPrev: true }));
        syncPayModeFromDom({ clearPrev: false });
      } else {
        st.payMode = st.payMode || 'PAYE';
        refreshPayModeColumns();
      }

      const lblMap = {
        bucket_day: 'day',
        bucket_night: 'night',
        bucket_sat: 'sat',
        bucket_sun: 'sun',
        bucket_bh: 'bh'
      };
      Object.keys(lblMap).forEach(n => {
        const el = root?.querySelector(`#rp_labels_grid [name="${n}"]`);
        if (!el) return;
        el.addEventListener('input', () => {
          const k = lblMap[n];
          st[`bucket_${k}`] = el.value || '';
          const cell = root?.querySelector(`.rp-rate-row[data-bucket="${k}"] .lbl`);
          if (cell) cell.textContent = st[`bucket_${k}`] || cell.textContent;
          updatePresetSaveState();
        });
      });

      const useSch = document.getElementById('rp_use_schedule');
      const schBlk = document.getElementById('rp_sched_block');
      if (useSch && schBlk) {
        const togg = () => {
          st.use_schedule = !!useSch.checked;
          schBlk.style.display = st.use_schedule ? 'block' : 'none';
          updatePresetSaveState();
        };
        useSch.addEventListener('change', togg);
        togg();
      }

      const normalizeRateInput = (el) => {
        if (!el) return;
        let v = (el.value || '').trim();
        if (!v) return;
        v = v.replace(/\s+/g, '');
        if (v.startsWith('.')) v = '0' + v;
        const n = Number(v);
        if (!Number.isFinite(n)) return;
        el.value = n.toFixed(2);
      };

      buckets.forEach(b => {
        ['paye', 'umb', 'charge'].forEach(prefix => {
          const inp = root?.querySelector(`[name="${prefix}_${b}"]`);
          if (inp) {
            inp.addEventListener('blur', () => {
              normalizeRateInput(inp);
              st[`${prefix}_${b}`] = inp.value || '';
              updatePresetSaveState();
            });
            inp.addEventListener('input', () => {
              st[`${prefix}_${b}`] = inp.value || '';
            });
          }
        });
      });

      const mileagePayEl = root?.querySelector('[name="mileage_pay_rate"]');
      const mileageChargeEl = root?.querySelector('[name="mileage_charge_rate"]');
      const normalizeMileageInput = (el) => {
        if (!el) return;
        let v = (el.value || '').trim();
        if (!v) return;
        if (v.startsWith('.')) v = '0' + v;
        let numVal;
        if (v.includes('.')) {
          numVal = Number(v);
        } else {
          numVal = Number(v) / 100;
        }
        if (!Number.isFinite(numVal)) return;
        el.value = numVal.toFixed(2);
      };
      if (mileagePayEl) {
        mileagePayEl.addEventListener('blur', () => {
          normalizeMileageInput(mileagePayEl);
          st.mileage_pay_rate = mileagePayEl.value || '';
          const isCreateNow = !st.id;
          if (isCreateNow && mileageChargeEl && !(mileageChargeEl.value || '').trim()) {
            mileageChargeEl.value = mileagePayEl.value;
            st.mileage_charge_rate = mileageChargeEl.value || '';
          }
          updatePresetSaveState();
        });
        mileagePayEl.addEventListener('input', () => {
          st.mileage_pay_rate = mileagePayEl.value || '';
        });
      }
      if (mileageChargeEl) {
        mileageChargeEl.addEventListener('blur', () => {
          normalizeMileageInput(mileageChargeEl);
          st.mileage_charge_rate = mileageChargeEl.value || '';
          updatePresetSaveState();
        });
        mileageChargeEl.addEventListener('input', () => {
          st.mileage_charge_rate = mileageChargeEl.value || '';
        });
      }

      let schedClipboard = null;
      const schedRoot = document.getElementById('rp_sched_block');

      const normaliseTimeInput = (t) => {
        if (!t || !/^(mon|tue|wed|thu|fri|sat|sun)_(start|end)$/.test(t.name)) return;
        const raw = (t.value || '').trim();
        const norm = (function (x) {
          if (!x) return '';
          const y = x.replace(/\s+/g, '');
          let h, m;
          if (/^\d{3,4}$/.test(y)) {
            const s = y.padStart(4, '0'); h = +s.slice(0, 2); m = +s.slice(2, 4);
          } else if (/^\d{1,2}:\d{1,2}$/.test(y)) {
            const parts = y.split(':'); h = +parts[0]; m = +parts[1];
          } else return '';
          if (h < 0 || h > 23 || m < 0 || m > 59) return '';
          return String(h).padStart(2, '0') + ':' + String(m).padStart(2, '0');
        })(raw);

        if (!norm && raw) {
          t.value = '';
          t.setAttribute('data-invalid', '1');
          t.setAttribute('title', 'Enter a valid time HH:MM (00:00â€“23:59)');
          try {
            t.dispatchEvent(new Event('input', { bubbles: true }));
            t.dispatchEvent(new Event('change', { bubbles: true }));
          } catch {}
          st[t.name] = '';
          return;
        }

        if (norm) {
          t.value = norm;
          t.removeAttribute('data-invalid');
          t.removeAttribute('title');
          st[t.name] = norm;
          try {
            t.dispatchEvent(new Event('input', { bubbles: true }));
            t.dispatchEvent(new Event('change', { bubbles: true }));
          } catch {}
        }
      };

      if (schedRoot) {
        schedRoot.addEventListener('blur', (e) => {
          normaliseTimeInput(e.target);
        }, true);

        schedRoot.addEventListener('keydown', (e) => {
          if (e.key === 'Tab') normaliseTimeInput(e.target);
        }, true);

        schedRoot.addEventListener('click', (e) => {
          const copyBtn = e.target.closest('button.rp_copy');
          const pasteBtn = e.target.closest('button.rp_paste');
          if (copyBtn) {
            const day = copyBtn.dataset.day;
            const sEl = root.querySelector(`[name="${day}_start"]`);
            const eEl = root.querySelector(`[name="${day}_end"]`);
            const bEl = root.querySelector(`[name="${day}_break"]`);
            schedClipboard = {
              start: sEl?.value || '',
              end: eEl?.value || '',
              br: bEl?.value || ''
            };
            return;
          }
          if (pasteBtn && schedClipboard) {
            const day = pasteBtn.dataset.day;
            const sEl = root.querySelector(`[name="${day}_start"]`);
            const eEl = root.querySelector(`[name="${day}_end"]`);
            const bEl = root.querySelector(`[name="${day}_break"]`);
            if (sEl) { sEl.value = schedClipboard.start; st[`${day}_start`] = sEl.value || ''; }
            if (eEl) { eEl.value = schedClipboard.end;   st[`${day}_end`]   = eEl.value || ''; }
            if (bEl) { bEl.value = schedClipboard.br;    st[`${day}_break`] = bEl.value || ''; }
            updatePresetSaveState();
          }
        });
      }

      ['input', 'change'].forEach(evt => {
        root?.addEventListener(evt, (e) => {
          const t = e.target;
          if (!t?.name) return;
          if (t.name === 'rp_pay_mode' || t.name === 'rp_rate_type') return;
          if (/^(name|role|band|display_site)$/.test(t.name)) {
            st[t.name] = t.value || '';
          } else if (/^bucket_(day|night|sat|sun|bh)$/.test(t.name)) {
            st[t.name] = t.value || '';
          } else if (/^mileage_(pay|charge)_rate$/.test(t.name)) {
            st[t.name] = t.value || '';
          } else if (/^(mon|tue|wed|thu|fri|sat|sun)_(start|end|break)$/.test(t.name)) {
            st[t.name] = t.value || '';
          } else if (/^(paye|umb|charge)_(day|night|sat|sun|bh)$/.test(t.name)) {
            st[t.name] = t.value || '';
          }
          if (
            /^(paye|umb|charge)_(day|night|sat|sun|bh)$/.test(t.name) ||
            /^(name|role|band|display_site|bucket_(day|night|sat|sun|bh)|mileage_(pay|charge)_rate)$/.test(t.name) ||
            /^(mon|tue|wed|thu|fri|sat|sun)_(start|end|break)$/.test(t.name)
          ) {
            updatePresetSaveState();
          }
        }, true);
      });

      updatePresetSaveState();
    },
    {
      kind: 'rate-preset',
      noParentGate: true,
      forceEdit: initialMode === 'edit'
    }
  );

  setTimeout(() => {
    const fr = window.__getModalFrame?.();
    if (fr && fr.kind === 'rate-preset' && typeof fr.onReturn === 'function' && !fr.__init__) {
      fr.__init__ = true;
      fr.onReturn();
    }
  }, 0);
}
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Rates Presets â€” API wrappers
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function listRatePresets({ scope, client_id, q } = {}) {
  const qs = new URLSearchParams();
  if (scope && scope !== 'ALL') qs.set('scope', String(scope).toUpperCase()); // 'GLOBAL' | 'CLIENT'
  if (client_id) qs.set('client_id', String(client_id));
  if (q) qs.set('q', String(q));
  const url = API(`/api/rates/presets${qs.toString() ? `?${qs.toString()}` : ''}`);
  const r = await authFetch(url);
  const j = await r.json().catch(()=>({ rows: [] }));
  // Return array of full rows (endpoint returns extended shape)
  const rows =
    (Array.isArray(j) ? j :
     Array.isArray(j.rows) ? j.rows :
     Array.isArray(j.data) ? j.data : []);
  return rows;
}

async function deleteRatePreset(id) {
  const r = await authFetch(API(`/api/rates/presets/${encodeURIComponent(String(id))}`), { method:'DELETE' });
  if (!r.ok) throw new Error(await r.text().catch(()=> 'Delete failed'));
  return true;
}

async function loadRatePreset(id) {
  const r = await authFetch(API(`/api/rates/presets/${encodeURIComponent(String(id))}`));
  if (!r.ok) throw new Error(await r.text().catch(()=> 'Failed to load'));
  const j = await r.json().catch(()=> ({}));
  return (j && (j.preset || j.row || j)) || {};
}

async function saveRatePreset(payload /* { id?, ... } */) {
  const hasId = !!payload?.id;
  const url   = hasId
    ? API(`/api/rates/presets/${encodeURIComponent(String(payload.id))}`)
    : API(`/api/rates/presets`);
  const method = hasId ? 'PATCH' : 'POST';

  const body = { ...payload };
  // Do not send id inside body on PATCH
  if (hasId) delete body.id;

  const r = await authFetch(url, {
    method,
    headers: { 'content-type':'application/json' },
    body: JSON.stringify(body)
  });
  if (!r.ok) throw new Error(await r.text().catch(()=> 'Save failed'));
  return r.json().catch(()=> ({}));
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Stable sort helper per spec
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function sortPresetsForView(scopeFilter /* 'ALL'|'GLOBAL'|'CLIENT' */, rows = []) {
  const arr = (rows || []).map((r, i) => ({ r, i })); // keep stable index
  const name = (x) => (x?.name || '').toString().toLowerCase();
  const cli  = (x) => (x?.client?.name || x?.client_name || '').toString().toLowerCase();
  const isGlobal = (x) => !x?.client_id && (String(x?.scope || '').toUpperCase() !== 'CLIENT');

  const cmpStr = (a, b) => (a < b ? -1 : a > b ? 1 : 0);

  arr.sort((A,B) => {
    const a = A.r, b = B.r;
    if (scopeFilter === 'GLOBAL') {
      const c = cmpStr(name(a), name(b));
      return c !== 0 ? c : (A.i - B.i);
    }
    if (scopeFilter === 'CLIENT') {
      const c1 = cmpStr(cli(a), cli(b));
      if (c1 !== 0) return c1;
      const c2 = cmpStr(name(a), name(b));
      return c2 !== 0 ? c2 : (A.i - B.i);
    }
    // ALL â†’ globals first, then client name, then rate name
    const gA = isGlobal(a) ? 0 : 1;
    const gB = isGlobal(b) ? 0 : 1;
    if (gA !== gB) return gA - gB;
    const c1 = cmpStr(cli(a), cli(b));
    if (c1 !== 0) return c1;
    const c2 = cmpStr(name(a), name(b));
    return c2 !== 0 ? c2 : (A.i - B.i);
  });

  return arr.map(x => x.r);
}




async function listReportPresets({ section, kind = 'search', include_shared = true, q, page = 1, page_size = 100 } = {}) {
  const opts = { include_shared, q, page, page_size };
  const cached = getPresetCache(section, kind, opts);
  if (cached) return cached;

  const qs = new URLSearchParams();
  if (section) qs.set('section', section);
  if (kind) qs.set('kind', kind);
  if (include_shared) qs.set('include_shared', 'true');
  if (q) qs.set('q', q);
  qs.set('page', page);
  qs.set('page_size', page_size);

  const res = await authFetch(API(`/api/report-presets?${qs.toString()}`));
  const data = await res.json().catch(() => ({ rows: [] }));
  // Keep user_id in cache so ownership checks work downstream
  const rows = data && Array.isArray(data.rows) ? data.rows : [];
  setPresetCache(section, kind, rows, opts);
  return rows;
}

async function createReportPreset({ section, kind='search', name, filters, selection, is_shared=false, is_default=false }) {
  const res = await authFetch(
    API(`/api/report-presets`),
    {
      method: 'POST',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify({ section, kind, name, filters, selection, is_shared, is_default })
    }
  );

  if (res.status === 409) {
    let conflicting = null;
    try {
      const presets = await listReportPresets({ section, kind, include_shared: false, q: name, page: 1, page_size: 100 });
      const lower = String(name || '').toLowerCase();
      conflicting = (presets || []).find(p => String(p.name || '').toLowerCase() === lower) || null;
    } catch {}

    try {
      const form = document.getElementById('saveSearchForm');
      if (form) {
        const overwriteRadio = form.querySelector('input[name="mode"][value="overwrite"]') || form.querySelector('input[name="mode"][value="append"]');
        const overwriteWrap  = form.querySelector('#overwriteWrap') || form.querySelector('#appendWrap');
        const selectEl       = form.querySelector('#overwritePresetId') || form.querySelector('#appendPresetId');
        if (overwriteRadio) overwriteRadio.checked = true;
        if (overwriteWrap)  overwriteWrap.style.display = 'block';
        if (selectEl && conflicting) {
          const hasOption = Array.from(selectEl.options).some(o => o.value === String(conflicting.id));
          if (!hasOption) {
            const opt = document.createElement('option');
            opt.value = String(conflicting.id);
            opt.textContent = conflicting.name || '(unnamed)';
            selectEl.appendChild(opt);
          }
          selectEl.value = String(conflicting.id);
        }
      }
    } catch {}

    const err = new Error('Preset name already exists. Switched to Overwriteâ€”pick the preset and save again.');
    err.code = 'PRESET_NAME_CONFLICT';
    if (conflicting) err.preset = conflicting;
    err.section = section;
    err.kind = kind;
    throw err;
  }

  if (!res.ok) throw new Error(await res.text());

  invalidatePresetCache(section, kind);
  const data = await res.json().catch(()=>({}));
  return data.row || null;
}


async function updateReportPreset({ id, name, filters, selection, is_shared, is_default, section, kind }) {
  const patch = {};
  if (typeof name === 'string') patch.name = name;
  if (filters && typeof filters === 'object') patch.filters = filters;
  if (selection && typeof selection === 'object') patch.selection = selection;
  if (typeof is_shared === 'boolean') patch.is_shared = is_shared;
  if (typeof is_default === 'boolean') patch.is_default = is_default;
  if (typeof section === 'string') patch.section = section;
  if (typeof kind === 'string') patch.kind = kind;

  const res = await authFetch(
    API(`/api/report-presets/${encodeURIComponent(id)}`),
    {
      method: 'PATCH',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify(patch)
    }
  );
  if (!res.ok) throw new Error(await res.text());
  __PRESETS_CACHE__.clear();
  const data = await res.json().catch(()=>({}));
  return data.row || null;
}

async function deleteReportPreset(id) {
  const res = await authFetch(API(`/api/report-presets/${encodeURIComponent(id)}`), { method: 'DELETE' });
  if (!res.ok) throw new Error(await res.text());
  __PRESETS_CACHE__.clear();
  const data = await res.json().catch(()=> ({}));
  return data.deleted_id || id;
}

// -----------------------------
// Search helpers
// -----------------------------
function extractFiltersFromForm(formSel='#searchForm'){
  const raw = collectForm(formSel, false);

  // Convert select[multiple] to array and booleans from "true"/"false"
  Object.keys(raw).forEach(k=>{
    const el = document.querySelector(`${formSel} [name="${k}"]`);
    if (!el) return;
    if (el.tagName==='SELECT' && el.multiple){
      raw[k] = Array.from(el.selectedOptions).map(o=>o.value);
    }
    if (el.tagName==='SELECT' && (el.value === 'true' || el.value === 'false')){
      raw[k] = (el.value === 'true');
    }
    if (el.type === 'number' && raw[k] === '') raw[k] = null;
    if (raw[k] === '') delete raw[k];
  });

  // Convert UK dates â†’ ISO (backend expects ISO)
  const dateFields = [
    'created_from','created_to',
    'updated_from','updated_to',
    'worked_from','worked_to',
    'week_ending_from','week_ending_to',
    'issued_from','issued_to',
    'due_from','due_to',
    'dob',
    'start_date_from','start_date_to',
    'end_date_from','end_date_to',
    'active_on'
  ];

  dateFields.forEach(f => {
    if (raw[f]) {
      const iso = parseUkDateToIso(raw[f]);
      if (iso) raw[f] = iso;
    }
  });

  return raw;
}

function populateSearchFormFromFilters(filters={}, formSel='#searchForm'){
  const form = document.querySelector(formSel);
  if (!form) return;

  const dateFields = [
    'created_from','created_to',
    'updated_from','updated_to',
    'worked_from','worked_to',
    'week_ending_from','week_ending_to',
    'issued_from','issued_to',
    'due_from','due_to',
    'dob',
    'start_date_from','start_date_to',
    'end_date_from','end_date_to',
    'active_on'
  ];

  for (const [k,v] of Object.entries(filters || {})) {
    const el = form.querySelector(`[name="${k}"]`);
    if (!el) continue;

    if (Array.isArray(v) && el.tagName === 'SELECT' && el.multiple) {
      const values = new Set(v.map(String));
      Array.from(el.options).forEach(opt => { opt.selected = values.has(opt.value); });
      continue;
    }

    if (typeof v === 'boolean' && el.tagName === 'SELECT') {
      el.value = v ? 'true' : 'false';
      continue;
    }

    const isDateField = dateFields.includes(k);
    if (isDateField && typeof v === 'string') {
      const uk = (typeof formatIsoToUk === 'function') ? formatIsoToUk(v) : v;
      el.value = uk || '';
      continue;
    }

    // Default
    el.value = (v == null ? '' : String(v));
  }
}



// Build querystring per section


// -----------------------------
// UPDATED: search()
// -----------------------------
// ======================================
// FRONTEND â€” search (UPDATED: no extra logic beyond existing; kept for completeness)
// ======================================

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// FIX 1: Search route mismatch (contracts now calls /api/contracts with filters)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function search(section, filters = {}) {
  window.__listState = window.__listState || {};
  const st = (window.__listState[section] ||= {
    page: 1,
    pageSize: 50,
    total: null,
    hasMore: false,
    filters: null,
    sort: { key: null, dir: 'asc' }
  });

  if (!st.sort || typeof st.sort !== 'object') {
    st.sort = { key: null, dir: 'asc' };
  }

  // Reset selection when applying a new dataset (fingerprint change)
  window.__selection = window.__selection || {};
  const sel = (window.__selection[section] ||= { fingerprint:'', ids:new Set() });
  sel.fingerprint = JSON.stringify({
    section,
    filters: filters || {},
    sort: st.sort
  });
  sel.ids.clear();

  // Default mappings for existing sections
  const map = {
    candidates:'/api/search/candidates',
    clients:'/api/search/clients',
    umbrellas:'/api/search/umbrellas',
    timesheets:'/api/search/timesheets',
    invoices:'/api/search/invoices'
  };

  // Contracts use /api/contracts (admin list)
  let p = (section === 'contracts') ? '/api/contracts' : map[section];
  if (!p) return [];

  const qs = buildSearchQS(section, filters);
  const url = qs ? `${p}?${qs}` : p;

  const r = await authFetch(API(url));
  const rows = toList(r);

  // update state
  st.filters = { ...(filters || {}) };
  const ps = (st.pageSize === 'ALL') ? null : Number(st.pageSize || 50);
  st.hasMore = (ps != null) ? (Array.isArray(rows) && rows.length === ps) : false;

  return rows;
}


function defaultColumnsFor(section){
  // No longer read localStorage; server grid prefs are the source of truth.
  switch(section){
    case 'candidates':
      return ['last_name','first_name','phone','role','postcode','email'];
    case 'clients':
      return ['name','primary_invoice_email','invoice_address','postcode','ap_phone'];
    case 'umbrellas':
      return ['name','vat_chargeable','bank_name','sort_code','account_number','enabled'];
    case 'audit':
      return ['type','to','subject','status','created_at_utc','last_error'];
    case 'contracts':
      // Sensible defaults for the new section
      return ['candidate_display','client_name','role','band','pay_method_snapshot','default_submission_mode','start_date','end_date','bucket_labels_preview'];
    default:
      return ['id'];
  }
}






// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Data / API wrappers â€” Contracts + Weeks + Utilities
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€-

const _enc = (v) => encodeURIComponent(String(v ?? ''));
const _json = (o) => JSON.stringify(o ?? {});

async function listContracts(filters = {}) {
  // Mirrors /api/contracts (admin list) with common FE filters.
  const qs = new URLSearchParams();
  if (filters.candidate_id) qs.set('candidate_id', filters.candidate_id);
  if (filters.client_id)    qs.set('client_id',    filters.client_id);
  if (filters.role)         qs.set('role',         filters.role);
  if (filters.band != null) qs.set('band',         filters.band);
  if (filters.pay_method_snapshot) qs.set('pay_method_snapshot', String(filters.pay_method_snapshot).toUpperCase());
  if (filters.active_on)    qs.set('active_on',    filters.active_on);  // YYYY-MM-DD
  if (typeof filters.auto_invoice === 'boolean') qs.set('auto_invoice', String(filters.auto_invoice));
  if (filters.status) qs.set('status', String(filters.status)); // NEW

  const url = qs.toString() ? `/api/contracts?${qs}` : `/api/contracts`;
  const r = await authFetch(API(url));
  return toList(r);
}


// âœ… CHANGED: add cache-busting and explicit no-cache header

async function getContract(contract_id) {
  const url = API(`/api/contracts/${_enc(contract_id)}?ts=${Date.now()}`);
  const r = await authFetch(url);
  if (!r?.ok) return null;
  const j = await r.json();
  return j && j.contract ? j.contract : j;
}

async function upsertContract(payload, id /* optional */) {
  const LOGC = (typeof window.__LOG_CONTRACTS === 'boolean') ? window.__LOG_CONTRACTS : true;
  const patch = { ...payload };

  // Ensure required window fields are present for PUT without re-clobber.
  if (id && patch.__userChangedDates !== true) {
    const snap = (window.modalCtx && window.modalCtx.data) || {};
    if (!patch.start_date && snap.start_date) patch.start_date = snap.start_date;
    if (!patch.end_date   && snap.end_date)   patch.end_date   = snap.end_date;

    // NEW: if caller didn't include additional_rates_json on an edit,
    // keep whatever is already stored on the contract instead of wiping it.
    if (!Object.prototype.hasOwnProperty.call(patch, 'additional_rates_json') &&
        Object.prototype.hasOwnProperty.call(snap, 'additional_rates_json')) {
      patch.additional_rates_json = snap.additional_rates_json;
    }
  }

  if ('__userChangedDates' in patch) delete patch.__userChangedDates;

  if ('bucket_labels_json' in patch) {
    const norm = normaliseBucketLabelsInput(patch.bucket_labels_json);
    patch.bucket_labels_json = (norm === false) ? null : norm;
  }

  const BUCKETS = [
    'paye_day','paye_night','paye_sat','paye_sun','paye_bh',
    'umb_day','umb_night','umb_sat','umb_sun','umb_bh',
    'charge_day','charge_night','charge_sat','charge_sun','charge_bh'
  ];

  const method = id ? 'PUT' : 'POST';
  const url = id ? `/api/contracts/${_enc(id)}` : `/api/contracts`;

  try {
    const currentTab = (window.modalCtx && window.modalCtx.currentTabKey) || null;
    const baseRates = (window.modalCtx && window.modalCtx.data && window.modalCtx.data.rates_json) || {};
    const incoming  = (patch.rates_json && typeof patch.rates_json === 'object') ? patch.rates_json : {};

    if (id) {
      const merged = { ...baseRates };
      for (const k of BUCKETS) {
        const n = Number(incoming[k]);
        if (Number.isFinite(n)) {
          merged[k] = n;
        } else if (merged[k] !== undefined) {
          merged[k] = Number(merged[k]);
        }
      }
      patch.rates_json = merged;
    }

    // Prune PAYE vs Umbrella buckets according to pay_method_snapshot
    try {
      const pm = String(patch.pay_method_snapshot || '').toUpperCase();
      if (patch.rates_json && typeof patch.rates_json === 'object') {
        const keepPrefixes =
          pm === 'PAYE'     ? ['paye_','charge_'] :
          pm === 'UMBRELLA' ? ['umb_','charge_'] :
                              ['charge_'];
        for (const key of Object.keys(patch.rates_json)) {
          if (!keepPrefixes.some(pre => key.startsWith(pre))) {
            delete patch.rates_json[key];
          }
        }
      }
    } catch (e) {
      if (LOGC) console.warn('[CONTRACTS][UPSERT] rate pruning failed (non-fatal)', e);
    }

    if (LOGC) {
      console.groupCollapsed('[CONTRACTS][UPSERT] sending');
      console.log('method', method, 'url', API(url));
      console.log('currentTab', currentTab);
      console.log('payload (final)', patch);
      if (id) console.log('baseRates (from modalCtx.data.rates_json)', baseRates);
      console.groupEnd();
    }
  } catch (e) {
    if (LOGC) console.warn('[CONTRACTS][UPSERT] logging/pre-seed failed', e);
  }

  const res = await authFetch(API(url), {
    method,
    headers: { 'content-type': 'application/json' },
    body: _json(patch)
  });

  let data = null;
  try { data = await res.json(); } catch (_) {}

  if (!res || !res.ok) {
    const msg =
      (data && (data.error || data.message || data.detail)) ||
      (res && res.statusText) ||
      `Contract ${id ? 'update' : 'create'} failed`;
    if (LOGC) console.error('[CONTRACTS][UPSERT] error', { status: res?.status, msg, data });
    throw new Error(msg);
  }

  if (LOGC) {
    console.log('[CONTRACTS][UPSERT] success', { method, id, status: res.status });
    if (data) console.log('[CONTRACTS][UPSERT] response body', data);
  }

  // Merge saved contract into list cache so reopen uses fresh values
  try {
    const savedContract = (data && (data.contract || data)) || null;
    const savedId = savedContract && savedContract.id;
    if (savedId && Array.isArray(window.currentRows)) {
      const idx = window.currentRows.findIndex(r => String(r.id) === String(savedId));
      if (idx >= 0) {
        window.currentRows[idx] = { ...window.currentRows[idx], ...savedContract };
      }
    }
  } catch (e) {
    if (LOGC) console.warn('[CONTRACTS][UPSERT] list cache merge failed', e);
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Auto-refresh any open weekly import resolve panels (NHSP / HR_WEEKLY)
  // so that newly created/extended contracts are immediately reflected
  // in the weekly import summary without re-uploading files.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  try {
    if (typeof refreshOpenWeeklyImportSummariesAfterContractSave === 'function') {
      await refreshOpenWeeklyImportSummariesAfterContractSave();
    }
  } catch (e) {
    if (LOGC) console.warn('[CONTRACTS][UPSERT] weekly import auto-refresh failed', e);
  }

  return data;
}


// âœ… CHANGED: after successful upsert, also merge into currentRows and stamp recency


async function deleteContract(contract_id) {
  const r = await authFetch(API(`/api/contracts/${_enc(contract_id)}`), { method: 'DELETE' });
  if (!r?.ok) throw new Error('Delete contract failed');
  return r.json();
}
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UPDATED: checkContractOverlap (adds logging)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function checkContractOverlap(payload /* {candidate_id,start_date,end_date,ignore_contract_id?} */) {
  const LOGC = (typeof window.__LOG_CONTRACTS === 'boolean') ? window.__LOG_CONTRACTS : false;
  if (LOGC) console.log('[CONTRACTS] POST /api/contracts/check-overlap', payload);
  const r = await authFetch(API(`/api/contracts/check-overlap`), {
    method: 'POST', headers: { 'content-type':'application/json' }, body: _json(payload)
  });
  if (!r?.ok) {
    if (LOGC) console.error('[CONTRACTS] overlap check failed', r);
    throw new Error('Overlap check failed');
  }
  const json = await r.json();
  if (LOGC) console.log('[CONTRACTS] overlap check OK', json);
  return json;
}

async function generateContractWeeks(contract_id) {
  const r = await authFetch(API(`/api/contracts/${_enc(contract_id)}/generate-weeks`), { method: 'POST' });
  if (!r?.ok) throw new Error('Generate weeks failed');
  return r.json();
}


async function listContractWeeks(contract_id, filters = {}) {
  const qs = new URLSearchParams();
  if (contract_id) qs.set('contract_id', contract_id);
  if (filters.status) qs.set('status', filters.status);
  if (filters.submission_mode_snapshot) qs.set('submission_mode_snapshot', filters.submission_mode_snapshot);
  if (filters.week_ending_from) qs.set('week_ending_from', filters.week_ending_from);
  if (filters.week_ending_to)   qs.set('week_ending_to',   filters.week_ending_to);
  const url = qs.toString() ? `/api/contract-weeks?${qs}` : `/api/contract-weeks`;
  const r = await authFetch(API(url));
  return toList(r);
}

async function contractWeekSwitchMode(week_id, newMode /* optional; server toggles if omitted */) {
  // Backend toggles if no body; allow hint mode to be explicit
  const init = newMode
    ? { method:'POST', headers:{'content-type':'application/json'}, body:_json({ submission_mode_snapshot: String(newMode).toUpperCase() }) }
    : { method:'POST' };
  const r = await authFetch(API(`/api/contract-weeks/${_enc(week_id)}/switch-mode`), init);
  if (!r?.ok) throw new Error('Switch mode failed');
  return r.json();
}

async function contractWeekPresignPdf(week_id) {
  const r = await authFetch(API(`/api/contract-weeks/${_enc(week_id)}/presign-manual-pdf`), { method:'POST' });
  if (!r?.ok) throw new Error('Presign failed');
  return r.json(); // { key, upload_url, token, expires_in }
}

async function contractWeekReplacePdf(week_id, r2_key) {
  const r = await authFetch(API(`/api/contract-weeks/${_enc(week_id)}/replace-manual-pdf`), {
    method:'POST', headers:{'content-type':'application/json'}, body:_json({ r2_key })
  });
  if (!r?.ok) throw new Error('Replace manual PDF failed');
  return r.json();
}

async function contractWeekManualUpsert(week_id, payload /* { hours or day_entries_json, reference_number? } */) {
  // Ensure numeric 5-bucket totals if passed in
  if (payload?.hours) {
    const h = payload.hours;
    payload.hours = {
      day: Number(h?.day || 0), night: Number(h?.night || 0),
      sat: Number(h?.sat || 0), sun: Number(h?.sun || 0), bh: Number(h?.bh || 0)
    };
  }
  const r = await authFetch(API(`/api/contract-weeks/${_enc(week_id)}/manual-upsert`), {
    method:'POST', headers:{'content-type':'application/json'}, body:_json(payload)
  });
  if (!r?.ok) throw new Error('Manual upsert failed');
  return r.json(); // { timesheet_id, processing_status, hours, had_day_entries }
}

async function contractWeekAuthorise(week_id) {
  const r = await authFetch(API(`/api/contract-weeks/${_enc(week_id)}/manual-authorise`), { method:'POST' });
  if (!r?.ok) throw new Error('Authorise failed');
  return r.json();
}

async function contractWeekDeleteTimesheet(week_id) {
  const r = await authFetch(API(`/api/contract-weeks/${_enc(week_id)}/timesheet`), { method:'DELETE' });
  if (!r?.ok) throw new Error('Delete timesheet failed');
  return r.json();
}

async function contractWeekCreateExpenseSheet(week_id) {
  const r = await authFetch(API(`/api/contract-weeks/${_enc(week_id)}/create-expense-sheet`), { method:'POST' });
  if (!r?.ok) throw new Error('Create expense sheet failed');
  return r.json();
}

// Minimal picker feed
async function listContractsBasic() {
  const rows = await listContracts({});
  return (rows || []).map(c => ({
    id: c.id,
    label: [
      (c.candidate_display || c.candidate_id || '').toString(),
      'â€”',
      (c.client_name || c.client_id || '').toString(),
      (c.role ? `(${c.role}${c.band ? ` ${c.band}` : ''})` : ''),
      ' ',
      `[${c.start_date || ''} â†’ ${c.end_date || ''}]`
    ].join(' ').replace(/\s+/g, ' ').trim()
  }));
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Bucket label helpers (display-only; math stays canonical)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€-

function labelsDefault() {
  return { day:'Day', night:'Night', sat:'Sat', sun:'Sun', bh:'BH' };
}

/**
 * @returns {object|false} normalized labels object or false if invalid (to clear)
 */
function normaliseBucketLabelsInput(raw) {
  if (!raw || typeof raw !== 'object') return false;
  const keys = ['day','night','sat','sun','bh'];
  const out = {};
  for (const k of keys) {
    const v = raw[k];
    if (typeof v !== 'string' || !v.trim()) return false;
    out[k] = v.trim();
  }
  return out;
}

function getBucketLabelsForContract(contract) {
  const userSet = normaliseBucketLabelsInput(contract?.bucket_labels_json || null);
  return userSet || labelsDefault();
}

function summariseBucketLabels(labels) {
  const L = normaliseBucketLabelsInput(labels);
  return L ? [L.day, L.night, L.sat, L.sun, L.bh].join('/') : '';
}

function applyBucketLabelsToHoursGrid(gridEl, labels) {
  const L = normaliseBucketLabelsInput(labels) || labelsDefault();
  if (!gridEl) return;
  const map = {
    day:   gridEl.querySelector('[data-bucket="day"] .lbl'),
    night: gridEl.querySelector('[data-bucket="night"] .lbl'),
    sat:   gridEl.querySelector('[data-bucket="sat"] .lbl'),
    sun:   gridEl.querySelector('[data-bucket="sun"] .lbl'),
    bh:    gridEl.querySelector('[data-bucket="bh"] .lbl'),
  };
  Object.entries(map).forEach(([k, el]) => { if (el) el.textContent = L[k]; });
}

function renderBucketLabelsEditor(ctx /* modalCtx */) {
  // Prefer staged labels from formState.main; fallback to contract's stored labels; finally to defaults
  const fsMain = (window.modalCtx && window.modalCtx.formState && window.modalCtx.formState.main) || {};
  const stored = getBucketLabelsForContract(ctx.data || {});
  const L = {
    day:   fsMain.bucket_day   ?? stored.day   ?? 'Day',
    night: fsMain.bucket_night ?? stored.night ?? 'Night',
    sat:   fsMain.bucket_sat   ?? stored.sat   ?? 'Sat',
    sun:   fsMain.bucket_sun   ?? stored.sun   ?? 'Sun',
    bh:    fsMain.bucket_bh    ?? stored.bh    ?? 'BH',
  };
  return `
    <div class="group">
      <div class="row"><label>Bucket labels (optional)</label>
        <div class="controls small">
          <div class="grid-5" id="bucketLabelsGrid">
            <div data-k="day"><span>Standard</span><input class="input" type="text" name="bucket_day"   value="${(L.day||'Day')}" /></div>
            <div data-k="night"><span>OT1</span>     <input class="input" type="text" name="bucket_night" value="${(L.night||'Night')}" /></div>
            <div data-k="sat"><span>OT2</span>       <input class="input" type="text" name="bucket_sat"   value="${(L.sat||'Sat')}" /></div>
            <div data-k="sun"><span>OT3</span>       <input class="input" type="text" name="bucket_sun"   value="${(L.sun||'Sun')}" /></div>
            <div data-k="bh"><span>OT4</span>        <input class="input" type="text" name="bucket_bh"    value="${(L.bh||'BH')}" /></div>
          </div>
        </div>
      </div>
    </div>`;
}


function _collectBucketLabelsFromForm(rootSel = '#contractForm') {
  const root = document.querySelector(rootSel);
  if (!root) return null;
  const day   = root.querySelector('input[name="bucket_day"]')?.value?.trim();
  const night = root.querySelector('input[name="bucket_night"]')?.value?.trim();
  const sat   = root.querySelector('input[name="bucket_sat"]')?.value?.trim();
  const sun   = root.querySelector('input[name="bucket_sun"]')?.value?.trim();
  const bh    = root.querySelector('input[name="bucket_bh"]')?.value?.trim();
  const raw = { day, night, sat, sun, bh };
  // If all empty â†’ treat as null; if partially filled â†’ require full 5, else clear to null
  const filled = Object.values(raw).filter(Boolean).length;
  if (filled === 0) return null;
  const norm = normaliseBucketLabelsInput(raw);
  return norm || null;
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Overlap guard flow
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€-

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UPDATED: preSaveContractWithOverlapCheck (adds logging)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function preSaveContractWithOverlapCheck(formData /* object */) {
  const LOGC = (typeof window.__LOG_CONTRACTS === 'boolean') ? window.__LOG_CONTRACTS : false;
  const payload = {
    candidate_id: formData.candidate_id,
    start_date:   formData.start_date,
    end_date:     formData.end_date,
    ignore_contract_id: formData.id || null
  };
  if (LOGC) console.log('[CONTRACTS] overlap check â†’ request', payload);
  const res = await checkContractOverlap(payload);
  if (LOGC) console.log('[CONTRACTS] overlap check â†’ response', res);
  if (!res?.has_overlap) return true;
  const ok = await showContractOverlapWarningDialog(res.overlaps || []);
  if (LOGC) console.log('[CONTRACTS] overlap dialog â†’ userChoice', ok);
  return !!ok;
}

function showContractOverlapWarningDialog(overlaps = []) {
  // Returns a Promise<boolean> that resolves when user chooses.
  return new Promise((resolve) => {
    const list = overlaps.map(o => `
      <li>
        <div><b>${(o.client_name || o.client_id || '')}</b> â€” ${o.role || ''}${o.band ? ` (Band ${o.band})` : ''}</div>
        <div class="mini">Existing: ${o.existing_start_date} â†’ ${o.existing_end_date}</div>
        <div class="mini">Overlap: <b>${o.overlap_start_date} â†’ ${o.overlap_end_date}</b> (${o.overlap_days} day(s))</div>
      </li>`).join('');

    const content = `
      <div class="warn">
        <p>The proposed dates overlap the following contract(s) for this candidate:</p>
        <ul class="overlap-list">${list || '<li>(none)</li>'}</ul>
        <p>Do you want to proceed anyway?</p>
      </div>`;

    showModal(
      'Overlap detected',
      [{ key: 'ov', title: 'Warning'}],
      () => content,
      async () => { resolve(true); return true; },
      false,
      () => {}, // onReturn
      {
        kind:'overlap-warning',
        extraButtons: [
          { label:'Cancel', role:'secondary', onClick: () => { resolve(false); discardTopModal && discardTopModal(); } }
        ]
      }
    );
  });
}
function confirmProceedWithOverlap(){ /* kept for API parity; handled in modal above */ return Promise.resolve(true); }
function cancelOverlapSave(){ /* kept for API parity; handled in modal above */ return Promise.resolve(false); }


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UI â€” Contracts section (table + modal tabs)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€-

function renderContractsTable(rows) {
  // Custom lightweight renderer that highlights <Unassigned> in red.
  // If your environment prefers the generic grid, you can still call that instead.
  // This function simply returns a DOM node that your caller can insert.

  const make = (tag, attrs = {}, children = []) => {
    const el = document.createElement(tag);
    Object.entries(attrs).forEach(([k, v]) => {
      if (k === 'style' && typeof v === 'object') {
        Object.assign(el.style, v);
      } else if (k === 'className') {
        el.className = v;
      } else {
        el.setAttribute(k, v);
      }
    });
    (Array.isArray(children) ? children : [children]).forEach(ch => {
      if (ch == null) return;
      if (typeof ch === 'string') el.appendChild(document.createTextNode(ch));
      else el.appendChild(ch);
    });
    return el;
  };

  const wrap = make('div');
  const style = make('style', {}, `
    .contracts-table { width:100%; border-collapse:collapse; font-size:13px; }
    .contracts-table th, .contracts-table td { border:1px solid var(--line,#e5e5e5); padding:8px; text-align:left; }
    .contracts-table th { background: var(--panel,#fafafa); }
    .contracts-table .unassigned { color: var(--danger,#c0392b); font-weight: 600; }
    .contracts-table .sm { color: var(--muted,#666); font-size: 12px; }
  `);
  wrap.appendChild(style);

  const table = make('table', { className: 'contracts-table' });
  const thead = make('thead');
  const trh = make('tr');
  ['ID','Candidate','Client','Role','Start','End'].forEach(h => trh.appendChild(make('th', {}, h)));
  thead.appendChild(trh);
  table.appendChild(thead);

  const tbody = make('tbody');

  (Array.isArray(rows) ? rows : []).forEach(r => {
    const tr = make('tr');

    // ID
    tr.appendChild(make('td', {}, String(r.id ?? '')));

    // Candidate (show <Unassigned> in red if missing)
    const candLabel = (r.candidate_display || r.candidate_name || '').trim();
    if (candLabel) {
      tr.appendChild(make('td', {}, candLabel));
    } else {
      const td = make('td');
      const span = make('span', { className: 'unassigned' }, '<Unassigned>');
      td.appendChild(span);
      tr.appendChild(td);
    }

    // Client
    tr.appendChild(make('td', {}, (r.client_name || '').trim()));

    // Role
    tr.appendChild(make('td', {}, (r.role || '').trim()));

    // Start / End (show raw ISO or formatted upstream)
    tr.appendChild(make('td', {}, (r.start_date || '')));
    tr.appendChild(make('td', {}, (r.end_date || '')));

    tbody.appendChild(tr);
  });

  table.appendChild(tbody);
  wrap.appendChild(table);

  return wrap;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// FIX 6: Add guarded Delete entry point inside openContract (plus std_hours_json save)
// (Delete only if unused; handled by backend; no change to global openDelete())
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// openContract (amended) â€” surface PAY_METHOD_MISMATCH warnings after save
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UPDATED: openContract (Rates tab enabled on create; picker wiring always-on;
// typing in Candidate/Client field will open the picker; rich logging)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UPDATED: openContract â€” adds initial onReturn() kick so Pick buttons are wired
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UPDATED: openContract(row)
// (unchanged logic except it opens the updated pickers; initial onReturn retained)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// âœ… CHANGED: honour fresh row; give the modal an openToken for stable formState binding

function openContract(row) {
  const LOGC = (typeof window.__LOG_CONTRACTS === 'boolean') ? window.__LOG_CONTRACTS : true;
  const isCreate = !row || !row.id;
  if (LOGC) console.log('[CONTRACTS] openContract ENTRY', { isCreate, rowPreview: !!row });

   window.modalCtx = {
    entity: 'contracts',
    mode: isCreate ? 'create' : 'view',
    data: { ...(row || {}) },
    _saveInFlight: false
  };

  const preToken = window.__preOpenToken || null;
  if (LOGC) console.log('[CONTRACTS] preOpenToken snapshot', preToken);

  if (isCreate) {
    if (preToken) {
      window.modalCtx.openToken = preToken;
      try { delete window.__preOpenToken; } catch {}
      if (LOGC) console.log('[CONTRACTS] using preOpenToken for create', preToken);
    } else if (!window.modalCtx.openToken) {
      window.modalCtx.openToken = `contract:new:${Date.now()}:${Math.random().toString(36).slice(2)}`;
      if (LOGC) console.log('[CONTRACTS] openToken issued for create', window.modalCtx.openToken);
    }
  }

  // If this create comes from Clone&Extend staging, pull intent (end-old etc.)
  try {
    const intents = (window.__cloneIntents || {});
    const token   = window.modalCtx.openToken;
    const ci      = intents[token];

    if (LOGC) console.groupCollapsed('[CLONE][attach-intent]');
    if (LOGC) console.log('openToken', token);
    if (LOGC) console.log('staging.keys', Object.keys(intents || {}));
    if (LOGC) console.log('staging.has(openToken)?', Object.prototype.hasOwnProperty.call(intents, token));

    if (ci) {
      // Normalise & echo intent
      const endIso = ci.end_existing_on || null;
      window.modalCtx.__cloneIntent = {
        source_contract_id: ci.source_contract_id || null,
        end_existing: !!ci.end_existing,
        end_existing_on: endIso
      };
      if (LOGC) console.log('ATTACHED', window.modalCtx.__cloneIntent);
      // one-shot: keep it only on this modal
      try { delete intents[token]; if (LOGC) console.log('intent cleared from staging bucket'); } catch {}
    } else {
      if (LOGC) console.log('NO_INTENT_FOR_TOKEN (possible token mismatch) â€“ will not truncate tail unless a later step re-attaches.');
    }
    if (LOGC) console.groupEnd?.();
  } catch (e) {
    if (LOGC) console.warn('[CLONE][attach-intent] EXCEPTION', e);
  }

  try {
    const base = window.modalCtx.data || {};

    const fs = (window.modalCtx.formState ||= { __forId: (base.id ?? window.modalCtx.openToken ?? null), main:{}, pay:{} });
    fs.__forId = preToken || fs.__forId || (base.id ?? window.modalCtx.openToken ?? null);
    if (LOGC) console.log('[CONTRACTS] formState forId bound', { preToken, forId: fs.__forId, openToken: window.modalCtx.openToken });

    const m = (fs.main ||= {});
    if (m.__seeded !== true) {
      if (base.candidate_id != null) m.candidate_id = base.candidate_id;
      if (base.client_id != null)    m.client_id    = base.client_id;
      if (base.role != null)         m.role         = base.role;
      if (base.band != null)         m.band         = base.band;
      if (base.display_site != null) m.display_site = base.display_site;
      if (base.start_date)           m.start_date   = base.start_date;
      if (base.end_date)             m.end_date     = base.end_date;
      if (base.pay_method_snapshot)  m.pay_method_snapshot = base.pay_method_snapshot;
      if (base.default_submission_mode) m.default_submission_mode = base.default_submission_mode;
      if (base.week_ending_weekday_snapshot != null) m.week_ending_weekday_snapshot = String(base.week_ending_weekday_snapshot);
      if (base.bucket_labels_json)   m.__bucket_labels = base.bucket_labels_json;
      if (base.std_schedule_json)    m.__template      = base.std_schedule_json;
      if (base.std_hours_json)       m.__hours         = base.std_hours_json;
      // Seed mileage if present on row
      if (base.mileage_charge_rate != null) m.mileage_charge_rate = base.mileage_charge_rate;
      if (base.mileage_pay_rate != null)    m.mileage_pay_rate    = base.mileage_pay_rate;
      m.__seeded = true;
      if (LOGC) console.log('[CONTRACTS] seed formState (main/pay) from base row', {
        forId: (window.modalCtx.formState && window.modalCtx.formState.__forId),
        mainKeys: Object.keys(window.modalCtx.formState?.main || {}),
        payKeys: Object.keys(window.modalCtx.formState?.pay || {})
      });

    }
    const p = (fs.pay ||= {});
    if (!Object.keys(p).length && base.rates_json && typeof base.rates_json === 'object') {
      const buckets = ['paye_day','paye_night','paye_sat','paye_sun','paye_bh','umb_day','umb_night','umb_sat','umb_sun','umb_bh','charge_day','charge_night','charge_sat','charge_sun','charge_bh'];
      for (const k of buckets) {
        const v = base.rates_json[k];
        if (v === 0 || (typeof v === 'number' && Number.isFinite(v))) p[k] = String(v);
      }
    }
  } catch {}

    const extraButtons = [];

  // Only attach Delete Contract for existing contracts that the backend
  // has marked as deletable (can_delete === true).
  const hasId     = !!window.modalCtx.data?.id;
  const canDelete = !!(hasId && window.modalCtx.data?.can_delete);

  if (!isCreate && hasId && canDelete) {
    extraButtons.push({
      label: 'Delete contract',
      role: 'danger',
      onClick: async () => {
        const id = window.modalCtx.data?.id;
        if (!id) return;

        // Only allow action in EDIT mode â€“ if still in view mode,
        // nudge the user to click Edit first.
        const fr = (typeof window.__getModalFrame === 'function')
          ? window.__getModalFrame()
          : null;
        if (fr && fr.mode !== 'edit') {
          alert('Click Edit to make changes before deleting this contract.');
          return;
        }

        const ok = window.confirm('Do you want to permanently delete this contract?');
        if (!ok) return;

        try {
          if (LOGC) console.log('[CONTRACTS] deleteContract', { id });
          await deleteContract(id);
          try { discardAllModalsAndState(); } catch {}
          await renderAll();
        } catch (e) {
          alert(e?.message || 'Delete failed');
        }
      }
    });
  }

const tabDefs = [
  { key: 'main',     title: 'Main' },
  { key: 'rates',    title: 'Rates' },
  { key: 'extras',   title: 'Additional Rates' }, // NEW TAB
  { key: 'calendar', title: 'Calendar' }
];
if (LOGC) console.log('[CONTRACTS] tabs', tabDefs.map(t => t.key));

  const isSuccessorCreate = isCreate && ( !!window.modalCtx?.__cloneIntent || !!preToken );
  if (LOGC) console.log('[CONTRACTS] showModal opts preview', {
    hasId, isCreate, isSuccessorCreate,
    stayOpenOnSave: !!isSuccessorCreate, noParentGate: !!isSuccessorCreate,
    openToken: window.modalCtx.openToken, hasCloneIntent: !!window.modalCtx.__cloneIntent
  });

  showModal(

  isCreate ? 'Create Contract' : 'Edit Contract',
  tabDefs,
  (key, row) => {
    const ctx = { data: row };
    if (key === 'main')     return renderContractMainTab(ctx);
    if (key === 'rates')    return renderContractRatesTab(ctx);
    if (key === 'extras')   return renderContractAdditionalRatesTab(ctx); // NEW
    if (key === 'calendar') return renderContractCalendarTab(ctx);
    return `<div class="tabc">Unknown tab.</div>`;
  },
  async () => {
      if (window.modalCtx?._saveInFlight) return false;
      window.modalCtx._saveInFlight = true;
      try {
        if (LOGC) console.groupCollapsed('[CONTRACTS] onSave pipeline');

        snapshotContractForm();
        console.warn('[BREACH A] after snapshotContractForm');

        // Keep a stable copy in case something re-renders and drops modalCtx.__cloneIntent
        const __preCloneIntent = window.modalCtx?.__cloneIntent
          ? { ...window.modalCtx.__cloneIntent }
          : null;
        if (LOGC) console.log('[CLONE][pre-save snapshot]', __preCloneIntent || '(none)');

        const base = window.modalCtx?.data || {};
        const fs   = (window.modalCtx?.formState || { main:{}, pay:{} });
        const fdForm = document.querySelector('#contractForm');
        const fd = fdForm ? new FormData(fdForm) : null;

        const fromFS = (k, fallback='') => {
          const v = (fs.main||{})[k]; return (v===undefined ? fallback : v);
        };
        const fromFD = (k, fallback='') => {
          if (!fd) return fallback;
          const raw = fd.get(k); return (raw==null ? fallback : String(raw).trim());
        };
        const choose = (key, fallback='') => {
          const fsVal = fromFS(key, null);
          if (fsVal !== null && fsVal !== undefined && fsVal !== '') return fsVal;
          const fdVal = fromFD(key, null);
          if (fdVal !== null && fdVal !== undefined && fdVal !== '') return fdVal;
          return (base[key] ?? fallback);
        };

        const ukToIso = (ddmmyyyy, fb=null) => {
          try {
            return (typeof parseUkDateToIso === 'function')
              ? (parseUkDateToIso(ddmmyyyy) || fb)
              : ((ddmmyyyy && /^\d{2}\/\d{2}\/\d{4}$/.test(ddmmyyyy)) ? ddmmyyyy : (ddmmyyyy || fb));
          } catch { return ddmmyyyy || fb; }
        };

              const domLabels = (typeof _collectBucketLabelsFromForm === 'function')
          ? _collectBucketLabelsFromForm('#contractForm')
          : null;

        let bucket_labels_json = null;

        // 1) Prefer DOM-collected labels (used as-is, including empty strings)
        if (domLabels && typeof domLabels === 'object' && Object.keys(domLabels).length) {
          bucket_labels_json = { ...domLabels };
        }

        // 2) Else prefer staged labels from preset/application (__bucket_labels)
        if (!bucket_labels_json) {
          const stagedMap = (fs.main && typeof fs.main.__bucket_labels === 'object')
            ? fs.main.__bucket_labels
            : null;
          if (stagedMap && Object.keys(stagedMap).length) {
            bucket_labels_json = { ...stagedMap };
          }
        }

        // 3) Else fall back to individual bucket_* / bucket_label_* fields
        if (!bucket_labels_json) {
          const staged = {
            day   : String(fs.main?.bucket_day            ?? fs.main?.bucket_label_day   ?? '').trim(),
            night : String(fs.main?.bucket_night          ?? fs.main?.bucket_label_night ?? '').trim(),
            sat   : String(fs.main?.bucket_sat            ?? fs.main?.bucket_label_sat   ?? '').trim(),
            sun   : String(fs.main?.bucket_sun            ?? fs.main?.bucket_label_sun   ?? '').trim(),
            bh    : String(fs.main?.bucket_bh             ?? fs.main?.bucket_label_bh    ?? '').trim()
          };
          const hasAnyFromStaged = Object.values(staged).some(v => v !== '');
          bucket_labels_json = hasAnyFromStaged ? staged : (base.bucket_labels_json ?? null);
        }


        const numOrNull = (s) => {
          const raw = fromFS(s, fromFD(s, ''));
          if (raw === '' || raw === null || raw === undefined) return null;
          const n = Number(raw); return Number.isFinite(n) ? n : null;
        };
            const gh = { mon: numOrNull('gh_mon'), tue: numOrNull('gh_tue'), wed: numOrNull('gh_wed'),
                     thu: numOrNull('gh_thu'), fri: numOrNull('gh_fri'), sat: numOrNull('gh_sat'), sun: numOrNull('gh_sun') };
        const ghFilled = Object.values(gh).some(v => v != null && v !== 0);
        let std_hours_json = ghFilled ? gh : (base.std_hours_json ?? null);
        if (!std_hours_json && fs.main && fs.main.__hours) std_hours_json = fs.main.__hours;

        // --- Build std_schedule_json from mon_start/end/break etc. ---
        const buildScheduleJson = () => {
          const formEl = document.querySelector('#contractForm');
          const fd = formEl ? new FormData(formEl) : null;
          const fsLocal = window.modalCtx?.formState || {};
          const mainFS  = fsLocal.main || {};
          const baseRow = window.modalCtx?.data || {};

          const fromFS = (k, fallback = '') => {
            const v = mainFS[k];
            return (v === undefined ? fallback : v);
          };
          const fromFD = (k, fallback = '') => {
            if (!fd) return fallback;
            const raw = fd.get(k);
            return (raw == null ? fallback : String(raw).trim());
          };
          const val = (key, fallback = '') => {
            const staged = fromFS(key, undefined);
            if (staged !== undefined && staged !== null && String(staged).trim() !== '') {
              return String(staged).trim();
            }
            const domVal = fromFD(key, undefined);
            if (domVal !== undefined && domVal !== null && String(domVal).trim() !== '') {
              return String(domVal).trim();
            }
            return fallback;
          };

          const parseTime = (raw) => {
            const s = String(raw || '').trim();
            if (!s) return null;

            // 3â€“4 digits â†’ HHMM (800, 0830, 2000)
            if (/^\d{3,4}$/.test(s)) {
              const p = s.padStart(4, '0');
              const h = +p.slice(0, 2);
              const m = +p.slice(2, 4);
              if (h < 0 || h > 23 || m < 0 || m > 59) return null;
              return { h, m };
            }

            // H:MM / HH:MM
            if (/^\d{1,2}:\d{1,2}$/.test(s)) {
              const [hh, mm] = s.split(':');
              const h = +hh;
              const m = +mm;
              if (h < 0 || h > 23 || m < 0 || m > 59) return null;
              return { h, m };
            }

            return null;
          };

          const days   = ['mon','tue','wed','thu','fri','sat','sun'];
          const sched  = {};
          const issues = [];

          for (const d of days) {
            const startRaw = val(`${d}_start`, '');
            const endRaw   = val(`${d}_end`, '');
            const brRaw    = val(`${d}_break`, '');

            // Completely blank day â†’ skip
            if (!startRaw && !endRaw && !brRaw) continue;

            const start = parseTime(startRaw);
            const end   = parseTime(endRaw);
            const br    = brRaw ? (Number(brRaw) || 0) : 0;

            if (!start || !end) {
              issues.push(d.toUpperCase());
              continue;
            }

            const startStr = `${String(start.h).padStart(2,'0')}:${String(start.m).padStart(2,'0')}`;
            const endStr   = `${String(end.h).padStart(2,'0')}:${String(end.m).padStart(2,'0')}`;

            sched[d] = {
              start: startStr,
              end:   endStr,
              break_minutes: Math.max(0, br)
            };
          }

          if (issues.length) {
            const msg = `Fix invalid times on: ${issues.join(', ')}`;
            if (typeof showModalHint === 'function') showModalHint(msg, 'warn');
            else alert(msg);
          }

          return { schedule: sched, issues };
        };

        const { schedule, issues } = buildScheduleJson();
        if (issues.length) {
          // Block save; user must fix bad times first
          window.modalCtx._saveInFlight = false;
          if (LOGC) console.groupEnd?.();
          return false;
        }

        let std_schedule_json = null;

        if (schedule && Object.keys(schedule).length) {
          // New schedule fully replaces previous one
          std_schedule_json = schedule;
        } else if (fs.main && fs.main.__template) {
          // No rows entered this time â†’ keep last template if present
          std_schedule_json = fs.main.__template;
        } else if (base.std_schedule_json) {
          std_schedule_json = base.std_schedule_json;
        }



        const prevStartIso = base.start_date || null;
        const prevEndIso   = base.end_date   || null;

        const startIso = ukToIso(choose('start_date', ''), base.start_date ?? null);
        const endIso   = ukToIso(choose('end_date', ''),   base.end_date   ?? null);

        const payMethodSnap = String(
          (fs.main?.pay_method_snapshot) ||
          fromFD('pay_method_snapshot', fromFD('default_pay_method_snapshot', base.pay_method_snapshot || 'PAYE')) ||
          base.pay_method_snapshot || 'PAYE'
        ).toUpperCase();

        const default_submission_mode = String(
          choose('default_submission_mode', base.default_submission_mode || 'ELECTRONIC')
        ).toUpperCase();

        const week_ending_weekday_snapshot = String(
          choose('week_ending_weekday_snapshot', (base.week_ending_weekday_snapshot ?? '0'))
        );

    const candidate_id = choose('candidate_id', base.candidate_id ?? null) || null;

// NEW: polite confirmation when saving with no candidate
if (!candidate_id) {
  const okProceed = window.confirm('No candidate is selected. Save this contract as â€œ<Unassigned>â€?');
  if (!okProceed) {
    window.modalCtx._saveInFlight = false;
    if (LOGC) console.groupEnd?.();
    return false;
  }
}

const client_id    = choose('client_id', base.client_id ?? null) || null;
const role         = choose('role', base.role ?? null);
const band         = choose('band', base.band ?? null);
const display_site = choose('display_site', base.display_site ?? '');


        const boolFromFS = (name, baseVal=false) => {
          if (fs && fs.main && Object.prototype.hasOwnProperty.call(fs.main, name)) {
            const v = fs.main[name];
            return v === 'on' || v === true || v === 'true' || v === 1 || v === '1';
          }
          return !!base[name];
        };
        const auto_invoice                 = boolFromFS('auto_invoice',                 !!base.auto_invoice);
        const require_reference_to_pay     = boolFromFS('require_reference_to_pay',     !!base.require_reference_to_pay);
        const require_reference_to_invoice = boolFromFS('require_reference_to_invoice', !!base.require_reference_to_invoice);

        const BUCKETS = ['paye_day','paye_night','paye_sat','paye_sun','paye_bh','umb_day','umb_night','umb_sat','umb_sun','umb_bh','charge_day','charge_night','charge_sat','charge_sun','charge_bh'];
        const baseRates = { ...(base.rates_json || {}) };
        const mergedRates = { ...baseRates };
        for (const k of BUCKETS) {
          const staged = (fs.pay || {})[k];
          if (staged !== undefined && staged !== '') {
            const n = Number(staged);
            mergedRates[k] = Number.isFinite(n) ? n : 0;
          } else {
            const domVal = fd ? fd.get(k) : null;
            if (domVal !== null && domVal !== undefined && String(domVal).trim() !== '') {
              const n = Number(domVal);
              mergedRates[k] = Number.isFinite(n) ? n : 0;
            }
          }
        }

      // NEW: mileage values â€” prefer Rates tab DOM, then FS staging, else null
const mcrDom = document.querySelector('#contractRatesTab input[name="mileage_charge_rate"]');
const mprDom = document.querySelector('#contractRatesTab input[name="mileage_pay_rate"]');
const mileage_charge_rate = (mcrDom && mcrDom.value !== '') ? (Number(mcrDom.value) || null) : numOrNull('mileage_charge_rate');
const mileage_pay_rate    = (mprDom && mprDom.value !== '') ? (Number(mprDom.value) || null) : numOrNull('mileage_pay_rate');

// NEW: collect Additional Rates (up to 5 slots) from "Additional Rates" tab
let additional_rates_json = null;
try {
  const existing = Array.isArray(base.additional_rates_json) ? base.additional_rates_json : null;
  const rows = [];

  const normaliseFrequency = (raw) => {
    if (!raw) return null;
    const s = String(raw).trim().toUpperCase();
    const ALLOWED = [
      'ONE_PER_WEEK',
      'ONE_PER_DAY',
      'WEEKENDS_AND_BH_ONLY',
      'WEEKDAYS_EXCL_BH_ONLY'
    ];
    return ALLOWED.includes(s) ? s : null;
  };

  const tab = document.getElementById('contractAdditionalRatesTab');
  if (tab) {
    for (let i = 1; i <= 5; i++) {
      const code = `EX${i}`;
      const bnEl = tab.querySelector(`input[name="extra_bucket_name_${i}"]`);
      const unEl = tab.querySelector(`input[name="extra_unit_name_${i}"]`);
      const frEl = tab.querySelector(`select[name="extra_frequency_${i}"]`);
      const prEl = tab.querySelector(`input[name="extra_pay_${i}"]`);
      const crEl = tab.querySelector(`input[name="extra_charge_${i}"]`);

      const bucket_name = (bnEl?.value || '').trim();
      const unit_name   = (unEl?.value || '').trim();
      const freqRaw     = (frEl?.value || '').trim();
      const payRaw      = (prEl?.value || '').trim();
      const chargeRaw   = (crEl?.value || '').trim();

      const hasAny = !!(bucket_name || unit_name || freqRaw || payRaw || chargeRaw);
      if (!hasAny) continue;

      const payNum    = payRaw === '' ? null : Number(payRaw);
      const chargeNum = chargeRaw === '' ? null : Number(chargeRaw);
      const frequency = normaliseFrequency(freqRaw) || 'ONE_PER_WEEK';

      rows.push({
        code,
        bucket_name,
        unit_name: unit_name || null,
        frequency,
        pay_rate: Number.isFinite(payNum) ? payNum : null,
        charge_rate: Number.isFinite(chargeNum) ? chargeNum : null
      });
    }
  }

  if (rows.length) {
    additional_rates_json = rows;
  } else if (existing) {
    // If the tab was never touched this session, keep what backend sent
    additional_rates_json = existing;
  } else {
    additional_rates_json = null;
  }
} catch (e) {
  if (LOGC) console.warn('[CONTRACTS] additional_rates_json build failed', e);
  const fallback = Array.isArray(base.additional_rates_json) ? base.additional_rates_json : null;
  additional_rates_json = fallback || null;
}

const data = {
  id: window.modalCtx.data?.id || null,
  candidate_id,
  client_id,
  role,
  band,
  display_site,
  start_date:   startIso,
  end_date:     endIso,
  pay_method_snapshot: payMethodSnap,
  default_submission_mode,
  week_ending_weekday_snapshot,
  auto_invoice,
  require_reference_to_pay,
  require_reference_to_invoice,
  rates_json: mergedRates,
  std_hours_json,
  std_schedule_json,
  bucket_labels_json,
  additional_rates_json,                     // ðŸ”¹ NEW FIELD
  mileage_charge_rate: mileage_charge_rate,
  mileage_pay_rate:    mileage_pay_rate
};

if (LOGC) {
  const preview = {
    ...data,
    rates_json: '(object)',
    std_hours_json: std_hours_json ? '(object)' : null,
    std_schedule_json: std_schedule_json ? '(object)' : null,
    additional_rates_json: additional_rates_json ? '(object)' : null
  };
  console.log('[CONTRACTS] onSave payload (preview)', preview);
}

        let overlapProceed = true;
        try {
          if (typeof checkContractOverlap === 'function' && data.candidate_id && data.start_date && data.end_date) {
            const ov = await checkContractOverlap({
              candidate_id: data.candidate_id,
              start_date: data.start_date,
              end_date: data.end_date,
              ignore_contract_id: data.id || null
            });
            if (ov && ov.has_overlap) {
              const lines = (ov.overlaps || []).slice(0, 3).map(o => {
                const nm = o.client_name || o.client || 'Client';
                const a  = o.overlap_from || '';
                const b  = o.overlap_to   || '';
                return `${nm} ${a}â†’${b}`;
              });
              const extra = (ov.overlaps || []).length > 3 ? ` â€¦and ${ov.overlaps.length - 3} more` : '';
              const msg = `This contract overlaps existing contract(s):\nâ€¢ ${lines.join('\nâ€¢ ')}${extra}\n\nProceed anyway?`;
              overlapProceed = !!window.confirm(msg);
            }
          }
        } catch (e) {
          if (LOGC) console.warn('[CONTRACTS] overlap check failed (non-blocking)', e);
        }
        if (!overlapProceed) {
          window.modalCtx._saveInFlight = false;
          if (LOGC) console.log('[CONTRACTS] Save cancelled by user on overlap dialog');
          console.groupEnd?.();
          return false;
        }

        try {} catch {}

        if (!isCreate && data.id && typeof callCheckTimesheetBoundary === 'function' && data.start_date && data.end_date) {
          try {
            const boundary = await callCheckTimesheetBoundary(data.id, data.start_date, data.end_date);
            window.__tsBoundaryResult = boundary || null;
            if (!boundary || boundary.ok === false) {
              let msg = 'Date range excludes existing timesheets.';
              try {
                const v = boundary?.violations || [];
                if (v.length) {
                  const sample = v.slice(0,3).map(x => {
                    const nm = x.client_name || 'Client';
                    const dt = x.date || '';
                    const st = x.status || '';
                    return `${nm} ${dt}${st?` (${st})`:''}`;
                  }).join(' â€¢ ');
                  msg = `Dates exclude existing timesheets: ${sample}${v.length>3? 'â€¦':''}`;
                } else if (boundary?.min_ts_date || boundary?.max_ts_date) {
                  const a = boundary.min_ts_date || '';
                  const b = boundary.max_ts_date || '';
                  msg = `Dates exclude timesheets in range ${a} â†’ ${b}.`;
                }
              } catch {}
              if (typeof showModalHint === 'function') showModalHint(msg, 'warn'); else alert(msg);
              window.modalCtx._saveInFlight = false;
              console.groupEnd?.();
              return false;
            }
          } catch (e) {
            if (LOGC) console.warn('[CONTRACTS] timesheet boundary check failed (non-blocking fallback)', e);
          }
        }

        let hasManualStage = false;
        try {
          const stageKey = data.id || window.modalCtx.openToken || null;
          if (stageKey && typeof getContractCalendarStageState === 'function') {
            const st = getContractCalendarStageState(stageKey);
            hasManualStage = !!(st && (st.add?.size || st.remove?.size || Object.keys(st.additional || {}).length));
          }
        } catch {}

        if (!isCreate && hasManualStage) data.skip_generate_weeks = true;

        // --- detect calendar stage shape BEFORE any persistence ---
        let stageShape = { hasAny:false, hasRemoveAll:false, hasAdds:false, hasAdditionals:false };
        try {
          const stageKey = data.id || window.modalCtx.openToken || null;
          if (stageKey && typeof getContractCalendarStageState === 'function') {
            const st = getContractCalendarStageState(stageKey);
            stageShape.hasAny         = !!st && (!!st.removeAll || st.add.size || st.remove.size || Object.keys(st.additional||{}).length);
            stageShape.hasRemoveAll   = !!st?.removeAll;
            stageShape.hasAdds        = !!(st && st.add && st.add.size);
            stageShape.hasAdditionals = !!(st && st.additional && Object.keys(st.additional).length);
          }
        } catch {}

        // === CREATE vs EDIT ordering ===
        // CREATE: upsert first to obtain id â†’ then commit stage (if any) â†’ normalize window â†’ (maybe) generate defaults
        // EDIT: if any stage present, always commit calendar FIRST â†’ normalize window â†’ then upsert metadata
  if (!isCreate && data.id && stageShape.hasAny) {
  if (LOGC) console.log('[CONTRACTS] calendar (any stage) â†’ commitContractCalendarStageIfPending');
  const preCalRes = await commitContractCalendarStageIfPending(data.id);
  if (!preCalRes.ok) {
    const msg = `Calendar save failed: ${preCalRes.message || 'unknown error'}. Contract details were not saved.`;
    if (LOGC) console.warn('[CONTRACTS] calendar commit failed (pre-upsert)', preCalRes);
    if (typeof showModalHint === 'function') showModalHint(msg, 'warn'); else alert(msg);
    window.modalCtx._saveInFlight = false;
    console.groupEnd?.();
    return false;
  }

  // Do NOT normalize on the FE â€” backend now owns window shrink/extend.
  // Instead, pull the fresh contract (authoritative window) and bind it.
  try {
    const fresh = await getContract(data.id);
    if (fresh && fresh.id) {
      window.modalCtx.data = fresh;

      // Update formState (so subsequent PUTs never push stale dates)
      const fs = (window.modalCtx.formState ||= { __forId: (data.id||null), main:{}, pay:{} });
      fs.main ||= {};
      fs.main.start_date = fresh.start_date || null;
      fs.main.end_date   = fresh.end_date   || null;

      // Update visible inputs if we're on the Main tab
      try {
        const form = document.querySelector('#contractForm');
        if (form) {
          const sd = form.querySelector('input[name="start_date"]');
          const ed = form.querySelector('input[name="end_date"]');
          const toUk = (iso) => {
            try { return (typeof formatIsoToUk === 'function') ? (formatIsoToUk(iso) || iso) : iso; } catch { return iso; }
          };
          if (sd && fresh.start_date) sd.value = toUk(fresh.start_date);
          if (ed && fresh.end_date)   ed.value = toUk(fresh.end_date);
        }
      } catch {}
      // Ensure the payload carries authoritative dates unless user explicitly changed them
      const userEditedStart = !!(prevStartIso && startIso && startIso !== prevStartIso);
      const userEditedEnd   = !!(prevEndIso   && endIso   && endIso   !== prevEndIso);
      data.__userChangedDates = (userEditedStart || userEditedEnd);
      if (!data.__userChangedDates) {
        data.start_date = fresh.start_date;
        data.end_date   = fresh.end_date;
      }
    }
  } catch (e) {
    if (LOGC) console.warn('[CONTRACTS] fresh refetch failed (proceeding with current modal data)', e);
  }

  // Avoid auto-generation when calendar stage was present
  data.skip_generate_weeks = true;
}


if (LOGC) console.log('[CONTRACTS] upsert â†’ upsertContract');
const saved = await upsertContract(data, data.id || undefined);

const persistedId = saved?.id || saved?.contract?.id || null;
if (LOGC) console.log('[CONTRACTS] upsertContract result', {
  isCreate, persistedId, rawHasSaved: !!saved
});

window.modalCtx.data = saved?.contract || saved || window.modalCtx.data;
if (LOGC) console.log('[CONTRACTS] modalCtx.data snapshot', {
  id: window.modalCtx.data?.id || null,
  start_date: window.modalCtx.data?.start_date || null,
  end_date:   window.modalCtx.data?.end_date   || null
});

// ðŸ”Ž breadcrumb to prove we reached the post-save gate
console.warn('[AFTER UPSERT] reached post-save pre-gate', {
  modalId: window.modalCtx?.data?.id,
  isCreate,
  openToken: window.modalCtx?.openToken,
  persistedId
});

        try {
          const warnings = saved?.warnings || saved?.contract?.warnings || [];
          const warnStr  = Array.isArray(warnings) ? warnings.join(', ') : (saved?.warning || '');
          if (warnStr) { if (LOGC) console.warn('[CONTRACTS] warnings', warnStr); showModalHint?.(`Warning: ${warnStr}`, 'warn'); }
        } catch {}

        const contractId = saved?.id || saved?.contract?.id;
        if (contractId) {
          window.__pendingFocus = { section: 'contracts', id: contractId };

          // If this was a Clone&Extend staging and user opted to end the old contract, apply now.
          try {
            const t0 = Date.now();
            const savedContractId = contractId || (saved?.contract?.id) || (saved?.id) || null;

            // Prefer the live intent; if lost due to UI state flips, fall back to the pre-save snapshot
            const ciLive     = window.modalCtx?.__cloneIntent || null;
            const ciSnapshot = __preCloneIntent || null;
            const ci         = (ciLive ?? ciSnapshot) || null;

            const hasCi      = !!ci;
            const wantsEnd   = !!ci?.end_existing;
            const hasSource  = !!ci?.source_contract_id;
            const hasEndDate = !!ci?.end_existing_on;

            // Resolve callable from either module/global or window
            const fnLive = (typeof endContractSafely === 'function') ? endContractSafely : undefined;
            const fnWin  = (typeof window !== 'undefined' && typeof window.endContractSafely === 'function') ? window.endContractSafely : undefined;
            const trimFn = fnLive || fnWin;
            const hasFn  = !!trimFn;

            if (LOGC) {
              console.groupCollapsed('[CLONE][post-save gate]');
              console.log({
                isCreate,
                savedContractId,
                modalCtxId: window.modalCtx?.data?.id || null,
                savedStart: window.modalCtx?.data?.start_date || null,
                savedEnd:   window.modalCtx?.data?.end_date   || null,
                openToken:  window.modalCtx?.openToken || null,
                hasCi, wantsEnd, hasSource, hasEndDate,
                ciLive: !!ciLive,
                ciSnapshot: !!ciSnapshot,
                ci: {
                  source_contract_id: ci?.source_contract_id ?? null,
                  end_existing:       ci?.end_existing ?? null,
                  end_existing_on:    ci?.end_existing_on ?? null
                },
                hasFnLive:  !!fnLive,
                hasFnWin:   !!fnWin,
                hasFnResolved: hasFn
              });
              console.groupEnd();
            }

            if (hasCi && wantsEnd && hasSource && hasEndDate && hasFn) {
              if (LOGC) console.log('WILL_CALL endContractSafely', { source: ci.source_contract_id, desired_end: ci.end_existing_on });

              let res = null, ok=false, clamped=false, safe_end=null, message=null, t1=0;
              try {
                console.groupCollapsed('[TRIM_CALL] â†’', { source: ci.source_contract_id, desired_end: ci.end_existing_on });
                res = await trimFn(ci.source_contract_id, ci.end_existing_on);
                t1 = Date.now();
                ok       = !!(res && (res.ok ?? (res === true)));
                clamped  = !!res?.clamped;
                safe_end = res?.safe_end || null;
                message  = res?.message  || null;
                console.log('result', { ok, clamped, safe_end, message, raw: res, elapsed_ms: (t1 - t0) });
                console.groupEnd();
              } catch (err) {
                console.warn('[TRIM_CALL] âœ– threw', err);
              }

              if (ok) {
                if (clamped && typeof showTailClampWarning === 'function') {
                  try { showTailClampWarning(safe_end, ci.end_existing_on); } catch {}
                }
                if (typeof refreshOldContractAfterTruncate === 'function') {
                  try { await refreshOldContractAfterTruncate(ci.source_contract_id); } catch (e) { if (LOGC) console.warn('refreshOldContractAfterTruncate failed', e); }
                }
                if (LOGC) console.log('CLEAR_INTENT (after endContractSafely)');
                clearCloneIntent();
              } else {
                if (LOGC) console.warn('TRIM_CALL did not report ok', { res });
                if (LOGC) console.log('CLEAR_INTENT (after not-ok result)');
                clearCloneIntent();
              }
            } else {
              const reasons = [];
              if (!hasCi)               reasons.push('NO_INTENT');
              if (hasCi && !wantsEnd)   reasons.push('BOX_UNTICKED_end_existing=false');
              if (hasCi && !hasSource)  reasons.push('MISSING_source_contract_id');
              if (hasCi && !hasEndDate) reasons.push('MISSING_end_existing_on');
              if (!hasFn)               reasons.push(`NO_endContractSafely (live=${!!fnLive}, window=${!!fnWin})`);
              console.warn('[CLONE][post-save SKIP] not calling endContractSafely', { reasons });
              console.log('CLEAR_INTENT (skip path)');
              clearCloneIntent();
            }

          } catch (e) {
            if (LOGC) console.warn('[CLONE][post-save decision] EXCEPTION', e);
          }

        }

        try { if (typeof computeContractMargins === 'function') computeContractMargins(); } catch {}

        try {
          const fr = window.__getModalFrame?.();
          const currentTab = fr?.currentTabKey || (document.querySelector('#modalTabs button.active')?.textContent?.toLowerCase() || 'main');
          if (LOGC) console.log('[CONTRACTS] post-save repaint (in-place)', { currentTab, contractId: (window.modalCtx?.data?.id) });

          if (currentTab === 'calendar' && window.modalCtx?.data?.id) {
            const contractId2 = window.modalCtx.data.id;
            const win = (window.__calState?.[contractId2]?.win) || null;
            const candId = window.modalCtx?.data?.candidate_id || null;
            const scrollBox = document.getElementById('__calScroll');
            const prevScroll = scrollBox ? scrollBox.scrollTop : 0;
            if (typeof fetchAndRenderCandidateCalendarForContract === 'function' && candId) {
              await fetchAndRenderCandidateCalendarForContract(contractId2, candId, {
                from: win?.from, to: win?.to, view: window.__calState?.[contractId2]?.view,
                weekEnding: window.modalCtx?.data?.week_ending_weekday_snapshot ?? 0
              });
            } else {
              await fetchAndRenderContractCalendar(contractId2, win ? { from: win.from, to: win.to, view: window.__calState?.[contractId2]?.view } : undefined);
            }
            const newScrollBox = document.getElementById('__calScroll');
            if (newScrollBox) newScrollBox.scrollTop = prevScroll;
          } else if (currentTab === 'rates') {
            try { computeContractMargins(); } catch {}
          }
          try { window.__toast?.('Saved'); } catch {}
        } catch (e) {
          if (LOGC) console.warn('[CONTRACTS] post-save repaint failed', e);
        }

        if (LOGC) console.groupEnd?.();
        // Return the saved row so saveForFrame() can set hasId=true and flip to View
        const savedRow = (window.modalCtx.data || null);
        return { ok: true, saved: savedRow };

       } catch (e) {
        if (LOGC) { console.error('[CONTRACTS] Save failed', e); console.groupEnd?.(); }
        alert(`Save failed: ${e?.message || e}`);
        return false;
      } finally {
        window.modalCtx._saveInFlight = false;
      }
    },

    hasId, // 5th

    // 6th: onReturn â€” single, deduped
    () => {
      const wire = () => {
        snapshotContractForm();

     const form   = document.querySelector('#contractForm');
    const tabsEl = document.getElementById('modalTabs');
    const active = tabsEl?.querySelector('button.active')?.textContent?.toLowerCase() || 'main';


     if (form) {
      if (!form.__wiredStage) {
        form.__wiredStage = true;
const stage = (e) => {
  const t = e.target;
  if (!t || !t.name) return;

  const name = t.name;

  // Base value: just read whatâ€™s in the field
  const v = t.type === 'checkbox'
    ? (t.checked ? 'on' : '')
    : t.value;

  const isScheduleTime = /^(mon|tue|wed|thu|fri|sat|sun)_(start|end)$/.test(name);

  if (isScheduleTime) {
    // For schedule times, just stage raw text into formState; blur/Tab
    // normalisers + explicit calls to setContractFormValue will handle
    // validation and normalisation later.
    window.modalCtx = window.modalCtx || {};
    const fs = (window.modalCtx.formState ||= {
      __forId: (window.modalCtx.data?.id ?? window.modalCtx.openToken ?? null),
      main:{},
      pay:{}
    });
    fs.main ||= {};
    fs.main[name] = v;
  } else {
    // Everything else keeps current behaviour
    setContractFormValue(name, v);

    // Recompute margins when rate / pay_method changes
    if (name === 'pay_method_snapshot' || /^(paye_|umb_|charge_)/.test(name)) {
      computeContractMargins();
    }
  }

  try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
};





        form.addEventListener('input', stage, true);
        form.addEventListener('change', stage, true);

        // NEW: lock pay_method_snapshot select appropriately
        try {
          const sel = form.querySelector('select[name="pay_method_snapshot"], select[name="default_pay_method_snapshot"]');
          const candId = window.modalCtx?.data?.candidate_id || null;
          const hasId  = !!window.modalCtx?.data?.id;
          const mainFs = (window.modalCtx?.formState && window.modalCtx.formState.main) || {};

          if (sel) {
            if (hasId) {
              // Edit mode: always read-only â€“ pay method comes from candidate / history
              sel.disabled = true;
            } else if (candId) {
              // New contract with candidate already chosen:
              // re-use derived snapshot and keep it locked
              sel.disabled = true;
            } else if (mainFs.__pay_locked) {
              // Candidate picker has already derived & locked the snapshot
              sel.disabled = true;
            } else {
              // Brand-new, no candidate yet â†’ leave editable (rare case, but allowed)
              sel.disabled = false;
            }
          }
        } catch (e) {
          if (LOGC) console.warn('[CONTRACTS] pay_method_snapshot lock wiring failed', e);
        }

            const normaliseTimeInput = (t) => {
              if (!t || !/^(mon|tue|wed|thu|fri|sat|sun)_(start|end)$/.test(t.name)) return;
              const raw = (t.value || '').trim();
              const norm = (function (x) {
                if (!x) return '';
                const y = x.replace(/\s+/g, '');
                let h, m;
                if (/^\d{3,4}$/.test(y)) {
                  const s = y.padStart(4, '0'); h = +s.slice(0, 2); m = +s.slice(2, 4);
                } else if (/^\d{1,2}:\d{1,2}$/.test(y)) {
                  const parts = y.split(':'); h = +parts[0]; m = +parts[1];
                } else return '';
                if (h < 0 || h > 23 || m < 0 || m > 59) return '';
                return String(h).padStart(2, '0') + ':' + String(m).padStart(2, '0');
              })(raw);

              if (!norm && raw) {
                t.value = '';
                t.setAttribute('data-invalid', '1');
                t.setAttribute('title', 'Enter a valid time HH:MM (00:00â€“23:59)');
                setContractFormValue(t.name, '');
                try { t.dispatchEvent(new Event('input', { bubbles: true })); t.dispatchEvent(new Event('change', { bubbles: true })); } catch {}
                try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
                return;
              }

              if (norm) {
                t.value = norm;
                t.removeAttribute('data-invalid');
                t.removeAttribute('title');
                setContractFormValue(t.name, norm);
                try { t.dispatchEvent(new Event('input', { bubbles: true })); t.dispatchEvent(new Event('change', { bubbles: true })); } catch {}
                try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
              }
            };

            const onBlurNorm = (e) => { normaliseTimeInput(e.target); };
            form.addEventListener('blur', onBlurNorm, true);

            const onKeydownNorm = (e) => {
              if (e.key === 'Tab') normaliseTimeInput(e.target);
            };
            form.addEventListener('keydown', onKeydownNorm, true);
          }

          if (active === 'main') {
            try {
              const sd = form.querySelector('input[name="start_date"]');
              const ed = form.querySelector('input[name="end_date"]');
              const toUk = (iso) => {
                try { return (typeof formatIsoToUk === 'function') ? (formatIsoToUk(iso) || '') : (iso || ''); }
                catch { return iso || ''; }
              };
              if (sd && /^\d{4}-\d{2}-\d{2}$/.test(sd.value||'')) sd.value = toUk(sd.value);
              if (ed && /^\d{4}-\d{2}-\d{2}$/.test(ed.value||'')) ed.value = toUk(ed.value);
              if (sd) { sd.setAttribute('placeholder','DD/MM/YYYY'); if (typeof attachUkDatePicker === 'function') attachUkDatePicker(sd); }
              if (ed) { ed.setAttribute('placeholder','DD/MM/YYYY'); if (typeof attachUkDatePicker === 'function') attachUkDatePicker(ed, { minDate: sd?.value || null }); }
              if (sd && ed) {
                sd.addEventListener('change', () => {
                  const sv = sd.value || '';
                  if (typeof attachUkDatePicker === 'function') attachUkDatePicker(ed, { minDate: sv || null });
                  if (sv && ed.value) {
                    try {
                      const si = parseUkDateToIso?.(sv) || sv;
                      const ei = parseUkDateToIso?.(ed.value) || ed.value;
                      if (si && ei && si > ei) { ed.value=''; showModalHint?.('Pick an end date after start','warn'); setContractFormValue('end_date',''); }
                    } catch {}
                  }
                });
              }
              if (LOGC) console.log('[CONTRACTS] datepickers wired for start_date/end_date', { hasStart: !!sd, hasEnd: !!ed });
            } catch (e) {
              if (LOGC) console.warn('[CONTRACTS] datepicker wiring failed', e);
            }

            const btnPC = document.getElementById('btnPickCandidate');
            const btnCC = document.getElementById('btnClearCandidate');
            const btnPL = document.getElementById('btnPickClient');
            const btnCL = document.getElementById('btnClearClient');
            const candInput = document.getElementById('candidate_name_display');
            const cliInput  = document.getElementById('client_name_display');

            const ensurePrimed = async (entity) => {
              try {
                await ensurePickerDatasetPrimed(entity);
                const fp = getSummaryFingerprint(entity);
                const mem = getSummaryMembership(entity, fp);
                if (!mem?.ids?.length || mem?.stale) {
                  await primeSummaryMembership(entity, fp);
                }
              } catch (e) { if (LOGC) console.warn('[CONTRACTS] typeahead priming failed', entity, e); }
            };

            const buildItemLabel = (entity, r) => {
              if (entity === 'candidates') {
                const first = (r.first_name||'').trim();
                const last  = (r.last_name||'').trim();
                const role  = ((r.roles_display||'').split(/[â€¢;,]/)[0]||'').trim();
                return `${last}${last?', ':''}${first}${role?` ${role}`:''}`.trim();
              } else {
                const name  = (r.name||'').trim();
                return name;
              }
            };

            const wireTypeahead = async (entity, inputEl, hiddenName, labelElId) => {
              if (!inputEl) return;
              await ensurePrimed(entity);

              const menuId = entity === 'candidates' ? 'candTypeaheadMenu' : 'clientTypeaheadMenu';
              let menu = document.getElementById(menuId);
              if (!menu) {
                menu = document.createElement('div');
                menu.id = menuId;
                menu.className = 'typeahead-menu';
                menu.style.position = 'absolute';
                menu.style.zIndex = '1000';
                menu.style.background = 'var(--panel, #fff)';
                menu.style.border = '1px solid var(--line, #ddd)';
                menu.style.boxShadow = '0 4px 12px rgba(0,0,0,0.08)';
                menu.style.maxHeight = '240px';
                menu.style.overflowY = 'auto';
                menu.style.display = 'none';
                document.body.appendChild(menu);
              }

              const positionMenu = () => {
                const r = inputEl.getBoundingClientRect();
                menu.style.minWidth = `${Math.max(260, r.width)}px`;
                menu.style.left = `${window.scrollX + r.left}px`;
                menu.style.top  = `${window.scrollY + r.bottom + 4}px`;
              };

              const closeMenu = () => { menu.style.display = 'none'; menu.innerHTML = ''; };
              const openMenu  = () => { positionMenu(); menu.style.display = ''; };

              const getDataset = () => {
                const fp  = getSummaryFingerprint(entity);
                const mem = getSummaryMembership(entity, fp);
                const ds  = (window.__pickerData ||= {})[entity] || { since:null, itemsById:{} };
                const items = ds.itemsById || {};
                let ids = Array.isArray(mem?.ids) ? mem.ids : [];
                if (!ids.length) ids = Object.keys(items);
                return { ids, items };
              };

              const applyList = (rows) => {
                menu.innerHTML = rows.slice(0, 10).map(r => {
                  const label = buildItemLabel(entity, r);
                  return `<div class="ta-item" data-id="${r.id||''}" data-label="${(label||'').replace(/"/g,'&quot;')}" style="padding:8px 10px;cursor:pointer;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${label}</div>`;
                }).join('');
                const first = menu.querySelector('.ta-item');
                if (first) first.style.background = 'var(--hover, #f5f5f5)';
              };

              const selectRow = (id, label) => {
                setContractFormValue(hiddenName, id);
                inputEl.value = label || '';
                const labEl = document.getElementById(labelElId);
                if (labEl) labEl.textContent = label ? `Chosen: ${label}` : '';

                try {
                  const fs = (window.modalCtx.formState ||= { __forId: (window.modalCtx.data?.id ?? window.modalCtx.openToken ?? null), main:{}, pay:{} });
                  fs.main ||= {};
                  fs.main[hiddenName] = id;
                  if (hiddenName === 'candidate_id') fs.main['candidate_display'] = label;
                  if (hiddenName === 'client_id')    fs.main['client_name']       = label;
                } catch {}

                try {
                  window.modalCtx.data = window.modalCtx.data || {};
                  if (hiddenName === 'candidate_id') { window.modalCtx.data.candidate_id = id; window.modalCtx.data.candidate_display = label; }
                  if (hiddenName === 'client_id')    { window.modalCtx.data.client_id    = id; window.modalCtx.data.client_name = label; }
                } catch {}
if (hiddenName === 'candidate_id') {
  (async () => {
    try {
      const candRaw = await getCandidate(id);
      // Support both shapes: { candidate:{...} } or flat row
      const cand = (candRaw && candRaw.candidate) ? candRaw.candidate : candRaw;

      const pmRaw = cand && cand.pay_method ? String(cand.pay_method).toUpperCase() : '';
      const derived =
        (pmRaw === 'UMBRELLA' && cand && cand.umbrella_id)
          ? 'UMBRELLA'
          : 'PAYE';

      const fsm = (window.modalCtx.formState ||= { main:{}, pay:{} }).main ||= {};
      fsm.pay_method_snapshot = derived;
      fsm.__pay_locked = true;
      const sel = document.querySelector('select[name="pay_method_snapshot"], select[name="default_pay_method_snapshot"]');
      if (sel) { sel.value = derived; sel.disabled = true; }
      computeContractMargins();
    } catch (e) {
      if (LOGC) console.warn('[CONTRACTS] derive pay method failed', e);
    }
  })();
}


                closeMenu();
                try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
              };

              let debTimer = 0;
              const handleInput = () => {
                const q = (inputEl.value||'').trim();
                if (q.length < 3) { closeMenu(); return; }
                if (debTimer) clearTimeout(debTimer);
                debTimer = setTimeout(() => {
                  const { ids, items } = getDataset();
                  const rows = pickersLocalFilterAndSort(entity, ids, q, entity==='candidates'?'last_name':'name', 'asc')
                    .map(v => (typeof v === 'object' ? v : items[String(v)]))
                    .filter(Boolean);
                  if (!rows.length) { closeMenu(); return; }
                  applyList(rows);
                  openMenu();
                }, 120);
              };

              const handleKeyDown = (e) => {
                if (menu.style.display === 'none') return;
                const items = Array.from(menu.querySelectorAll('.ta-item'));
                if (!items.length) return;
                const idx = items.findIndex(n => n.style.background && n.style.background.includes('hover'));
                const setActive = (i) => {
                  items.forEach(n => n.style.background='');
                  items[i].style.background = 'var(--hover, #f5f5f5)';
                  items[i].scrollIntoView({ block:'nearest' });
                };
                if (e.key === 'ArrowDown') { e.preventDefault(); setActive(Math.min((idx<0?0:idx+1), items.length-1)); }
                if (e.key === 'ArrowUp')   { e.preventDefault(); setActive(Math.max((idx<0?0:idx-1), 0)); }
                if (e.key === 'Enter')     { e.preventDefault(); const n = items[Math.max(idx,0)]; if (n) selectRow(n.dataset.id, n.dataset.label); }
                if (e.key === 'Escape')    { e.preventDefault(); closeMenu(); }
              };

              menu.addEventListener('click', (ev) => {
                const n = ev.target && ev.target.closest('.ta-item'); if (!n) return;
                selectRow(n.dataset.id, n.dataset.label);
              });

              let blurTimer = 0;
              inputEl.addEventListener('blur', () => { blurTimer = setTimeout(closeMenu, 150); });
              menu.addEventListener('mousedown', () => { if (blurTimer) clearTimeout(blurTimer); });

              inputEl.addEventListener('input', handleInput);
              inputEl.addEventListener('keydown', handleKeyDown);
            };

            wireTypeahead('candidates', candInput, 'candidate_id', 'candidatePickLabel');
            wireTypeahead('clients',    cliInput,  'client_id',    'clientPickLabel');

   if (btnPC && !btnPC.__wired) {
  btnPC.__wired = true;
  btnPC.addEventListener('click', async () => {
    if (LOGC) console.log('[CONTRACTS] Pick Candidate clicked');
    openCandidatePicker(async ({ id, label }) => {
      if (LOGC) console.log('[CONTRACTS] Pick Candidate â†’ selected', { id, label });

      let candRow = null;
      try {
        const candRaw = await getCandidate(id);
        // Support both shapes: { candidate:{...} } or flat row
        candRow = (candRaw && candRaw.candidate) ? candRaw.candidate : candRaw;
      } catch (e) {
        alert('Failed to load candidate details for this contract.');
        if (LOGC) console.warn('[CONTRACTS] getCandidate failed', e);
        return;
      }

      const pmRaw = candRow && candRow.pay_method ? String(candRow.pay_method).toUpperCase() : '';
      const pm    = (pmRaw === 'PAYE' || pmRaw === 'UMBRELLA') ? pmRaw : null;

      if (!pm) {
        alert('This candidate has no pay method set (Unknown). Please set their pay method to PAYE or UMBRELLA before creating a contract.');
        if (LOGC) console.warn('[CONTRACTS] blocking contract create for candidate with Unknown pay_method', {
          candidate_id: id,
          pay_method: candRow?.pay_method
        });
        return;
      }

      // Only now do we bind candidate + snapshot into the contract form
      setContractFormValue('candidate_id', id);
      const lab = document.getElementById('candidatePickLabel'); if (lab) lab.textContent = `Chosen: ${label}`;
      try {
        const fs2 = (window.modalCtx.formState ||= { __forId: (window.modalCtx.data?.id ?? window.modalCtx.openToken ?? null), main:{}, pay:{} });
        fs2.main ||= {}; fs2.main.candidate_id = id; fs2.main.candidate_display = label;
        window.modalCtx.data = window.modalCtx.data || {};
        window.modalCtx.data.candidate_id = id; window.modalCtx.data.candidate_display = label;
      } catch {}

      try {
        const fsm = (window.modalCtx.formState ||= { main:{}, pay:{} }).main ||= {};
        fsm.pay_method_snapshot = pm;
        fsm.__pay_locked = true;
        const sel = document.querySelector('select[name="pay_method_snapshot"], select[name="default_pay_method_snapshot"]');
        if (sel) { sel.value = pm; sel.disabled = true; }
        computeContractMargins();
      } catch (e) {
        if (LOGC) console.warn('[CONTRACTS] prefillPayMethodFromCandidate failed', e);
      }
    });
  });

  if (LOGC) console.log('[CONTRACTS] wired btnPickCandidate');
}

      if (btnCC && !btnCC.__wired) {
  btnCC.__wired = true;
  btnCC.addEventListener('click', () => {
    if (LOGC) console.log('[CONTRACTS] Clear Candidate clicked');
    setContractFormValue('candidate_id', '');

    // ðŸ”¹ Clear the visible candidate text input as well
    const candInput = document.getElementById('candidate_name_display');
    if (candInput) candInput.value = '';

    const lab = document.getElementById('candidatePickLabel');
    if (lab) lab.textContent = '';

    try {
      const fs2 = (window.modalCtx.formState ||= {
        __forId: (window.modalCtx.data?.id ?? window.modalCtx.openToken ?? null),
        main:{}, pay:{}
      });
      fs2.main ||= {};
      delete fs2.main.candidate_id;
      delete fs2.main.candidate_display;
      fs2.main.__pay_locked = false;
      fs2.main.pay_method_snapshot = 'PAYE';

      const sel = document.querySelector('select[name="pay_method_snapshot"], select[name="default_pay_method_snapshot"]');
      if (sel) { sel.disabled = false; sel.value = 'PAYE'; }

      window.modalCtx.data = window.modalCtx.data || {};
      delete window.modalCtx.data.candidate_id;
      delete window.modalCtx.data.candidate_display;
    } catch {}
    try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
  });
  if (LOGC) console.log('[CONTRACTS] wired btnClearCandidate');
}


            if (btnPL && !btnPL.__wired) {
              btnPL.__wired = true;
              btnPL.addEventListener('click', async () => {
                if (LOGC) console.log('[CONTRACTS] Pick Client clicked');
                openClientPicker(async ({ id, label }) => {
                  if (LOGC) console.log('[CONTRACTS] Pick Client â†’ selected', { id, label });
                  setContractFormValue('client_id', id);
                  const lab = document.getElementById('clientPickLabel'); if (lab) lab.textContent = `Chosen: ${label}`;
                  try {
                    const fs2 = (window.modalCtx.formState ||= { __forId: (window.modalCtx.data?.id ?? window.modalCtx.openToken ?? null), main:{}, pay:{} });
                    fs2.main ||= {}; fs2.main.client_id = id; fs2.main.client_name = label;
                    window.modalCtx.data = window.modalCtx.data || {};
                    window.modalCtx.data.client_id = id; window.modalCtx.data.client_name = label;
                  } catch {}
                  try {
                    const client = await getClient(id);
                    const h = checkClientInvoiceEmailPresence(client);
                    if (h) showModalHint(h, 'warn');
                    const we = (client?.week_ending_weekday ?? (client?.client_settings && client.client_settings.week_ending_weekday)) ?? 0;
                    const fs2 = (window.modalCtx.formState ||= { main:{}, pay:{} });
                    fs2.main ||= {}; fs2.main.week_ending_weekday_snapshot = String(we);
                    const weekNames = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];
                    const lbl = document.getElementById('weLabel'); if (lbl) lbl.textContent = weekNames[Number(we)] || 'Sunday';
                    const hidden = form?.querySelector('input[name="week_ending_weekday_snapshot"]'); if (hidden) hidden.value = String(we);

                    // NEW: 2.5 defaults (only on brand new contract and if not manually set yet)
try {
  const isNewContract = !window.modalCtx?.data?.id;
  const cs = client?.client_settings || {};
  if (isNewContract) {
    const main = (window.modalCtx.formState ||= {main:{},pay:{}}).main ||= {};

    if (!Object.prototype.hasOwnProperty.call(main, 'require_reference_to_pay')) {
      const v = !!cs.pay_reference_required;
      setContractFormValue('require_reference_to_pay', v ? 'on' : '');
      main.require_reference_to_pay = v;
    }
    if (!Object.prototype.hasOwnProperty.call(main, 'require_reference_to_invoice')) {
      const v = !!cs.invoice_reference_required;
      setContractFormValue('require_reference_to_invoice', v ? 'on' : '');
      main.require_reference_to_invoice = v;
    }
    if (!Object.prototype.hasOwnProperty.call(main, 'default_submission_mode')) {
      const mode = String(cs.default_submission_mode || 'ELECTRONIC').toUpperCase();
      const sel = document.querySelector('select[name="default_submission_mode"]');
      if (sel) sel.value = mode;
      main.default_submission_mode = mode;
    }

    // NEW: auto_invoice default from client settings
    if (!Object.prototype.hasOwnProperty.call(main, 'auto_invoice')) {
      const v = !!cs.auto_invoice_default;              // tweak property name if needed
      setContractFormValue('auto_invoice', v ? 'on' : '');
      main.auto_invoice = v;
      const cb = form?.querySelector('input[name="auto_invoice"]');
      if (cb) cb.checked = v;
    }

    // NEW: mileage default from client when empty
    const mcrEl = document.querySelector('#contractRatesTab input[name="mileage_charge_rate"]');
    const mprEl = document.querySelector('#contractRatesTab input[name="mileage_pay_rate"]');
    const isBlank = (el) => !el || String(el.value||'').trim()==='';
    if ((isBlank(mcrEl) && !main.mileage_charge_rate) || (isBlank(mprEl) && !main.mileage_pay_rate)) {
      const charge = (client?.mileage_charge_rate != null) ? Number(client.mileage_charge_rate) : null;
      if (charge != null && Number.isFinite(charge)) {
        const pay = Math.max(0, charge - 0.10);
        if (mcrEl) mcrEl.value = charge;
        if (mprEl) mprEl.value = pay;
        main.mileage_charge_rate = charge;
        main.mileage_pay_rate    = pay;
        try {
          if (mcrEl) { mcrEl.dispatchEvent(new Event('input',{bubbles:true})); mcrEl.dispatchEvent(new Event('change',{bubbles:true})); }
          if (mprEl) { mprEl.dispatchEvent(new Event('input',{bubbles:true})); mprEl.dispatchEvent(new Event('change',{bubbles:true})); }
        } catch {}
      }
    }
  }
} catch (e) { if (LOGC) console.warn('[CONTRACTS] client defaults (gates/submission/mileage) failed', e); }

                    try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
                  } catch (e) { if (LOGC) console.warn('[CONTRACTS] client hint/week-ending check failed', e); }
                });
              });
              if (LOGC) console.log('[CONTRACTS] wired btnPickClient');
            }
        if (btnCL && !btnCL.__wired) {
  btnCL.__wired = true;
  btnCL.addEventListener('click', () => {
    if (LOGC) console.log('[CONTRACTS] Clear Client clicked');
    setContractFormValue('client_id', '');

    // ðŸ”¹ Clear the visible client text input as well
    const cliInput = document.getElementById('client_name_display');
    if (cliInput) cliInput.value = '';

    const lab = document.getElementById('clientPickLabel');
    if (lab) lab.textContent = '';

    try {
      const fs2 = (window.modalCtx.formState ||= {
        __forId: (window.modalCtx.data?.id ?? window.modalCtx.openToken ?? null),
        main:{}, pay:{}
      });
      fs2.main ||= {};
      delete fs2.main.client_id;
      delete fs2.main.client_name;
      delete fs2.main.week_ending_weekday_snapshot;

      window.modalCtx.data = window.modalCtx.data || {};
      delete window.modalCtx.data.client_id;
      delete window.modalCtx.data.client_name;

      const lbl = document.getElementById('weLabel');
      if (lbl) lbl.textContent = 'Sunday';

      const hidden = form?.querySelector('input[name="week_ending_weekday_snapshot"]');
      if (hidden) hidden.value = '';
    } catch {}
    try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
  });
  if (LOGC) console.log('[CONTRACTS] wired btnClearClient');
}


            const openOnType = (inputEl, openerName) => {
              if (!inputEl || inputEl.__wiredTyping) return;
              inputEl.__wiredTyping = true;
              if (LOGC) console.log('[CONTRACTS] typing handler installed for', openerName);
            };
            openOnType(candInput, 'candidate');
            openOnType(cliInput, 'client');
          }
        }

           const ratesTab = document.querySelector('#contractRatesTab');
        if (ratesTab) {
          // One-time wiring for the tab container (stageRates, margins)
          if (!ratesTab.__wiredStage) {
            ratesTab.__wiredStage = true;

            // Stage numeric rate fields + margins
            const stageRates = (e) => {
              const t = e.target;
              if (!t || !t.name) return;
              if (/^(paye_|umb_|charge_)/.test(t.name) || /^mileage_(charge|pay)_rate$/.test(t.name)) {
                setContractFormValue(t.name, t.value);
                if (/^(paye_|umb_|charge_)/.test(t.name)) computeContractMargins();
                try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
              }
            };
            ratesTab.addEventListener('input', stageRates, true);
            ratesTab.addEventListener('change', stageRates, true);
            computeContractMargins();
          }

          // Choose preset wiring: may run on every wire(), guarded per-button
 // Choose preset wiring: may run on every wire(), guarded per-button
const chooseBtn = document.getElementById('btnChoosePreset');
if (chooseBtn && !chooseBtn.__wired) {
  chooseBtn.__wired = true;
  chooseBtn.addEventListener('click', () => {
    console.log('[CONTRACTS] Choose preset clicked');

    const payMethod = (function () {
      try {
        const v =
          (window.modalCtx?.formState?.main?.pay_method_snapshot) ||
          document.querySelector('select[name="pay_method_snapshot"], select[name="default_pay_method_snapshot"]')?.value ||
          window.modalCtx?.data?.pay_method_snapshot ||
          'PAYE';
        return String(v).toUpperCase();
      } catch { return 'PAYE'; }
    })();

    const formEl = document.querySelector('#contractForm');
    const fsMain = window.modalCtx?.formState?.main || {};

    // Prefer staged state and modalCtx.data for client_id; DOM is last resort
    let clientId =
      (fsMain.client_id && String(fsMain.client_id).trim()) ||
      (window.modalCtx?.data?.client_id && String(window.modalCtx.data.client_id).trim()) ||
      (formEl?.querySelector('[name="client_id"]')?.value?.trim()) ||
      null;

    clientId = clientId || null; // normalise empty string to null

    const start =
      (formEl?.querySelector('[name="start_date"]')?.value?.trim()) ||
      (fsMain.start_date && String(fsMain.start_date)) ||
      (window.modalCtx?.data?.start_date && String(window.modalCtx.data.start_date)) ||
      null;

    openRatePresetPicker(
      (preset) => {
        // NEW: pre-apply snapshot for Reset
        try {
          if (typeof snapshotContractForm === 'function') snapshotContractForm();
          const src = window.modalCtx && window.modalCtx.formState ? window.modalCtx.formState : null;
          if (src) {
            window.modalCtx.__presetBefore =
              (typeof structuredClone === 'function')
                ? structuredClone(src)
                : JSON.parse(JSON.stringify(src));
          }
        } catch (e) {
          console.warn('[CONTRACTS] pre-apply snapshot failed (non-fatal)', e);
        }

        applyRatePresetToContractForm(preset, payMethod);
        try {
          const chip = document.getElementById('presetChip');
          if (chip) {
            chip.style.display = '';
            const title =
              preset.name ||
              [preset.role, preset.band ? `Band ${preset.band}` : '']
                .filter(Boolean)
                .join(' / ') ||
              'Preset';
            chip.textContent = `Preset: ${title}`;
          }
        } catch {}
        try { computeContractMargins(); } catch {}
        // Mark the contracts frame dirty so Save becomes available
        try {
          const fr = window.__getModalFrame?.();
          if (fr && (fr.kind === 'contracts' || fr.entity === 'contracts')) {
            fr.isDirty = true;
            if (typeof fr._updateButtons === 'function') fr._updateButtons();
          }
        } catch {}
        try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
      },
      {
        client_id:    clientId,
        start_date:   start,
        defaultScope: clientId ? 'CLIENT' : 'GLOBAL'
      }
    );
  });
}



          // Full reset wiring: same pattern (per-button guard, not tied to __wiredStage)
              // Full reset wiring: same pattern (per-button guard, not tied to __wiredStage)
            const resetBtn = document.getElementById('btnResetPreset');
          if (resetBtn && !resetBtn.__wired) {
            resetBtn.__wired = true;
            resetBtn.addEventListener('click', () => {
              const snap = window.modalCtx && window.modalCtx.__presetBefore ? window.modalCtx.__presetBefore : null;
              if (snap && typeof snap === 'object') {
                // Restore from snapshot
                try {
                  const form = document.querySelector('#contractForm');
                  const writeInput = (name, value) => {
                    const el = document.querySelector(`#contractRatesTab input[name="${name}"]`) ||
                               (form && form.querySelector(`[name="${name}"]`)) ||
                               document.querySelector(`[name="${name}"]`);
                    if (el) el.value = (value == null ? '' : String(value));
                    setContractFormValue(name, (value == null ? '' : String(value)));
                  };

                  // Rates
                  const rateKeys = ['paye_day','paye_night','paye_sat','paye_sun','paye_bh','umb_day','umb_night','umb_sat','umb_sun','umb_bh','charge_day','charge_night','charge_sat','charge_sun','charge_bh'];
                  for (const k of rateKeys) writeInput(k, (snap.pay || {})[k] ?? '');

                  // Mileage â€“ try both main & pay snapshots
                  const mp = (snap.main || {})['mileage_pay_rate'];
                  const mc = (snap.main || {})['mileage_charge_rate'];
                  const mp2= (snap.pay  || {})['mileage_pay_rate'];
                  const mc2= (snap.pay  || {})['mileage_charge_rate'];
                  writeInput('mileage_pay_rate',    mp  ?? mp2  ?? '');
                  writeInput('mileage_charge_rate', mc  ?? mc2  ?? '');

                  // Bucket labels (prefer consolidated labels map if present)
                  const L = (snap.main && snap.main.__bucket_labels) ? snap.main.__bucket_labels : {
                    day:   (snap.main || {})['bucket_day']   || '',
                    night: (snap.main || {})['bucket_night'] || '',
                    sat:   (snap.main || {})['bucket_sat']   || '',
                    sun:   (snap.main || {})['bucket_sun']   || '',
                    bh:    (snap.main || {})['bucket_bh']    || ''
                  };
                  [['day','bucket_label_day'],
                   ['night','bucket_label_night'],
                   ['sat','bucket_label_sat'],
                   ['sun','bucket_label_sun'],
                   ['bh','bucket_label_bh']].forEach(([k, field]) => {
                    writeInput(field, L[k] || '');
                    // mirror to any "bucket_" fields if present
                    if (form) {
                      const el2 = form.querySelector(`[name="bucket_${k}"]`);
                      if (el2) el2.value = (L[k] || '');
                    }
                    const tr = document.querySelector(`#marginsTable tr[data-b="${k}"] > td:first-child`);
                    if (tr) tr.textContent = (L[k] || '');
                    ['cardPAYE','cardUMB','cardCHG'].forEach(cid=>{
                      const card = document.getElementById(cid);
                      const inp = card?.querySelector(`input[name$="_${k}"]`);
                      if (card && inp) { const row = inp.closest('.row'); if (row) { const lab=row.querySelector('label'); if (lab) lab.textContent=(L[k] || ''); } }
                    });
                  });

                  // Schedule
                  const tpl = (snap.main || {}).__template || null;
                  const days = ['mon','tue','wed','thu','fri','sat','sun'];
                  if (tpl) {
                    days.forEach(d => {
                      const S = tpl[d] || {};
                      writeInput(`${d}_start`, S.start || '');
                      writeInput(`${d}_end`,   S.end   || '');
                      writeInput(`${d}_break`, (S.break_minutes == null ? '' : String(S.break_minutes)));
                    });
                    const fs = (window.modalCtx.formState ||= { main:{}, pay:{} });
                    fs.main.__template = tpl;
                  } else {
                    // fallback: if snapshot had raw fields
                    days.forEach(d => {
                      writeInput(`${d}_start`, (snap.main || {})[`${d}_start`] || '');
                      writeInput(`${d}_end`,   (snap.main || {})[`${d}_end`]   || '');
                      writeInput(`${d}_break`, (snap.main || {})[`${d}_break`] || '');
                    });
                    const fs = (window.modalCtx.formState ||= { main:{}, pay:{} });
                    fs.main.__template = null;
                  }

                  // Role / band / display_site
                  writeInput('role',         (snap.main || {}).role || '');
                  writeInput('band',         (snap.main || {}).band || '');
                  writeInput('display_site', (snap.main || {}).display_site || '');

                  // Hide chip
                  try { const chip=document.getElementById('presetChip'); if (chip) { chip.style.display='none'; chip.textContent=''; } } catch {}
                } catch (err) {
                  console.warn('[CONTRACTS] preset reset restore failed, falling back to clear', err);
                }

                try { computeContractMargins(); } catch {}
                try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
                return;
              }

              // Fallback: your previous clear-to-blank behavior
              const clear = (sel) => { ratesTab.querySelectorAll(sel).forEach(el => { el.value=''; setContractFormValue(el.name, ''); }); };
              clear('input[name^="paye_"]');
              clear('input[name^="umb_"]');
              clear('input[name^="charge_"]');

              // Clear mileage
              ['mileage_charge_rate','mileage_pay_rate'].forEach(n=>{
                const el = ratesTab.querySelector(`input[name="${n}"]`);
                if (el) el.value = '';
                setContractFormValue(n, '');
              });

              // Reset bucket labels to defaults & update headings
              try {
                const defaults = { day:'Day', night:'Night', sat:'Sat', sun:'Sun', bh:'BH' };
                const form = document.querySelector('#contractForm');
                Object.entries(defaults).forEach(([k,v])=>{
                  setContractFormValue(`bucket_label_${k}`, v);
                  if (form) {
                    const el1 = form.querySelector(`[name="bucket_label_${k}"]`);
                    const el2 = form.querySelector(`[name="bucket_${k}"]`);
                    if (el1) el1.value = v;
                    if (el2) el2.value = v;
                  }
                  const tr = document.querySelector(`#marginsTable tr[data-b="${k}"] > td:first-child`);
                  if (tr) tr.textContent = v;
                  ['cardPAYE','cardUMB','cardCHG'].forEach(cid=>{
                    const card = document.getElementById(cid);
                    const inp = card?.querySelector(`input[name$="_${k}"]`);
                    if (card && inp) { const row = inp.closest('.row'); if (row) { const lab=row.querySelector('label'); if (lab) lab.textContent=v; } }
                  });
                });
              } catch {}

              // Clear schedule grid and stage std_schedule_json=null
              try {
                const days = ['mon','tue','wed','thu','fri','sat','sun'];
                days.forEach(d=>{
                  const s = document.querySelector(`input[name="${d}_start"]`);
                  const e = document.querySelector(`input[name="${d}_end"]`);
                  const b = document.querySelector(`input[name="${d}_break"]`);
                  if (s) s.value = '';
                  if (e) e.value = '';
                  if (b) b.value = '';
                });
                const fs = (window.modalCtx.formState ||= { main:{}, pay:{} });
                fs.main.__template = null;
              } catch {}

              // Clear role/band/display_site
              try {
                const fs = (window.modalCtx.formState ||= { main:{}, pay:{} }).main ||= {};
                fs.role = ''; fs.band = ''; fs.display_site = '';
                const form = document.querySelector('#contractForm');
                if (form) {
                  const r=form.querySelector('[name="role"]'); if (r) r.value='';
                  const b=form.querySelector('[name="band"]'); if (b) b.value='';
                  const s=form.querySelector('[name="display_site"]'); if (s) s.value='';
                }
              } catch {}

              // Clear chip & recompute margins
              try { const chip=document.getElementById('presetChip'); if (chip) { chip.style.display='none'; chip.textContent=''; } } catch {}
              try { computeContractMargins(); } catch {}
              try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
            });
          }


        }

       };

  setTimeout(() => {
        const fr = window.__getModalFrame?.();
        const prevDirty = fr?.isDirty;
        if (fr) fr._suppressDirty = true;

        wire();

        if (fr) {
          fr._suppressDirty = false;
          fr.isDirty = prevDirty;
          fr._updateButtons && fr._updateButtons();
        }
      }, 0);
      if (!window.__contractsWireBound) {
        window.__contractsWireBound = true;

        const rewire = () => {
          const fr = window.__getModalFrame?.();
          const prevDirty = fr?.isDirty;
          if (fr) fr._suppressDirty = true;

          setTimeout(() => {
            wire();
            if (fr) {
              fr._suppressDirty = false;
              fr.isDirty = prevDirty;
              fr._updateButtons && fr._updateButtons();
            }
          }, 0);
        };

        window.addEventListener('contracts-main-rendered', rewire);
        window.addEventListener('contracts-rates-rendered', rewire);
      }

 // Re-wire when the user clicks between Main / Rates / Calendar
      const tabsEl = document.getElementById('modalTabs');
      if (tabsEl && !tabsEl.__wired_contract_stage) {
        tabsEl.__wired_contract_stage = true;
        tabsEl.addEventListener('click', () => {
          const fr = window.__getModalFrame?.();
          const prevDirty = fr?.isDirty;
          if (fr) fr._suppressDirty = true;

          snapshotContractForm();
          setTimeout(() => {
            wire();
            if (fr) {
              fr._suppressDirty = false;
              fr.isDirty = prevDirty;
              fr._updateButtons && fr._updateButtons();
            }
          }, 0);
        });
      }

    },


    // 7th: options (now with noParentGate)
    {
      kind: 'contracts',
      extraButtons,
      noParentGate: !!isSuccessorCreate,
      stayOpenOnSave: !!isSuccessorCreate,
      _trace: (LOGC && {
        tag: 'contracts-open',
        isCreate,
        isSuccessorCreate,
        openToken: window.modalCtx.openToken
      })
    }
  );
   setTimeout(() => {
    try {
      const fr = window.__getModalFrame?.();
      if (fr && (fr.entity === 'contracts' || fr.kind === 'contracts') && typeof fr.onReturn === 'function' && !fr.__contractsInit) {
        fr.__contractsInit = true;
        fr.onReturn();
        if (LOGC) console.log('[CONTRACTS] initial onReturn() executed');
      } else if (LOGC) {
        console.log('[CONTRACTS] onReturn not executed', {
          hasFrame: !!fr, entity: fr?.entity, kind: fr?.kind, hasOnReturn: typeof fr?.onReturn === 'function', init: !!fr?.__contractsInit
        });
      }

      // ðŸ”¹ After wiring, surface any pay-method mismatch warnings returned by backend
      try {
        const baseData = (window.modalCtx && window.modalCtx.data)
          ? window.modalCtx.data
          : (row || {});
        const warnings = Array.isArray(baseData.warnings) ? baseData.warnings : [];
        if (warnings.length && typeof showModalHint === 'function') {
          showModalHint(warnings.join(' '), 'warn');
        }
      } catch (warnErr) {
        if (LOGC) console.warn('[CONTRACTS] show pay-method warnings failed', warnErr);
      }

    } catch (e) {
      if (LOGC) console.warn('[CONTRACTS] initial onReturn failed', e);
    } finally {
      if (LOGC) console.log('[CONTRACTS] openContract EXIT');
    }
  }, 0);
}



// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// NEW: getSummaryFingerprint(section)
// Deterministic fingerprint of current filters (and section)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getSummaryFingerprint(section){
  window.__listState = window.__listState || {};
  const st = (window.__listState[section] ||= { page:1, pageSize:50, total:null, hasMore:false, filters:null });
  const filters = st.filters || {};
  const norm = (o)=> {
    const k = Object.keys(o||{}).sort();
    const out = {};
    for (const key of k) {
      const v = o[key];
      if (Array.isArray(v)) out[key] = v.slice().map(x=>String(x)).sort();
      else out[key] = v;
    }
    return out;
  };
  return JSON.stringify({ section, filters: norm(filters) });
}



// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
/* NEW: primeSummaryMembership(section, fingerprint)
   - Calls backend id-list endpoint to fetch **all ids** for the current filters
   - Stores into window.__summaryCache[section][fingerprint] = { ids, total, updatedAt }
   - Non-blocking; safe to call repeatedly (dedup by fingerprint)
*/
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function primeSummaryMembership(section, fingerprint){
  const LOGC = (typeof window.__LOG_CONTRACTS === 'boolean') ? window.__LOG_CONTRACTS : false;
  window.__summaryCache = window.__summaryCache || { candidates:{}, clients:{} };
  const secKey = (section==='candidates'||section==='clients') ? section : null;
  if (!secKey) return;

  const cache = window.__summaryCache[secKey] ||= {};
  const existing = cache[fingerprint];
  if (existing && existing._inflight) return;
  if (existing && Array.isArray(existing.ids) && existing.ids.length) return;
  if (existing && existing.updatedAt && (Date.now() - existing.updatedAt > 60_000)) existing.stale = true;

  cache[fingerprint] = cache[fingerprint] || {};
  cache[fingerprint]._inflight = true;

  try {
    window.__listState = window.__listState || {};
    const st   = window.__listState[secKey] || {};
    const qs   = buildSummaryFilterQSForIdList(secKey, st.filters || {});
    const url  = API(`/api/pickers/${secKey}/id-list${qs ? ('?'+qs) : ''}`);
    const resp = await authFetch(url);
    const json = await resp.json().catch(()=>null);

    const ids = Array.isArray(json?.ids) ? json.ids.map(String) : [];
    cache[fingerprint] = {
      ids,
      total: Number(json?.total || ids.length || 0),
      updatedAt: Date.now(),
      stale: false,
    };
    if (LOGC) console.log('[SUMMARY][primeMembership]', { section: secKey, total: ids.length });
  } catch (e) {
    cache[fingerprint] = { ids: [], total: 0, updatedAt: Date.now(), stale: true };
    if (LOGC) console.warn('[SUMMARY][primeMembership] failed', e);
  } finally {
    if (cache[fingerprint]) delete cache[fingerprint]._inflight;
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// NEW: getSummaryMembership(section, fingerprint)
// Returns { ids, total, updatedAt, stale } or a stub if missing
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getSummaryMembership(section, fingerprint){
  window.__summaryCache = window.__summaryCache || { candidates:{}, clients:{} };
  const secKey = (section==='candidates'||section==='clients') ? section : null;
  if (!secKey) return { ids: [], total: 0, updatedAt: 0, stale: true };
  const ent = window.__summaryCache[secKey] || {};
  const res = ent[fingerprint] || { ids: [], total: 0, updatedAt: 0, stale: true };
  return { ids: Array.isArray(res.ids) ? res.ids : [], total: Number(res.total||0), updatedAt: Number(res.updatedAt||0), stale: !!res.stale };
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// NEW: buildSummaryFilterQSForIdList(section, filters)
// Converts current summary filters to QS for id-list endpoints.
// Reuse your search QS rules; keep only filter params (no paging).
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function buildSummaryFilterQSForIdList(section, filters){
  const sp = new URLSearchParams();
  const f  = filters || {};

  if (Array.isArray(f.ids) && f.ids.length) sp.set('ids', f.ids.join(','));
  if (f.role)      sp.set('role', f.role);
  if (f.band)      sp.set('band', f.band);
  if (f.client_id) sp.set('client_id', f.client_id);
  if (f.q)         sp.set('q', f.q);

  if (f.active != null && section === 'candidates') sp.set('active', String(!!f.active));

  return sp.toString();
}



// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// NEW: ensurePickerDatasetPrimed(entity)  entity in {'candidates','clients'}
// - Ensures dataset snapshot is loaded, then applies pending deltas.
// - Safe to call before opening a picker.
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function ensurePickerDatasetPrimed(entity){
  const LOGC = (typeof window.__LOG_CONTRACTS === 'boolean') ? window.__LOG_CONTRACTS : false;
  window.__pickerData = window.__pickerData || { candidates:{ since:null, itemsById:{} }, clients:{ since:null, itemsById:{} } };
  const ds = window.__pickerData[entity] ||= { since:null, itemsById:{} };

  if (!ds._initStarted) {
    ds._initStarted = true;
    try {
      const url  = API(`/api/pickers/${entity}/snapshot`);
      const resp = await authFetch(url);
      const json = await resp.json();
      ds.itemsById = ds.itemsById || {};
      const arr = Array.isArray(json?.items) ? json.items : [];
      for (const it of arr) ds.itemsById[String(it.id)] = it;
      ds.since = json?.since ?? ds.since ?? null;
      if (LOGC) console.log('[PICKER][dataset snapshot]', { entity, count: arr.length, since: ds.since });
    } catch (e) {
      if (LOGC) console.warn('[PICKER][dataset snapshot] failed', e);
    }
  }

  try {
    if (ds.since != null) {
      const url  = API(`/api/pickers/${entity}/delta?since=${encodeURIComponent(ds.since)}`);
      const resp = await authFetch(url);
      if (resp && resp.ok) {
        const json = await resp.json();
        applyDatasetDelta(entity, json);
        if (LOGC) console.log('[PICKER][dataset delta]', { entity, added: json?.added?.length||0, updated: json?.updated?.length||0, removed: json?.removed?.length||0, since: json?.since });
      }
    }
  } catch (e) {
    if (LOGC) console.warn('[PICKER][dataset delta] failed', e);
  }
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// NEW: applyDatasetDelta(entity, delta)  // { added:[], updated:[], removed:[], since }
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function applyDatasetDelta(entity, delta){
  window.__pickerData = window.__pickerData || { candidates:{ since:null, itemsById:{} }, clients:{ since:null, itemsById:{} } };
  const ds = window.__pickerData[entity] ||= { since:null, itemsById:{} };
  ds.itemsById = ds.itemsById || {};

  // merge in additions
  for (const it of (delta?.added || [])) {
    ds.itemsById[String(it.id)] = it;
  }

  // shallow-merge updates into existing (preserve any fields not present in payload)
  for (const it of (delta?.updated || [])) {
    const k = String(it.id);
    ds.itemsById[k] = { ...(ds.itemsById[k] || {}), ...it };
  }

  // remove deleted ids
  for (const id of (delta?.removed || [])) {
    delete ds.itemsById[String(id)];
  }

  // advance since watermark
  if (delta?.since != null) ds.since = delta.since;
}
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// NEW: pickersLocalFilterAndSort(entity, ids, query, sortKey, sortDir)
// Uses dataset cache rows restricted to {ids}, filters locally and sorts.
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function pickersLocalFilterAndSort(entity, ids, query, sortKey, sortDir){
  window.__pickerData = window.__pickerData || { candidates:{ itemsById:{} }, clients:{ itemsById:{} } };
  const itemsById = (window.__pickerData[entity]||{}).itemsById || {};
  const norm = (s)=> (s||'').toString().toLowerCase();
  const toks = norm(query||'').split(/\s+/).filter(Boolean);

  // Accept either an array of IDs or an array of row objects
  const rows = (ids && ids.length && typeof ids[0] === 'object')
    ? ids.slice()
    : (ids || []).map(id => itemsById[String(id)]).filter(Boolean);

  if (typeof window.__LOG_CONTRACTS === 'boolean' ? window.__LOG_CONTRACTS : true) {
    console.log('[PLFS:entry]', { entity, q: query, toks, in: rows.length, sortKey, sortDir });
  }

  const scoreRow = (r) => {
    if (!toks.length) return 0;
    let nameScore = 0, extraScore = 0;
    let allNameTokensMatch = true;
    if (entity === 'candidates') {
      const first = norm(r.first_name), last = norm(r.last_name);
      const disp  = norm(r.display_name || `${r.first_name||''} ${r.last_name||''}`);
      const role  = norm(r.roles_display);
      const email = norm(r.email);
      toks.forEach(t=>{
        let matched=false;
        if (first.startsWith(t)) { nameScore+=6; matched=true; }
        if (last.startsWith(t))  { nameScore+=6; matched=true; }
        if (disp.includes(t))    { nameScore+=5; matched=true; }
        if (first===t||last===t) { nameScore+=8; matched=true; }
        if (!matched) allNameTokensMatch=false;
        if (role.includes(t))    extraScore+=2;
        if (email.includes(t))   extraScore+=1;
      });
    } else {
      const name  = norm(r.name);
      const email = norm(r.primary_invoice_email);
      toks.forEach(t=>{
        let matched=false;
        if (name.includes(t))    { nameScore+=6; matched=true; }
        if (!matched) allNameTokensMatch=false;
        if (email.includes(t))   extraScore+=1;
      });
    }
    if (!allNameTokensMatch) return 0;
    if (nameScore <= 0) return 0;
    return nameScore + extraScore;
  };

  if (!toks.length) {
    const cmpAlpha = (a,b) => {
      const av = (a?.[sortKey] ?? '').toString().toLowerCase();
      const bv = (b?.[sortKey] ?? '').toString().toLowerCase();
      if (av < bv) return (sortDir==='asc'? -1 : 1);
      if (av > bv) return (sortDir==='asc'? 1 : -1);
      return 0;
    };
    const out = rows.slice().sort(cmpAlpha);
    if (typeof window.__LOG_CONTRACTS === 'boolean' ? window.__LOG_CONTRACTS : true) {
      console.log('[PLFS:noquery]', { entity, out: out.length, sample: out.slice(0,6).map(r=> r.display_name||r.name) });
    }
    return out;
  }

  const withScore = rows.map(r => ({ r, s: scoreRow(r) })).filter(x => x.s > 0);
  withScore.sort((A,B) => {
    if (A.s !== B.s) return B.s - A.s;
    const av = (A.r?.[sortKey] ?? '').toString().toLowerCase();
    const bv = (B.r?.[sortKey] ?? '').toString().toLowerCase();
    if (av < bv) return (sortDir==='asc'? -1 : 1);
    if (av > bv) return (sortDir==='asc'? 1 : -1);
    return 0;
  });
  const out = withScore.map(x => x.r);
  if (typeof window.__LOG_CONTRACTS === 'boolean' ? window.__LOG_CONTRACTS : true) {
    console.log('[PLFS:out]', { entity, q: query, out: out.length, sample: out.slice(0,6).map(r=> r.display_name||r.name) });
  }
  return out;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// NEW: revalidateCandidateOnPick(id) / revalidateClientOnPick(id)
// Fetches current detail and refreshes dataset cache before accept
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function revalidateCandidateOnPick(id){
  const url  = API(`/api/candidates/${encodeURIComponent(id)}`);
  const resp = await authFetch(url);
  if (!resp || !resp.ok) throw new Error('Could not fetch candidate.');
  const r = await resp.json();
  window.__pickerData = window.__pickerData || { candidates:{ itemsById:{} } };
  const ds = window.__pickerData.candidates ||= { itemsById:{} };
  const proj = {
    id: r.id,
    display_name: r.display_name || `${r.first_name||''} ${r.last_name||''}`.trim(),
    first_name: r.first_name || '',
    last_name: r.last_name || '',
    email: r.email || '',
    roles_display: Array.isArray(r.roles)? formatRolesSummary(r.roles) : (r.role||''),
    active: r.active !== false
  };
  ds.itemsById[String(r.id)] = proj;
}

async function revalidateClientOnPick(id){
  const url  = API(`/api/clients/${encodeURIComponent(id)}`);
  const resp = await authFetch(url);
  if (!resp || !resp.ok) throw new Error('Could not fetch client.');
  const r = await resp.json();

  window.__pickerData = window.__pickerData || { clients:{ itemsById:{} } };
  const ds = (window.__pickerData.clients ||= { itemsById:{} });

  const cs = r.client_settings || {};

  const proj = {
    id:   r.id,
    name: r.name || '',
    primary_invoice_email: r.primary_invoice_email || '',
    active: r.active !== false,
    // Preserve flags used by the NHSP-only / HR-autoprocess filters
    is_nhsp:       !!(r.is_nhsp ?? cs.is_nhsp),
    autoprocess_hr: !!(r.autoprocess_hr ?? cs.autoprocess_hr)
  };

  ds.itemsById[String(r.id)] = proj;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// NEW: contractWeekCreateAdditional â€” POST /api/contract-weeks/:id/additional
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function contractWeekCreateAdditional(week_id) {
  const r = await authFetch(API(`/api/contract-weeks/${encodeURIComponent(String(week_id))}/additional`), {
    method: 'POST'
  });
  if (!r?.ok) throw new Error('Create additional sheet failed');
  return r.json();
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// (Optional UX) NEW: openCandidatePicker / openClientPicker
// Lightweight pickers that call onPick({id,label}) and close
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UPDATED: openCandidatePicker â€” delegated clicks + debounced live search with ranking
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UPDATED: openCandidatePicker(onPick)
// - Uses summary-membership cache (ids) âˆ© dataset cache (minimal rows)
// - Type-to-filter + header sort (Surname/First/Role/Email) locally
// - Revalidates on pick
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€









  // â”€â”€ Timesheets quick filters: Stage / Route / Scope / Flags â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (currentSection === 'timesheets') {
    const stFilters = window.__listState[currentSection].filters || {};
    window.__listState[currentSection].filters = stFilters;

    // Stage dropdown
    const stageLabel = document.createElement('span');
    stageLabel.className = 'mini';
    stageLabel.textContent = 'Stage:';
    const stageSel = document.createElement('select');

    const stageOpts = [
      ['ALL',              'All'],
      ['PAID',             'Paid'],
      ['INVOICED',         'Invoiced'],
      ['READY_FOR_INVOICE','Ready for invoice'],
      ['READY_FOR_HR',     'Ready for HR'],
      ['PENDING_AUTH',     'Awaiting auth'],
      ['NEEDS_ATTENTION',  'Needs attention']
    ];
    const stageCur = (stFilters.summary_stage || 'ALL').toUpperCase();
    stageOpts.forEach(([v, label]) => {
      const o = document.createElement('option');
      o.value = v;
      o.textContent = label;
      if (stageCur === v) o.selected = true;
      stageSel.appendChild(o);
    });
    stageSel.addEventListener('change', async () => {
      const val = stageSel.value;
      const curFilters = { ...(window.__listState[currentSection].filters || {}) };
      curFilters.summary_stage = val;
      window.__listState[currentSection].filters = curFilters;
      window.__listState[currentSection].page = 1;
      const data = await loadSection();
      renderSummary(data);
    });
    topControls.appendChild(stageLabel);
    topControls.appendChild(stageSel);

    // Route dropdown
    const routeLabel = document.createElement('span');
    routeLabel.className = 'mini';
    routeLabel.textContent = 'Route:';
    const routeSel = document.createElement('select');
    const routeOpts = [
      ['ALL',              'All'],
      ['DAILY_ELECTRONIC', 'Daily â€“ electronic'],
      ['DAILY_MANUAL',     'Daily â€“ manual'],
      ['WEEKLY_ELECTRONIC','Weekly â€“ electronic'],
      ['WEEKLY_MANUAL',    'Weekly â€“ manual'],
      ['WEEKLY_NHSP',      'Weekly â€“ NHSP'],
      ['WEEKLY_NHSP_ADJUSTMENT','Weekly â€“ NHSP adj']
    ];
    const routeCur = (stFilters.route_type || 'ALL').toUpperCase();
    routeOpts.forEach(([v, label]) => {
      const o = document.createElement('option');
      o.value = v;
      o.textContent = label;
      if (routeCur === v) o.selected = true;
      routeSel.appendChild(o);
    });
    routeSel.addEventListener('change', async () => {
      const val = routeSel.value;
      const curFilters = { ...(window.__listState[currentSection].filters || {}) };
      curFilters.route_type = val;
      window.__listState[currentSection].filters = curFilters;
      window.__listState[currentSection].page = 1;
      const data = await loadSection();
      renderSummary(data);
    });
    topControls.appendChild(routeLabel);
    topControls.appendChild(routeSel);

    // Scope dropdown (Both / Weekly / Daily)
    const scopeLabel = document.createElement('span');
    scopeLabel.className = 'mini';
    scopeLabel.textContent = 'Type:';
    const scopeSel = document.createElement('select');
    const scopeOpts = [
      ['ALL',    'Both'],
      ['WEEKLY', 'Weekly only'],
      ['DAILY',  'Daily only']
    ];
    const scopeCur = (stFilters.sheet_scope || 'ALL').toUpperCase();
    scopeOpts.forEach(([v, label]) => {
      const o = document.createElement('option');
      o.value = v;
      o.textContent = label;
      if (scopeCur === v) o.selected = true;
      scopeSel.appendChild(o);
    });
    scopeSel.addEventListener('change', async () => {
      const val = scopeSel.value;
      const curFilters = { ...(window.__listState[currentSection].filters || {}) };
      curFilters.sheet_scope = val;
      window.__listState[currentSection].filters = curFilters;
      window.__listState[currentSection].page = 1;
      const data = await loadSection();
      renderSummary(data);
    });
    topControls.appendChild(scopeLabel);
    topControls.appendChild(scopeSel);

    // Flags: adjusted / QR / needs attention
    const mkFlag = (name, label) => {
      const wrap = document.createElement('label');
      wrap.className = 'mini';
      wrap.style.display = 'flex';
      wrap.style.alignItems = 'center';
      wrap.style.gap = '4px';
      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.checked = !!stFilters[name];
      cb.addEventListener('change', async () => {
        const curFilters = { ...(window.__listState[currentSection].filters || {}) };
        curFilters[name] = cb.checked ? true : false;
        window.__listState[currentSection].filters = curFilters;
        window.__listState[currentSection].page = 1;
        const data = await loadSection();
        renderSummary(data);
      });
      wrap.appendChild(cb);
      wrap.appendChild(document.createTextNode(label));
      return wrap;
    };

    topControls.appendChild(mkFlag('is_adjusted', 'Adjusted only'));
    topControls.appendChild(mkFlag('is_qr', 'QR only'));
    topControls.appendChild(mkFlag('needs_attention', 'Needs attention'));
  }

































async function openCandidatePicker(onPick, options) {
  const LOGC = (typeof window.__LOG_CONTRACTS === 'boolean') ? window.__LOG_CONTRACTS : true; // default ON
  const ctx  = options && options.context ? options.context : null;

  if (LOGC) console.log('[PICKER][candidates] ensure dataset primed â†’ start');
  await ensurePickerDatasetPrimed('candidates').catch(e => {
    if (LOGC) console.warn('[PICKER][candidates] priming failed', e);
  });

  let fp  = getSummaryFingerprint('candidates');
  let mem = getSummaryMembership('candidates', fp);
  if (!mem?.ids?.length || mem?.stale) {
    if (LOGC) console.log('[PICKER][candidates] membership empty/stale â†’ priming', { fp, mem });
    await primeSummaryMembership('candidates', fp);
    fp  = getSummaryFingerprint('candidates');
    mem = getSummaryMembership('candidates', fp);
  }

  const ds    = (window.__pickerData ||= {}).candidates || { since: null, itemsById: {} };
  const items = ds.itemsById || {};

  const baseIds  = (mem?.ids && mem.ids.length) ? mem.ids : Object.keys(items);
  const baseRows = baseIds.map(id => items[id]).filter(Boolean);

  if (LOGC) console.log('[PICKER][candidates] dataset snapshot', {
    fingerprint: fp,
    total: mem?.total,
    ids: baseIds.length,
    stale: !!mem?.stale,
    since: ds?.since,
    rowsBase: baseRows.length,
    missingItems: baseIds.length - baseRows.length
  });

  const renderRows = (rows) => rows.map(r => {
    const first = r.first_name || '';
    const last  = r.last_name || '';
    const label = (r.display_name || `${first} ${last}`).trim() || (r.tms_ref || r.id || '');
    return `
      <tr data-id="${r.id||''}" data-label="${(label||'').replace(/"/g,'&quot;')}" class="pick-row">
        <td data-k="last_name">${(last)}</td>
        <td data-k="first_name">${(first)}</td>
        <td data-k="roles_display" class="mini">${(r.roles_display||'')}</td>
        <td data-k="email" class="mini">${(r.email||'')}</td>
      </tr>`;
  }).join('');

  // Context block above the search (which shift weâ€™re resolving)
  let ctxHtml = '';
  if (ctx) {
    const staff  = ctx.staffName || '';
    const unit   = ctx.unit || ctx.hospital || '';
    const ymd    = ctx.dateYmd || '';
    const nice   = ctx.dateNice || (typeof formatYmdToNiceDate === 'function' ? formatYmdToNiceDate(ymd) : ymd);
    const importId = ctx.importId || '';

    ctxHtml = `
      <div class="row">
        <label>Resolving</label>
        <div class="controls">
          <div class="mini">
            Candidate: <span class="mono">${escapeHtml ? escapeHtml(staff) : staff}</span><br/>
            Unit / Site: <span class="mono">${escapeHtml ? escapeHtml(unit) : unit}</span><br/>
            Date: <span class="mono">${escapeHtml ? escapeHtml(nice || 'â€”') : (nice || 'â€”')}</span><br/>
            Import ID: <span class="mono">${escapeHtml ? escapeHtml(importId || 'â€”') : (importId || 'â€”')}</span>
          </div>
        </div>
      </div>`;
  }

  const html = `
    <div class="tabc">
      ${ctxHtml}
      <div class="row">
        <label>Search</label>
        <div class="controls">
          <input class="input" type="text" id="pickerSearch"
                 placeholder="${mem?.stale ? 'Priming listâ€¦ type to narrow' : 'Type a first name, surname, role or emailâ€¦'}"/>
        </div>
      </div>
      <div class="hint">
        Showing candidates from the current summary list${mem?.total ? ` (${mem.total} total)` : ''}.
      </div>
      <div class="picker-table-wrap">
        <table class="grid" id="pickerTable">
          <thead>
            <tr>
              <th data-sort="last_name">Surname</th>
              <th data-sort="first_name">First name</th>
              <th data-sort="roles_display">Role</th>
              <th data-sort="email">Email</th>
            </tr>
          </thead>
          <tbody id="pickerTBody">${renderRows(baseRows)}</tbody>
        </table>
      </div>
    </div>`;

  let selectedId    = null;
  let selectedLabel = '';
  let applySelection = null;

  const renderTab = () => html;

  const onSave = async () => {
    if (typeof applySelection !== 'function') {
      if (LOGC) console.warn('[PICKER][candidates] onSave called before wiring');
      return false;
    }
    return await applySelection(true);
  };

  if (LOGC) console.log('[PICKER][candidates] opening modal');
  showModal(
    'Pick Candidate',
    [{ key: 'p', title: 'Candidates' }],
    renderTab,
    onSave,
    false,
    () => {
      const tbody  = document.getElementById('pickerTBody');
      const search = document.getElementById('pickerSearch');
      const table  = document.getElementById('pickerTable');
      if (LOGC) console.log('[PICKER][candidates] onReturn', { hasTBody: !!tbody, hasSearch: !!search, hasTable: !!table });
      if (!tbody || !search || !table) return;

      let sortKey = 'last_name', sortDir = 'asc';
      let currentRows = baseRows.slice();

      const frame = window.__getModalFrame?.();
      if (frame && frame.kind === 'candidate-picker') {
        frame._pickerHasSelection = false;
        frame._updateButtons && frame._updateButtons();
      }

      const applyRows = (rows) => {
        tbody.innerHTML = renderRows(rows);
        // Reapply active highlight if we have a selectedId
        if (selectedId) {
          const match = tbody.querySelector(`tr[data-id="${selectedId}"]`);
          if (match) match.classList.add('active');
        }
        if (LOGC) console.log('[PICKER][candidates] render()', {
          count: rows.length,
          sample: rows.slice(0, 6).map(r => r.display_name || `${r.first_name} ${r.last_name}`)
        });
      };

      const doFilter = (q) => {
        const fn = (window.pickersLocalFilterAndSort || pickersLocalFilterAndSort);
        const out = fn('candidates', currentRows.length ? currentRows : baseRows, q, sortKey, sortDir);
        if (LOGC) console.log('[PICKER][candidates] doFilter()', {
          q,
          in: (currentRows.length || baseRows.length),
          out: out.length
        });
        return out;
      };

      const setActiveRow = (tr) => {
        const all = tbody.querySelectorAll('tr[data-id]');
        all.forEach(r => r.classList.remove('active'));
        if (!tr) {
          selectedId = null;
          selectedLabel = '';
        } else {
          tr.classList.add('active');
          selectedId    = tr.getAttribute('data-id');
          selectedLabel = tr.getAttribute('data-label') || tr.textContent.trim();
        }

        const fr = window.__getModalFrame?.();
        if (fr && fr.kind === 'candidate-picker') {
          fr._pickerHasSelection = !!selectedId;
          fr._updateButtons && fr._updateButtons();
        }
      };

      applySelection = async (triggerClose) => {
        if (!selectedId) {
          alert('Please select a candidate first.');
          return false;
        }
        if (LOGC) console.log('[PICKER][candidates] applySelection()', { selectedId, selectedLabel });
        try {
          await revalidateCandidateOnPick(selectedId);
          if (typeof onPick === 'function') {
            await onPick({ id: selectedId, label: selectedLabel });
          }
        } catch (err) {
          console.warn('[PICKER][candidates] selection validation failed', err);
          alert(err?.message || 'Selection could not be validated.');
          return false;
        }

        if (triggerClose) {
          const closeBtn = document.getElementById('btnCloseModal');
          if (closeBtn) closeBtn.click();
        }
        return true;
      };

      if (!tbody.__wiredClick) {
        tbody.__wiredClick = true;
        tbody.addEventListener('click', (e) => {
          const tr = e.target && e.target.closest('tr[data-id]');
          if (!tr) return;
          setActiveRow(tr);
        });
        tbody.addEventListener('dblclick', async (e) => {
          const tr = e.target && e.target.closest('tr[data-id]');
          if (!tr) return;
          setActiveRow(tr);
          const btnSave = document.getElementById('btnSave');
          if (btnSave && !btnSave.disabled) btnSave.click();
        });
        if (LOGC) console.log('[PICKER][candidates] wired click + dblclick handler');
      }

      if (!table.__wiredSort) {
        table.__wiredSort = true;
        table.querySelector('thead').addEventListener('click', (e) => {
          const th = e.target && e.target.closest('th[data-sort]');
          if (!th) return;
          const key = th.getAttribute('data-sort');
          sortDir = (sortKey === key && sortDir === 'asc') ? 'desc' : 'asc';
          sortKey = key;
          currentRows = doFilter(search.value.trim());
          applyRows(currentRows);
          if (LOGC) console.log('[PICKER][candidates] sort', { sortKey, sortDir, count: currentRows.length });
        });
        if (LOGC) console.log('[PICKER][candidates] wired sort header');
      }

      let t = 0;
      if (!search.__wiredInput) {
        search.__wiredInput = true;
        search.addEventListener('input', () => {
          const q = search.value.trim();
          if (LOGC) console.log('[PICKER][candidates] search input', { q });
          if (t) clearTimeout(t);
          t = setTimeout(() => {
            currentRows = doFilter(q);
            applyRows(currentRows);
            // clear current selection on new search
            setActiveRow(null);
          }, 150);
        });
        if (LOGC) console.log('[PICKER][candidates] wired search input');
      }

      if (!search.__wiredKey) {
        search.__wiredKey = true;
        search.addEventListener('keydown', (e) => {
          const itemsEls = Array.from(tbody.querySelectorAll('tr[data-id]'));
          if (!itemsEls.length) {
            if (e.key === 'Escape') {
              const closeBtn = document.getElementById('btnCloseModal');
              if (closeBtn) closeBtn.click();
            }
            return;
          }
          const idx = itemsEls.findIndex(tr => tr.classList.contains('active'));
          const setActiveIdx = (i) => {
            const safe = Math.max(0, Math.min(i, itemsEls.length - 1));
            setActiveRow(itemsEls[safe]);
            itemsEls[safe].scrollIntoView({ block: 'nearest' });
          };

          if (e.key === 'ArrowDown') {
            e.preventDefault();
            setActiveIdx(idx < 0 ? 0 : idx + 1);
          }
          if (e.key === 'ArrowUp') {
            e.preventDefault();
            setActiveIdx(idx < 0 ? 0 : idx - 1);
          }
          if (e.key === 'Enter') {
            e.preventDefault();
            const target = itemsEls[Math.max(idx, 0)];
            if (target) {
              setActiveRow(target);
              const btnSave = document.getElementById('btnSave');
              if (btnSave && !btnSave.disabled) btnSave.click();
            }
          }
          if (e.key === 'Escape') {
            e.preventDefault();
            const closeBtn = document.getElementById('btnCloseModal');
            if (closeBtn) closeBtn.click();
          }
        });
        if (LOGC) console.log('[PICKER][candidates] wired search keydown');
      }

      setTimeout(() => {
        try {
          search.focus();
          if (LOGC) console.log('[PICKER][candidates] search focused');
        } catch {}
      }, 0);
    },
    { kind: 'candidate-picker', noParentGate: true }
  );

  // Post-render kick: ensure the picker's onReturn wiring runs once on first open
  setTimeout(() => {
    try {
      const fr = window.__getModalFrame?.();
      const willCall = !!(fr && fr.kind === 'candidate-picker' && typeof fr.onReturn === 'function' && !fr.__pickerInit);
      if (LOGC) console.log('[PICKER][candidates] post-render kick', {
        hasFrame: !!fr,
        kind: fr?.kind,
        hasOnReturn: typeof fr?.onReturn === 'function',
        already: !!fr?.__pickerInit,
        willCall
      });
      if (willCall) {
        fr.__pickerInit = true;
        fr.onReturn();
        if (LOGC) console.log('[PICKER][candidates] initial onReturn() executed');
      }
    } catch (e) {
      if (LOGC) console.warn('[PICKER][candidates] post-render kick failed', e);
    }
  }, 0);
}




// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UPDATED: openClientPicker â€” delegated clicks + debounced live search
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UPDATED: openClientPicker(onPick)
// - Uses summary-membership cache + dataset cache (clients)
// - Type-to-filter + header sort (Name/Email) locally
// - Revalidates on pick
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function openClientPicker(onPick, opts) {
  const LOGC      = (typeof window.__LOG_CONTRACTS === 'boolean') ? window.__LOG_CONTRACTS : true; // default ON
  const nhspOnly  = !!(opts && opts.nhspOnly);
  const hrAutoOnly= !!(opts && opts.hrAutoOnly);
  const ctx       = opts && opts.context ? opts.context : null;

  if (LOGC) console.log('[PICKER][clients] ensure dataset primed â†’ start');
  await ensurePickerDatasetPrimed('clients').catch(e => {
    if (LOGC) console.warn('[PICKER][clients] priming failed', e);
  });

  let fp  = getSummaryFingerprint('clients');
  let mem = getSummaryMembership('clients', fp);
  if (!mem?.ids?.length || mem?.stale) {
    if (LOGC) console.log('[PICKER][clients] membership empty/stale â†’ priming', { fp, mem });
    await primeSummaryMembership('clients', fp);
    fp  = getSummaryFingerprint('clients');
    mem = getSummaryMembership('clients', fp);
  }

  const ds    = (window.__pickerData ||= {}).clients || { since: null, itemsById: {} };
  const items = ds.itemsById || {};

  const baseIds     = (mem?.ids && mem.ids.length) ? mem.ids : Object.keys(items);
  const baseRowsAll = baseIds.map(id => items[id]).filter(Boolean);

  let baseRows = baseRowsAll;
  if (nhspOnly) {
    baseRows = baseRows.filter(r => r && (r.is_nhsp === true || r.is_nhsp === 'true'));
  }
  if (hrAutoOnly) {
    baseRows = baseRows.filter(r => r && (r.autoprocess_hr === true || r.autoprocess_hr === 'true'));
  }

  if (LOGC) console.log('[PICKER][clients] dataset snapshot', {
    fingerprint: fp,
    total: mem?.total,
    ids: baseIds.length,
    stale: !!mem?.stale,
    since: ds?.since,
    rowsBase: baseRows.length,
    missingItems: baseIds.length - baseRows.length,
    nhspOnly,
    hrAutoOnly
  });

  const renderRows = (rows) => rows.map(r => {
    const label = (r.name || '').trim();
    const sub   = (r.primary_invoice_email || '').trim();
    return `
      <tr data-id="${r.id||''}" data-label="${(label||'').replace(/"/g,'&quot;')}" class="pick-row">
        <td data-k="name">${label}</td>
        <td data-k="primary_invoice_email" class="mini">${sub}</td>
      </tr>`;
  }).join('');

  let ctxHtml = '';
  if (ctx) {
    const staff   = ctx.staffName || '';
    const unit    = ctx.unit || ctx.hospital || '';
    const ymd     = ctx.dateYmd || '';
    const nice    = ctx.dateNice || (typeof formatYmdToNiceDate === 'function' ? formatYmdToNiceDate(ymd) : ymd);
    const importId= ctx.importId || '';

    ctxHtml = `
      <div class="row">
        <label>Resolving</label>
        <div class="controls">
          <div class="mini">
            Candidate: <span class="mono">${escapeHtml ? escapeHtml(staff) : staff}</span><br/>
            Unit / Site: <span class="mono">${escapeHtml ? escapeHtml(unit) : unit}</span><br/>
            Date: <span class="mono">${escapeHtml ? escapeHtml(nice || 'â€”') : (nice || 'â€”')}</span><br/>
            Import ID: <span class="mono">${escapeHtml ? escapeHtml(importId || 'â€”') : (importId || 'â€”')}</span>
          </div>
        </div>
      </div>`;
  }

  const html = `
    <div class="tabc">
      ${ctxHtml}
      <div class="row">
        <label>Search</label>
        <div class="controls">
          <input class="input" type="text" id="pickerSearch"
                 placeholder="${mem?.stale ? 'Priming listâ€¦ type to narrow' : 'Type a client name or emailâ€¦'}"/>
        </div>
      </div>
      <div class="hint">
        Showing clients from the current summary list${mem?.total ? ` (${mem.total} total)` : ''}.
        ${nhspOnly ? ' (NHSP-only filter)' : ''}${hrAutoOnly ? ' (Auto-process HR only)' : ''}
      </div>
      <div class="picker-table-wrap">
        <table class="grid" id="pickerTable">
          <thead>
            <tr>
              <th data-sort="name">Name</th>
              <th data-sort="primary_invoice_email">Email</th>
            </tr>
          </thead>
          <tbody id="pickerTBody">${renderRows(baseRows)}</tbody>
        </table>
      </div>
    </div>`;

  let selectedId    = null;
  let selectedLabel = '';
  let applySelection = null;

  const renderTab = () => html;

  const onSave = async () => {
    if (typeof applySelection !== 'function') {
      if (LOGC) console.warn('[PICKER][clients] onSave called before wiring');
      return false;
    }
    return await applySelection(true);
  };

  if (LOGC) console.log('[PICKER][clients] opening modal');
  showModal(
    'Pick Client',
    [{ key: 'p', title: 'Clients' }],
    renderTab,
    onSave,
    false,
    () => {
      const tbody  = document.getElementById('pickerTBody');
      const search = document.getElementById('pickerSearch');
      const table  = document.getElementById('pickerTable');
      if (LOGC) console.log('[PICKER][clients] onReturn', { hasTBody: !!tbody, hasSearch: !!search, hasTable: !!table });
      if (!tbody || !search || !table) return;

      let sortKey = 'name', sortDir = 'asc';
      let currentRows = baseRows.slice();

      const frame = window.__getModalFrame?.();
      if (frame && frame.kind === 'client-picker') {
        frame._pickerHasSelection = false;
        frame._updateButtons && frame._updateButtons();
      }

      const applyRows = (rows) => {
        tbody.innerHTML = renderRows(rows);
        if (selectedId) {
          const match = tbody.querySelector(`tr[data-id="${selectedId}"]`);
          if (match) match.classList.add('active');
        }
        if (LOGC) console.log('[PICKER][clients] render()', {
          count: rows.length,
          sample: rows.slice(0, 6).map(r => r.name)
        });
      };

      const doFilter = (q) => {
        const fn = (window.pickersLocalFilterAndSort || pickersLocalFilterAndSort);
        const out = fn('clients', currentRows.length ? currentRows : baseRows, q, sortKey, sortDir);
        if (LOGC) console.log('[PICKER][clients] doFilter()', {
          q,
          in: (currentRows.length || baseRows.length),
          out: out.length
        });
        return out;
      };

      const setActiveRow = (tr) => {
        const all = tbody.querySelectorAll('tr[data-id]');
        all.forEach(r => r.classList.remove('active'));
        if (!tr) {
          selectedId = null;
          selectedLabel = '';
        } else {
          tr.classList.add('active');
          selectedId    = tr.getAttribute('data-id');
          selectedLabel = tr.getAttribute('data-label') || tr.textContent.trim();
        }

        const fr = window.__getModalFrame?.();
        if (fr && fr.kind === 'client-picker') {
          fr._pickerHasSelection = !!selectedId;
          fr._updateButtons && fr._updateButtons();
        }
      };

      applySelection = async (triggerClose) => {
        if (!selectedId) {
          alert('Please select a client first.');
          return false;
        }
        if (LOGC) console.log('[PICKER][clients] applySelection()', { selectedId, selectedLabel });
        try {
          await revalidateClientOnPick(selectedId);
          if (typeof onPick === 'function') {
            await onPick({ id: selectedId, label: selectedLabel });
          }
        } catch (err) {
          console.warn('[PICKER][clients] selection validation failed', err);
          alert(err?.message || 'Selection could not be validated.');
          return false;
        }

        if (triggerClose) {
          const closeBtn = document.getElementById('btnCloseModal');
          if (closeBtn) closeBtn.click();
        }
        return true;
      };

      if (!tbody.__wiredClick) {
        tbody.__wiredClick = true;
        tbody.addEventListener('click', (e) => {
          const tr = e.target && e.target.closest('tr[data-id]');
          if (!tr) return;
          setActiveRow(tr);
        });
        tbody.addEventListener('dblclick', (e) => {
          const tr = e.target && e.target.closest('tr[data-id]');
          if (!tr) return;
          setActiveRow(tr);
          const btnSave = document.getElementById('btnSave');
          if (btnSave && !btnSave.disabled) btnSave.click();
        });
        if (LOGC) console.log('[PICKER][clients] wired click + dblclick handler');
      }

      if (!table.__wiredSort) {
        table.__wiredSort = true;
        table.querySelector('thead').addEventListener('click', (e) => {
          const th = e.target && e.target.closest('th[data-sort]');
          if (!th) return;
          const key = th.getAttribute('data-sort');
          sortDir = (sortKey === key && sortDir === 'asc') ? 'desc' : 'asc';
          sortKey = key;
          currentRows = doFilter(search.value.trim());
          applyRows(currentRows);
          if (LOGC) console.log('[PICKER][clients] sort', { sortKey, sortDir, count: currentRows.length });
        });
        if (LOGC) console.log('[PICKER][clients] wired sort header');
      }

      let t = 0;
      if (!search.__wiredInput) {
        search.__wiredInput = true;
        search.addEventListener('input', () => {
          const q = search.value.trim();
          if (LOGC) console.log('[PICKER][clients] search input', { q });
          if (t) clearTimeout(t);
          t = setTimeout(() => {
            currentRows = doFilter(q);
            applyRows(currentRows);
            setActiveRow(null);
          }, 150);
        });
        if (LOGC) console.log('[PICKER][clients] wired search input');
      }

      if (!search.__wiredKey) {
        search.__wiredKey = true;
        search.addEventListener('keydown', (e) => {
          const itemsEls = Array.from(tbody.querySelectorAll('tr[data-id]'));
          if (!itemsEls.length) {
            if (e.key === 'Escape') {
              const closeBtn = document.getElementById('btnCloseModal');
              if (closeBtn) closeBtn.click();
            }
            return;
          }

          const idx = itemsEls.findIndex(tr => tr.classList.contains('active'));
          const setActiveIdx = (i) => {
            const safe = Math.max(0, Math.min(i, itemsEls.length - 1));
            setActiveRow(itemsEls[safe]);
            itemsEls[safe].scrollIntoView({ block: 'nearest' });
          };

          if (e.key === 'ArrowDown') {
            e.preventDefault();
            setActiveIdx(idx < 0 ? 0 : idx + 1);
          }
          if (e.key === 'ArrowUp') {
            e.preventDefault();
            setActiveIdx(idx < 0 ? 0 : idx - 1);
          }
          if (e.key === 'Enter') {
            e.preventDefault();
            const target = itemsEls[Math.max(idx, 0)];
            if (target) {
              setActiveRow(target);
              const btnSave = document.getElementById('btnSave');
              if (btnSave && !btnSave.disabled) btnSave.click();
            }
          }
          if (e.key === 'Escape') {
            e.preventDefault();
            const closeBtn = document.getElementById('btnCloseModal');
            if (closeBtn) closeBtn.click();
          }
        });
        if (LOGC) console.log('[PICKER][clients] wired search keydown');
      }

      setTimeout(() => {
        try {
          search.focus();
          if (LOGC) console.log('[PICKER][clients] search focused');
        } catch {}
      }, 0);
    },
    { kind: 'client-picker', noParentGate: true }
  );

  // Post-render kick: ensure the picker's onReturn wiring runs once on first open
  setTimeout(() => {
    try {
      const fr = window.__getModalFrame?.();
      const willCall = !!(fr && fr.kind === 'client-picker' && typeof fr.onReturn === 'function' && !fr.__pickerInit);
      if (LOGC) console.log('[PICKER][clients] post-render kick', {
        hasFrame: !!fr,
        kind: fr?.kind,
        hasOnReturn: typeof fr?.onReturn === 'function',
        already: !!fr?.__pickerInit,
        willCall
      });
      if (willCall) {
        fr.__pickerInit = true;
        fr.onReturn();
        if (LOGC) console.log('[PICKER][clients] initial onReturn() executed');
      }
    } catch (e) {
      if (LOGC) console.warn('[PICKER][clients] post-render kick failed', e);
    }
  }, 0);
}



// ===== NEW HELPERS / WRAPPERS =====

// Fetch one candidate by id (adjust endpoint to your API if needed)
async function getCandidate(candidate_id) {
  if (!candidate_id) throw new Error('candidate_id required');
  const r = await authFetch(API(`/api/candidates/${encodeURIComponent(String(candidate_id))}`));
  if (!r?.ok) throw new Error('Failed to load candidate');
  return r.json();
}

// Fetch one client by id (adjust endpoint to your API if needed)
async function getClient(client_id) {
  if (!client_id) throw new Error('client_id required');
  const r = await authFetch(API(`/api/clients/${encodeURIComponent(String(client_id))}`));
  if (!r?.ok) throw new Error('Failed to load client');
  return r.json();
}

// Set/update the non-blocking hint text in the contract modal footer
function showModalHint(text, tone /* 'ok' | 'warn' | 'fail' */) {
  const el = byId('modalHint'); if (!el) return;
  el.textContent = text || '';
  el.classList.remove('tag-ok','tag-warn','tag-fail');
  if (tone === 'ok')   el.classList.add('tag-ok');
  if (tone === 'warn') el.classList.add('tag-warn');
  if (tone === 'fail') el.classList.add('tag-fail');
}

// Generic live-filter helper for picker tables
function wirePickerLiveFilter(inputEl, tableEl) {
  const rows = Array.from(tableEl.querySelectorAll('tbody tr'));
  const norm = (s) => (s||'').toLowerCase();
  inputEl.addEventListener('input', () => {
    const q = norm(inputEl.value);
    rows.forEach(tr => {
      const show = !q || norm(tr.textContent).includes(q);
      tr.style.display = show ? '' : 'none';
    });
  });
}

// Convenience: set a form field inside the contract modal
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UPDATED: setContractFormValue (adds logging)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function setContractFormValue(name, value) {
  const LOGC = (typeof window.__LOG_CONTRACTS === 'boolean') ? window.__LOG_CONTRACTS : false;

  // Do not stage ward_hint at all (deprecated)
  if (name === 'ward_hint') {
    if (LOGC) console.log('[CONTRACTS] setContractFormValue ignored (ward_hint deprecated)');
    return;
  }

  let targetName = (name === 'default_pay_method_snapshot') ? 'pay_method_snapshot' : name;

  try {
    const locked = !!(window.modalCtx?.formState?.main?.__pay_locked);
    if ((targetName === 'pay_method_snapshot' || name === 'default_pay_method_snapshot') && locked) {
      if (LOGC) console.log('[CONTRACTS] setContractFormValue ignored (pay method locked)', { name, value });
      return;
    }
  } catch {}

  const form =
    document.querySelector('#modalBody #contractForm') ||
    document.querySelector('#contractForm') ||
    null;
  const ratesRoot =
    document.getElementById('contractRatesTab') ||
    document.querySelector('#contractRatesTab') ||
    null;

  let el = null;
  if (ratesRoot) {
    el =
      ratesRoot.querySelector(`*[name="${CSS.escape(targetName)}"]`) ||
      ratesRoot.querySelector(`*[name="${CSS.escape(name)}"]`);
  }
  if (!el && form) {
    el =
      form.querySelector(`*[name="${CSS.escape(targetName)}"]`) ||
      form.querySelector(`*[name="${CSS.escape(name)}"]`);
  }

  // Validate & normalise *_start/*_end (empty allowed) **without** wiping partial input
  if (/^(mon|tue|wed|thu|fri|sat|sun)_(start|end)$/.test(targetName)) {
    const raw = (value == null ? '' : String(value).trim());

    const isValidHHMM = (s) => {
      if (!s) return true; // empty is allowed
      if (!/^(\d{1,2}:\d{1,2}|\d{3,4})$/.test(s)) return false;
      let h, m;
      if (/^\d{3,4}$/.test(s)) {
        const p = s.padStart(4, '0');
        h = +p.slice(0, 2);
        m = +p.slice(2, 4);
      } else {
        const a = s.split(':');
        h = +a[0];
        m = +a[1];
      }
      return (h >= 0 && h <= 23 && m >= 0 && m <= 59);
    };

    if (!raw) {
      // Empty: clear error markers and treat as blank
      if (el) {
        el.removeAttribute('data-invalid');
        el.removeAttribute('title');
      }
      value = '';
    } else if (isValidHHMM(raw)) {
      // Normalise to HH:MM (supports 3/4 digits or H:MM / HH:MM)
      let h, m;
      if (/^\d{3,4}$/.test(raw)) {
        const p = raw.padStart(4, '0');
        h = +p.slice(0, 2);
        m = +p.slice(2, 4);
      } else {
        const a = raw.split(':');
        h = +a[0];
        m = +a[1];
      }
      value = String(h).padStart(2, '0') + ':' + String(m).padStart(2, '0');
      if (el) {
        el.value = value;
        el.removeAttribute('data-invalid');
        el.removeAttribute('title');
      }
    } else {
      // Partially typed or invalid: keep what the user has typed, just mark it
      if (el) {
        el.setAttribute('data-invalid', '1');
        el.setAttribute('title', 'Enter HH:MM (00:00â€“23:59)');
      }
      value = raw; // keep raw so typing is not wiped
    }
  }

  window.modalCtx = window.modalCtx || {};
  const fs = (window.modalCtx.formState ||= {
    __forId: (window.modalCtx.data?.id ?? window.modalCtx.openToken ?? null),
    main:{},
    pay:{}
  });

  const isRate = /^(paye_|umb_|charge_)/.test(targetName);
  const prev = isRate ? fs.pay[targetName] : fs.main[targetName];

  let stored;
  if (el && el.type === 'checkbox') {
    el.checked = !!value && value !== 'false' && value !== '0';
    stored = el.checked ? 'on' : '';
  } else if (el && el.type === 'radio') {
    stored = String(value ?? '');
    const group = form ? Array.from(form.querySelectorAll(`input[type="radio"][name="${CSS.escape(el.name)}"]`)) : [];
    for (const r of group) r.checked = (String(r.value) === stored);
  } else {
    stored = (value == null ? '' : String(value));
    if (el) el.value = stored;
  }

  if (prev === stored) {
    if (LOGC) {
      console.log('[CONTRACTS] setContractFormValue no-op (unchanged)', {
        name: targetName,
        stored,
        prev,
        isRate
      });
    }
    return;
  }

  if (isRate) fs.pay[targetName] = stored;
  else        fs.main[targetName] = stored;

  if (LOGC) {
    let scope = 'none';
    try {
      if (el && ratesRoot && ratesRoot.contains(el)) scope = 'rates';
      else if (el && form && form.contains(el))      scope = 'form';
    } catch {}
    console.log('[CONTRACTS] setContractFormValue APPLY', {
      name: targetName,
      prev,
      stored,
      isRate,
      scope
    });
  }

  if (isRate || targetName === 'pay_method_snapshot') {
    try { computeContractMargins(); } catch {}
  }

  try { window.dispatchEvent(new CustomEvent('modal-dirty')); } catch {}
}


function applyRatePresetToContractForm(preset, payMethod /* 'PAYE'|'UMBRELLA' */) {
  if (!preset) return;

  const LOGC = (typeof window.__LOG_CONTRACTS === 'boolean') ? window.__LOG_CONTRACTS : false;

  // Helper: resolve the nearest/open Contracts frame (parent or higher)
  const getContractsFrame = () => {
    const s = window.__modalStack || [];
    for (let i = s.length - 1; i >= 0; i--) {
      const f = s[i];
      if (f && (f.kind === 'contracts' || f.entity === 'contracts')) return f;
    }
    return null;
  };

  const form =
    document.querySelector('#modalBody #contractForm') ||
    document.querySelector('#contractForm') ||
    null;
  const ratesRoot =
    document.getElementById('contractRatesTab') ||
    document.querySelector('#contractRatesTab') ||
    null;
  const canTouchDom = !!(form || ratesRoot);

  const mc = window.modalCtx || (window.modalCtx = {});
  if (!mc.formState) {
    const baseId = (mc.data && mc.data.id) || mc.openToken || null;
    mc.formState = { __forId: baseId, main: {}, pay: {} };
  }
  const fs = mc.formState;
  fs.main = fs.main || {};
  fs.pay  = fs.pay  || {};

  const effectivePayMethod = String(
    payMethod ||
    fs.main.pay_method_snapshot ||
    (mc.data && mc.data.pay_method_snapshot) ||
    'PAYE'
  ).toUpperCase();

  if (LOGC) {
    console.log('[CONTRACTS] applyRatePresetToContractForm ENTER', {
      presetId: preset.id,
      payMethodParam: payMethod,
      effectivePayMethod
    });
  }

  // Format helper: 2 decimal places if numeric, otherwise leave as-is
  const as2dpRate = (raw) => {
    if (raw == null || raw === '') return '';
    const n = Number(raw);
    return Number.isFinite(n) ? n.toFixed(2) : String(raw);
  };

  const write = (name, raw) => {
    const isRate = /^(paye_|umb_|charge_)/.test(name) || /^mileage_(pay|charge)_rate$/.test(name);
    const v = (raw == null || raw === '')
      ? ''
      : (isRate ? as2dpRate(raw) : String(raw));

    const prev = /^(paye_|umb_|charge_)/.test(name) ? fs.pay[name] : fs.main[name];

    let el = null;
    let hit = 'none';
    if (ratesRoot) {
      el = ratesRoot.querySelector(`[name="${CSS.escape(name)}"]`);
      if (el) hit = 'rates';
    }
    if (!el && form) {
      el = form.querySelector(`[name="${CSS.escape(name)}"]`);
      if (el) hit = 'form';
    }

    if (LOGC) {
      console.log('[CONTRACTS] preset write BEFORE', { name, prev, next: v, hit });
    }

    if (el && canTouchDom) {
      el.value = v;
      try {
        el.dispatchEvent(new Event('input',  { bubbles:true }));
        el.dispatchEvent(new Event('change', { bubbles:true }));
      } catch {}
    }

    // single source of truth: let setContractFormValue stage + fire margins/dirty
    if (typeof setContractFormValue === 'function') {
      try { setContractFormValue(name, v); }
      catch (e) {
        if (LOGC) console.warn('[CONTRACTS] setContractFormValue from preset failed', { name, v, err: e && e.message });
      }
    }
  };

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Identity fields: always overwrite from preset
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  [['role','role'], ['band','band'], ['display_site','display_site']].forEach(([field, key]) => {
    const next = preset[key] != null ? String(preset[key]).trim() : '';
    write(field, next);
  });

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Rates: copy all families the preset actually defines
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const BUCKETS  = ['day','night','sat','sun','bh'];
  const prefixes = ['paye','umb','charge'];

  BUCKETS.forEach(b => {
    prefixes.forEach(p => {
      const fieldName = `${p}_${b}`;
      if (!Object.prototype.hasOwnProperty.call(preset, fieldName)) return;
      const raw = preset[fieldName];
      const finalVal = as2dpRate(raw);
      write(fieldName, finalVal);
    });
  });

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Mileage â€” copy if present on the preset; leave untouched if absent
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const as2dpMileage = as2dpRate; // same behaviour

  if (Object.prototype.hasOwnProperty.call(preset, 'mileage_pay_rate')) {
    write('mileage_pay_rate', as2dpMileage(preset.mileage_pay_rate));
  }
  if (Object.prototype.hasOwnProperty.call(preset, 'mileage_charge_rate')) {
    write('mileage_charge_rate', as2dpMileage(preset.mileage_charge_rate));
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Bucket labels: if any labels present, overwrite for those keys;
  // even blank values wipe existing labels.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (preset.bucket_labels_json) {
    const BL = preset.bucket_labels_json || {};
    const hasAnyLabel = BUCKETS.some(k => Object.prototype.hasOwnProperty.call(BL, k));

    if (hasAnyLabel) {
      fs.main.__bucket_labels = fs.main.__bucket_labels || {};
      BUCKETS.forEach(k => {
        if (!Object.prototype.hasOwnProperty.call(BL, k)) return; // leave others as-is
        const raw  = BL[k];
        const next = raw == null ? '' : String(raw).trim();
        write(`bucket_label_${k}`, next);
        write(`bucket_${k}`,       next);
        fs.main.__bucket_labels[k] = next;
      });
    }
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Standard schedule:
  // - If NO days at all in std_schedule_json â†’ do nothing
  // - If ANY day present â†’ overwrite ALL 7 days (blanks where absent)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const days = ['mon','tue','wed','thu','fri','sat','sun'];

  if (preset.std_schedule_json) {
    const sched = preset.std_schedule_json || {};
    const hasAnyDay = days.some(d => Object.prototype.hasOwnProperty.call(sched, d));

    if (hasAnyDay) {
      const template = {};
      const toStr = (v) => (v == null ? '' : String(v).trim());

      days.forEach(d => {
        const hasThisDay = Object.prototype.hasOwnProperty.call(sched, d);
        const src        = hasThisDay ? (sched[d] || {}) : {};
        const start      = toStr(src.start);
        const end        = toStr(src.end);

        let brStr = '';
        let brNum = 0;
        if (src.break_minutes != null && start && end) {
          brNum = Number(src.break_minutes) || 0;
          brStr = String(brNum);
        }

        // Always overwrite all 7 days (even to blanks)
        write(`${d}_start`, start);
        write(`${d}_end`,   end);
        write(`${d}_break`, brStr);

        if (start && end) {
          template[d] = { start, end, break_minutes: brNum };
        }
      });

      fs.main.__template = template;
    }
  }

  // Hours snapshot from preset or derived from template
  if (preset.std_hours_json) {
    fs.main.__hours = preset.std_hours_json;
  } else if (fs.main.__template) {
    const hours = {};
    const toMinutes = (hhmm) => {
      const m = String(hhmm || '').match(/^(\d{1,2}):(\d{2})$/);
      return m ? (+m[1] * 60 + +m[2]) : null;
    };

    days.forEach(d => {
      const slot = fs.main.__template[d];
      if (!slot || !slot.start || !slot.end) return;

      const startMin = toMinutes(slot.start);
      const endMin   = toMinutes(slot.end);
      if (startMin == null || endMin == null) return;

      let mins = endMin < startMin ? (endMin + 1440 - startMin) : (endMin - startMin);
      mins -= Number(slot.break_minutes || 0);
      if (mins <= 0) return;

      hours[d] = +(mins / 60).toFixed(2);
    });

    fs.main.__hours = Object.keys(hours).length ? hours : null;
  }

  // Non-blocking warnings for pay-method / family mismatches
  const hasFamily = (fam) => BUCKETS.some(k => {
    const v = preset[`${fam}_${k}`];
    return v !== undefined && v !== null && String(v).trim() !== '';
  });

  try {
    if (effectivePayMethod === 'UMBRELLA' && !hasFamily('umb')) {
      if (typeof showModalHint === 'function') {
        showModalHint(
          'No Umbrella rates are set for this preset rate card. Please enter the Umbrella pay rates manually',
          'warn'
        );
      } else if (window.__toast) {
        window.__toast('No Umbrella rates are set for this preset rate card. Please enter the Umbrella pay rates manually');
      }
    } else if (effectivePayMethod === 'PAYE' && !hasFamily('paye')) {
      if (typeof showModalHint === 'function') {
        showModalHint(
          'No PAYE rates are set for this preset rate card. Please enter the PAYE pay rates manually',
          'warn'
        );
      } else if (window.__toast) {
        window.__toast('No PAYE rates are set for this preset rate card. Please enter the PAYE pay rates manually');
      }
    }
  } catch {}

  // Recompute margins + mark modal dirty
  try { if (typeof computeContractMargins === 'function') computeContractMargins(); } catch {}

  try {
    const fr = getContractsFrame();
    if (fr) {
      fr.isDirty = true;
      if (typeof fr._updateButtons === 'function') fr._updateButtons();
    }
    window.dispatchEvent(new Event('modal-dirty'));
  } catch {}

  if (LOGC) {
    console.log('[CONTRACTS] applyRatePresetToContractForm EXIT', {
      presetId: preset.id,
      effectivePayMethod
    });
  }
}


function mergeContractStateIntoRow(row) {
  const base = { ...(row || {}) };
  const fs = (window.modalCtx && window.modalCtx.formState) || null;

  // Merge MAIN staged fields (text/selects/checkbox snapshots)
  if (fs && fs.main) {
    for (const [k, v] of Object.entries(fs.main)) {
      // For checkboxes we store 'on' or '', hydrate to boolean-like fields where appropriate
      if (k === 'auto_invoice' || k === 'require_reference_to_pay' || k === 'require_reference_to_invoice') {
        base[k] = v === 'on' || v === true;
      } else if (k === 'start_date' || k === 'end_date') {
        base[k] = v; // Keep as DD/MM/YYYY in the UI; conversion happens on save
      } else if (k === 'week_ending_weekday_snapshot') {
        base[k] = v;
      } else {
        base[k] = v;
      }
    }
  }

  // Merge PAY staged fields into rates_json without forcing number conversion (UI shows strings)
  const stagedRates = (fs && fs.pay) ? fs.pay : null;
  if (stagedRates) {
    const r = { ...(base.rates_json || {}) };
    for (const [k, v] of Object.entries(stagedRates)) r[k] = v;
    base.rates_json = r;
  }

  return base;
}
function snapshotContractForm() {
  const fs = (window.modalCtx.formState ||= { __forId: (window.modalCtx.data?.id ?? window.modalCtx.openToken ?? null), main:{}, pay:{} });

  const form = document.querySelector('#contractForm');
  const fromMain  = form ? Array.from(form.querySelectorAll('input, select, textarea')) : [];

  const ratesTab  = document.querySelector('#contractRatesTab');
  const fromRates = ratesTab ? Array.from(ratesTab.querySelectorAll('input, select, textarea')) : [];

  const all = [...fromMain, ...fromRates];

  for (const el of all) {
    const name = el && el.name;
    if (!name) continue;
    if (el.disabled || el.readOnly || el.dataset.noCollect === 'true') continue;
    if (name === 'ward_hint') continue; // do not stage ward_hint

    let v;
    if (el.type === 'checkbox') {
      v = el.checked ? 'on' : '';
    } else if (el.type === 'radio') {
      if (!el.checked) continue;
      v = el.value;
    } else {
      v = el.value;
    }

    if (name === 'default_pay_method_snapshot') {
      fs.main.pay_method_snapshot = v;
      continue;
    }

    if (/^(paye_|umb_|charge_)/.test(name)) {
      fs.pay[name] = v;
    } else {
      fs.main[name] = v;
    }
  }
}


// Optional helper: align pay_method_snapshot to candidate; return hint if mismatch
function prefillPayMethodFromCandidate(candidate) {
  if (!candidate) return '';
  const method = (candidate.pay_method || candidate.pay_method_snapshot || '').toString().toUpperCase();
  if (!method || (method !== 'PAYE' && method !== 'UMBRELLA')) return '';

  const form = document.querySelector('#contractForm'); if (!form) return '';
  const sel = form.querySelector('select[name="pay_method_snapshot"]');
  if (!sel) return '';

  const current = (sel.value || '').toUpperCase();
  if (current === method) return '';

  // Preselect to match candidate to reduce mistakes (still editable)
  sel.value = method;
  const evt = new Event('change', { bubbles: true });
  sel.dispatchEvent(evt);

  return `Candidate pay method is ${method}; snapshot updated from ${current || 'N/A'}.`;
}

// Optional helper: return a friendly hint if client has no primary invoice email
function checkClientInvoiceEmailPresence(client) {
  if (!client) return '';
  const has = !!(client.primary_invoice_email && String(client.primary_invoice_email).trim());
  return has ? '' : 'Client has no primary invoice email set â€” auto-invoicing may be blocked.';
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// FIX 5: Guide hours UI (std_hours_json) added to Main tab
// (Monâ€“Sun numeric hours; optional, display-only helper)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UPDATED: renderContractMainTab (layout + logs; site under Client, Ward hint to right;
// Role with Band to the right; uses .form to pick up input styling)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function renderContractMainTab(ctx) {
  const LOGC = (typeof window.__LOG_CONTRACTS === 'boolean') ? window.__LOG_CONTRACTS : true;

  const d = mergeContractStateIntoRow(ctx?.data || {});
  const labelsBlock = renderBucketLabelsEditor({ data: d });

  const candVal   = d.candidate_id || '';
  const clientVal = d.client_id || '';

  const candLabel   = (d.candidate_display || '').trim();
  const clientLabel = (d.client_name || '').trim();

  // Derive labels from picker cache if missing but ids exist (and store into formState for persistence)
  let derivedCand = '';
  let derivedClient = '';
  try {
    const pickData = (window.__pickerData ||= {});
    if (!candLabel && candVal && pickData.candidates && pickData.candidates.itemsById) {
      const r = pickData.candidates.itemsById[candVal];
      if (r) {
        const first = (r.first_name||'').trim();
        const last  = (r.last_name||'').trim();
        const role  = ((r.roles_display||'').split(/[â€¢;,]/)[0]||'').trim();
        derivedCand = `${last}${last?', ':''}${first}${role?` ${role}`:''}`.trim();
        const fs = (window.modalCtx.formState ||= { __forId:(window.modalCtx.data?.id ?? window.modalCtx.openToken ?? null), main:{}, pay:{} });
        (fs.main ||= {}).candidate_display = derivedCand;
      }
    }
    if (!clientLabel && clientVal && pickData.clients && pickData.clients.itemsById) {
      const r = pickData.clients.itemsById[clientVal];
      if (r) {
        derivedClient = (r.name||'').trim();
        const fs = (window.modalCtx.formState ||= { __forId:(window.modalCtx.data?.id ?? window.modalCtx.openToken ?? null), main:{}, pay:{} });
        (fs.main ||= {}).client_name = derivedClient;
      }
    }
  } catch {}

  const _candLabel   = candLabel   || derivedCand;
  const _clientLabel = clientLabel || derivedClient;

  const toUk = (iso) => {
    try { return (typeof formatIsoToUk === 'function') ? (formatIsoToUk(iso) || '') : (iso || ''); }
    catch { return iso || ''; }
  };
  const startUk = (d.start_date && /^\d{2}\/\d{2}\/\d{4}$/.test(d.start_date)) ? d.start_date : toUk(d.start_date);
  const endUk   = (d.end_date && /^\d{2}\/\d{2}\/\d{4}$/.test(d.end_date)) ? d.end_date : toUk(d.end_date);

  const SS = d.std_schedule_json || {};

  const pick = (day, part) => {
    const staged = d[`${day}_${part}`];
    if (staged !== undefined && staged !== null && String(staged).trim() !== '') return String(staged).trim();
    if (part === 'break') {
      const v = SS?.[day]?.break_minutes;
      return (v === 0 || v) ? String(v) : '';
    }
    return (SS?.[day]?.[part] || '');
  };

  const DAYS = [
    ['mon','Mon'],['tue','Tue'],['wed','Wed'],['thu','Thu'],
    ['fri','Fri'],['sat','Sat'],['sun','Sun']
  ];

  // disable Pay Method snapshot whenever a candidate is present or __pay_locked is set
  const payLocked = !!(d.__pay_locked || d.candidate_id);

  // Inline time normaliser/validator wired on blur + Tab (keydown)
  const timeEvents = () => `
    onblur="(function(el){
      var v=(el.value||'').trim(); v=v.replace(/[^0-9:]/g,'');
      if(!v){ try{ if(typeof setContractFormValue==='function') setContractFormValue(el.name,''); }catch(e){}; return; }
      if(v.indexOf(':')<0){
        if(v.length===3){ v='0'+v; }
        if(v.length!==4){ el.value=''; try{ if(typeof setContractFormValue==='function') setContractFormValue(el.name,''); }catch(e){}; try{ el.dispatchEvent(new Event('input',{bubbles:true})); el.dispatchEvent(new Event('change',{bubbles:true})); }catch(e){}; return; }
        v=v.slice(0,2)+':'+v.slice(2,4);
      }
      var p=v.split(':'), h=parseInt(p[0],10), m=parseInt(p[1],10);
      if(isNaN(h)||isNaN(m)||h<0||h>23||m<0||m>59){ el.value=''; }
      else { el.value=(h<10?'0'+h:h)+':' + (m<10?'0'+m:m); }
      try{ if(typeof setContractFormValue==='function') setContractFormValue(el.name, el.value);}catch(e){}
      try{ el.dispatchEvent(new Event('input',{bubbles:true})); el.dispatchEvent(new Event('change',{bubbles:true})); }catch(e){}
    })(this)"
    onkeydown="if(event.key==='Tab'){ (function(el){
      var v=(el.value||'').trim(); v=v.replace(/[^0-9:]/g,'');
      if(!v){ try{ if(typeof setContractFormValue==='function') setContractFormValue(el.name,''); }catch(e){}; return; }
      if(v.indexOf(':')<0){
        if(v.length===3){ v='0'+v; }
        if(v.length!==4){ el.value=''; try{ if(typeof setContractFormValue==='function') setContractFormValue(el.name,''); }catch(e){}; try{ el.dispatchEvent(new Event('input',{bubbles:true})); el.dispatchEvent(new Event('change',{bubbles:true})); }catch(e){}; return; }
        v=v.slice(0,2)+':'+v.slice(2,4);
      }
      var p=v.split(':'), h=parseInt(p[0],10), m=parseInt(p[1],10);
      if(isNaN(h)||isNaN(m)||h<0||h>23||m<0||m>59){ el.value=''; }
      else { el.value=(h<10?'0'+h:h)+':' + (m<10?'0'+m:m); }
      try{ if(typeof setContractFormValue==='function') setContractFormValue(el.name, el.value);}catch(e){}
      try{ el.dispatchEvent(new Event('input',{bubbles:true})); el.dispatchEvent(new Event('change',{bubbles:true})); }catch(e){}
    })(this) }"
  `;

  const dayRow = (k, label) => {
    const s  = pick(k,'start');
    const e  = pick(k,'end');
    const br = pick(k,'break');
    const num = (v) => (v == null ? '' : String(v));
    return `
      <div class="row sched" data-day="${k}">
        <label>${label}</label>
        <div class="controls" style="display:flex;align-items:flex-end;gap:8px;flex-wrap:wrap">
          <div class="grid-3" style="min-width:420px">
            <div class="split">
              <span class="mini">Start</span>
              <input class="input" name="${k}_start" value="${s}" placeholder="HH:MM" ${timeEvents()} />
            </div>
            <div class="split">
              <span class="mini">End</span>
              <input class="input" name="${k}_end" value="${e}" placeholder="HH:MM" ${timeEvents()} />
            </div>
            <div class="split">
              <span class="mini">Break (min)</span>
              <input class="input" type="number" min="0" step="1" name="${k}_break" value="${num(br)}" placeholder="0"
                oninput="try{ if(typeof setContractFormValue==='function') setContractFormValue(this.name, this.value); }catch(e){}" />
            </div>
          </div>
          <div class="row-actions" style="display:flex;gap:6px">
            <button type="button" class="btn mini"
              title="Copy this rowâ€™s Start/End/Break"
              onclick="(function(){
                try{
                  const f=document.querySelector('#contractForm'); if(!f) return;
                  const s=f['${k}_start']?.value||''; const e=f['${k}_end']?.value||''; const b=f['${k}_break']?.value||'';
                  window.__schedClipboard = { s, e, b };
                  try {
                    var day='${label}';
                    var range=(s||'â€”') + ((s||e)?'â€“':'') + (e||'');
                    var br=(b && String(b).trim()?(' + '+b+'m'):'');
                    if (window.__toast) window.__toast('Copied ' + day + ' ' + range + br);
                  } catch {}
                }catch(e){ console.warn('sched copy failed', e); }
              })()">Copy</button>
            <button type="button" class="btn mini"
              title="Paste to this row"
              onclick="(function(){
                try{
                  const clip = window.__schedClipboard || {};
                  const f=document.querySelector('#contractForm'); if(!f) return;
                  const S=f['${k}_start'], E=f['${k}_end'], B=f['${k}_break'];
                  if(S && clip.s!=null){ S.value = clip.s; S.dispatchEvent(new Event('blur', {bubbles:true})); }
                  if(E && clip.e!=null){ E.value = clip.e; E.dispatchEvent(new Event('blur', {bubbles:true})); }
                  if(B && clip.b!=null){
                    B.value = clip.b;
                    try{ if(typeof setContractFormValue==='function') setContractFormValue(B.name, B.value); }catch(e){}
                    B.dispatchEvent(new Event('input',{bubbles:true})); B.dispatchEvent(new Event('change',{bubbles:true}));
                  }
                }catch(e){ console.warn('sched paste failed', e); }
              })()">Paste</button>
          </div>
        </div>
      </div>`;
  };

  if (LOGC) console.log('[CONTRACTS] renderContractMainTab â†’ Start/End/Breaks enabled + per-row Copy/Paste, auto-normalise on blur/Tab');

  const weekNames = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];
  const weVal = Number(d.week_ending_weekday_snapshot ?? 0);
  const weLabel = weekNames[isNaN(weVal) ? 0 : weVal];

  const schedGrid = `
    <div class="row"><label class="section">Proposed schedule (Monâ€“Sun)</label></div>
    <div class="sched-grid" style="min-width:0;flex:1">
      ${DAYS.map(([k,l]) => dayRow(k,l)).join('')}
    </div>
  `;

  if (LOGC) console.log('[CONTRACTS] renderContractMainTab snapshot', {
    candidate_id: candVal, client_id: clientVal,
    candidate_label: _candLabel, client_label: _clientLabel,
    week_ending_weekday_snapshot: d.week_ending_weekday_snapshot,
    mode: window.__getModalFrame?.()?.mode
  });

  // Inline, non-blocking overlap + timesheet-boundary checks on date changes
  const overlapChangeAttr = `
    onchange="(function(el){
      try{
        var form = document.querySelector('#contractForm');
        var cid  = form ? (form.querySelector('[name=\\'candidate_id\\']')?.value||'') : '';
        var sd   = form ? (form.querySelector('[name=\\'start_date\\']')?.value||'') : '';
        var ed   = form ? (form.querySelector('[name=\\'end_date\\']')?.value||'')  : '';
        var sIso = (window.parseUkDateToIso ? parseUkDateToIso(sd) : sd);
        var eIso = (window.parseUkDateToIso ? parseUkDateToIso(ed) : ed);
        var excl = (window.modalCtx && window.modalCtx.data && window.modalCtx.data.id) || null;

        // Overlap (non-blocking)
        if (cid && sIso && eIso && window.callCheckContractWindowOverlap) {
          callCheckContractWindowOverlap(cid, sIso, eIso, excl).then(function(res){
            if (res && res.has_overlap) {
              var msg = (res.overlaps||[]).map(function(o){
                var nm = o.client_name || o.client || 'Client';
                var a = o.overlap_from || '';
                var b = o.overlap_to   || '';
                return nm + ' ' + a + 'â†’' + b;
              }).join(' â€¢ ');
              if (window.showModalHint) { showModalHint('Overlap with: ' + msg, 'warn'); }
              else if (window.__toast)  { __toast('Overlap with: ' + msg); }
            }
          });
        }

        // Timesheet boundary (non-blocking hint + cache for save eligibility). Skip in create (no contract id yet)
        if (excl && sIso && eIso && window.callCheckTimesheetBoundary) {
          callCheckTimesheetBoundary(excl, sIso, eIso).then(function(bres){
            window.__tsBoundaryResult = bres || null;
            if (bres && bres.ok === false) {
              var txt = 'Dates exclude existing timesheets.';
              try {
                var v = bres.violations || [];
                if (v.length) {
                  var sample = v.slice(0,3).map(function(x){
                    var nm = x.client_name || 'Client';
                    var dt = x.date || '';
                    var st = x.status || '';
                    return nm + ' ' + dt + (st?(' ('+st+')'):'');
                  }).join(' â€¢ ');
                  txt = 'Dates exclude existing timesheets: ' + sample + (v.length>3?'â€¦':'');
                } else if (bres.min_ts_date || bres.max_ts_date) {
                  txt = 'Dates exclude timesheets in range ' + (bres.min_ts_date||'') + ' â†’ ' + (bres.max_ts_date||'') + '.';
                }
              } catch {}
              if (window.showModalHint) { showModalHint(txt, 'warn'); } else if (window.__toast) { __toast(txt); }
            }
          });
        } else {
          if (!excl) window.__tsBoundaryResult = null;
        }
      }catch(e){}
    })(this)"`;

  return `
    <form id="contractForm" class="tabc form">
      <input type="hidden" name="candidate_id" value="${candVal}">
      <input type="hidden" name="client_id"    value="${clientVal}">
      <input type="hidden" name="week_ending_weekday_snapshot" value="${String(d.week_ending_weekday_snapshot ?? '')}">

      <div class="row">
        <label>Candidate</label>
        <div class="controls">
          <div class="split">
            <input class="input" type="text" id="candidate_name_display" value="${_candLabel}" placeholder="Type 3+ letters to searchâ€¦" />
            <span>
              <button type="button" class="btn mini" id="btnPickCandidate">Pickâ€¦</button>
              <button type="button" class="btn mini" id="btnClearCandidate">Clear</button>
            </span>
          </div>
          <div class="mini" id="candidatePickLabel">${_candLabel ? `Chosen: ${_candLabel}` : ''}</div>
        </div>
      </div>

      <div class="row">
        <label>Client</label>
        <div class="controls">
          <div class="split">
            <input class="input" type="text" id="client_name_display" value="${_clientLabel}" placeholder="Type 3+ letters to searchâ€¦" />
            <span>
              <button type="button" class="btn mini" id="btnPickClient">Pickâ€¦</button>
              <button type="button" class="btn mini" id="btnClearClient">Clear</button>
            </span>
          </div>
          <div class="mini" id="clientPickLabel">${_clientLabel ? `Chosen: ${_clientLabel}` : ''}</div>
        </div>
      </div>

      <div class="grid-2">
        <div class="row"><label>Display site</label><div class="controls"><input class="input" name="display_site" value="${d.display_site || ''}" /></div></div>
        <div class="row"><label>Week-ending day</label><div class="controls"><div class="mini" id="weLabel">${weLabel}</div></div></div>
      </div>

      <div class="grid-2">
        <div class="row"><label>Role</label><div class="controls"><input class="input" name="role" value="${d.role || ''}" /></div></div>
        <div class="row"><label>Band</label><div class="controls"><input class="input" name="band" value="${d.band || ''}" /></div></div>
      </div>

      <div class="grid-2">
        <div class="row"><label>Start date</label><div class="controls"><input class="input" name="start_date" value="${startUk}" placeholder="DD/MM/YYYY" required ${overlapChangeAttr} /></div></div>
        <div class="row"><label>End date</label><div class="controls"><input class="input" name="end_date" value="${endUk}" placeholder="DD/MM/YYYY" required ${overlapChangeAttr} /></div></div>
      </div>

        <div class="grid-2">
        <div class="row"><label>Pay method snapshot</label>
          <div class="controls">
            <select name="pay_method_snapshot" ${payLocked ? 'disabled' : ''}>
              <option value="PAYE" ${String(d.pay_method_snapshot||'PAYE').toUpperCase()==='PAYE'?'selected':''}>PAYE</option>
              <option value="UMBRELLA" ${String(d.pay_method_snapshot||'PAYE').toUpperCase()==='UMBRELLA'?'selected':''}>Umbrella</option>
            </select>
          </div>
        </div>
        <div class="row"><label>Default submission mode</label>
          <div class="controls">
            <select name="default_submission_mode">
              <option value="ELECTRONIC" ${String(d.default_submission_mode||'ELECTRONIC').toUpperCase()==='ELECTRONIC'?'selected':''}>Electronic</option>
              <option value="MANUAL" ${String(d.default_submission_mode||'ELECTRONIC').toUpperCase()==='MANUAL'?'selected':''}>Manual</option>
            </select>
          </div>
        </div>
      </div>

      <div class="row">
        <label>Billing & references</label>
        <div class="controls" style="display:flex;flex-wrap:wrap;gap:12px;align-items:center">
          <label class="inline">
            <input type="checkbox" name="auto_invoice" ${d.auto_invoice ? 'checked' : ''} />
            <span>Auto-invoice</span>
          </label>
          <label class="inline">
            <input type="checkbox" name="require_reference_to_pay" ${d.require_reference_to_pay ? 'checked' : ''} />
            <span>Require reference to PAY</span>
          </label>
          <label class="inline">
            <input type="checkbox" name="require_reference_to_invoice" ${d.require_reference_to_invoice ? 'checked' : ''} />
            <span>Require reference to INVOICE</span>
          </label>
        </div>
      </div>

      ${schedGrid}


      ${labelsBlock}
    </form>`;
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UPDATED: renderContractRatesTab (adds logging only)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function renderContractRatesTab(ctx) {
  const LOGC = (typeof window.__LOG_CONTRACTS === 'boolean') ? window.__LOG_CONTRACTS : false;

  const merged = mergeContractStateIntoRow(ctx?.data || {});
  const R = (merged?.rates_json) || {};
  const payMethod = String(merged?.pay_method_snapshot || 'PAYE').toUpperCase();
  const showPAYE = (payMethod === 'PAYE');
  const num = (v) => (v == null ? '' : String(v));
  const LBL = merged?.bucket_labels_json || {};
  const labelOf = (k) => {
    if (k==='day') return (LBL.day||'Day');
    if (k==='night') return (LBL.night||'Night');
    if (k==='sat') return (LBL.sat||'Sat');
    if (k==='sun') return (LBL.sun||'Sun');
    if (k==='bh') return (LBL.bh||'BH');
    return k;
  };

  if (LOGC) console.log('[CONTRACTS] renderContractRatesTab', { payMethod, hasRates: !!merged?.rates_json });

  const html = `
    <div class="tabc" id="contractRatesTab" data-pay-method="${payMethod}">
      <div class="row" style="display:flex;justify-content:space-between;align-items:center">
        <label class="section">Rates</label>
        <div class="actions" style="gap:8px">
          <span class="pill" id="presetChip" style="display:none"></span>
          <button type="button" id="btnChoosePreset">Choose presetâ€¦</button>
          <button type="button" id="btnResetPreset">Reset preset</button>
        </div>
      </div>

      <div class="grid-3" id="ratesCards">
        <div class="card" id="cardPAYE" style="${showPAYE?'':'display:none'}">
          <div class="row"><label class="section">PAYE pay (visible if PAYE)</label></div>
          <div class="grid-5">
            <div class="row"><label>${labelOf('day')}</label><div class="controls"><input class="input" name="paye_day"  value="${num(R.paye_day)}" /></div></div>
            <div class="row"><label>${labelOf('night')}</label><div class="controls"><input class="input" name="paye_night" value="${num(R.paye_night)}" /></div></div>
            <div class="row"><label>${labelOf('sat')}</label><div class="controls"><input class="input" name="paye_sat"  value="${num(R.paye_sat)}" /></div></div>
            <div class="row"><label>${labelOf('sun')}</label><div class="controls"><input class="input" name="paye_sun"  value="${num(R.paye_sun)}" /></div></div>
            <div class="row"><label>${labelOf('bh')}</label><div class="controls"><input class="input" name="paye_bh"   value="${num(R.paye_bh)}" /></div></div>
          </div>
        </div>

        <div class="card" id="cardUMB" style="${showPAYE?'display:none':''}">
          <div class="row"><label class="section">Umbrella pay (visible if Umbrella)</label></div>
          <div class="grid-5">
            <div class="row"><label>${labelOf('day')}</label><div class="controls"><input class="input" name="umb_day"  value="${num(R.umb_day)}" /></div></div>
            <div class="row"><label>${labelOf('night')}</label><div class="controls"><input class="input" name="umb_night" value="${num(R.umb_night)}" /></div></div>
            <div class="row"><label>${labelOf('sat')}</label><div class="controls"><input class="input" name="umb_sat"  value="${num(R.umb_sat)}" /></div></div>
            <div class="row"><label>${labelOf('sun')}</label><div class="controls"><input class="input" name="umb_sun"  value="${num(R.umb_sun)}" /></div></div>
            <div class="row"><label>${labelOf('bh')}</label><div class="controls"><input class="input" name="umb_bh"   value="${num(R.umb_bh)}" /></div></div>
          </div>
        </div>

        <div class="card" id="cardCHG">
          <div class="row"><label class="section">Charge-out</label></div>
          <div class="grid-5">
            <div class="row"><label>${labelOf('day')}</label><div class="controls"><input class="input" name="charge_day"   value="${num(R.charge_day)}" /></div></div>
            <div class="row"><label>${labelOf('night')}</label><div class="controls"><input class="input" name="charge_night" value="${num(R.charge_night)}" /></div></div>
            <div class="row"><label>${labelOf('sat')}</label><div class="controls"><input class="input" name="charge_sat"   value="${num(R.charge_sat)}" /></div></div>
            <div class="row"><label>${labelOf('sun')}</label><div class="controls"><input class="input" name="charge_sun"   value="${num(R.charge_sun)}" /></div></div>
            <div class="row"><label>${labelOf('bh')}</label><div class="controls"><input class="input" name="charge_bh"    value="${num(R.charge_bh)}" /></div></div>
          </div>

          <!-- Mileage row -->
          <div class="grid-2" style="margin-top:10px">
            <div class="row"><label>Mileage charge</label><div class="controls"><input class="input" name="mileage_charge_rate" value="${num(merged?.mileage_charge_rate)}" /></div></div>
            <div class="row"><label>Mileage pay</label><div class="controls"><input class="input" name="mileage_pay_rate" value="${num(merged?.mileage_pay_rate)}" /></div></div>
          </div>
        </div>
      </div>

      <div class="row" style="margin-top:12px"><label class="section">Margins</label></div>
      <table class="grid" id="marginsTable">
        <thead><tr><th>Bucket</th><th>Pay</th><th>Charge</th><th>Margin</th></tr></thead>
        <tbody>
          <tr data-b="day"><td>${labelOf('day')}</td><td class="py"></td><td class="ch"></td><td class="mg"></td></tr>
          <tr data-b="night"><td>${labelOf('night')}</td><td class="py"></td><td class="ch"></td><td class="mg"></td></tr>
          <tr data-b="sat"><td>${labelOf('sat')}</td><td class="py"></td><td class="ch"></td><td class="mg"></td></tr>
          <tr data-b="sun"><td>${labelOf('sun')}</td><td class="py"></td><td class="ch"></td><td class="mg"></td></tr>
          <tr data-b="bh"><td>${labelOf('bh')}</td><td class="py"></td><td class="ch"></td><td class="mg"></td></tr>
        </tbody>
      </table>
    </div>`;

  setTimeout(() => {
    try {
      const root = document.getElementById('contractRatesTab');
      if (!root) return;
      const ev = new CustomEvent('contracts-rates-rendered', {
        detail: { payMethod }
      });
      if (LOGC) console.log('[CONTRACTS] dispatch contracts-rates-rendered', { payMethod });
      window.dispatchEvent(ev);
    } catch (e) {
      if (LOGC) console.warn('[CONTRACTS] contracts-rates-rendered dispatch failed', e);
    }
  }, 0);

  return html;
}



// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Week actions (drawer modals)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€-

function openManualWeekEditor(week_id, contract_id /* optional but recommended */) {
  const LOG = (typeof window.__LOG_CONTRACTS === 'boolean') ? window.__LOG_CONTRACTS : true;

  // Extra-rate config + week dates live in this closure so onSave can see them
  let extrasConfig = [];
  let weekDates = []; // [{ ymd, label }...]

  const main = `
    <div class="tabc">
      <div id="hoursGrid" class="grid-5 tight">
        ${['day','night','sat','sun','bh'].map(k => `
          <div data-bucket="${k}">
            <div class="lbl mini" style="margin-bottom:4px">${k.toUpperCase()}</div>
            <input class="input" type="number" step="0.01" min="0" name="h_${k}" placeholder="0.00" />
          </div>`).join('')}
      </div>

      <div class="row" style="margin-top:16px">
        <label class="section">Additional Rates</label>
        <div class="controls">
          <div id="additionalRatesSection">
            <div class="hint">No additional rates configured for this contract.</div>
          </div>
        </div>
      </div>

      <div class="row" style="margin-top:10px">
        <label>Reference (optional)</label>
        <div class="controls"><input class="input" name="reference_number" placeholder="PO / Ref" /></div>
      </div>
      <div class="row"><div class="hint">Tip: attach or replace a manual PDF in â€œActionsâ€¦â€.</div></div>
    </div>
  `;

  showModal(
    `Manual Week â€” ${week_id}`,
    [{ key:'edit', title:'Edit hours' }],
    () => main,
    async () => {
      // Collect & post
      const root = document.querySelector('#modalRoot') || document;
      const v = (n) => Number(root.querySelector(`input[name="${n}"]`)?.value || 0);
      const ref = root.querySelector('input[name="reference_number"]')?.value?.trim() || '';

      const payload = {
        hours: {
          day:  v('h_day'),
          night:v('h_night'),
          sat:  v('h_sat'),
          sun:  v('h_sun'),
          bh:   v('h_bh')
        }
      };
      if (ref) payload.reference_number = ref;

      // Additional weekly buckets â€“ derive weekly totals (and optional per-day map)
      if (extrasConfig && extrasConfig.length) {
        const addWeek = {};
        const addPerDay = {};

        extrasConfig.forEach((cfg, idx) => {
          const code = cfg.code || `EX${idx + 1}`;
          const freq = String(cfg.frequency || 'ONE_PER_WEEK').toUpperCase();

          if (freq === 'ONE_PER_WEEK') {
            const inp = root.querySelector(`input[name="extra_week_${code}"]`);
            const val = inp ? Number(inp.value || 0) : 0;
            if (val && Number.isFinite(val)) {
              addWeek[code] = val;
            }
          } else {
            // Per-day modes (ONE_PER_DAY, WEEKENDS_AND_BH_ONLY, WEEKDAYS_EXCL_BH_ONLY)
            // We collect units per displayed day and let the backend apply the BH/weekend rules.
            const perDay = {};
            let total = 0;
            if (weekDates && weekDates.length === 7) {
              for (let i = 0; i < 7; i++) {
                const meta = weekDates[i];
                const inp = root.querySelector(`input[name="extra_${code}_d${i}"]`);
                if (!inp) continue;
                const numVal = Number(inp.value || 0);
                if (!numVal || !Number.isFinite(numVal)) continue;
                perDay[meta.ymd] = numVal;
                total += numVal;
              }
            }
            if (total > 0) {
              addWeek[code] = total;
              if (Object.keys(perDay).length) addPerDay[code] = perDay;
            }
          }
        });

        if (Object.keys(addWeek).length) {
          payload.additional_units_week = addWeek;
        }
        if (Object.keys(addPerDay).length) {
          payload.additional_units_per_day = addPerDay;
        }
      }

      await contractWeekManualUpsert(week_id, payload);
      alert('Saved.');
      return true;
    },
    false,
    async () => {
      // Post-render: apply bucket labels and render Additional Rates if we have a contract
      try {
        // First resolve the contract + week-ending date
        let cw = null;
        try {
          const r = await authFetch(API(`/api/contract-weeks?id=eq.${_enc(week_id)}&select=contract_id,week_ending_date`));
          if (r && r.ok) {
            const rows = await r.json();
            if (Array.isArray(rows) && rows.length) cw = rows[0];
          }
        } catch (e) {
          if (LOG) console.warn('[MANUAL-WEEK] failed to load contract_week', e);
        }

        let cid = contract_id || (cw && cw.contract_id) || null;
        if (!cid) return;

        let cr;
        try {
          cr = await getContract(cid);
        } catch (e) {
          if (LOG) console.warn('[MANUAL-WEEK] getContract failed', e);
          return;
        }
        const contract = cr?.contract || cr;
        if (!contract) return;

        // Apply bucket labels for the 5 standard hours buckets
        try {
          const L = getBucketLabelsForContract(contract);
          applyBucketLabelsToHoursGrid(document.querySelector('#hoursGrid'), L);
        } catch (e) {
          if (LOG) console.warn('[MANUAL-WEEK] applyBucketLabels failed', e);
        }

        // Compute the 7 dates for this contract week (WE-6 .. WE)
        weekDates = [];
        if (cw && cw.week_ending_date) {
          const weIso = String(cw.week_ending_date);
          const baseDate = new Date(weIso + 'T00:00:00');
          if (!isNaN(baseDate.getTime())) {
            const dowNames = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
            for (let offset = 6; offset >= 0; offset--) {
              const d = new Date(baseDate);
              d.setDate(baseDate.getDate() - offset);
              const yyyy = d.getFullYear();
              const mm = String(d.getMonth() + 1).padStart(2, '0');
              const dd = String(d.getDate()).padStart(2, '0');
              const ymd = `${yyyy}-${mm}-${dd}`;
              const label = `${dowNames[d.getDay()]} ${dd}/${mm}`;
              weekDates.push({ ymd, label });
            }
          }
        }

        const host = document.getElementById('additionalRatesSection');
        if (!host) return;

        const extras = Array.isArray(contract.additional_rates_json)
          ? contract.additional_rates_json
          : [];

        extrasConfig = (extras || []).filter(e => e && (e.bucket_name || e.unit_name || e.code));

        if (!extrasConfig.length) {
          host.innerHTML = '<div class="hint">No additional rates configured for this contract.</div>';
          return;
        }

        const freqLabel = (f) => {
          const s = String(f || '').toUpperCase();
          if (s === 'ONE_PER_WEEK') return 'One per week';
          if (s === 'ONE_PER_DAY') return 'One per day';
          if (s === 'WEEKENDS_AND_BH_ONLY') return 'Weekends & BH only';
          if (s === 'WEEKDAYS_EXCL_BH_ONLY') return 'Weekdays (excl BH) only';
          return s || 'One per week';
        };

        const esc = (x) => String(x == null ? '' : x)
          .replace(/&/g,'&amp;')
          .replace(/</g,'&lt;')
          .replace(/>/g,'&gt;')
          .replace(/"/g,'&quot;')
          .replace(/'/g,'&#39;');

        let html = '';
        extrasConfig.forEach((cfg, idx) => {
          const code = cfg.code || `EX${idx + 1}`;
          const name = esc(cfg.bucket_name || code);
          const unitName = esc(cfg.unit_name || 'Units');
          const freq = String(cfg.frequency || 'ONE_PER_WEEK').toUpperCase();
          const pay = (cfg.pay_rate != null && Number.isFinite(Number(cfg.pay_rate))) ? Number(cfg.pay_rate) : null;
          const chg = (cfg.charge_rate != null && Number.isFinite(Number(cfg.charge_rate))) ? Number(cfg.charge_rate) : null;
          const payStr = pay != null ? pay.toFixed(2) : '0.00';
          const chgStr = chg != null ? chg.toFixed(2) : '0.00';

          if (freq === 'ONE_PER_WEEK') {
            html += `
              <div class="row extra-row" data-code="${esc(code)}">
                <label>${name}</label>
                <div class="controls">
                  <div class="split">
                    <span class="mini">${unitName} (${freqLabel(freq)})</span>
                    <input class="input" type="number" min="0" step="0.01"
                      name="extra_week_${esc(code)}" placeholder="0" />
                  </div>
                  <div class="mini" style="margin-top:4px;">
                    Pay per unit Â£${payStr}, Charge per unit Â£${chgStr}
                  </div>
                </div>
              </div>`;
          } else {
            const perDayInputs = (weekDates && weekDates.length === 7)
              ? weekDates.map((d, i) => `
                  <div class="split">
                    <span class="mini">${esc(d.label)}</span>
                    <input class="input" type="number" min="0" step="0.01"
                      name="extra_${esc(code)}_d${i}" placeholder="0" />
                  </div>
                `).join('')
              : '';

            html += `
              <div class="row extra-row" data-code="${esc(code)}">
                <label>${name}</label>
                <div class="controls" style="flex-direction:column;gap:4px;align-items:flex-start">
                  <div class="mini">${unitName} (${freqLabel(freq)})</div>
                  <div class="grid-7 tight" style="min-width:0;flex-wrap:wrap;gap:6px">
                    ${perDayInputs}
                  </div>
                  <div class="mini" style="margin-top:4px;">
                    Pay per unit Â£${payStr}, Charge per unit Â£${chgStr}
                  </div>
                </div>
              </div>`;
          }
        });

        host.innerHTML = `
          <div class="card" id="manualExtrasCard" style="margin-top:4px">
            <div class="row"><label class="section">Additional Rates â€” weekly units</label></div>
            <div class="extras-body" style="display:flex;flex-direction:column;gap:8px">
              ${html}
            </div>
          </div>
        `;
      } catch (e) {
        if (LOG) console.warn('[MANUAL-WEEK] post-render wiring failed', e);
      }
    },
    { kind:'manual-week' }
  );
}
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// openContractWeekActions (amended) â€” â€œAdd additional sheetâ€ now calls additional;
// add separate â€œCreate expense sheetâ€ button wired to expense-sheet endpoint
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€




// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// FIX 2: Clone & Extend endpoint name mismatch (â€¦/clone-and-extend)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function openContractCloneAndExtend(contract_id) {
  const LOGM = !!window.__LOG_MODAL;
  const old = (window.modalCtx && window.modalCtx.data) ? window.modalCtx.data : {};
  if (LOGM) console.log('[CLONE] entry', { contract_id, hasOld: !!old?.id, oldPreview: old?.id ? { id: old.id, start: old.start_date, end: old.end_date } : null });

  const iso = (d)=> (typeof d === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(d)) ? d : toYmd(new Date());
  const oldStart = iso(old?.start_date);
  const oldEnd   = iso(old?.end_date);

  // Defaults for the wizard
  const defaultStart = (() => { const d=new Date((oldEnd||toYmd(new Date()))+'T00:00:00Z'); d.setUTCDate(d.getUTCDate()+1); return toYmd(d); })();
  const defaultEnd   = (() => { const d=new Date(defaultStart+'T00:00:00Z'); d.setUTCDate(d.getUTCDate()+84); return toYmd(d); })();
  const defaultEndOld= (() => { const d=new Date(defaultStart+'T00:00:00Z'); d.setUTCDate(d.getUTCDate()-1); return toYmd(d); })();

  const content = `
    <div class="tabc" id="cloneExtendForm">
      <div class="row"><label>New start</label>
        <div class="controls"><input class="input" type="text" name="new_start_date" placeholder="DD/MM/YYYY" value="${formatIsoToUk(defaultStart)}" /></div>
      </div>
      <div class="row"><label>New end</label>
        <div class="controls"><input class="input" type="text" name="new_end_date" placeholder="DD/MM/YYYY" value="${formatIsoToUk(defaultEnd)}" /></div>
      </div>

      <div class="row" style="margin-top:6px">
        <label style="display:flex;align-items:center;gap:6px">
          <input type="checkbox" name="end_existing_checked" checked />
          End existing contract on
        </label>
        <div class="controls" style="margin-top:6px">
          <input class="input" type="text" name="end_existing_on" placeholder="DD/MM/YYYY" value="${formatIsoToUk(defaultEndOld)}" />
          <div class="mini" style="margin-top:4px">Default is New start âˆ’ 1 day. Untick to keep the existing contract running.</div>
        </div>
      </div>

      <div class="mini" style="margin-top:10px">
        After this, the successor opens in the normal contract modal (Create mode). You can edit Main / Rates / Calendar before saving.
      </div>
    </div>
  `;

  showModal(
    'Clone & Extend',
    [{ key:'c', title:'Successor window' }],
    () => content,
    async () => {
      const LOGM = !!window.__LOG_MODAL;
      const root = document.getElementById('cloneExtendForm') || document;

      const newStartUk  = root.querySelector('input[name="new_start_date"]')?.value?.trim() || '';
      const newEndUk    = root.querySelector('input[name="new_end_date"]')?.value?.trim()   || '';
      const endChk      = !!root.querySelector('input[name="end_existing_checked"]')?.checked;
      const endOldUk    = root.querySelector('input[name="end_existing_on"]')?.value?.trim() || '';

      const new_start_date = parseUkDateToIso(newStartUk);
      const new_end_date   = parseUkDateToIso(newEndUk);
      const end_existing_on= endChk ? parseUkDateToIso(endOldUk) : null;

      if (!new_start_date || !new_end_date) { alert('Enter both new start and new end.'); return false; }
      if (new_start_date > new_end_date)   { alert('New end must be on or after new start.'); return false; }

      try {
        const oldStartIso = (window.modalCtx?.data?.start_date) || '';
        if (endChk) {
          if (!end_existing_on) { alert('Pick a valid end date for the existing contract.'); return false; }
          if (oldStartIso && end_existing_on < oldStartIso) { alert('Existing contract cannot end before its original start.'); return false; }
          if (end_existing_on >= new_start_date) { alert('Existing contract end must be before the new start.'); return false; }
        }
      } catch {}

      // === NEW: pre-truncate the existing contract (blocking) BEFORE opening successor ===
      let effectiveOldEnd = end_existing_on;
      if (endChk) {
        const oldId = String(window.modalCtx?.data?.id || '');
        if (!oldId) { alert('Source contract id missing.'); return false; }

        try {
          console.groupCollapsed('[CLONE][pre-trim gate]');
          const url  = API(`/api/contracts/${encodeURIComponent(oldId)}/truncate-tail`);
          const init = {
            method: 'POST',
            headers: { 'content-type': 'application/json' },
            body: JSON.stringify({ id: oldId, desired_end: end_existing_on })
          };
          console.log('request', { url, init, new_start_date, new_end_date });
          try { window.__LOG_API = true; } catch {}

          const res = await (typeof authFetch === 'function' ? authFetch(url, init) : fetch(url, init));
          let obj = null;
          try { obj = await res.clone().json(); } catch { obj = null; }

          const okField =
            (typeof obj?.ok === 'boolean' ? obj.ok :
             typeof obj?.success === 'boolean' ? obj.success :
             (typeof res?.ok === 'boolean' ? res.ok : undefined));

          const clamped  = !!obj?.clamped;
          const safe_end = obj?.safe_end || null;
          const status   = (typeof res?.status === 'number') ? res.status : (typeof obj?.status === 'number' ? obj.status : undefined);

          console.log('response', { status, ok: !!okField, clamped, safe_end, obj });

          if (!okField) {
            alert((obj && (obj.message || obj.error)) || res.statusText || 'Failed to end the existing contract.');
            console.groupEnd?.();
            return false;
          }

          if (clamped && typeof showTailClampWarning === 'function') {
            try { showTailClampWarning(safe_end, end_existing_on); } catch {}
          }

          effectiveOldEnd = safe_end || end_existing_on;

          if (effectiveOldEnd >= new_start_date) {
            alert(`Existing contract now ends on ${effectiveOldEnd}, which overlaps the new start (${new_start_date}). Adjust dates and try again.`);
            console.groupEnd?.();
            return false;
          }

          if (typeof refreshOldContractAfterTruncate === 'function') {
            try { await refreshOldContractAfterTruncate(oldId); } catch (e) { if (LOGM) console.warn('[CLONE] refresh after truncate failed', e); }
          }
          console.groupEnd?.();
        } catch (e) {
          console.warn('[CLONE][pre-trim gate] exception', e);
          alert(`Could not end the existing contract: ${e?.message || e}`);
          return false;
        }
      }

      // Build staged successor row from current contract (no staging of end_existing intent anymore)
      const old = window.modalCtx?.data || {};
      const newToken = `contract:new:${Date.now()}:${Math.random().toString(36).slice(2)}`;
      const stagedRow = {
        id: null,
        candidate_id: old.candidate_id || '',
        client_id:    old.client_id    || '',
        role:         old.role         || '',
        band:         (old.band ?? null),
        display_site: old.display_site || '',
        start_date:   new_start_date,
        end_date:     new_end_date,
        pay_method_snapshot: old.pay_method_snapshot || 'PAYE',
        default_submission_mode: old.default_submission_mode || 'ELECTRONIC',
        week_ending_weekday_snapshot: Number(old.week_ending_weekday_snapshot ?? 0),
        std_schedule_json: old.std_schedule_json || null,
        std_hours_json:    old.std_hours_json    || null,
        bucket_labels_json: old.bucket_labels_json || null,
        rates_json: (old.rates_json && typeof old.rates_json === 'object') ? old.rates_json : {}
      };

      // Open successor ONLY AFTER the pre-trim has finished successfully â€” as a ROOT modal
      try {
        if (LOGM) console.log('[CLONE] will open staged successor in Create mode (root, deferred)', { token: newToken, stagedRow, effectiveOldEnd });
        window.__preOpenToken = newToken;
        setTimeout(() => {
          try {
            // Tear down entire stack so successor opens as root (no parent to resurface)
            try { discardAllModalsAndState(); } catch {}
            openContract(stagedRow);
            // After the modal builds its own formState, force-align __forId with our token
            setTimeout(() => {
              try {
                if (window.modalCtx) {
                  window.modalCtx.openToken = newToken;
                  const fs2 = (window.modalCtx.formState ||= { __forId: newToken, main:{}, pay:{} });
                  fs2.__forId = newToken;
                  if (LOGM) console.log('[CLONE] bound token to create modal', { openToken: window.modalCtx.openToken, forId: fs2.__forId });
                }
              } catch (e) { console.warn('[CLONE] bind token failed', e); }
            }, 0);
          } catch (e) {
            console.error('[CLONE] openContract failed', e);
            try { renderAll(); } catch {}
          }
        }, 0);
      } catch (e) {
        console.error('[CLONE] schedule open failed', e);
      }

      return true;
    },
    false,
    () => {
      try { window.dispatchEvent(new Event('contracts-main-rendered')); } catch {}
    },
    { kind:'contract-clone-extend', forceEdit:true, noParentGate:true }
  );

  // Wire pickers & auto-sync after mount
  setTimeout(() => {
    const root = document.getElementById('cloneExtendForm');
    if (!root) return;

    const startEl = root.querySelector('input[name="new_start_date"]');
    const endEl   = root.querySelector('input[name="new_end_date"]');
    const endChk  = root.querySelector('input[name="end_existing_checked"]');
    const endOld  = root.querySelector('input[name="end_existing_on"]');

    attachUkDatePicker(startEl, { minDate: formatIsoToUk(oldStart) });
    attachUkDatePicker(endEl,   { minDate: startEl.value, maxDate: null });
    attachUkDatePicker(endOld,  { minDate: formatIsoToUk(oldStart), maxDate: startEl.value });

    const isoMinusOne = (isoStr) => { try { const d=new Date(isoStr+'T00:00:00Z'); d.setUTCDate(d.getUTCDate()-1); return toYmd(d); } catch { return null; } };

    const onStartChange = () => {
      const startIso = parseUkDateToIso(startEl.value || '') || defaultStart;
      const maxOldEndIso = isoMinusOne(startIso);
      const maxOldEndUk  = formatIsoToUk(maxOldEndIso);
      if (typeof endOld.setMinDate === 'function') endOld.setMinDate(formatIsoToUk(oldStart));
      endOld._maxIso = maxOldEndIso;
      if (typeof endOld.__ukdpRepaint === 'function') endOld.__ukdpRepaint();
      if (endChk.checked) endOld.value = maxOldEndUk;
      if (LOGM) console.log('[CLONE] onStartChange', { startIso, endOldUk: endOld.value, maxOldEndIso });
    };

    const onChkToggle = () => {
      const checked = !!endChk.checked;
      endOld.disabled = !checked;
      if (checked) {
        const sIso = parseUkDateToIso(startEl.value || '') || oldEnd;
        const maxIso = isoMinusOne(sIso);
        const maxUk  = formatIsoToUk(maxIso);
        const eIso   = parseUkDateToIso(endOld.value || '') || '';
        if (!eIso || eIso >= sIso || eIso < oldStart) endOld.value = maxUk;
      }
      if (LOGM) console.log('[CLONE] onChkToggle', { checked, endOldUk: endOld.value });
    };

    startEl.addEventListener('change', onStartChange, true);
    startEl.addEventListener('blur',   onStartChange, true);
    endChk.addEventListener('change',  onChkToggle,   true);

    onChkToggle();
    onStartChange();
  }, 0);
}


function openContractSkipWeeks(contract_id) {
  const content = `
    <div class="tabc">
      <div class="row"><label>From (W/E)</label><div class="controls"><input class="input" name="from" placeholder="YYYY-MM-DD" /></div></div>
      <div class="row"><label>To (W/E)</label><div class="controls"><input class="input" name="to" placeholder="YYYY-MM-DD" /></div></div>
      <div class="hint">Only OPEN/PLANNED weeks without timesheets will be cancelled.</div>
    </div>
  `;
  showModal(
    'Skip Weeks',
    [{ key:'s', title:'Cancel range'}],
    () => content,
    async () => {
      const root = document;
      const from = root.querySelector('input[name="from"]')?.value?.trim() || null;
      const to   = root.querySelector('input[name="to"]')?.value?.trim() || null;
      const r = await authFetch(API(`/api/contracts/${_enc(contract_id)}/skip-weeks`), {
        method:'POST', headers:{'content-type':'application/json'}, body:_json({ from, to })
      });
      if (!r?.ok) { alert('Skip weeks failed.'); return false; }
      alert('Weeks cancelled (where eligible).');
      return true;
    },
    false,
    null,
    { kind:'skip-weeks' }
  );
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Helper â€” presign & upload a manual PDF to the week
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€-

async function presignAndAttachManualWeekPdf(week_id) {
  try {
    const { upload_url } = await contractWeekPresignPdf(week_id);

    // Spawn a file input + PUT the first file
    const inp = document.createElement('input');
    inp.type = 'file';
    inp.accept = '.pdf,.jpg,.jpeg,.png,.heic,.heif,application/pdf,image/*';
    inp.style.display = 'none';
    document.body.appendChild(inp);
    inp.onchange = async () => {
      const f = inp.files && inp.files[0];
      document.body.removeChild(inp);
      if (!f) return;

      const put = await fetch(upload_url, { method:'PUT', headers:{ 'content-type': f.type || 'application/octet-stream' }, body: f });
      if (!put.ok) throw new Error(`Upload failed (${put.status})`);
      alert('File uploaded and attached to the week.');
    };
    inp.click();
  } catch (e) {
    alert(e?.message || e);
  }
}














































// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// NEW: Quick wrapper to focus current ticked selection
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// NEW: Render the tiny Selection toolbar under the grid
// Buttons: ðŸ” Focus | ðŸ” Save | ðŸ” Load
// Call from renderSummary() after the pager, or anywhere you want.
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderSelectionToolbar(section, mountAfterEl) {
  // Locate a mount point
  const content = document.getElementById('content');
  const host = mountAfterEl || content;
  if (!host) return null;

  // Read selection
  window.__selection = window.__selection || {};
  const sel = (window.__selection[section] ||= { fingerprint: '', ids: new Set() });
  const hasSelection = sel.ids && sel.ids.size > 0;

  // Create bar
  const bar = document.createElement('div');
  bar.className = 'selection-toolbar';
  bar.style.cssText = 'display:flex;justify-content:flex-end;gap:8px;padding:6px 10px;border-top:1px dashed var(--line)';

  // Button factory
  const mkBtn = (title, text) => {
    const b = document.createElement('button');
    b.title = title;
    b.textContent = text;
    b.style.cssText = 'border:1px solid var(--line);background:#0b152a;color:var(--text);padding:4px 8px;border-radius:8px;cursor:pointer';
    return b;
  };

  const btnFocus = mkBtn('Focus on records', 'ðŸ” Focus');
  const btnSave  = mkBtn('Save selection',   'ðŸ” Save');
  const btnLoad  = mkBtn('Load selection',   'ðŸ” Load');

  btnFocus.disabled = !hasSelection;
  btnSave.disabled  = !hasSelection;

  btnFocus.addEventListener('click', async () => {
    try { await focusCurrentSelection(section); } catch (e) { console.error('Focus failed', e); }
  });

  btnSave.addEventListener('click', async () => {
    try { await openSaveSelectionModal(section); } catch (e) { console.error('Save selection failed', e); }
  });

  btnLoad.addEventListener('click', async () => {
    try { await openLoadSelectionModal(section); } catch (e) { console.error('Load selection failed', e); }
  });

  bar.appendChild(btnFocus);
  bar.appendChild(btnSave);
  bar.appendChild(btnLoad);

  // NEW: Resolve button for timesheets selection only
  if (section === 'timesheets') {
    const btnResolve = mkBtn('Resolve selected timesheets (candidate/client mapping)', 'Resolveâ€¦');
    btnResolve.disabled = !hasSelection;

    btnResolve.addEventListener('click', async () => {
      try {
        if (!hasSelection) return;
        if (typeof getSelectedSummaryRows !== 'function') {
          console.warn('getSelectedSummaryRows() is not defined; cannot resolve selection');
          return;
        }
        const rows = getSelectedSummaryRows('timesheets') || [];
        if (!rows.length) return;
        await openTimesheetsResolveModal(rows);
      } catch (e) {
        console.error('Resolve selection failed', e);
      }
    });

    bar.appendChild(btnResolve);
  }

  host.appendChild(bar);
  return bar;
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// NEW: Save the current ticked selection (IDs-only)
// Modes: Save as new, Append to existing (selection kind only)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function openSaveSelectionModal(section) {
  const sanitize = (typeof window !== 'undefined' && typeof window.sanitize === 'function')
    ? window.sanitize
    : (s => String(s ?? '').replace(/&/g,'&amp;').replace(/</g,'&lt;')
                           .replace(/>/g,'&gt;').replace(/"/g,'&quot;')
                           .replace(/'/g,'&#39;'));

  window.__selection = window.__selection || {};
  const curSel = window.__selection[section] || { fingerprint:'', ids:new Set() };
  const idsNow = Array.from(new Set((Array.from(curSel.ids || []).map(String).filter(Boolean)))); // dedupe

  if (!idsNow.length) {
    alert('No records selected to save.');
    return;
  }

  // Load owned selection presets for Append
  const myId = currentUserId();
  const mine = await listReportPresets({ section, kind: 'selection', include_shared: false }).catch(() => []);
  const owned = (mine || []).filter(p => String(p.user_id) === String(myId));
  const optionsHtml = owned.map(p => `<option value="${p.id}">${sanitize(p.name || '(unnamed)')}</option>`).join('');

  const body = html(`
    <div class="form" id="saveSelectionForm" style="max-width:720px">
      <div class="row">
        <label for="selPresetName">Preset name</label>
        <div class="controls">
          <input id="selPresetName" class="input" placeholder="e.g. â€˜Shortlist â€” RMNsâ€™" />
        </div>
      </div>

      <div class="row">
        <label>Mode</label>
        <div class="controls" style="display:flex;flex-direction:column;gap:8px;min-width:0">
          <div style="display:flex;gap:12px;align-items:center;flex-wrap:wrap">
            <label class="inline">
              <input type="radio" name="mode" value="new" checked>
              <span>Save as new selection</span>
            </label>
            <label class="inline">
              <input type="radio" name="mode" value="append" ${owned.length ? '' : 'disabled'}>
              <span>Append to existing selection</span>
            </label>
          </div>
          <div id="selAppendWrap" style="display:none; width:100%; max-width:100%">
            <div class="hint" style="margin:2px 0 4px">
              ${owned.length ? 'Choose selection to append to' : 'You donâ€™t own any selections to append'}
            </div>
            <select id="selAppendPresetId" class="input" style="width:100%; max-width:100%">
              ${optionsHtml}
            </select>
          </div>
        </div>
      </div>

      <div class="row">
        <label for="selPresetShared">Visibility</label>
        <div class="controls">
          <label class="inline">
            <input id="selPresetShared" type="checkbox">
            <span>Visible to all users</span>
          </label>
        </div>
      </div>
    </div>
  `);

  showModal(
    'Save selection',
    [{ key: 'form', label: 'Details' }],
    () => body,
    async () => {
      const name  = String(document.getElementById('selPresetName')?.value || '').trim();
      const share = !!document.getElementById('selPresetShared')?.checked;

      // Re-read & dedupe IDs at submit time
      const ids = Array.from(new Set((Array.from((window.__selection?.[section]?.ids) || []))
        .map(String).filter(Boolean)));

      if (!ids.length) { alert('No records selected.'); return false; }

      const mode = (document.querySelector('#saveSelectionForm input[name="mode"]:checked')?.value || 'new').toLowerCase();
      if (mode === 'append') {
        if (!owned.length) { alert('You donâ€™t own any selections to append.'); return false; }
        const targetId = (document.getElementById('selAppendPresetId')?.value) || '';
        if (!targetId) { alert('Select a selection to append to.'); return false; }

        // Fetch target â†’ dedupe-union â†’ PATCH kind: 'selection'
        const targetList = await listReportPresets({ section, kind: 'selection', include_shared: false }).catch(()=>[]);
        const target = (targetList || []).find(p => String(p.id) === String(targetId));
        const targetIds = Array.isArray(target?.selection_json?.ids) ? target.selection_json.ids.map(String).filter(Boolean) : [];
        const targetSet = new Set(targetIds);

        // Only add what isn't there already
        const toAdd = ids.filter(id => !targetSet.has(id));
        if (toAdd.length === 0) {
          alert('Those records are already in that selection. Nothing to append.');
          return false;
        }

        const merged = Array.from(new Set([...targetIds, ...toAdd]));

        await updateReportPreset({
          id: targetId,
          kind: 'selection',
          selection: { ids: merged }
          // keep name/visibility as-is
        });
      } else {
        if (!name) { alert('Please enter a name'); return false; }
        await createReportPreset({
          section,
          kind: 'selection',
          name,
          is_shared: share,
          filters: {},                         // not used for selections
          selection: { ids }                   // already deduped
        });
      }

      try { invalidatePresetCache(section, 'selection'); } catch {}
      return true;  // â† tells saveForFrame to treat as success and close the modal
    },
    false,
    undefined,
    { noParentGate: true, forceEdit: true, kind: 'selection-save' }
  );

  // Wire append toggling + name field enable/disable
  setTimeout(() => {
    const formEl = document.getElementById('saveSelectionForm');
    if (!formEl || formEl.dataset.wired === '1') return;
    formEl.dataset.wired = '1';

    const appendWrap = document.getElementById('selAppendWrap');
    const nameInput  = document.getElementById('selPresetName');

    const syncModeUI = () => {
      const modeEl = formEl.querySelector('input[name="mode"]:checked');
      const isAppend = !!(modeEl && modeEl.value === 'append');

      if (appendWrap) appendWrap.style.display = isAppend ? 'block' : 'none';

      if (nameInput) {
        nameInput.disabled = isAppend;
        nameInput.readOnly = isAppend;
      }
    };

    formEl.querySelectorAll('input[name="mode"]').forEach(r => {
      r.addEventListener('change', () => {
        syncModeUI();
      });
    });

    // Initialise UI (default is "new" so name should be editable)
    syncModeUI();
  }, 0);
}



async function openLoadSelectionModal(section) {
  const sanitize = (typeof window !== 'undefined' && typeof window.sanitize === 'function')
    ? window.sanitize
    : (s => String(s ?? '').replace(/&/g,'&amp;').replace(/</g,'&lt;')
                           .replace(/>/g,'&gt;').replace(/"/g,'&quot;')
                           .replace(/'/g,'&#39;'));

  let list = await listReportPresets({ section, kind: 'selection', include_shared: true }).catch(()=>[]);
  let selectedId = null;

  const renderList = () => {
    const myId = currentUserId();
    const mine   = (list || []).filter(r => String(r.user_id) === String(myId))
                     .sort((a,b)=>String(a.name||'').localeCompare(String(b.name||''), undefined, {sensitivity:'base'}));
    const shared = (list || []).filter(r => String(r.user_id) !== String(myId))
                     .sort((a,b)=>String(a.name||'').localeCompare(String(b.name||''), undefined, {sensitivity:'base'}));
    const rows = mine.concat(shared);

    const rowsHtml = rows.map(p => {
      const owned    = String(p.user_id) === String(myId);
      const nameHtml = `<span class="name">${sanitize(p.name || '(unnamed)')}</span>`;
      const creator  = (p.user && (p.user.display_name || p.user.email)) ? ` <span class="hint">â€¢ by ${sanitize(p.user.display_name || p.user.email)}</span>` : '';
      const badge    = p.is_shared ? `<span class="badge">shared</span>${creator}` : '';
      const trashBtn = owned ? `<button class="btn mini bin" title="Delete" data-act="delete">ðŸ—‘</button>` : '';
      return `
        <tr data-id="${p.id}">
          <td class="pick">${nameHtml} ${badge}</td>
          <td>${new Date(p.updated_at || p.created_at).toLocaleString()}</td>
          <td class="actions" style="text-align:right">${trashBtn}</td>
        </tr>`;
    }).join('') || `<tr><td colspan="3" class="hint">No saved selections</td></tr>`;

    return html(`
      <div class="form">
        <div class="row" style="justify-content:space-between;align-items:center">
          <strong>Saved selections</strong>
          <span class="hint">Section: <code>${sanitize(section)}</code></span>
        </div>
        <div class="row">
          <table class="grid compact" id="selPresetTable">
            <thead>
              <tr>
                <th>Name</th>
                <th>Updated</th>
                <th style="text-align:right">Delete</th>
              </tr>
            </thead>
            <tbody>${rowsHtml}</tbody>
          </table>
        </div>
      </div>
    `);
  };

  function wireTable() {
    const tbl = document.getElementById('selPresetTable');
    if (!tbl || tbl.__wired) return;
    tbl.__wired = true;

    const frame = window.__getModalFrame?.();
    const updateButtons = () => {
      try {
        const fr = window.__getModalFrame?.();
        if (!fr) return;
        fr.isDirty = !!selectedId; // just to enable Save/Load
        fr._updateButtons?.();
      } catch {}
    };

    // click â†’ select & enable Load
    tbl.addEventListener('click', (e) => {
      const tr = e.target && e.target.closest('tr[data-id]');
      const bin = e.target && e.target.closest('button[data-act="delete"]');
      if (bin) {
        // deletion handled in separate listener below
      }
      if (!tr) return;
      selectedId = tr.getAttribute('data-id');
      Array.from(tbl.querySelectorAll('tbody tr')).forEach(r => r.classList.toggle('selected', r === tr));
      updateButtons();
    });

    // dblclick â†’ apply immediately
    tbl.addEventListener('dblclick', async (e) => {
      const tr = e.target && e.target.closest('tr[data-id]');
      if (!tr) return;
      const id = tr.getAttribute('data-id');
      const chosen = (list || []).find(p => p.id === id);
      if (!chosen) return;

      const ids = Array.isArray(chosen?.selection_json?.ids) ? chosen.selection_json.ids : [];
      await applySelectionAsFilter(section, { ids });
      const closeBtn = document.getElementById('btnCloseModal');
      if (closeBtn) closeBtn.click();
    });

    // delete owned selection
    tbl.addEventListener('click', async (e) => {
      const bin = e.target && e.target.closest('button[data-act="delete"]');
      if (!bin) return;
      const tr = e.target && e.target.closest('tr[data-id]');
      const id = tr && tr.getAttribute('data-id');
      const row = (list || []).find(p => p.id === id);
      if (!row) return;
      const myIdNow = currentUserId();
      if (String(row.user_id) !== String(myIdNow)) return;
      if (!confirm(`Delete saved selection â€œ${row.name || '(unnamed)'}â€?`)) return;

      try { await deleteReportPreset(id); } catch (err) { alert(String(err?.message || err || 'Failed to delete preset')); return; }
      try { invalidatePresetCache(section, 'selection'); } catch {}
      list = await listReportPresets({ section, kind:'selection', include_shared:true }).catch(()=>[]);
      selectedId = null;
      updateButtons();

      const body = document.getElementById('modalBody');
      if (body) {
        const markup = renderList();
        if (typeof markup === 'string') body.innerHTML = markup;
        else if (markup && typeof markup.nodeType === 'number') body.replaceChildren(markup);
        else body.innerHTML = String(markup ?? '');
        wireTable();
      }
    });

    updateButtons();
  }

  showModal(
    'Load selection',
    [{ key: 'list', label: 'Saved' }],
    renderList,
    async () => {
      if (!selectedId) { alert('Pick a selection to load'); return false; }
      const chosen = (list || []).find(p => p.id === selectedId);
      if (!chosen) { alert('Selection not found'); return false; }
      const ids = Array.isArray(chosen?.selection_json?.ids) ? chosen.selection_json.ids : [];
      await applySelectionAsFilter(section, { ids });
      return true;
    },
    false,
    undefined,
    { noParentGate: true, forceEdit: true, kind: 'selection-load' }
  );

  setTimeout(wireTable, 0);
}


// ======================================
// FRONTEND â€” buildSearchQS (UPDATED: support ids[] â†’ id=in.(...))
// ======================================


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// buildSearchQS (amended) â€” map submission_mode â†’ default_submission_mode;
// keep original too for safety; pass has_custom_labels through
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function buildSearchQS(section, filters = {}) {
  window.__listState = window.__listState || {};
  const st = (window.__listState[section] ||= {
    page: 1,
    pageSize: 50,
    total: null,
    hasMore: false,
    filters: null,
    sort: { key: null, dir: 'asc' }
  });

  // Ensure we always have a sort object
  if (!st.sort || typeof st.sort !== 'object') {
    st.sort = { key: null, dir: 'asc' };
  }

  const qs = new URLSearchParams();
  const add = (key, val) => {
    if (val == null || val === '') return;
    qs.append(key, String(val));
  };
  const addArr = (key, arr) => {
    if (!Array.isArray(arr)) return;
    arr.forEach(v => {
      if (v != null && v !== '') qs.append(key, String(v));
    });
  };

  // paging
  if (st.pageSize !== 'ALL') {
    add('page', st.page || 1);
    add('page_size', st.pageSize || 50);
    add('include_count', 'true');
  } else {
    add('page', 1);
    add('include_count', 'true');
  }

  // IDs filter (show only these records)
  if (Array.isArray(filters.ids) && filters.ids.length > 0) {
    qs.append('id', `in.(${filters.ids.map(String).join(',')})`);
  }

  switch (section) {
    case 'candidates': {
      const {
        first_name,
        last_name,
        email,
        phone,
        pay_method,
        roles_any,
        active,
        created_from,
        created_to,

        // extra filters
        primary_job_title_contains,
        job_title_contains,
        prof_reg_number,
        prof_reg_type,
        dob,
        gender,
        town_city,
        postcode,
        updated_from,
        updated_to,
        sort_code,
        account_number,
        umbrella_name,
        tms_ref
      } = filters || {};

      add('first_name', first_name);
      add('last_name', last_name);
      add('email', email);
      add('phone', phone);
      add('pay_method', pay_method); // PAYE / UMBRELLA / BLANK

      // Care Package Roles (rota roles)
      addArr('roles_any', roles_any);

      if (typeof active === 'boolean') add('active', active);

      add('created_from', created_from);
      add('created_to', created_to);

      // Primary vs all job titles
      add('primary_job_title_contains', primary_job_title_contains);
      add('job_title_contains', job_title_contains);

      // Professional registration
      add('prof_reg_number', prof_reg_number);
      add('prof_reg_type', prof_reg_type);

      // DOB exact
      add('dob', dob);

      // Demographics
      add('gender', gender);
      add('town_city', town_city);
      add('postcode', postcode);

      // Updated_at range
      add('updated_from', updated_from);
      add('updated_to', updated_to);

      // Banking / umbrella / ref
      add('sort_code', sort_code);
      add('account_number', account_number);
      add('umbrella_name', umbrella_name);
      add('tms_ref', tms_ref);

      break;
    }

    case 'clients': {
      const {
        name,
        cli_ref,
        primary_invoice_email,
        invoice_address,
        postcode,
        ap_phone,
        vat_chargeable,
        payment_terms_days,
        mileage_charge_rate,
        ts_queries_email,
        created_from,
        created_to,
        updated_from,
        updated_to
      } = filters || {};

      if (name) add('q', name);
      add('cli_ref', cli_ref);
      add('primary_invoice_email', primary_invoice_email);
      add('invoice_address', invoice_address);
      add('postcode', postcode);
      add('ap_phone', ap_phone);
      if (typeof vat_chargeable === 'boolean') add('vat_chargeable', vat_chargeable);
      add('payment_terms_days', payment_terms_days);
      add('mileage_charge_rate', mileage_charge_rate);
      add('ts_queries_email', ts_queries_email);
      add('created_from', created_from);
      add('created_to', created_to);
      add('updated_from', updated_from);
      add('updated_to', updated_to);
      break;
    }

    case 'umbrellas': {
      const {
        name,
        bank_name,
        sort_code,
        account_number,
        vat_chargeable,
        enabled,
        created_from,
        created_to
      } = filters || {};
      if (name) add('q', name);
      add('bank_name', bank_name);
      add('sort_code', sort_code);
      add('account_number', account_number);
      if (typeof vat_chargeable === 'boolean') add('vat_chargeable', vat_chargeable);
      if (typeof enabled === 'boolean') add('enabled', enabled);
      add('created_from', created_from);
      add('created_to', created_to);
      break;
    }

    case 'timesheets': {
      const {
        booking_id,
        occupant_key_norm,
        hospital_norm,
        worked_from,
        worked_to,
        week_ending_from,
        week_ending_to,
        status,
        created_from,
        created_to
      } = filters || {};
      add('booking_id', booking_id);
      add('occupant_key_norm', occupant_key_norm);
      add('hospital_norm', hospital_norm);
      add('worked_from', worked_from);
      add('worked_to', worked_to);
      add('week_ending_from', week_ending_from);
      add('week_ending_to', week_ending_to);
      addArr('status', status);
      add('created_from', created_from);
      add('created_to', created_to);
      break;
    }

    case 'invoices': {
      const {
        invoice_no,
        client_id,
        status,
        issued_from,
        issued_to,
        due_from,
        due_to,
        created_from,
        created_to
      } = filters || {};
      add('invoice_no', invoice_no);
      add('client_id', client_id);
      addArr('status', status);
      add('issued_from', issued_from);
      add('issued_to', issued_to);
      add('due_from', due_from);
      add('due_to', due_to);
      add('created_from', created_from);
      add('created_to', created_to);
      break;
    }

    case 'contracts': {
      const weekdayCodeMap = {
        MON: 1, TUE: 2, WED: 3, THU: 4, FRI: 5, SAT: 6, SUN: 0
      };

      const {
        q: qText,
        candidate_name,
        client_name,
        candidate_id,
        client_id,
        role,
        band,
        pay_method_snapshot,
        submission_mode,
        week_ending_weekday_snapshot,
        require_reference_to_pay,
        require_reference_to_invoice,
        has_custom_labels,
        active_on,
        start_date_from,
        start_date_to,
        end_date_from,
        end_date_to,
        created_from,
        created_to,
        updated_from,
        updated_to,
        auto_invoice,
        mileage_pay_rate,
        mileage_charge_rate,
        status
      } = filters || {};

      add('q', qText);
      add('candidate_name', candidate_name);
      add('client_name', client_name);
      add('candidate_id', candidate_id);
      add('client_id', client_id);
      add('role', role);
      add('band', band);
      add('pay_method_snapshot', pay_method_snapshot);

      if (submission_mode) {
        add('default_submission_mode', submission_mode);
        add('submission_mode', submission_mode);
      }

      if (week_ending_weekday_snapshot) {
        const codeUpper = String(week_ending_weekday_snapshot).toUpperCase();
        const mapped = weekdayCodeMap[codeUpper];
        add('week_ending_weekday_snapshot', mapped != null ? mapped : week_ending_weekday_snapshot);
      }

      if (typeof auto_invoice === 'boolean') add('auto_invoice', auto_invoice);
      if (typeof require_reference_to_pay === 'boolean') {
        add('require_reference_to_pay', require_reference_to_pay);
      }
      if (typeof require_reference_to_invoice === 'boolean') {
        add('require_reference_to_invoice', require_reference_to_invoice);
      }
      if (typeof has_custom_labels === 'boolean') add('has_custom_labels', has_custom_labels);
      add('active_on', active_on);

      // Date ranges
      add('start_date_from', start_date_from);
      add('start_date_to',   start_date_to);
      add('end_date_from',   end_date_from);
      add('end_date_to',     end_date_to);
      add('created_from',    created_from);
      add('created_to',      created_to);
      add('updated_from',    updated_from);
      add('updated_to',      updated_to);

      // Mileage
      add('mileage_pay_rate',    mileage_pay_rate);
      add('mileage_charge_rate', mileage_charge_rate);

      if (status) add('status', status);

      break;
    }
  }

  // Sorting (shared for all sections that support it)
  const sort = st.sort && typeof st.sort === 'object' ? st.sort : null;
  if (sort && sort.key) {
    qs.set('order_by', String(sort.key));
    qs.set('order_dir', sort.dir === 'desc' ? 'desc' : 'asc');
  }

  return qs.toString();
}



// -----------------------------
// NEW: Save search modal (new / overwrite / shared)
// -----------------------------

// === REPLACE: openSaveSearchModal (no currentWorked; built-in sanitize) ===
// === REPLACE: openSaveSearchModal (radio-safe + stable layout + full-width dropdown)
// ======================================
// FRONTEND â€” openSaveSearchModal (UPDATED)
// Behaviour:
// - If there IS a selection: show â€œSave Selectionâ€ UI only (Save new / Append).
// - If there is NO selection: show â€œSave Filtersâ€ UI only.
// ======================================
// Save selection/search modal â€” simplified choices per your spec
async function openSaveSearchModal(section, filters){
  const sanitize = (typeof window !== 'undefined' && typeof window.sanitize === 'function')
    ? window.sanitize
    : (s => String(s ?? '').replace(/&/g,'&amp;').replace(/</g,'&lt;')
                           .replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;'));

  // Selection present?
  window.__selection = window.__selection || {};
  const sel = window.__selection[section];
  const hasSelection = !!sel && sel.ids && sel.ids.size > 0;

  // If weâ€™re going to append, we need the userâ€™s presets list
  const mineServer = await listReportPresets({ section, kind: 'search', include_shared: false }).catch(()=>[]);
  const myId = currentUserId();
  const mine = (mineServer || []).filter(m => String(m.user_id) === String(myId));
  const hasOwned = Array.isArray(mine) && mine.length > 0;
  const optionsHtml = hasOwned
    ? mine.map(m => `<option value="${m.id}">${sanitize(m.name)}</option>`).join('')
    : '';

  let body;
  if (hasSelection) {
    body = html(`
      <div class="form" id="saveSearchForm" style="max-width:720px">
        <div class="row">
          <label for="presetName">Preset name</label>
          <div class="controls">
            <input id="presetName" name="preset_name" class="input" placeholder="e.g. â€˜Shortlist â€” RMNsâ€™" />
          </div>
        </div>

        <div class="row">
          <label>Mode</label>
          <div class="controls" style="display:flex;flex-direction:column;gap:8px;min-width:0">
            <div style="display:flex;gap:12px;align-items:center;flex-wrap:wrap">
              <label class="inline"><input type="radio" name="mode" value="new" checked> <span>Save selection as new</span></label>
              <label class="inline">
                <input type="radio" name="mode" value="append" ${hasOwned ? '' : 'disabled'}>
                <span>Append to existing selection</span>
              </label>
            </div>
            <div id="appendWrap" style="display:none; width:100%; max-width:100%">
              <div class="hint" style="margin:2px 0 4px">${hasOwned ? 'Choose selection to append to' : 'You donâ€™t own any selections to append'}</div>
              <select id="appendPresetId" class="select" style="width:100%; max-width:100%">${optionsHtml}</select>
            </div>
          </div>
        </div>

        <div class="row">
          <label for="presetShared">Visibility</label>
          <div class="controls">
            <label class="inline"><input id="presetShared" type="checkbox"> <span>Visible to all users</span></label>
          </div>
        </div>
      </div>
    `);
  } else {
    body = html(`
      <div class="form" id="saveSearchForm" style="max-width:720px">
        <div class="row">
          <label for="presetName">Preset name</label>
          <div class="controls">
            <input id="presetName" name="preset_name" class="input" placeholder="e.g. â€˜PAYE RMNsâ€™" />
          </div>
        </div>

        <div class="row">
          <label>Visibility</label>
          <div class="controls">
            <label class="inline"><input id="presetShared" type="checkbox"> <span>Visible to all users</span></label>
          </div>
        </div>
      </div>
    `);
  }

  showModal(
    hasSelection ? 'Save selection' : 'Save search',
    [{ key: 'form', label: 'Details' }],
    () => body,
    async () => {
      const name  = String(document.getElementById('presetName')?.value || '').trim();
      const share = !!document.getElementById('presetShared')?.checked;
      if (!name && !hasSelection) { alert('Please enter a name'); return false; }

      // Recompute selection now
      const curSel = window.__selection[section];
      const hasSelectionNow = !!curSel && curSel.ids && curSel.ids.size>0;

      if (hasSelectionNow) {
        const modeInput = document.querySelector('#saveSearchForm input[name="mode"]:checked');
        const mode = (modeInput?.value || 'new').toLowerCase();
        if (mode === 'append') {
          if (!hasOwned) { alert('You donâ€™t own any selections to append'); return false; }
          const targetId = (document.getElementById('appendPresetId')?.value) || '';
          if (!targetId) { alert('Select a selection to append to'); return false; }

          const target = (await listReportPresets({ section, kind:'search', include_shared:false }).catch(()=>[])).find(p => String(p.id) === String(targetId));
          const targetSel = target?.selection || target?.selection_json || null;
          const merged = mergeSelectionSnapshots(section,
            { section, fingerprint: targetSel?.fingerprint || '', ids: Array.from(new Set((targetSel?.ids||[]).map(String))) },
            { section, fingerprint: curSel.fingerprint || '',  ids: Array.from(curSel.ids || []) }
          );
          await updateReportPreset({ id: targetId, name: target?.name, section, kind:'search', selection: merged, is_shared: target?.is_shared });
        } else {
          const payload = {
            section, kind:'search', name, is_shared: share,
            selection: {
              fingerprint: curSel.fingerprint || '',
              ids: Array.from(curSel.ids || [])
            }
          };
          await createReportPreset(payload);
        }
      } else {
        const payload = { section, kind:'search', name, is_shared: share, filters: filters || {} };
        await createReportPreset(payload);
      }

      invalidatePresetCache(section, 'search');
      try { window.dispatchEvent(new Event('search-preset-updated')); } catch(_) {}
      return true;
    },
    false,
    undefined,
    { noParentGate: true, forceEdit: true, kind: hasSelection ? 'selection-save' : 'search-save' }
  );

  // Wire append toggling (only in selection mode)
  if (hasSelection) {
    setTimeout(() => {
      const formEl = document.getElementById('saveSearchForm');
      if (!formEl || formEl.dataset.wired === '1') return;
      formEl.dataset.wired = '1';
      const appendWrap = document.getElementById('appendWrap');
      formEl.querySelectorAll('input[name="mode"]').forEach(r =>
        r.addEventListener('change', () => {
          const isAppend = r.value === 'append' && r.checked;
          if (appendWrap) appendWrap.style.display = isAppend ? 'block' : 'none';
        })
      );
    }, 0);
  }
}

// === REPLACE: openLoadSearchModal (built-in sanitize; no globals required) ===
// FRONTEND â€” UPDATED
// openLoadSearchModal: emit event with filters (so parent re-applies after repaint),
// stage-delete UI kept; shows shared badge and (when present) creator.


// ======================================
// FRONTEND â€” openLoadSearchModal (UPDATED)
// Behaviour: list saved presets; double-click applies immediately & closes.
// - If preset has selection with explicit ids â†’ show only those (applySelectionAsFilter).
// - If selection has allMatching=true â†’ apply its filters instead.
// - If preset is a filters-only search â†’ apply filters.
// ======================================

async function openLoadSearchModal(section){
  const sanitize = (typeof window !== 'undefined' && typeof window.sanitize === 'function')
    ? window.sanitize
    : (s => String(s ?? '').replace(/&/g,'&amp;').replace(/</g,'&lt;')
                           .replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;'));

  // Filters-only presets
  let list = await listReportPresets({ section, kind: 'search', include_shared: true }).catch(()=>[]);
  let selectedId = null;

  function sortMineThenShared(rows, myId) {
    const mine   = (rows || []).filter(r => String(r.user_id) === String(myId))
                     .sort((a,b)=>String(a.name||'').localeCompare(String(b.name||''), undefined, {sensitivity:'base'}));
    const shared = (rows || []).filter(r => String(r.user_id) !== String(myId))
                     .sort((a,b)=>String(a.name||'').localeCompare(String(b.name||''), undefined, {sensitivity:'base'}));
    return mine.concat(shared);
  }

  const renderList = () => {
    const myId = currentUserId();
    const rows = sortMineThenShared(list || [], myId);

    const rowsHtml = rows.map(p => {
      const owned    = String(p.user_id) === String(myId);
      const nameHtml = `<span class="name">${sanitize(p.name)}</span>`;
      const creator  = (p.user && (p.user.display_name || p.user.email)) ? ` <span class="hint">â€¢ by ${sanitize(p.user.display_name || p.user.email)}</span>` : '';
      const badge    = p.is_shared ? `<span class="badge">shared</span>${creator}` : '';
      const trashBtn = owned ? `<button class="bin btn btn-ghost btn-sm" title="Delete">ðŸ—‘</button>` : '';
      return `
        <tr data-id="${p.id}">
          <td class="pick">${nameHtml} ${badge}</td>
          <td>${new Date(p.updated_at || p.created_at).toLocaleString()}</td>
          <td class="actions">${trashBtn}</td>
        </tr>`;
    }).join('') || `<tr><td colspan="3" class="hint">No saved searches</td></tr>`;

    return html(`
      <div class="form">
        <div class="row" style="justify-content:space-between;align-items:center">
          <strong>Saved searches</strong>
          <span class="hint">Section: <code>${sanitize(section)}</code></span>
        </div>
        <div class="row">
          <table class="grid compact" id="presetTable">
            <thead><tr><th>Name</th><th>Updated</th><th></th></tr></thead>
            <tbody>${rowsHtml}</tbody>
          </table>
        </div>
      </div>
    `);
  };

  function wirePresetTable() {
    const tbl = document.getElementById('presetTable');
    if (!tbl || tbl.__wired) return;
    tbl.__wired = true;

    // Select row on click
    tbl.addEventListener('click', (e) => {
      const tr = e.target && e.target.closest('tr[data-id]');
      if (!tr) return;
      selectedId = tr.getAttribute('data-id');
      Array.from(tbl.querySelectorAll('tbody tr')).forEach(r => r.classList.toggle('selected', r === tr));
    });

    // Double-click: apply filters immediately and close + notify parent
    tbl.addEventListener('dblclick', async (e) => {
      const tr = e.target && e.target.closest('tr[data-id]');
      if (!tr) return;
      const id = tr.getAttribute('data-id');
      const chosen = (list || []).find(p => p.id === id);
      if (!chosen) return;

      const filters = chosen.filters || chosen.filters_json || chosen.filtersJson || {};

      window.__listState = window.__listState || {};
      const st = (window.__listState[section] ||= { page:1, pageSize:50, total:null, hasMore:false, filters:null });
      st.page = 1; st.filters = filters || {};
      const rows = await search(section, st.filters);
      renderSummary(rows);

      // notify parent advanced-search to re-populate its form
      try { window.__PENDING_ADV_PRESET = { section, filters: st.filters || {} }; } catch {}

      const closeBtn = document.getElementById('btnCloseModal');
      if (closeBtn) closeBtn.click();
    });

    // Delete handler
    tbl.addEventListener('click', async (e) => {
      const bin = e.target && e.target.closest('button.bin');
      if (!bin) return;
      const tr = e.target && e.target.closest('tr[data-id]');
      const id = tr && tr.getAttribute('data-id');
      const row = (list || []).find(p => p.id === id);
      if (!row) return;
      const myIdNow = currentUserId();
      if (String(row.user_id) !== String(myIdNow)) return;
      if (!confirm(`Delete saved preset â€œ${row.name}â€? This cannot be undone.`)) return;

      try { await deleteReportPreset(id); } catch (err) { alert(String(err?.message || err || 'Failed to delete preset')); return; }
      try { invalidatePresetCache(section, 'search'); } catch {}
      list = await listReportPresets({ section, kind:'search', include_shared:true }).catch(()=>[]);

      const body = document.getElementById('modalBody');
      if (body) {
        const markup = renderList();
        if (typeof markup === 'string') body.innerHTML = markup;
        else if (markup && typeof markup.nodeType === 'number') body.replaceChildren(markup);
        else body.innerHTML = String(markup ?? '');
        wirePresetTable();
      }
    });
  }

  showModal(
    'Load saved search',
    [{ key: 'list', label: 'Saved' }],
    renderList,
    async () => {
      if (!selectedId) { alert('Pick a preset to load'); return false; }
      const chosen = (list || []).find(p => p.id === selectedId);
      if (!chosen) { alert('Preset not found'); return false; }

      const filters = chosen.filters || chosen.filters_json || chosen.filtersJson || {};
      window.__listState = window.__listState || {};
      const st = (window.__listState[section] ||= { page:1, pageSize:50, total:null, hasMore:false, filters:null });
      st.page = 1; st.filters = filters || {};
      const rows = await search(section, st.filters);
      renderSummary(rows);

      // notify parent advanced-search to re-populate its form
      try { window.__PENDING_ADV_PRESET = { section, filters: st.filters || {} }; } catch {}
      return true; // child closes; parent will onReturn and re-populate form
    },
    false,
    undefined,
    { noParentGate: true, forceEdit: true, kind: 'search-load' }
  );

  setTimeout(wirePresetTable, 0);
}



// ============================================================================
// Selection presets â€” wrappers to save/list/load selection presets via backend
// ============================================================================

/**
 * Save a selection preset.
 * By default uses kind: 'selection' to keep it distinct from pure filter presets,
 * but your backend can also store it under kind: 'search' with a `selection` block.
 */

/** List selection presets for a section (owned + shared if requested). */
async function listSelectionPresets(section, { include_shared = true } = {}) {
  if (typeof listReportPresets === 'function') {
    return await listReportPresets({ section, kind: 'selection', include_shared });
  }
  // Fallback, if needed:
  const qs = new URLSearchParams({ section, kind: 'selection', include_shared: include_shared ? 'true' : 'false' });
  const res = await authFetch(API(`/api/report-presets?${qs}`));
  return res?.ok ? res.json().catch(()=>[]) : [];
}

/**
 * Load a selection preset by ID or name. Returns the preset object (or null).
 * Note: this does not apply it â€” use applySelectionSnapshot() or mergeSelectionSnapshots().
 */
async function loadSelectionPreset(section, idOrName) {
  const all = await listSelectionPresets(section, { include_shared: true }) || [];
  if (!idOrName) return null;
  const match = all.find(p => String(p.id) === String(idOrName)) ||
                all.find(p => String(p.name || '').toLowerCase() === String(idOrName).toLowerCase());
  return match || null;
}
















// -----------------------------
// UPDATED: openSearchModal()
// - Fix search submit path (object filters, not JSON string)
// - Provide inline Save/Load buttons that open child modals
// -----------------------------
// -----------------------------
// FIXED: openSearchModal()
// - No undefined variables
// - Uses attachUkDatePicker + extractFiltersFromForm
// - Section-aware fields that match buildSearchQS()
// -----------------------------
// === REPLACE: openSearchModal (icons + robust wiring + fallback for old text buttons) ===
// === FORCE-HIDE legacy buttons (one-time CSS) ===
// Run once: force-hide any legacy white buttons, and add compact button styles
(function ensureAdvancedSearchCSS(){
  if (document.getElementById('advSearchCSS')) return;
  const s = document.createElement('style');
  s.id = 'advSearchCSS';
  s.textContent = `
    /* never show legacy white buttons */
    #btnLoadSavedSearch, #btnSaveSearch { display: none !important; visibility: hidden !important; }

    /* compact, not-white text buttons */
    .adv-btn {
      height: 26px;
      padding: 0 10px;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      background: #f3f4f6;          /* not white */
      color: #111827;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
    }
    .adv-btn:hover { background: #e5e7eb; }
  `;
  document.head.appendChild(s);
})();

async function openSearchModal(opts = {}) {
  const TIMESHEET_STATUS = ['ERROR','RECEIVED','REVOKED','STORED','SAT','SUN','BH'];
  const INVOICE_STATUS   = ['DRAFT','ISSUED','ON_HOLD','PAID'];

  const row = (label, inner) => `
    <div class="row">
      <label>${label}</label>
      <div class="controls">${inner}</div>
    </div>`;

  const inputText = (name, placeholder='') =>
    `<input class="input" type="text" name="${name}" placeholder="${placeholder}" />`;

  const boolSelect = (name) => `
    <select name="${name}">
      <option value="">Any</option>
      <option value="true">Yes</option>
      <option value="false">No</option>
    </select>`;

  const datePair = (fromName, fromLabel, toName, toLabel) => `
    ${row(fromLabel, `<input class="input" type="text" name="${fromName}" placeholder="DD/MM/YYYY" />`)}
    ${row(toLabel,   `<input class="input" type="text" name="${toName}"   placeholder="DD/MM/YYYY" />`)}`;

  // Inline date range (From / To on one row)
  const dateRangeRow = (fromName, toName, label) => row(label, `
    <div class="split">
      <input class="input" type="text" name="${fromName}" placeholder="From DD/MM/YYYY" />
      <input class="input" type="text" name="${toName}"   placeholder="To DD/MM/YYYY" />
    </div>`);

  const multi = (name, values) =>
    `<select name="${name}" multiple size="6">${values.map(v=>`<option value="${v}">${v}</option>`).join('')}</select>`;

  const friendly = (section, key, fallback) => {
    try {
      if (typeof getFriendlyHeaderLabel === 'function') {
        const lbl = getFriendlyHeaderLabel(section, key);
        if (lbl && typeof lbl === 'string') return lbl;
      }
    } catch {}
    return fallback || key;
  };

  // Section-specific filters
  let inner = '';
  if (currentSection === 'candidates') {
    let roleOptions = [];
    try { roleOptions = await loadGlobalRoleOptions(); } catch { roleOptions = []; }

    inner = [
      // Basic identity / contact
      row('First name',           inputText('first_name')),
      row('Last name',            inputText('last_name')),
      row('Email',                `<input class="input" type="email" name="email" placeholder="name@domain" />`),
      row('Telephone',            inputText('phone')),

      // Pay type (including blank)
      row('Pay type', `
        <select name="pay_method">
          <option value="">Any</option>
          <option value="PAYE">PAYE</option>
          <option value="UMBRELLA">UMBRELLA</option>
          <option value="BLANK">Blank</option>
        </select>`),

      // Care Package Role (rota roles)
      row('Care Package Role (any)', `
        <select name="roles_any" multiple size="6">
          ${roleOptions.map(r => `<option value="${r}">${r}</option>`).join('')}
        </select>`),

      // Job titles
      row('Primary Job Title contains', inputText('primary_job_title_contains', 'e.g. CPN')),
      row('Any Job Title contains',     inputText('job_title_contains', 'includes primary and secondary')),

      // Professional registration
      row('Professional Reg Number', inputText('prof_reg_number')),
      row('Professional Reg Type', `
        <select name="prof_reg_type">
          <option value="">Any</option>
          <option value="NMC">NMC</option>
          <option value="GMC">GMC</option>
          <option value="HCPC">HCPC</option>
        </select>`),

      // DOB exact
      row('Date of birth', `<input class="input" type="text" name="dob" placeholder="DD/MM/YYYY" />`),

      // Gender / location
      row('Gender', `
        <select name="gender">
          <option value="">Any</option>
          <option value="Male">Male</option>
          <option value="Female">Female</option>
          <option value="Other">Other</option>
        </select>`),
      row('City',     inputText('town_city', 'Town / City')),
      row('Postcode', inputText('postcode', 'e.g. W7 3EE')),

      // Status + created range (inline)
      row('Active', boolSelect('active')),
      dateRangeRow('created_from','created_to','Created date (from / to)'),

      // Last updated range (inline)
      dateRangeRow('updated_from','updated_to','Last updated (from / to)'),

      // Banking / umbrella / ref
      row('Sort Code',       inputText('sort_code', '12-34-56')),
      row('Account Number',  inputText('account_number')),
      row('Umbrella Name',   inputText('umbrella_name')),
      row('TMS Ref',         inputText('tms_ref'))
    ].join('');
  } else if (currentSection === 'clients') {
    const lblName     = friendly('clients','name','Client name');
    const lblCliRef   = friendly('clients','cli_ref','Client ref');
    const lblEmail    = friendly('clients','primary_invoice_email','Invoice email');
    const lblInvAddr  = friendly('clients','invoice_address','Invoice address');
    const lblPost     = friendly('clients','postcode','Postcode');
    const lblApPhone  = friendly('clients','ap_phone','A/P phone');

    inner = [
      row(lblName,          inputText('name', 'partial match')),
      row(lblCliRef,        inputText('cli_ref')),
      row(lblEmail,         `<input class="input" type="email" name="primary_invoice_email" placeholder="ap@client" />`),
      row(lblInvAddr,       inputText('invoice_address')),
      row(lblPost,          inputText('postcode')),
      row(lblApPhone,       inputText('ap_phone')),
      row('VAT chargeable (Yes/No)', boolSelect('vat_chargeable')),
      row('Payment terms (days)', `<input class="input" type="number" name="payment_terms_days" min="0" />`),
      row('Mileage charge rate',  `<input class="input" type="number" step="0.01" name="mileage_charge_rate" />`),
      row('Timesheet queries email', `<input class="input" type="email" name="ts_queries_email" placeholder="ts@client" />`),
      dateRangeRow('created_from','created_to','Created date (from / to)'),
      dateRangeRow('updated_from','updated_to','Last updated (from / to)')
    ].join('');
  } else if (currentSection === 'umbrellas') {
    inner = [
      row('Name',                 inputText('name')),
      row('Bank',                 inputText('bank_name')),
      row('Sort code',            inputText('sort_code', '12-34-56')),
      row('Account number',       inputText('account_number')),
      row('VAT chargeable',       boolSelect('vat_chargeable')),
      row('Enabled',              boolSelect('enabled')),
      datePair('created_from','Created from','created_to','Created to')
    ].join('');
  } else if (currentSection === 'timesheets') {
    inner = [
      row('Booking ID',           inputText('booking_id')),
      row('Candidate key',        inputText('occupant_key_norm', 'candidate_id / key_norm')),
      row('Hospital',             inputText('hospital_norm')),
      datePair('worked_from','Worked from (date)','worked_to','Worked to (date)'),
      datePair('week_ending_from','Week ending from','week_ending_to','Week ending to'),
      row('Status',               multi('status', TIMESHEET_STATUS)),
      datePair('created_from','Created from','created_to','Created to')
    ].join('');
  } else if (currentSection === 'invoices') {
    inner = [
      row('Invoice no',           inputText('invoice_no')),
      row('Client ID',            inputText('client_id', 'UUID')),
      row('Status',               multi('status', INVOICE_STATUS)),
      datePair('issued_from','Issued from','issued_to','Issued to'),
      datePair('due_from','Due from','due_to','Due to'),
      datePair('created_from','Created from','created_to','Created to')
    ].join('');
  } else if (currentSection === 'contracts') {
    const weekdayOptions = [
      { value: '',    label: 'Any'    },
      { value: 'MON', label: 'Monday' },
      { value: 'TUE', label: 'Tuesday' },
      { value: 'WED', label: 'Wednesday' },
      { value: 'THU', label: 'Thursday' },
      { value: 'FRI', label: 'Friday' },
      { value: 'SAT', label: 'Saturday' },
      { value: 'SUN', label: 'Sunday' }
    ];

    const lblCandName  = friendly('contracts','candidate_display','Candidate name');
    const lblClient    = friendly('contracts','client_name','Client name');
    const lblBand      = friendly('contracts','band','Band');
    const lblRole      = friendly('contracts','role','Role');
    const lblPaySnap   = friendly('contracts','pay_method_snapshot','Pay method snapshot');
    const lblSubMode   = friendly('contracts','default_submission_mode','Submission mode');

    inner = [
      row('Free text',            inputText('q', 'client / candidate / role')),

      // Explicit name filters
      row(`${lblCandName} contains`, inputText('candidate_name', 'partial name match')),
      row(`${lblClient} contains`,   inputText('client_name', 'partial name match')),

      row('Candidate ID',         inputText('candidate_id', 'UUID')),
      row('Client ID',            inputText('client_id', 'UUID')),
      row(lblRole,                inputText('role', 'e.g. RMN')),
      row(lblBand,                inputText('band', 'e.g. 5 / 6 / 7')),
      row(lblPaySnap,  `
        <select name="pay_method_snapshot">
          <option value="">Any</option>
          <option value="PAYE">PAYE</option>
          <option value="UMBRELLA">UMBRELLA</option>
        </select>`),
      row(lblSubMode,      `
        <select name="submission_mode">
          <option value="">Any</option>
          <option value="MANUAL">Manual</option>
          <option value="ELECTRONIC">Electronic</option>
        </select>`),

      row('Start date (from / to)',
        `<div class="split">
           <input class="input" type="text" name="start_date_from" placeholder="From DD/MM/YYYY" />
           <input class="input" type="text" name="start_date_to"   placeholder="To DD/MM/YYYY" />
         </div>`),

      row('End date (from / to)',
        `<div class="split">
           <input class="input" type="text" name="end_date_from" placeholder="From DD/MM/YYYY" />
           <input class="input" type="text" name="end_date_to"   placeholder="To DD/MM/YYYY" />
         </div>`),

      row('Week-ending weekday',  `
        <select name="week_ending_weekday_snapshot">
          ${weekdayOptions.map(o=>`<option value="${o.value}">${o.label}</option>`).join('')}
        </select>`),

      row('Auto invoice',           boolSelect('auto_invoice')),
      row('Require ref to pay',     boolSelect('require_reference_to_pay')),
      row('Require ref to invoice', boolSelect('require_reference_to_invoice')),
      row('Has custom labels',      boolSelect('has_custom_labels')),
      row('Active on date',         `<input class="input" type="text" name="active_on" placeholder="DD/MM/YYYY" />`),

      dateRangeRow('created_from','created_to','Created date (from / to)'),
      dateRangeRow('updated_from','updated_to','Last updated (from / to)'),

      row('Mileage pay rate',    `<input class="input" type="number" step="0.01" name="mileage_pay_rate" />`),
      row('Mileage charge rate', `<input class="input" type="number" step="0.01" name="mileage_charge_rate" />`)
    ].join('');
  } else {
    inner = `<div class="tabc">No filters for this section.</div>`;
  }

  // Header: two small dark buttons, side by side, using .adv-btn styling
  const headerHtml = `
    <div class="row" id="searchHeaderRow" style="justify-content:flex-end;gap:6px;margin-bottom:.5rem">
      <div class="controls" style="display:flex;justify-content:flex-end;gap:6px">
        <button type="button" class="adv-btn" data-adv-act="load">Load saved search</button>
        <button type="button" class="adv-btn" data-adv-act="save">Save search</button>
      </div>
    </div>`;

  const formHtml = `
    <div class="form" id="searchForm">
      ${headerHtml}
      ${inner}
    </div>
  `;

  showModal(
    'Advanced Search',
    [{ key: 'filter', title: 'Filters' }],
    () => formHtml,
    async () => {
      window.__listState = window.__listState || {};
      const st = (window.__listState[currentSection] ||= {
        page: 1,
        pageSize: 50,
        total: null,
        hasMore: false,
        filters: null
      });
      st.page = 1;

      // Reset selection for the new dataset (IDs-only)
      window.__selection = window.__selection || {};
      const sel = (window.__selection[currentSection] ||= { fingerprint:'', ids:new Set() });
      const filters = extractFiltersFromForm('#searchForm');
      sel.fingerprint = JSON.stringify({ section: currentSection, filters });
      sel.ids.clear();

      const rows = await search(currentSection, filters);
      if (rows) renderSummary(rows);
      return true; // saveForFrame will close this advanced-search frame on success
    },
    false,
    () => {
      // Apply pending preset (if a child "Load search" just set it)
      const pending = (typeof window !== 'undefined') ? window.__PENDING_ADV_PRESET : null;
      if (pending && pending.section) {
        try {
          window.dispatchEvent(new CustomEvent('adv-search-apply-preset', { detail: pending }));
        } catch {}
      }
      if (typeof window !== 'undefined') delete window.__PENDING_ADV_PRESET;

      try { wireAdvancedSearch(); } catch {}

      // Prefill from current filters immediately on mount
      try {
        window.__listState = window.__listState || {};
        const st = (window.__listState[currentSection] ||= {
          page:1,
          pageSize:50,
          total:null,
          hasMore:false,
          filters:null
        });
        populateSearchFormFromFilters(st.filters || {}, '#searchForm');
      } catch {}

      // Wire datepickers to *all* DD/MM/YYYY fields (including From/To ranges)
      try {
        if (typeof attachUkDatePicker === 'function') {
          const root = document.getElementById('searchForm');
          if (root) {
            root.querySelectorAll('input[type="text"]').forEach(el => {
              const ph = (el.getAttribute('placeholder') || '').toUpperCase();
              if (ph.includes('DD/MM/YYYY')) {
                // Avoid double-wiring, in case modal is reopened
                if (!el.__ukPickerWired) {
                  attachUkDatePicker(el);
                  el.__ukPickerWired = true;
                }
              }
            });
          }
        }
      } catch {}
    },
    { noParentGate: true, forceEdit: true, kind: 'advanced-search' }
  );

  // Extra wiring (eg. load/save presets actions)
  setTimeout(wireAdvancedSearch, 0);
}



// === REPLACE: openSearchModal (icons only, legacy forced hidden, robust wiring) ===
// === REPLACE: openSearchModal (compact text buttons + robust delegated wiring) ===
// FRONTEND â€” UPDATED
// openSearchModal: compact text buttons + delegated wiring + listens for preset-apply event
// and re-applies filters AFTER parent repaint (onReturn hook).
// ======================================
// FRONTEND â€” openSearchModal (UPDATED)
// Branches: if there's a selection in the summary â†’ go straight to Save Selection.
// Otherwise, open the Advanced Search (filters) modal as usual.
// ======================================


// ======================================
// FRONTEND â€” wireAdvancedSearch (UPDATED only to call the updated save/load modals)
// ======================================


function wireAdvancedSearch() {
  const bodyEl = document.getElementById('modalBody');
  const formEl = document.getElementById('searchForm');
  if (!bodyEl || !formEl) return;

  formEl.querySelectorAll('input[placeholder="DD/MM/YYYY"]').forEach(el => {
    try { attachUkDatePicker(el); } catch {}
  });

  // hide any legacy buttons
  formEl.querySelectorAll('#btnLoadSavedSearch,#btnSaveSearch').forEach(el => {
    el.style.display = 'none'; el.hidden = true; el.disabled = true;
  });

  // delegated click (survives re-renders)
  if (bodyEl._advSearchHandler) bodyEl.removeEventListener('click', bodyEl._advSearchHandler, true);
  bodyEl._advSearchHandler = async (e) => {
    const btn = e.target && e.target.closest('button[data-adv-act]');
    if (!btn) return;
    const act = btn.dataset.advAct;
    if (act === 'load') {
      await openLoadSearchModal(currentSection);
    } else if (act === 'save') {
      // â†³ Recompute filters at click time so we pass the *current* criteria
      const filters = extractFiltersFromForm('#searchForm');
      await openSaveSearchModal(currentSection, filters);
    }
  };
  bodyEl.addEventListener('click', bodyEl._advSearchHandler, true);

  // listen once for preset apply events (filters only â€” selection is handled in the load modal)
  if (!window.__advPresetListener) {
    window.__advPresetListener = (ev) => {
      const det = ev && ev.detail;
      const here = String(currentSection || '').toLowerCase();
      const inc  = String(det && det.section || '').toLowerCase();
      if (!det || !inc || inc !== here) return;
      try { window.__squelchDirty = true; } catch {}
      try { populateSearchFormFromFilters(det.filters || {}, '#searchForm'); }
      finally {
        setTimeout(() => { try { window.__squelchDirty = false; } catch {} }, 0);
      }
    };
    window.addEventListener('adv-search-apply-preset', window.__advPresetListener);
  }

  // NEW: Immediately populate from current filters when the modal mounts/re-renders
  try {
    window.__listState = window.__listState || {};
    const st = (window.__listState[currentSection] ||= { page:1, pageSize:50, total:null, hasMore:false, filters:null });
    populateSearchFormFromFilters(st.filters || {}, '#searchForm');
  } catch {}
}

// -----------------------------
// UPDATED: renderTools()
// - Keep Searchâ€¦, add â€œSaved searchesâ€¦â€ shortcut that opens Search modal pre-focused on loading presets
// -----------------------------


function renderTools(){
  const el = byId('toolButtons');
  const canCreate = ['candidates','clients','umbrellas','contracts'].includes(currentSection); // added contracts

  el.innerHTML = '';
  const addBtn = (txt, cb) => {
    const b = document.createElement('button');
    b.textContent = txt;
    b.onclick = cb;
    el.appendChild(b);
    return b;
  };

  const btnCreate = addBtn('Create New Record', () => openCreate());
  addBtn('Show all records', () => showAllRecords(currentSection));
  addBtn('Searchâ€¦', () => openSearchModal()); // left toolbar search

  if (!canCreate) btnCreate.disabled = true;

  // â”€â”€ Timesheet filters box (only when in Timesheets summary) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (currentSection === 'timesheets') {
    window.__listState = window.__listState || {};
    const st = (window.__listState['timesheets'] ||= {
      page: 1,
      pageSize: 50,
      total: null,
      hasMore: false,
      filters: {},
      sort: { key: null, dir: 'asc' }
    });
    const filters = st.filters || {};
    window.__listState['timesheets'].filters = filters;

    const box = document.createElement('div');
    box.style.cssText = 'margin-top:10px;padding:8px;border:1px solid var(--line);border-radius:6px;background:#0b152a;';
    const title = document.createElement('div');
    title.textContent = 'Timesheet Filters';
    title.className = 'mini';
    title.style.fontWeight = 'bold';
    title.style.marginBottom = '4px';
    box.appendChild(title);

    const mkToolFlag = (name, label) => {
      const wrap = document.createElement('label');
      wrap.className = 'mini';
      wrap.style.display = 'flex';
      wrap.style.alignItems = 'center';
      wrap.style.gap = '4px';
      wrap.style.marginTop = '4px';
      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.checked = !!filters[name];
      cb.addEventListener('change', async () => {
        const curFilters = { ...(window.__listState['timesheets'].filters || {}) };
        curFilters[name] = cb.checked ? true : false;
        window.__listState['timesheets'].filters = curFilters;
        window.__listState['timesheets'].page = 1;
        const data = await loadSection();
        renderSummary(data);
      });
      wrap.appendChild(cb);
      wrap.appendChild(document.createTextNode(label));
      return wrap;
    };

    // Candidate Paid  â†’ candidate_paid = true â†’ backend: paid_at_utc NOT NULL
    box.appendChild(mkToolFlag('candidate_paid', 'Candidate paid'));

    // Client Invoiced â†’ client_invoiced = true â†’ backend: locked_by_invoice_id NOT NULL
    box.appendChild(mkToolFlag('client_invoiced', 'Client invoiced'));

    // Needs Attention â†’ needs_attention = true â†’ backend: needs_attention = true
    box.appendChild(mkToolFlag('needs_attention', 'Needs attention'));

    // â”€â”€ Stage selector (All / Unprocessed / Processed / Authorised) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const stageWrap = document.createElement('div');
    stageWrap.style.marginTop = '8px';
    stageWrap.className = 'mini';
    const stageLabel = document.createElement('div');
    stageLabel.textContent = 'Stage:';
    stageLabel.style.marginBottom = '2px';
    const stageSel = document.createElement('select');
    stageSel.style.width = '100%';

    const stageOpts = [
      ['ALL',         'All'],
      ['UNPROCESSED', 'Unprocessed'],
      ['PROCESSED',   'Processed'],
      ['AUTHORISED',  'Authorised']
    ];
    const curStage = (filters.ts_stage || 'ALL').toUpperCase();
    stageOpts.forEach(([v, label]) => {
      const o = document.createElement('option');
      o.value = v;
      o.textContent = label;
      if (curStage === v) o.selected = true;
      stageSel.appendChild(o);
    });

    stageSel.addEventListener('change', async () => {
      const val = stageSel.value;
      const curFilters = { ...(window.__listState['timesheets'].filters || {}) };
      curFilters.ts_stage = val; // All/UNPROCESSED/PROCESSED/AUTHORISED
      window.__listState['timesheets'].filters = curFilters;
      window.__listState['timesheets'].page = 1;
      const data = await loadSection();
      renderSummary(data);
    });

    stageWrap.appendChild(stageLabel);
    stageWrap.appendChild(stageSel);
    box.appendChild(stageWrap);

    el.appendChild(box);
  }
}


async function showAllRecords(section = currentSection){
  // Reset paging & clear all filters
  window.__listState = window.__listState || {};
  const st = (window.__listState[section] ||= {
    page: 1, pageSize: 50, total: null, hasMore: false, filters: null,
  });
  st.page = 1;
  st.filters = null;

  // Forget any focused shortlist (IDs selection)
  const sel = ensureSelection(section);
  sel.ids.clear();
  sel.fingerprint = ''; // optional: allow renderSummary to recompute

  // Reload full list for the section and render
  const rows = await loadSection();
  renderSummary(rows);
}
// Optional alias if other code calls clearFilters()
function clearFilters(section = currentSection){
  return showAllRecords(section);
}


// ===================== NEW HELPERS (UI + data) =====================

// Cache for global roles
// Cache for global roles
let __GLOBAL_ROLE_CODES_CACHE__ = null;
let __GLOBAL_ROLE_CODES_CACHE_TS__ = 0;
function invalidateGlobalRoleOptionsCache(){
  __GLOBAL_ROLE_CODES_CACHE__ = null;
  __GLOBAL_ROLE_CODES_CACHE_TS__ = 0;
}

// Load and dedupe all role codes from client defaults across all clients
// ðŸ”§ CHANGE: truly global roles list (de-duplicated across ALL clients), with a short TTL cache.
// Works even when there is no active client in context (e.g., Candidate create).
async function loadGlobalRoleOptions(){
  const now = Date.now();
  const TTL_MS = 60_000;

  // Prefer our global cache
  if (Array.isArray(window.__GLOBAL_ROLE_CODES_ALL__) &&
      (now - (window.__GLOBAL_ROLE_CODES_ALL_TS__ || 0) < TTL_MS)) {
    return window.__GLOBAL_ROLE_CODES_ALL__;
  }

  // Fallback to legacy '__fallback__' if itâ€™s fresh
  if (window.__GLOBAL_ROLE_CODES_CACHE__ &&
      window.__GLOBAL_ROLE_CODES_CACHE__['__fallback__'] &&
      (now - (window.__GLOBAL_ROLE_CODES_CACHE_TS__?.['__fallback__'] || 0) < TTL_MS)) {
    const arr = window.__GLOBAL_ROLE_CODES_CACHE__['__fallback__'];
    window.__GLOBAL_ROLE_CODES_ALL__ = arr.slice();
    window.__GLOBAL_ROLE_CODES_ALL_TS__ = now;
    return arr;
  }

  // Aggregate roles across all clients (enabled client-default windows only)
  const roles = new Set();
  try {
    const clients = await listClientsBasic();
    for (const c of (clients || [])) {
      try {
        const rows = await listClientRates(c.id, { only_enabled: true });
        for (const r of (rows || [])) {
          if (r && r.role) roles.add(String(r.role));
        }
      } catch { /* ignore per-client errors */ }
    }
  } catch { /* ignore listClientsBasic error */ }

  const arr = [...roles].sort((a,b)=> a.localeCompare(b));

  // Save to both the new global cache AND the legacy fallback keys so existing invalidation hooks still help
  window.__GLOBAL_ROLE_CODES_ALL__ = arr;
  window.__GLOBAL_ROLE_CODES_ALL_TS__ = now;

  window.__GLOBAL_ROLE_CODES_CACHE__    = window.__GLOBAL_ROLE_CODES_CACHE__    || Object.create(null);
  window.__GLOBAL_ROLE_CODES_CACHE_TS__ = window.__GLOBAL_ROLE_CODES_CACHE_TS__ || Object.create(null);
  window.__GLOBAL_ROLE_CODES_CACHE__['__fallback__']    = arr;
  window.__GLOBAL_ROLE_CODES_CACHE_TS__['__fallback__'] = now;

  return arr;
}


// Render roles editor into a container; updates modalCtx.rolesState
function renderRolesEditor(container, rolesState, allRoleOptions){
  // Detect read-only (view mode) from the active modal frame
  const fr = (window.__modalStack || [])[ (window.__modalStack || []).length - 1 ] || null;
  // âœ… Treat 'create' same as 'edit' (editable)
  const readOnly = !fr || !(fr.mode === 'edit' || fr.mode === 'create');

  // Local, mutable copy of available options so we can refresh after adds/removes
  let roleOptions = Array.isArray(allRoleOptions) ? allRoleOptions.slice() : [];

  function markDirty() {
    try {
      const stack = window.__modalStack || [];
      const top = stack[stack.length - 1];
      if (top) top.isDirty = true;
      try { window.dispatchEvent(new CustomEvent('modal-dirty')); }
      catch { try { window.dispatchEvent(new Event('modal-dirty')); } catch(_) {} }
    } catch (_) {}
  }

  container.innerHTML = `
    <div class="roles-editor">
      <div class="roles-add" ${readOnly ? 'style="display:none"' : ''}>
        <select id="rolesAddSelect">
          <option value="">Add roleâ€¦</option>
          ${roleOptions.map(code => `<option value="${code}">${code}</option>`).join('')}
        </select>
        <button id="rolesAddBtn" type="button">Add</button>
      </div>
      <ul id="rolesList" class="roles-list"></ul>
    </div>
  `;

  const sel = container.querySelector('#rolesAddSelect');
  const btn = container.querySelector('#rolesAddBtn');
  const ul  = container.querySelector('#rolesList');

  const byCode = (code) => (rolesState || []).find(r => String(r.code) === String(code));

  function availableOptions(){
    const picked = new Set((rolesState||[]).map(x => x.code));
    return roleOptions.filter(code => !picked.has(code));
  }

  function refreshAddSelect(){
    if (!sel) return;
    const opts = ['<option value="">Add roleâ€¦</option>']
      .concat(availableOptions().map(code => `<option value="${code}">${code}</option>`))
      .join('');
    sel.innerHTML = opts;
  }

  function renderList(){
    ul.innerHTML = '';
    const arr = (rolesState||[]).slice().sort((a,b)=> (a.rank||0) - (b.rank||0));

    arr.forEach((item, idx) => {
      const li = document.createElement('li');
      li.className = 'role-item';
      li.draggable = !readOnly;
      li.dataset.index = String(idx);

      li.innerHTML = `
        <span class="drag" title="Drag to reorder" style="cursor:${readOnly?'default':'grab'}">â‹®â‹®</span>
        <span class="rank">${idx+1}.</span>
        <span class="code">${item.code}</span>
        <input class="label" type="text" placeholder="Optional labelâ€¦" value="${item.label || ''}" ${readOnly?'disabled':''}/>
        <button class="remove" type="button" title="Remove" ${readOnly?'disabled style="display:none"':''}>âœ•</button>
      `;

      if (!readOnly) {
        li.querySelector('.remove').onclick = () => {
          rolesState = (rolesState || []).filter(r => r.code !== item.code);
          rolesState.forEach((r,i)=> r.rank = i+1);
          rolesState = normaliseRolesForSave(rolesState);
          window.modalCtx.rolesState = rolesState;
          markDirty();
          renderList(); refreshAddSelect();
        };

        li.querySelector('.label').oninput = (e) => {
          const rec = byCode(item.code);
          if (rec) rec.label = e.target.value;
          window.modalCtx.rolesState = rolesState;
          // dirty state handled by global tracker
        };

        // Drag payload
        li.addEventListener('dragstart', (e) => {
          const from = li.dataset.index || String(idx);
          try { e.dataTransfer.setData('text/x-role-index', from); } catch {}
          try { e.dataTransfer.setData('text/plain', from); } catch {}
          if (e.dataTransfer) e.dataTransfer.effectAllowed = 'move';
          li.classList.add('dragging');
        });
        li.addEventListener('dragend', () => {
          li.classList.remove('dragging');
          ul.querySelectorAll('.over').forEach(n => n.classList.remove('over'));
        });
      }

      ul.appendChild(li);
    });
  }

  // Delegate DnD only when editable
  if (!readOnly) {
    ul.addEventListener('dragover', (e) => {
      e.preventDefault();
      const overLi = e.target && e.target.closest('li.role-item');
      ul.querySelectorAll('.over').forEach(n => n.classList.remove('over'));
      if (overLi) overLi.classList.add('over');
      if (e.dataTransfer) e.dataTransfer.dropEffect = 'move';
    });

    ul.addEventListener('drop', (e) => {
      e.preventDefault();
      const toLi = e.target && e.target.closest('li.role-item');
      if (!toLi) return;

      let from = NaN;
      try { from = parseInt(e.dataTransfer.getData('text/x-role-index'), 10); } catch {}
      if (isNaN(from)) {
        try { from = parseInt(e.dataTransfer.getData('text/plain'), 10); } catch {}
      }
      const to = parseInt(toLi.dataset.index, 10);
      if (!Number.isInteger(from) || !Number.isInteger(to) || from === to) return;

      // Reorder against current rank-sorted view
      const view = (rolesState||[]).slice().sort((a,b)=> (a.rank||0) - (b.rank||0));
      const [moved] = view.splice(from, 1);
      view.splice(to, 0, moved);

      view.forEach((r,i)=> r.rank = i+1);
      rolesState = normaliseRolesForSave(view);
      window.modalCtx.rolesState = rolesState;

      markDirty();
      renderList();
      refreshAddSelect();
    });
  }

  // Add role (only in edit/create)
  if (!readOnly && btn) {
    btn.onclick = () => {
      const code = sel.value;
      if (!code) return;
      if ((rolesState||[]).some(r => r.code === code)) return; // no duplicates
      const nextRank = ((rolesState||[]).length || 0) + 1;
      rolesState = [...(rolesState||[]), { code, rank: nextRank }];
      rolesState = normaliseRolesForSave(rolesState);
      window.modalCtx.rolesState = rolesState;
      markDirty();
      renderList(); refreshAddSelect();
    };
  }

  // Expose a tiny API for refreshing options live
  container.__rolesEditor = {
    updateOptions(newOptions){
      roleOptions = Array.isArray(newOptions) ? newOptions.slice() : [];
      refreshAddSelect();
    }
  };

  // Initial paint
  refreshAddSelect();
  renderList();
}


// Drop dups (by code), sort by rank, rewrite rank 1..N
function normaliseRolesForSave(roles){
  const out = [];
  const seen = new Set();
  (Array.isArray(roles) ? roles : []).forEach(r => {
    const code = String(r.code || '').trim();
    if (!code) return;
    if (seen.has(code)) return;
    seen.add(code);
    out.push({ code, rank: Number(r.rank) || 0, label: r.label ? String(r.label) : undefined });
  });
  out.sort((a,b)=> a.rank - b.rank);
  out.forEach((r,i)=> r.rank = i+1);
  return out;
}

async function listClientHospitals(clientId){
  if (!clientId) return [];
  const url = API(`/api/clients/${clientId}/hospitals`);
  const APILOG = (typeof window !== 'undefined' && !!window.__LOG_API) || (typeof __LOG_API !== 'undefined' && !!__LOG_API);
  if (APILOG) console.log('[listClientHospitals] â†’ GET', url);
  const r = await authFetch(url);
  if (APILOG) console.log('[listClientHospitals] â†', r.status, r.ok);
  const list = await toList(r);
  if (APILOG) console.log('[listClientHospitals] parsed length', Array.isArray(list) ? list.length : -1);
  return list;
}

function formatYmdToNiceDate(ymd) {
  const s = String(ymd || '').trim();
  if (!s) return '';
  const parts = s.split('-');
  if (parts.length !== 3) return s;

  const [Y, M, D] = parts.map(Number);
  if (!Y || !M || !D) return s;

  // Use UTC so it doesn't shift with timezone
  const d = new Date(Date.UTC(Y, M - 1, D));
  const days   = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
  const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

  const dayName = days[d.getUTCDay()];
  const dayNum  = d.getUTCDate();       // 1..31
  const month   = months[d.getUTCMonth()];
  const year    = d.getUTCFullYear();

  return `${dayName} ${dayNum} ${month} ${year}`;
}


function formatRolesSummary(roles){
  if (!Array.isArray(roles) || !roles.length) return '';
  const sorted = roles.slice().sort((a,b)=> (a.rank||0)-(b.rank||0));
  return sorted.map(r => `${ordinal(r.rank)} ${r.code}`).join(', ');
}

function ordinal(n){
  const s = ["th","st","nd","rd"], v = n % 100;
  return n + (s[(v-20)%10] || s[v] || s[0]);
}

// Basic clients list for dropdowns (id + name)
async function listClientsBasic(){
  const r = await authFetch(API('/api/clients'));
  const rows = await r.json().catch(()=>({items:[]}));
  const list = Array.isArray(rows?.items) ? rows.items : (Array.isArray(rows) ? rows : []);
  return list.map(x => ({ id: x.id, name: x.name })).filter(x => x.id && x.name);
}

// ===== UK date helpers & lightweight picker =====

function formatIsoToUk(iso){ // 'YYYY-MM-DD' -> 'DD/MM/YYYY'
  if (!iso || typeof iso !== 'string') return '';
  const m = iso.match(/^(\d{4})-(\d{2})-(\d{2})/);
  if (!m) return '';
  return `${m[3]}/${m[2]}/${m[1]}`;
}

function parseUkDateToIso(ddmmyyyy){ // 'DD/MM/YYYY' -> 'YYYY-MM-DD' or null
  if (!ddmmyyyy || typeof ddmmyyyy !== 'string') return null;
  const m = ddmmyyyy.trim().match(/^(\d{2})\/(\d{2})\/(\d{4})$/);
  if (!m) return null;
  const d = parseInt(m[1],10), mo=parseInt(m[2],10), y=parseInt(m[3],10);
  if (mo<1||mo>12||d<1||d>31||y<1900||y>3000) return null;
  const dt = new Date(Date.UTC(y, mo-1, d));
  if (dt.getUTCFullYear()!==y || (dt.getUTCMonth()+1)!==mo || dt.getUTCDate()!==d) return null; // invalid date like 31/02
  const mm = String(mo).padStart(2,'0'), dd = String(d).padStart(2,'0');
  return `${y}-${mm}-${dd}`;
}

// Minimal calendar that sits above modals; ESC / outside closes; keyboard nav supported
function attachUkDatePicker(inputEl, opts) {
  if (!inputEl) return;
  inputEl.setAttribute('autocomplete','off');

  const setIso = (v) => {
    if (!v) return null;
    if (/^\d{2}\/\d{2}\/\d{4}$/.test(String(v))) {
      try { return parseUkDateToIso(v) || null; } catch { return null; }
    }
    return String(v);
  };

  // allow dynamic (re)configuration
  if (opts && typeof opts === 'object') {
    if ('minDate' in opts) inputEl._minIso = setIso(opts.minDate);
    if ('maxDate' in opts) inputEl._maxIso = setIso(opts.maxDate);
  }

  // if already wired, just update constraints and return
  if (inputEl.__ukdpBound) {
    if (inputEl.__ukdpPortal) {
      // refresh current view with new bounds
      try { inputEl.__ukdpRepaint && inputEl.__ukdpRepaint(); } catch {}
    }
    return;
  }

  // Bounds helpers (YYYY-MM-DD or null)
  const getMinIso = () => inputEl._minIso || null;
  const getMaxIso = () => inputEl._maxIso || null;

  let portal = null;
  let current = null;

  function openPicker(){
    closePicker();

    let today = new Date();
    if (inputEl.value) {
      const iso = parseUkDateToIso(inputEl.value);
      if (iso) {
        const [y,m,d] = iso.split('-').map(Number);
        today = new Date(Date.UTC(y, m-1, d));
      }
    }
    current = { year: today.getUTCFullYear(), month: today.getUTCMonth() }; // 0-based

    portal = document.createElement('div');
    inputEl.__ukdpPortal = portal;
    portal.className = 'uk-datepicker-portal';
    portal.style.position = 'fixed';
    portal.style.zIndex = '99999';
    portal.style.background = '#fff';
    portal.style.border = '1px solid #ccc';
    portal.style.borderRadius = '8px';
    portal.style.boxShadow = '0 8px 24px rgba(0,0,0,0.15)';
    portal.style.padding = '8px';

    positionPortal();

    portal.innerHTML = renderCalendarHtml(current.year, current.month, inputEl.value);
    document.body.appendChild(portal);

    portal.addEventListener('click', onPortalClick);
    window.addEventListener('resize', positionPortal);
    document.addEventListener('keydown', onKeyDown, true);
    setTimeout(()=> document.addEventListener('click', onOutside, true), 0);
  }

  function positionPortal(){
    if (!portal) return;
    const r = inputEl.getBoundingClientRect();
    portal.style.left = `${Math.max(8, r.left)}px`;
    portal.style.top  = `${Math.max(8, r.top + window.scrollY + r.height + 6)}px`;
  }

  function closePicker(){
    if (!portal) return;
    document.removeEventListener('click', onOutside, true);
    document.removeEventListener('keydown', onKeyDown, true);
    window.removeEventListener('resize', positionPortal);
    portal.removeEventListener('click', onPortalClick);
    portal.remove();
    portal = null;
    inputEl.__ukdpPortal = null;
  }

  function onOutside(e){
    if (portal && !portal.contains(e.target) && e.target !== inputEl) closePicker();
  }

  function onKeyDown(e){
    if (!portal) return;
    if (e.key === 'Escape') { e.preventDefault(); closePicker(); return; }
  }

  function onPortalClick(e){
    const t = e.target;
    if (t.matches('.nav-prev')) { e.preventDefault(); navMonth(-1); return; }
    if (t.matches('.nav-next')) { e.preventDefault(); navMonth(+1); return; }
    const dayBtn = t.closest('button.day');
    if (dayBtn && !dayBtn.disabled) {
      const y = Number(dayBtn.dataset.y), m = Number(dayBtn.dataset.m), d = Number(dayBtn.dataset.d);
      const iso = `${y}-${String(m+1).padStart(2,'0')}-${String(d).padStart(2,'0')}`;
      inputEl.value = formatIsoToUk(iso);
      closePicker();
      inputEl.dispatchEvent(new Event('change'));
    }
  }

  function dateAllowed(iso){
    const minIso = getMinIso(), maxIso = getMaxIso();
    if (minIso && iso < minIso) return false;
    if (maxIso && iso > maxIso) return false;
    return true;
  }

  function navMonth(delta){
    current.month += delta;
    if (current.month < 0) { current.month = 11; current.year--; }
    if (current.month > 11){ current.month = 0;  current.year++; }
    portal.innerHTML = renderCalendarHtml(current.year, current.month, inputEl.value);
  }

  function renderCalendarHtml(year, month0, selectedUk){
    const selectedIso = parseUkDateToIso(selectedUk || '') || '';
    const sel = selectedIso ? selectedIso.split('-').map(Number) : null;

    const first = new Date(Date.UTC(year, month0, 1));
    const startDow = first.getUTCDay(); // 0=Sun
    const daysInMonth = new Date(Date.UTC(year, month0+1, 0)).getUTCDate();
    const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];

    let grid = '<div class="cal-head" style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px;">' +
      `<a href="#" class="nav-prev" aria-label="Previous month">â€¹</a>` +
      `<div class="title" style="font-weight:600">${monthNames[month0]} ${year}</div>` +
      `<a href="#" class="nav-next" aria-label="Next month">â€º</a>` +
      '</div>';

    grid += `<div class="cal-grid" style="display:grid;grid-template-columns:repeat(7,2em);gap:2px;justify-items:center;align-items:center">`;
    ['Su','Mo','Tu','We','Th','Fr','Sa'].forEach(d => grid += `<div style="font-size:12px;color:#666">${d}</div>`);

    // leading blanks
    for (let i=0;i<startDow;i++) grid += `<div></div>`;
    for (let d=1; d<=daysInMonth; d++){
      const iso = `${year}-${String(month0+1).padStart(2,'0')}-${String(d).padStart(2,'0')}`;
      const isSel = sel && sel[0]===year && (sel[1]-1)===month0 && sel[2]===d;
      const allowed = dateAllowed(iso);
      grid += `<button type="button" class="day${isSel?' selected':''}" data-y="${year}" data-m="${month0}" data-d="${d}"` +
              ` style="width:2em;height:2em;border:1px solid #ddd;border-radius:4px;${allowed?'background:#fff':'background:#f4f4f4;color:#aaa'}" ${allowed?'':'disabled'}>${d}</button>`;
    }
    grid += `</div>`;
    return grid;
  }

   // public dynamic API for constraints refresh
  inputEl.setMinDate = (minDate) => {
    inputEl._minIso = setIso(minDate);
    if (inputEl.__ukdpPortal) { try { inputEl.__ukdpRepaint && inputEl.__ukdpRepaint(); } catch {} }
  };

  inputEl.setMaxDate = (maxDate) => {
    inputEl._maxIso = setIso(maxDate);
    if (inputEl.__ukdpPortal) { try { inputEl.__ukdpRepaint && inputEl.__ukdpRepaint(); } catch {} }
  };

  inputEl.addEventListener('focus', openPicker);

  inputEl.addEventListener('click', openPicker);

  inputEl.__ukdpBound = true;
  inputEl.__ukdpRepaint = ()=>{ if (portal && current) portal.innerHTML = renderCalendarHtml(current.year, current.month, inputEl.value); };
}


function headersFromRows(rows){
  if (!rows.length) return [];
  const keys = new Set(Object.keys(rows[0]));
  rows.forEach(r=> Object.keys(r).forEach(k=> keys.add(k)));
  return [...keys];
}



/* ===== UK date/time formatter helpers (display only) =====
   - Date-only 'YYYY-MM-DD' -> 'DD/MM/YYYY'
   - UTC timestamps -> 'DD/MM/YYYY HHMMhrs' (Europe/London, no seconds)
*/
function formatUkDate(isoDateStr){
  if (!isoDateStr || typeof isoDateStr !== 'string') return isoDateStr;
  const m = /^(\d{4})-(\d{2})-(\d{2})$/.exec(isoDateStr);
  if (!m) return isoDateStr;
  const [,y,mo,d] = m;
  return `${d}/${mo}/${y}`;
}

// ============================================================================
// NEW HELPERS
// ============================================================================

// Toggle enable/disable via backend endpoint
async function patchClientDefault(id, { disabled }) {
  const url = API(`/api/rates/client-defaults/${encodeURIComponent(id)}`);
  const res = await authFetch(url, {
    method: 'PATCH',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify({ disabled: !!disabled })
  });
  if (!res.ok) {
    const text = await res.text().catch(()=> '');
    throw new Error(text || `PATCH failed (${res.status})`);
  }
  const data = await res.json().catch(()=> ({}));
  // Endpoint returns { rate: {...} } or the row; support both
  const row = (data && (data.rate || data)) || null;
  return row;
}

// Format a user reference gracefully
function formatUserRef(u) {
  if (!u) return '';
  const s = String(u);
  if (s.includes('@')) return s;           // email
  if (s.length > 8) return s.slice(0,8)+'â€¦';
  return s;
}

// Trivial HTML escape
function escapeHtml(x) {
  return String(x || '')
    .replaceAll('&','&amp;')
    .replaceAll('<','&lt;')
    .replaceAll('>','&gt;')
    .replaceAll('"','&quot;')
    .replaceAll("'",'&#39;');
}
function formatUkTimestampFromUtc(isoLike){
  if (!isoLike) return isoLike;
  const dt = new Date(isoLike); // parse ISO / ISO-like (+00:00, with ms) to JS Date
  if (isNaN(dt.getTime())) return isoLike;
  const fmt = new Intl.DateTimeFormat('en-GB', {
    timeZone: 'Europe/London',
    year:'numeric', month:'2-digit', day:'2-digit',
    hour:'2-digit', minute:'2-digit', hour12:false
  });
  const parts = fmt.formatToParts(dt);
  const g = (type)=> (parts.find(p=>p.type===type)?.value || '');
  const dd = g('day'), mm = g('month'), yyyy = g('year');
  const hh = g('hour'), mi = g('minute');
  return `${dd}/${mm}/${yyyy} ${hh}${mi}hrs`;
}
function formatDisplayValue(key, val){
  if (val === null || val === undefined || val === '') return 'â€”';
  if (typeof val === 'boolean') return val ? 'Yes' : 'No';

  if (typeof val === 'string'){
    // date-only?
    if (/^\d{4}-\d{2}-\d{2}$/.test(val)) return formatUkDate(val);
    // ISO-ish timestamp?
    if (/\d{4}-\d{2}-\d{2}T/.test(val))  return formatUkTimestampFromUtc(val);
  }

  // Heuristic by column name
  if (typeof key === 'string' && (
      key.endsWith('_at_utc') ||
      key === 'created_at' || key === 'updated_at' ||
      key.endsWith('_timestamp') || key.endsWith('_utc')
    )){
    return formatUkTimestampFromUtc(val);
  }

  return String(val);
}

// === UPDATED: Summary renders role summary for candidates (computed from JSON) ===


function renderAuditTable(content, rows){
  const cols = defaultColumnsFor('audit');
  const tbl = document.createElement('table'); tbl.className='grid';
  const thead = document.createElement('thead'); const trh=document.createElement('tr');
  cols.forEach(c=>{ const th=document.createElement('th'); th.textContent=c; trh.appendChild(th); });
  thead.appendChild(trh); tbl.appendChild(thead);
  const tb = document.createElement('tbody');
  rows.forEach(r=>{
    const tr=document.createElement('tr'); tr.ondblclick=()=> openAuditItem(r);
    cols.forEach(c=>{
      const td=document.createElement('td');
      let v=r[c];
      if (c==='status') td.innerHTML = `<span class="pill ${v==='SENT'?'tag-ok':v==='FAILED'?'tag-fail':'tag-warn'}">${v}</span>`;
      else td.textContent = formatDisplayValue(c, v);
      tr.appendChild(td);
    }); tb.appendChild(tr);
  }); tbl.appendChild(tb); content.appendChild(tbl);
}

// Column manager
const globalColsBtn = byId('btnColumns');
if (globalColsBtn) {
  globalColsBtn.onclick = () => {
    if (!currentSection || !Array.isArray(currentRows)) return;
    openColumnsDialog(currentSection);
  };
}


// ===== Data fetchers =====
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UPDATED: listCandidates â€” supports { q, page, page_size } + best-effort server search
// Falls back to list+local filter if /api/search/candidates is unavailable.
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function listCandidates(opts = {}) {
  const LOGC = (typeof window.__LOG_CONTRACTS === 'boolean') ? window.__LOG_CONTRACTS : false;
  const q = (opts.q || '').trim();
  window.__listState = window.__listState || {};
  const st = (window.__listState['candidates'] ||= { page: 1, pageSize: 50, total: null, hasMore: false, filters: null });
  const page = Number(opts.page || st.page || 1);
  const ps   = String(opts.page_size || st.pageSize || 50);

  // Helper: choose a search strategy based on q
  const buildCandidateQS = (qText) => {
    const qs = new URLSearchParams();
    if (ps !== 'ALL') { qs.set('page', String(page)); qs.set('page_size', String(ps)); } else { qs.set('page','1'); }
    if (!qText) return qs;

    if (qText.includes('@'))        qs.set('email', qText);
    else if (qText.replace(/\D/g,'').length >= 7) qs.set('phone', qText);
    else if (qText.includes(' ')) {
      const parts = qText.split(/\s+/).filter(Boolean);
      const fn = parts.shift() || qText; const ln = parts.join(' ');
      qs.set('first_name', fn); if (ln) qs.set('last_name', ln);
    } else                          qs.set('first_name', qText);

    return qs;
  };

  // Try server-side search first when q is present
  if (q) {
    const qs = buildCandidateQS(q);
    const url = `/api/search/candidates?${qs.toString()}`;
    try {
      if (LOGC) console.log('[PICKER][candidates] server-search â†’', url);
      const r = await authFetch(API(url));
      if (r.ok) {
        const rows = await toList(r);
        if (LOGC) console.log('[PICKER][candidates] server-search OK', { count: rows.length });
        if (ps !== 'ALL') st.hasMore = Array.isArray(rows) && rows.length === Number(ps || 50);
        return rows;
      }
    } catch (e) {
      if (LOGC) console.warn('[PICKER][candidates] server-search failed, falling back', e);
    }
  }

  // Fallback: plain list, then optional local filter
  const qs = new URLSearchParams();
  if (ps !== 'ALL') { qs.set('page', String(page)); qs.set('page_size', String(ps)); } else { qs.set('page','1'); }
  const url = qs.toString() ? `/api/candidates?${qs}` : '/api/candidates';
  const r = await authFetch(API(url));
  const rows = await toList(r);
  if (ps !== 'ALL') st.hasMore = Array.isArray(rows) && rows.length === Number(ps || 50);

  if (!q) return rows;

  // Local best-match ranking when server search isnâ€™t available
  const norm = (s) => (s||'').toString().toLowerCase();
  const toks = q.toLowerCase().split(/\s+/).filter(Boolean);
  const score = (row) => {
    const first = norm(row.first_name), last = norm(row.last_name);
    const disp  = norm(row.display_name || `${row.first_name||''} ${row.last_name||''}`);
    const email = norm(row.email), ref = norm(row.tms_ref);
    let s = 0;
    toks.forEach(t => {
      if (first.startsWith(t)) s += 6;
      if (last.startsWith(t))  s += 6;
      if (disp.startsWith(t))  s += 4;
      if (first === t || last === t) s += 8;
      if (disp.includes(t))    s += 2;
      if (email.includes(t))   s += 1;
      if (ref.includes(t))     s += 1;
    });
    if (toks.length >= 2) {
      // bonus if tokens cover first+last in any order
      const set = new Set(toks);
      if (set.has(first) && set.has(last)) s += 4;
    }
    return s;
  };
  const ranked = rows
    .map(r => ({ r, s: score(r) }))
    .filter(x => x.s > 0)
    .sort((a,b)=> b.s - a.s || String(a.r.display_name||'').localeCompare(String(b.r.display_name||'')))
    .map(x => x.r);

  if (LOGC) console.log('[PICKER][candidates] local-filter', { q, in: rows.length, out: ranked.length });
  return ranked;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UPDATED: listClients â€” supports { q, page, page_size } with /api/search/clients?q=â€¦
// Falls back to list when q is empty.
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function listClients(opts = {}) {
  const LOGC = (typeof window.__LOG_CONTRACTS === 'boolean') ? window.__LOG_CONTRACTS : false;
  const q = (opts.q || '').trim();
  window.__listState = window.__listState || {};
  const st = (window.__listState['clients'] ||= { page: 1, pageSize: 50, total: null, hasMore: false, filters: null });
  const page = Number(opts.page || st.page || 1);
  const ps   = String(opts.page_size || st.pageSize || 50);

  if (q) {
    const qs = new URLSearchParams();
    if (ps !== 'ALL') { qs.set('page', String(page)); qs.set('page_size', String(ps)); } else { qs.set('page','1'); }
    qs.set('q', q);
    const url = `/api/search/clients?${qs.toString()}`;
    try {
      if (LOGC) console.log('[PICKER][clients] server-search â†’', url);
      const r = await authFetch(API(url));
      if (r.ok) {
        const rows = await toList(r);
        if (LOGC) console.log('[PICKER][clients] server-search OK', { count: rows.length });
        if (ps !== 'ALL') st.hasMore = Array.isArray(rows) && rows.length === Number(ps || 50);
        return rows;
      }
    } catch (e) {
      if (LOGC) console.warn('[PICKER][clients] server-search failed, falling back', e);
    }
  }

  const qs = new URLSearchParams();
  if (ps !== 'ALL') { qs.set('page', String(page)); qs.set('page_size', String(ps)); } else { qs.set('page','1'); }
  const url = qs.toString() ? `/api/clients?${qs}` : '/api/clients';
  const r = await authFetch(API(url));
  const rows = await toList(r);
  if (ps !== 'ALL') st.hasMore = Array.isArray(rows) && rows.length === Number(ps || 50);

  // local filter when q present but search route unavailable
  if (!q) return rows;
  const qn = q.toLowerCase();
  const filtered = rows.filter(x => (x.name || '').toLowerCase().includes(qn) || (x.primary_invoice_email||'').toLowerCase().includes(qn));
  if (LOGC) console.log('[PICKER][clients] local-filter', { q, in: rows.length, out: filtered.length });
  return filtered;
}


async function listUmbrellas(){
  window.__listState = window.__listState || {};
  const st = (window.__listState['umbrellas'] ||= { page: 1, pageSize: 50, total: null, hasMore: false, filters: null });
  const ps = st.pageSize, pg = st.page;
  const qs = new URLSearchParams();
  if (ps !== 'ALL') { qs.set('page', String(pg || 1)); qs.set('page_size', String(ps || 50)); }
  else { qs.set('page', '1'); }
  const url = qs.toString() ? `/api/umbrellas?${qs}` : '/api/umbrellas';
  const r = await authFetch(API(url));
  const rows = toList(r);
  if (ps !== 'ALL') st.hasMore = Array.isArray(rows) && rows.length === Number(ps || 50);
  return rows;
}

async function listOutbox(){    const r = await authFetch(API('/api/email/outbox')); return toList(r); }
// ===================== API WRAPPERS (UPDATED) =====================

// GET /api/rates/client-defaults with optional filters:
//   clientId (path param), opts: { rate_type, role, band, active_on }
// Note: charge is shared; rate_type filter is optional and used by UI lists.
// âœ… UPDATED â€” unified FE model; grouping raw per-type rows into unified windows
//    Returned shape: [{ client_id, role, band|null, date_from, date_to|null,
//                       charge_day..bh, paye_day..bh, umb_day..bh }]
// ============================================================================
// LIST CLIENT RATES (adds only_enabled support)
// ============================================================================

async function listClientRates(clientId, opts = {}) {
  const APILOG = (typeof window !== 'undefined' && !!window.__LOG_API) || (typeof __LOG_API !== 'undefined' && !!__LOG_API);

  // ðŸ”§ Guard: never fetch without a client_id (prevents global empty lists clobbering staged state)
  if (!clientId) {
    if (APILOG) console.warn('[listClientRates] called without clientId â€” returning [] to avoid clobbering state');
    return [];
  }

  const qp = new URLSearchParams();
  qp.set('client_id', clientId);
  if (opts.role) qp.set('role', String(opts.role));
  if (opts.band !== undefined && opts.band !== null && `${opts.band}` !== '') {
    qp.set('band', String(opts.band));
  }
  if (opts.active_on) qp.set('active_on', String(opts.active_on)); // YYYY-MM-DD
  if (opts.only_enabled) qp.set('only_enabled', 'true');

  const qs = `?${qp.toString()}`;
  const url = API(`/api/rates/client-defaults${qs}`);
  if (APILOG) console.log('[listClientRates] â†’ GET', url);

  const res = await authFetch(url);
  if (APILOG) console.log('[listClientRates] â†', res.status, res.ok);
  const rows = await toList(res);
  if (APILOG) console.log('[listClientRates] parsed length', Array.isArray(rows) ? rows.length : -1);
  return Array.isArray(rows) ? rows : [];
}

// POST /api/rates/client-defaults â€” requires rate_type = 'PAYE' | 'UMBRELLA'

// POST /api/rates/candidate-overrides â€” requires rate_type
async function addCandidateRate(payload) {
  const rt = String(payload?.rate_type || '').toUpperCase();
  if (rt !== 'PAYE' && rt !== 'UMBRELLA') throw new Error("rate_type must be 'PAYE' or 'UMBRELLA'");
  const r = await authFetch(API('/api/rates/candidate-overrides'), {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify({ ...payload, rate_type: rt })
  });
  return r.ok;
}
// âœ… UPDATED â€” FE accepts a unified window payload; bridges to current per-type backend
//    Posts TWO rows: PAYE (pay from paye_*), UMBRELLA (pay from umb_*), both with same charge set
async function upsertClientRate(payload) {
  if (!payload || !payload.client_id || !payload.role || !payload.date_from) {
    throw new Error('upsertClientRate: client_id, role and date_from are required');
  }
  const APILOG = (typeof window !== 'undefined' && !!window.__LOG_API) || (typeof __LOG_API !== 'undefined' && !!__LOG_API);

  const body = {
    client_id : String(payload.client_id),
    role      : String(payload.role),
    band      : payload.band ?? null,
    date_from : payload.date_from,
    date_to   : payload.date_to ?? null,

    charge_day   : payload.charge_day   ?? null,
    charge_night : payload.charge_night ?? null,
    charge_sat   : payload.charge_sat   ?? null,
    charge_sun   : payload.charge_sun   ?? null,
    charge_bh    : payload.charge_bh    ?? null,

    paye_day     : payload.paye_day     ?? null,
    paye_night   : payload.paye_night   ?? null,
    paye_sat     : payload.paye_sat     ?? null,
    paye_sun     : payload.paye_sun     ?? null,
    paye_bh      : payload.paye_bh      ?? null,

    umb_day      : payload.umb_day      ?? null,
    umb_night    : payload.umb_night    ?? null,
    umb_sat      : payload.umb_sat      ?? null,
    umb_sun      : payload.umb_sun      ?? null,
    umb_bh       : payload.umb_bh       ?? null
  };

  if (APILOG) console.log('[upsertClientRate] â†’ POST /api/rates/client-defaults', body);
  const res = await authFetch(
    API(`/api/rates/client-defaults`),
    { method: 'POST', headers: { 'content-type': 'application/json' }, body: JSON.stringify(body) }
  );
  if (APILOG) console.log('[upsertClientRate] â†', res.status, res.ok);
  if (!res.ok) {
    const msg = await res.text().catch(() => 'Failed to upsert client default window');
    if (APILOG) console.error('[upsertClientRate] error body', msg);
    throw new Error(msg);
  }
  const json = await res.json().catch(() => ({}));
  if (APILOG) console.log('[upsertClientRate] parsed', json);
  return json;
}


// Small helper: cached settings (for ERNI%)
// Falls back to 0 if missing; returns { erni_pct: number (e.g. 0.15), ... }
let __SETTINGS_CACHE__ = null;
async function getSettingsCached() {
  if (__SETTINGS_CACHE__) return __SETTINGS_CACHE__;
  try {
    const s = await getSettings();
    __SETTINGS_CACHE__ = s || {};
  } catch {
    __SETTINGS_CACHE__ = {};
  }
  return __SETTINGS_CACHE__;
}

// Small helper: pick best shared charge row for {client_id, role, band, active_on}
// Uses backendâ€™s selection logic via filters; no rate_type filter here (shared).
// âœ… UPDATED â€” works against unified rows returned by listClientRates()
//    Picks exact band first, then band-null; newest start date wins
async function findBestChargeFor({ client_id, role, band, active_on }) {
  // Fetch ONLY enabled windows for this client/role/date
  const rows = await listClientRates(client_id, { role, band: undefined, active_on, only_enabled: true });
  if (!Array.isArray(rows) || !rows.length) return null;

  const ranked = rows
    // extra guard: ignore any disabled rows that might slip through
    .filter(r =>
      !r.disabled_at_utc &&
      r.role === role &&
      r.date_from &&
      r.date_from <= (active_on || '9999-12-31') &&
      (!r.date_to || r.date_to >= (active_on || '0000-01-01'))
    )
    .sort((a,b) => {
      const aExact = (String(a.band||'') === String(band||''));
      const bExact = (String(b.band||'') === String(band||''));
      if (aExact !== bExact) return aExact ? -1 : 1;          // exact band before band-null
      // newer start first
      return (a.date_from < b.date_from) ? 1 : (a.date_from > b.date_from ? -1 : 0);
    });

  const best = ranked[0];
  return best ? {
    charge_day  : best.charge_day  ?? null,
    charge_night: best.charge_night?? null,
    charge_sat  : best.charge_sat  ?? null,
    charge_sun  : best.charge_sun  ?? null,
    charge_bh   : best.charge_bh   ?? null
  } : null;
}


// Small helper: per-bucket margin
function calcMargin(charge, pay, rate_type, erni_pct = 0) {
  if (charge == null || pay == null) return null;
  const rt = String(rate_type || '').toUpperCase();
  if (rt === 'PAYE') {
    const factor = 1 + (Number.isFinite(erni_pct) ? erni_pct : 0);
    return +(charge - (pay * factor)).toFixed(2);
  }
  return +(charge - pay).toFixed(2);
}


// Helper: basic date overlap check for YYYY-MM-DD strings (null = open-ended)
function rangesOverlap(a_from, a_to, b_from, b_to) {
  const A0 = a_from || '0000-01-01';
  const A1 = a_to   || '9999-12-31';
  const B0 = b_from || '0000-01-01';
  const B1 = b_to   || '9999-12-31';
  return !(A1 < B0 || B1 < A0);
}

// ====================== listCandidateRates (unchanged API) ======================
async function listCandidateRates(candidate_id){
  const r = await authFetch(API(`/api/rates/candidate-overrides?candidate_id=${encodeURIComponent(candidate_id)}`));
  return toList(r);
}
// =========================== fetchRelated (unchanged API) ===========================
async function fetchRelated(entity, id, type){
  const url = API(`/api/related/${entity}/${id}/${type}`);
  let res;
  try {
    res = await authFetch(url);
  } catch (err) {
    console.error('fetchRelated network error:', { url, error: err });
    throw err;
  }

  if (!res.ok) {
    const text = await res.text().catch(()=> '');
    console.error('fetchRelated failed:', { status: res.status, url, server: text });
    throw new Error(`Request failed: ${res.status}`);
  }
  return toList(res);
}


// Settings (singleton)
async function getSettings(){
  const r = await authFetch(API('/api/settings/defaults'));
  if (!r.ok) throw new Error('Fetch settings failed');
  const j = await r.json();
  return j?.settings || j || {};   // <-- unwrap {settings: {...}}
}

async function saveSettings(payload){
  const r = await authFetch(API('/api/settings/defaults'), {
    method:'PUT',
    headers:{'content-type':'application/json'},
    body: JSON.stringify(payload)
  });
  if (!r.ok) throw new Error('Save failed');
  return true;
}

// Related counts (object map: {type: count, ...})
async function fetchRelatedCounts(entity, id){
  const r = await authFetch(API(`/api/related/${entity}/${id}/counts`));
  if (!r.ok) return {};
  return r.json();
}
// ===== UPDATED: upsertCandidate â€” normalize server response so we always return the created/updated object with an id
async function upsertCandidate(payload, id){
  if ('tms_ref' in payload) delete payload.tms_ref; // safety

  const url = id ? `/api/candidates/${id}` : '/api/candidates';
  const method = id ? 'PUT' : 'POST';

  let res;
  try {
    res = await authFetch(API(url), {
      method,
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify(payload),
    });
  } catch (err) {
    console.error('Candidate save request/network error:', { url, method, payload, error: err });
    throw err;
  }

  const text = await res.text().catch(() => '');
  if (!res.ok) {
    console.error('Candidate save failed:', { status: res.status, url, method, payload, server: text });
    throw new Error(text || `Save failed (${res.status})`);
  }

  try {
    const data = text ? JSON.parse(text) : null;
    // normalize common shapes: [row], { candidate: {...} }, or { ...row }
    let obj = null;
    if (Array.isArray(data)) obj = data[0] || null;
    else if (data && data.candidate) obj = data.candidate;
    else if (data && typeof data === 'object') obj = data;

    return obj || (id ? { id, ...payload } : {});
  } catch (e) {
    console.warn('Candidate save: non-JSON response body', { body: text });
    return id ? { id, ...payload } : {};
  }
}

// ===== UPDATED: upsertClient â€” normalize server response so we always return the created/updated object with an id

async function upsertClient(payload, id){
  // Never allow CLI to be sent from UI
  if ('cli_ref' in payload) delete payload.cli_ref;

  // Strip empty-string fields so we don't overwrite existing values with ''
  const clean = {};
  for (const [k, v] of Object.entries(payload || {})) {
    if (v === '' || v === undefined) continue;
    clean[k] = v;
  }

  const url    = id ? `/api/clients/${id}` : '/api/clients';
  const method = id ? 'PUT' : 'POST';
  const APILOG = (typeof window !== 'undefined' && !!window.__LOG_API) || (typeof __LOG_API !== 'undefined' && !!__LOG_API);
  if (APILOG) console.log('[upsertClient] â†’', { method, url: API(url), body: clean });

  const r = await authFetch(API(url), {
    method,
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify(clean)
  });

  if (APILOG) console.log('[upsertClient] â†', r.status, r.ok);
  if (!r.ok) {
    const msg = await r.text().catch(()=> '');
    if (APILOG) console.error('[upsertClient] error body', msg);
    throw new Error(msg || 'Save failed');
  }

  // Try to parse a full client row from the response
  try {
    const data = await r.json();
    if (APILOG) console.log('[upsertClient] parsed', data);
    let obj = null;
    if (Array.isArray(data)) obj = data[0] || null;
    else if (data && data.client) obj = data.client;
    else if (data && typeof data === 'object') obj = data;
    if (obj) return obj;
  } catch (_) { /* fall through to Location/GET fallback */ }

  // Fallbacks: try to extract id from Location, then GET the full row (to get cli_ref/name/etc.)
  let clientId = id || null;
  try {
    const loc = r.headers && r.headers.get('Location');
    if (!clientId && loc) {
      const m = loc.match(/\/api\/clients\/([^/?#]+)/i) || loc.match(/\/clients\/([^/?#]+)/i);
      if (m) clientId = m[1];
    }
  } catch (_) {}

  if (clientId) {
    try {
      const rr = await authFetch(API(`/api/clients/${encodeURIComponent(clientId)}`));
      if (rr.ok) {
        const dd = await rr.json().catch(()=> ({}));
        const obj = (dd && dd.client) ? dd.client : dd;
        if (obj && typeof obj === 'object') {
          if (APILOG) console.log('[upsertClient] GET backfill', obj);
          return obj;
        }
      }
    } catch (_) {}
  }

  // Last resort: return what we know
  const fallback = clientId ? { id: clientId, ...clean } : (id ? { id, ...clean } : { ...clean });
  if (APILOG) console.log('[upsertClient] fallback', fallback);
  return fallback;
}

// ================== FRONTEND: upsertUmbrella (UPDATED to return saved object) ==================
// ===== UPDATED: upsertUmbrella â€” normalize server response so we always return the created/updated object with an id
async function upsertUmbrella(payload, id){
  const url = id ? `/api/umbrellas/${id}` : '/api/umbrellas';
  const method = id ? 'PUT' : 'POST';
  const r = await authFetch(API(url), {method, headers:{'content-type':'application/json'}, body: JSON.stringify(payload)});
  if (!r.ok) { 
    const msg = await r.text().catch(()=> 'Save failed');
    throw new Error(msg || 'Save failed'); 
  }
  try {
    const data = await r.json();
    // normalize shapes: [row], { umbrella: {...} }, or { ...row }
    let obj = null;
    if (Array.isArray(data)) obj = data[0] || null;
    else if (data && data.umbrella) obj = data.umbrella;
    else if (data && typeof data === 'object') obj = data;

    return obj || (id ? { id, ...payload } : { ...payload });
  } catch (_) {
    return id ? { id, ...payload } : { ...payload };
  }
}


async function deleteCandidateRatesFor(candidate_id){
  const r = await authFetch(API(`/api/rates/candidate-overrides/${candidate_id}`), {method:'DELETE'}); return r.ok;
}



// ===== Details Modals =====
let modalCtx = { entity:null, data:null };


// âœ… CHANGED: make this async, always hydrate fresh from server before opening

function openDetails(rowOrId) {
  if (!confirmDiscardChangesIfDirty()) return;

  let row = rowOrId;
  let id  = null;

  if (!row || typeof row !== 'object') {
    id = String(rowOrId || '');
    row = currentRows.find(x => String(x.id) === id) || null;
  } else {
    id = String(row.id || '');
  }

  if (!id) { alert('Record id not provided'); return; }

  if (currentSection === 'contracts') {
    (async () => {
      let fresh = null;
      try {
        fresh = await getContract(id);
      } catch (e) {
        console.debug('[OPEN] getContract failed, falling back to cached row', e);
      }
      const effective = fresh || row;
      if (!effective) { alert('Record not found'); return; }
      currentSelection = effective;
      console.debug('[OPEN] openDetails', { section: currentSection, id: effective.id });
      openContract(effective);
    })();
    return;
  }

  if (!row) { alert('Record not found'); return; }

  currentSelection = row;
  console.debug('[OPEN] openDetails', { section: currentSection, id: row.id });

  if (currentSection === 'candidates')      openCandidate(row);
  else if (currentSection === 'clients')    openClient(row);
  else if (currentSection === 'umbrellas')  openUmbrella(row);
  else if (currentSection === 'audit')      openAuditItem(row);
  else if (currentSection === 'contracts')  openContract(row);
  else if (currentSection === 'timesheets') openTimesheet(row);
}

async function unauthoriseTimesheet(ctxOrId) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][UNAUTH]');
  GC('unauthoriseTimesheet');

  const mc  = window.modalCtx || {};
  const row = (mc.data && mc.data.timesheet_id) ? mc.data :
              (ctxOrId && ctxOrId.row ? ctxOrId.row : {});
  const tsId = (typeof ctxOrId === 'string')
    ? ctxOrId
    : (row.timesheet_id || row.id || mc.data?.id || null);

  if (!tsId) {
    L('ERROR: missing timesheetId');
    GE();
    throw new Error('unauthoriseTimesheet: timesheetId is required');
  }

  const encId = encodeURIComponent(tsId);
  const url   = API(`/api/timesheets/${encId}/unauthorise`);

  L('REQUEST', { url, tsId });

  let res, text;
  try {
    res  = await authFetch(url, { method: 'POST' });
    text = await res.text();
  } catch (err) {
    L('network error', err);
    GE();
    throw err;
  }

  if (!res.ok) {
    L('server error', { status: res.status, bodyPreview: text.slice(0, 400) });
    GE();
    throw new Error(text || `Failed to unauthorise timesheet ${tsId}`);
  }

  let json = {};
  try { json = text ? JSON.parse(text) : {}; } catch (err) {
    L('parse error', err);
  }

  L('unauthorise result', json);

  let newDetails = mc.timesheetDetails;
  try {
    newDetails = await fetchTimesheetDetails(tsId);
    window.modalCtx.timesheetDetails = newDetails;
  } catch (err) {
    L('refresh details failed (non-fatal)', err);
  }

  const tsfin = newDetails?.tsfin || {};
  const updatedRow = {
    ...(mc.data || row),
    summary_stage: json.summary_stage || mc.data?.summary_stage || 'PENDING_AUTH',
    processing_status: tsfin.processing_status || mc.data?.processing_status,
    total_pay_ex_vat: tsfin.total_pay_ex_vat ?? mc.data?.total_pay_ex_vat,
    total_charge_ex_vat: tsfin.total_charge_ex_vat ?? mc.data?.total_charge_ex_vat,
    margin_ex_vat: tsfin.margin_ex_vat ?? mc.data?.margin_ex_vat,
    id: tsId
  };

  window.modalCtx.data = updatedRow;

  try {
    window.__pendingFocus = {
      section: 'timesheets',
      ids: [String(tsId)],
      primaryIds: [String(tsId)]
    };
  } catch {}

  L('UPDATED ROW', updatedRow);
  GE();
  return { ok: true, updatedRow, details: newDetails };
}

function openCreate(){
  if (!confirmDiscardChangesIfDirty()) return;
  if (currentSection==='candidates') openCandidate({});
  else if (currentSection==='clients') openClient({});
  else if (currentSection==='umbrellas') openUmbrella({});
  else if (currentSection==='contracts') openContract({}); // new route
  else alert('Create not supported for this section yet.');
}

function openEdit(){
  if (!confirmDiscardChangesIfDirty()) return;
  if (!currentSelection) return alert('Select by double-clicking a row first.');
  openDetails(currentSelection);
}

async function openDelete(){
  const inModal = (window.__modalStack?.length || 0) > 0;
  const row = inModal ? (modalCtx?.data || null) : currentSelection;

  if (!row) return alert('Select a record (or open it) first.');
  if (!confirm('Delete (or disable) this record?')) return;

  console.debug('[DELETE] request', {
    section: inModal ? modalCtx?.entity : currentSection,
    inModal, id: row.id
  });

  const section = inModal ? modalCtx?.entity : currentSection;

  if (section === 'candidates'){
    await upsertCandidate({ ...row, active:false }, row.id);
  } else if (section === 'umbrellas'){
    await upsertUmbrella({ ...row, enabled:false }, row.id);
  } else if (section === 'contracts'){
    alert('Delete is not available for Contracts here. Open the contract and use the dedicated action if supported.'); // guarded, non-breaking
    return;
  } else {
    alert('Delete is not available for this section.');
    return;
  }

  if (inModal) {
    // Ensure no lingering state after delete
    discardAllModalsAndState();
  }
  await renderAll();
}

// ---- Candidate modal
// === UPDATED: Candidate open modal (mount roles editor; include roles on save) ===
// === UPDATED: openCandidate â€” save uses full persisted state + current tab values ===

// ========================= openCandidate (FIXED) =========================

// =================== CANDIDATE MODAL (unchanged save; ensures pay_method present) ===================
// âœ… UPDATED â€” staged candidate overrides model (apply vs save)
//    Parent Save commits staged deletes â†’ edits â†’ creates

// FRONTEND â€” UPDATED
// openCandidate: default Account holder from umbrella name if pay_method is UMBRELLA and empty.
// ================== FRONTEND: openCandidate (UPDATED) ==================
// ================== FIXED: openCandidate (hydrate before showModal) ==================
// ================== FIXED: openCandidate (hydrate before showModal) ==================
// ================== FIXED: openCandidate (hydrate before showModal) ==================





















// NEW: dedicated Advances / Loans manager modal for a candidate
async function openCandidateAdvancesModal(candidateRow) {
  const deep = (o) => JSON.parse(JSON.stringify(o || {}));
  const row = deep(candidateRow || {});
  const candId = row.id;
  if (!candId) {
    alert('Candidate id is missing; save the candidate record first.');
    return;
  }

  window.appState = window.appState || {};
  window.appState.candidateAdvances = window.appState.candidateAdvances || {};

  // Ensure advances are fetched before opening
  try {
    if (!window.appState.candidateAdvances[candId]) {
      await fetchCandidateAdvances(candId);
    } else {
      // refresh in background, but don't block the modal opening
      fetchCandidateAdvances(candId).catch(() => {});
    }
  } catch (e) {
    console.warn('[ADVANCES][MGR] prefetch failed', e);
  }

  // Seed modal context as its own entity
  window.modalCtx = {
    entity: 'candidate-advances',
    data: row,
    formState: { __forId: candId, main: {} },
    openToken: `cand-adv:${candId}:${Date.now()}`
  };

  const titleName =
    row.display_name ||
    `${row.first_name || ''} ${row.last_name || ''}`.trim() ||
    row.tms_ref ||
    'Candidate';

  const renderAdvancesTab = () => {
    const S = (window.appState && window.appState.candidateAdvances) || {};
    const entry   = S[candId] || { list: [], summary: {} };
    const list    = Array.isArray(entry.list) ? entry.list : [];
    const summary = entry.summary || {};

    const missing = list.filter(a => (a.reason || '').toUpperCase() === 'MISSING_SHIFT');
    const general = list.filter(a => (a.reason || '').toUpperCase() !== 'MISSING_SHIFT');

    return html(`
      <div class="form" id="candidateAdvancesManager" data-candidate-id="${candId}">
        <div class="row">
          <label>Candidate</label>
          <div class="controls">
            <span class="mini">${escapeHtml(titleName)}</span>
          </div>
        </div>

        <div class="row">
          <label>Summary</label>
          <div class="controls" id="candidateAdvancesSummary">
            ${renderAdvancesSummary(summary)}
          </div>
        </div>

        <div class="row">
          <label>Missing-shift advances</label>
          <div class="controls">
            <div id="candidateMissingShiftAdvances">
              ${renderMissingShiftAdvancesList(missing)}
            </div>
            <button type="button"
                    class="btn mini"
                    data-act="adv-missing-new">
              New missing-shift advanceâ€¦
            </button>
          </div>
        </div>

        <div class="row">
          <label>Advances / loans</label>
          <div class="controls">
            <div id="candidateGeneralAdvances">
              ${renderGeneralAdvancesList(general)}
            </div>
            <button type="button"
                    class="btn mini"
                    data-act="adv-manual-new">
              New advance / loanâ€¦
            </button>
          </div>
        </div>
      </div>
    `);
  };

  const onSave = async () => {
    // All actions are applied immediately by their own dialogs/routes.
    // Parent Save just closes the manager.
    return { ok: true };
  };

  const onReturn = () => {
    try {
      const root = document.getElementById('candidateAdvancesManager');
      if (!root) return;
      const candIdLocal =
        root.getAttribute('data-candidate-id') ||
        window.modalCtx?.data?.id ||
        candId;

      if (!candIdLocal) return;

      // Wire "New missing-shift advance" & "New advance / loan"
      if (!root.__advNewWired) {
        root.__advNewWired = true;
        root.addEventListener('click', (ev) => {
          const btn = ev.target.closest('button[data-act]');
          if (!btn) return;
          const act = btn.getAttribute('data-act') || '';

          if (act === 'adv-missing-new') {
            const cand = window.modalCtx?.data || row;
            if (typeof openMissingShiftAdvanceModal === 'function') {
              openMissingShiftAdvanceModal(cand);
            }
          } else if (act === 'adv-manual-new') {
            const cand = window.modalCtx?.data || row;
            if (typeof openManualAdvanceModal === 'function') {
              openManualAdvanceModal(cand);
            }
          }
        });
      }

      // Wire general advances actions (Edit schedule / Pause/Resume / Mark paid off)
      const generalContainer = root.querySelector('#candidateGeneralAdvances');
      if (generalContainer && !generalContainer.__advWired) {
        generalContainer.__advWired = true;
        generalContainer.addEventListener('click', async (ev) => {
          const btn = ev.target.closest('button[data-act][data-advance-id]');
          if (!btn) return;

          const act   = btn.getAttribute('data-act') || '';
          const advId = btn.getAttribute('data-advance-id') || '';
          if (!advId) return;

          const S = (window.appState && window.appState.candidateAdvances) || {};
          const entry = S[candIdLocal] || {};
          const list  = Array.isArray(entry.list) ? entry.list : [];
          const advance = list.find(a => String(a.id) === String(advId));
          if (!advance) return;

          if (act === 'adv-edit-schedule') {
            if (typeof openEditAdvanceScheduleModal === 'function') {
              openEditAdvanceScheduleModal(advance);
            }
          } else if (act === 'adv-toggle-pause') {
            if (typeof toggleAdvancePause === 'function') {
              await toggleAdvancePause(advance);
            }
          } else if (act === 'adv-mark-paid-off') {
            if (typeof markAdvancePaidOff === 'function') {
              await markAdvancePaidOff(advance);
            }
          }
        });
      }
    } catch (e) {
      console.warn('[ADVANCES][MGR] wiring failed', e);
    }
  };

  showModal(
    `Advances / loans â€” ${escapeHtml(titleName)}`,
    [{ key: 'main', label: 'Advances' }],
    renderAdvancesTab,
    onSave,
    true,
    onReturn,
    { kind: 'candidate-advances', noParentGate: true }
  );

  // Ensure the advances manager is wired immediately on first open
  try {
    onReturn();
  } catch (e) {
    console.warn('[ADVANCES][MGR] initial wiring failed', e);
  }
}

function renderCandidateTab(key, row = {}) {
  if (key === 'main') {
    const enc = escapeHtml || ((s) => String(s || ''));

    return html(`
      <div class="form" id="tab-main">
        ${input('first_name','First name', row.first_name)}
        ${input('last_name','Last name', row.last_name)}
        ${input('email','Email', row.email, 'email')}
        ${input('phone','Telephone', row.phone)}

        ${select(
          'pay_method',
          'Pay method',
          (row.pay_method && row.pay_method !== 'Unknown' && row.pay_method !== 'UNKNOWN')
            ? row.pay_method
            : 'Unknown',
          ['Unknown','PAYE','UMBRELLA'],
          { id:'pay-method' }
        )}

        <!-- Rota key name: read-only, not posted -->
        <div class="row">
          <label>Rota key name</label>
          <div class="controls">
            <input
              class="input"
              value="${enc(row.key_norm || '')}"
              disabled
              readonly
              style="opacity:.7"
            />
            <div class="hint">
              This is the candidate's normalised rota key and is managed by the system / mappings.
            </div>
          </div>
        </div>

        <!-- NHSP / HealthRoster aliases (from hr_name_mappings) -->
        <div class="row">
          <label>Also known as in NHSP / HealthRoster</label>
          <div class="controls">
            <div class="split" id="cand-alias-select-row" style="display:none;">
              <select id="cand-alias-select" class="input"></select>
              <button type="button"
                      class="btn mini"
                      data-act="delete-cand-alias"
                      title="Remove this mapping">
                ðŸ—‘ Remove mapping
              </button>
            </div>
            <div id="cand-alias-empty" class="mini">
              No aliases configured yet.
            </div>
            <div class="hint">
              Aliases come from previous NHSP / HealthRoster imports where this staff name
              was resolved to this candidate. Removing a mapping will prevent future rotas
              using that name from auto-linking to this candidate.
            </div>
          </div>
        </div>

        <!-- CCR: display-only, never posted -->
        <div class="row">
          <label>CloudTMS Candidate Reference (CCR)</label>
          <input id="tms_ref_display"
                 value="${row.tms_ref ? String(row.tms_ref) : 'Awaiting CCR number from server'}"
                 disabled
                 readonly
                 style="opacity:.7" />
        </div>

        ${input('display_name','Display name', row.display_name)}

        <!-- New: NI / DOB / Gender -->
        ${input('ni_number','National Insurance Number', row.ni_number)}
        ${input('date_of_birth','Date of birth', row.date_of_birth)}
        ${select('gender','Gender', row.gender || '', ['', 'Male', 'Female', 'Other'])}

        <!-- New: Job Titles (multi, with bins) -->
        <div class="row">
          <label>Job Titles</label>
          <div class="controls">
            <div id="jobTitlesList"
                 style="display:flex;flex-wrap:wrap;gap:4px;min-height:24px;align-items:flex-start;"></div>
            <button type="button"
                    class="btn mini"
                    data-act="pick-job-title">
              Add Job Titleâ€¦
            </button>
            <div class="hint">
              Right click a Job Title in Edit mode to select a Primary Job Role.
            </div>
          </div>
        </div>

        <!-- Professional registration number (NMC/GMC/HCPC) -->
        <div class="row"
             data-block="prof_reg"
             style="${row.prof_reg_type ? '' : 'display:none'}">
          <label data-field="prof_reg_label">
            ${row.prof_reg_type
              ? escapeHtml(`${row.prof_reg_type} Number`)
              : 'Registration Number'}
          </label>
          <div class="controls">
            <input class="input"
                   name="prof_reg_number"
                   value="${escapeHtml(row.prof_reg_number || '')}">
          </div>
        </div>

        <!-- Home address + postcode lookup -->
        <div class="row">
          <label>Home address</label>
          <div class="controls">
            <div class="grid-2">
              <input class="input"
                     name="address_line1"
                     placeholder="Address line 1"
                     value="${escapeHtml(row.address_line1 || '')}">
              <input class="input"
                     name="address_line2"
                     placeholder="Address line 2"
                     value="${escapeHtml(row.address_line2 || '')}">
              <input class="input"
                     name="address_line3"
                     placeholder="Address line 3"
                     value="${escapeHtml(row.address_line3 || '')}">
              <input class="input"
                     name="town_city"
                     placeholder="City / Town"
                     value="${escapeHtml(row.town_city || '')}">
              <input class="input"
                     name="county"
                     placeholder="County"
                     value="${escapeHtml(row.county || '')}">
              <div class="split">
                <input class="input"
                       name="postcode"
                       placeholder="Postcode"
                       value="${escapeHtml(row.postcode || '')}">
                <button type="button"
                        class="btn mini"
                        data-act="postcode-lookup"
                        title="Lookup by postcode">
                  Lookup
                </button>
              </div>
            </div>
          </div>
        </div>

        <div class="row">
          <label>Notes</label>
          <textarea name="notes" placeholder="Free textâ€¦">${row.notes || ''}</textarea>
        </div>
      </div>
    `);
  }

  // Care Packages tab (was "Rates")
  if (key === 'rates') return html(`
    <div class="form" id="tab-rates">
      <!-- Global Candidate Key (GCK) -->
      <div class="row">
        <label>Global Candidate Key (GCK)</label>
        <div class="controls">
          <input class="input"
                 name="key_norm"
                 value="${escapeHtml(row.key_norm || '')}"
                 placeholder="" />
          <div class="hint">
            This links the candidate record to the Google Sheets Rota.
          </div>
        </div>
      </div>

      <!-- Rota Roles editor -->
      <div class="row">
        <label>Rota Roles</label>
        <div id="rolesEditor" data-init="1"></div>
        <div class="hint">
          This links the candidate job role to a Care Package rota only.
          If this candidate is not working on Care Packages, you can ignore this.
        </div>
      </div>

      <!-- Candidate rate overrides table (unchanged wiring) -->
      <div class="row">
        <label>Care Package Rates</label>
        <div id="ratesTable"></div>
      </div>
    </div>
  `);

  if (key === 'pay') return html(`
    <div class="form" id="tab-pay" data-candidate-id="${row.id || ''}">
      <div class="row">
        <label class="hint">
          PAYE bank fields are editable. If UMBRELLA is selected, bank details are taken from the umbrella and locked.
        </label>
      </div>

      ${input('account_holder','Account holder', row.account_holder)}
      ${input('bank_name','Bank name', row.bank_name)}
      ${input('sort_code','Sort code', row.sort_code)}
      ${input('account_number','Account number', row.account_number)}

      <!-- Umbrella chooser: text input + datalist + hidden canonical id -->
      <div class="row" id="umbRow">
        <label>Umbrella company</label>
        <input id="umbrella_name"
               list="umbList"
               placeholder="Type to search umbrellasâ€¦"
               value=""
               autocomplete="off"
               onclick="if (this.value) { this.dataset.prev=this.value; this.value=''; this.dispatchEvent(new Event('input',{bubbles:true})); }"
               onfocus="if (this.value) { this.dataset.prev=this.value; this.value=''; this.dispatchEvent(new Event('input',{bubbles:true})); }" />
        <datalist id="umbList"></datalist>
        <input type="hidden" name="umbrella_id" id="umbrella_id" value="${row.umbrella_id || ''}"/>
      </div>

      <!-- Advances summary (read-only) -->
      <div class="row">
        <label>Advances summary</label>
        <div class="controls" id="candidateAdvancesSummary">
          <span class="mini">No advances loaded yet.</span>
        </div>
      </div>

      <!-- Missing-shift advances (read-only) -->
      <div class="row">
        <label>Missing-shift advances</label>
        <div class="controls">
          <div id="candidateMissingShiftAdvances">
            <span class="mini">No missing-shift advances.</span>
          </div>
          <div class="hint mini">
            To add or edit missing-shift advances, right-click this candidate in the summary list and choose â€œAdvances / loansâ€¦â€.
          </div>
        </div>
      </div>

      <!-- General advances / loans (read-only) -->
      <div class="row">
        <label>Advances / loans</label>
        <div class="controls">
          <div id="candidateGeneralAdvances">
            <span class="mini">No advances or loans.</span>
          </div>
          <div class="hint mini">
            To manage advances or loans, right-click this candidate in the summary list and choose â€œAdvances / loansâ€¦â€.
          </div>
        </div>
      </div>
    </div>
  `);

  // Candidate Calendar tab container
  if (key === 'bookings') return html(`
    <div id="candidateCalendarHolder" class="tabc">
      <div class="hint">Loading calendarâ€¦</div>
    </div>
  `);
}


async function fetchCandidateAdvances(candidateId) {
  if (!candidateId) return;

  window.appState = window.appState || {};
  const S = (window.appState.candidateAdvances ||= {});

  const advancesUrl = API(`/api/candidates/${encodeURIComponent(candidateId)}/advances`);
  const summaryUrl  = API(`/api/candidates/${encodeURIComponent(candidateId)}/advances/summary`);

  let advances = [];
  let summary  = { total_owed_by_candidate: 0, total_advances_not_offset: 0 };

  try {
    const [resList, resSummary] = await Promise.all([
      authFetch(advancesUrl),
      authFetch(summaryUrl)
    ]);

    if (resList.ok) {
      const j = await resList.json().catch(() => ({}));
      advances = Array.isArray(j.advances) ? j.advances : (Array.isArray(j) ? j : []);
    }

    if (resSummary.ok) {
      const s = await resSummary.json().catch(() => ({}));
      if (typeof s.total_owed_by_candidate === 'number') {
        summary.total_owed_by_candidate = s.total_owed_by_candidate;
      }
      if (typeof s.total_advances_not_offset === 'number') {
        summary.total_advances_not_offset = s.total_advances_not_offset;
      }
    }
  } catch (e) {
    console.warn('[ADVANCES] fetchCandidateAdvances failed', e);
  }

  S[candidateId] = {
    list: advances,
    summary,
    fetched_at: new Date().toISOString()
  };

  try {
    updateCandidateAdvancesUI(candidateId);
  } catch (e) {
    console.warn('[ADVANCES] updateCandidateAdvancesUI failed', e);
  }
}


function renderMissingShiftAdvancesList(list) {
  const rows = Array.isArray(list) ? list : [];
  if (!rows.length) {
    return '<span class="mini">No missing-shift advances.</span>';
  }

  const body = rows.map(a => {
    const client = escapeHtml(a.client_name || a.client_label || a.client_id || '');
    const date   = escapeHtml(a.linked_shift_date || '');
    const orig   = (Number(a.original_amount || 0)).toFixed(2);
    const out    = (Number(a.outstanding_amount || 0)).toFixed(2);
    const notes  = escapeHtml(a.notes || '');

    return `
      <tr data-advance-id="${a.id}">
        <td>${client || '<span class="mini">â€”</span>'}</td>
        <td>${date   || '<span class="mini">â€”</span>'}</td>
        <td>Â£${orig}</td>
        <td>Â£${out}</td>
        <td>${notes || '<span class="mini">â€”</span>'}</td>
      </tr>
    `;
  }).join('');

  return `
    <div class="adv-table-wrap">
      <table class="grid mini adv-table" style="table-layout:auto;width:100%;">
        <thead>
          <tr>
            <th>Client</th>
            <th>Shift date</th>
            <th>Original</th>
            <th>Outstanding</th>
            <th>Notes</th>
          </tr>
        </thead>
        <tbody>${body}</tbody>
      </table>
    </div>
  `;
}

function renderGeneralAdvancesList(list, opts = {}) {
  const rows = Array.isArray(list) ? list : [];
  const context = String(opts.context || 'manager').toLowerCase();
  const showActions = (context === 'manager');

  if (!rows.length) {
    return '<span class="mini">No advances or loans.</span>';
  }

  const body = rows.map(a => {
    const client = escapeHtml(a.client_name || a.client_label || a.client_id || '');
    const reason = escapeHtml(a.reason || '');
    const origNum = Number(a.original_amount || 0);
    const outNum  = Number(a.outstanding_amount || 0);
    const orig    = origNum.toFixed(2);
    const out     = outNum.toFixed(2);
    const next    = escapeHtml(a.next_due_week_start || '');

    const rawStatus = String(a.status || '');
    const status    = escapeHtml(rawStatus);

    const schedule = Array.isArray(a.schedule_json) ? a.schedule_json : [];
    const notes    = escapeHtml(a.notes || '');

    const schedSummary = schedule.length
      ? schedule
          .map(e => {
            const ws  = escapeHtml(e.week_start || '');
            const amt = (Number(e.amount || 0)).toFixed(2);
            return `${ws}: Â£${amt}`;
          })
          .join('<br>')
      : '<span class="mini">No schedule</span>';

    const paused     = rawStatus === 'PAUSED';
    const pauseLabel = paused ? 'Resume' : 'Pause';
    const showMarkPaidOff = (outNum > 0 && rawStatus !== 'PAID_OFF');

    const actionsHtml = showActions ? `
      <div class="adv-sched-actions">
        <button type="button"
                class="btn mini"
                data-act="adv-edit-schedule"
                data-advance-id="${a.id}">
          Edit schedule
        </button>
        <button type="button"
                class="btn mini"
                data-act="adv-toggle-pause"
                data-advance-id="${a.id}">
          ${pauseLabel}
        </button>
        ${
          showMarkPaidOff
            ? `<button type="button"
                       class="btn mini"
                       data-act="adv-mark-paid-off"
                       data-advance-id="${a.id}">
                 Mark paid off
               </button>`
            : ''
        }
      </div>
    ` : '';

    return `
      <tr data-advance-id="${a.id}">
        <td>${client || '<span class="mini">â€”</span>'}</td>
        <td>${reason || '<span class="mini">â€”</span>'}</td>
        <td>Â£${orig}</td>
        <td>Â£${out}</td>
        <td>${next || '<span class="mini">â€”</span>'}</td>
        <td>${status}</td>
        <td>${notes || '<span class="mini">â€”</span>'}</td>
        <td style="min-width:260px;">
          <div class="adv-sched">
            <div class="adv-sched-lines">${schedSummary}</div>
            ${actionsHtml}
          </div>
        </td>
      </tr>
    `;
  }).join('');

  return `
    <div class="adv-table-wrap">
      <table class="grid mini adv-table" style="table-layout:auto;width:100%;">
        <thead>
          <tr>
            <th>Client</th>
            <th>Reason</th>
            <th>Original</th>
            <th>Outstanding</th>
            <th>Next due week</th>
            <th>Status</th>
            <th>Notes</th>
            <th>Schedule${showActions ? ' / Actions' : ''}</th>
          </tr>
        </thead>
        <tbody>${body}</tbody>
      </table>
    </div>
  `;
}


async function markAdvancePaidOff(advance) {
  if (!advance || !advance.id) {
    alert('Advance record missing id.');
    return;
  }

  const id     = advance.id;
  const candId = advance.candidate_id || window.modalCtx?.data?.id || null;
  const orig   = Number(advance.original_amount || 0);
  const out    = Number(advance.outstanding_amount || 0);

  const msg = [
    `Mark this advance as fully paid off?`,
    ``,
    `Original amount: Â£${orig.toFixed(2)}`,
    `Outstanding now: Â£${out.toFixed(2)}`,
    ``,
    `No further repayments will be taken in pay runs.`
  ].join('\n');

  const ok = window.confirm(msg);
  if (!ok) return;

  try {
    const payload = {
      status: 'PAID_OFF',
      outstanding_amount: 0
      // Backend can recompute next_due_week_start as needed
    };

    const res = await authFetch(
      API(`/api/advances/${encodeURIComponent(id)}`),
      {
        method: 'PATCH',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify(payload)
      }
    );

    if (!res.ok) {
      const text = await res.text().catch(() => '');
      alert(text || 'Failed to mark advance as paid off.');
      return;
    }

    if (candId) {
      await fetchCandidateAdvances(candId);
    }

    window.__toast && window.__toast('Advance marked as paid off.');
  } catch (e) {
    console.warn('[ADVANCES] markAdvancePaidOff failed', e);
    alert(e?.message || 'Failed to mark advance as paid off.');
  }
}

function renderAdvancesSummary(summary) {
  const totalOwed     = Number(summary?.total_owed_by_candidate || 0).toFixed(2);
  const totalMissing  = Number(summary?.total_advances_not_offset || 0).toFixed(2);

  return `
    <div class="mini">
      <div>Total owed by candidate (all advances): <strong>Â£${totalOwed}</strong></div>
      <div>Total advances owed to candidate (not yet offset by shifts): <strong>Â£${totalMissing}</strong></div>
    </div>
  `;
}
function updateCandidateAdvancesUI(candidateId) {
  const S = (window.appState && window.appState.candidateAdvances) || {};
  const entry = S[candidateId] || { list: [], summary: {} };
  const list  = Array.isArray(entry.list) ? entry.list : [];
  const summary = entry.summary || {};

  const missing = list.filter(a => (a.reason || '').toUpperCase() === 'MISSING_SHIFT');
  const general = list.filter(a => (a.reason || '').toUpperCase() !== 'MISSING_SHIFT');

  const sumEl  = document.getElementById('candidateAdvancesSummary');
  const missEl = document.getElementById('candidateMissingShiftAdvances');
  const genEl  = document.getElementById('candidateGeneralAdvances');

  if (sumEl)  sumEl.innerHTML  = renderAdvancesSummary(summary);
  if (missEl) missEl.innerHTML = renderMissingShiftAdvancesList(missing);
  // Candidate Pay tab: summary mode (no action buttons)
  if (genEl)  genEl.innerHTML  = renderGeneralAdvancesList(general, { context: 'summary' });
}


function openMissingShiftAdvanceModal(candidate) {
  const candId = candidate?.id;
  if (!candId) {
    alert('Save the candidate first before adding advances.');
    return;
  }

  const title = `New missing-shift advance for ${escapeHtml(
    candidate.display_name || `${candidate.first_name || ''} ${candidate.last_name || ''}`
  )}`;

  const formHtml = `
    <div class="form" id="missingShiftAdvanceForm">
      <div class="row">
        <label>Client</label>
        <div class="controls">
          <select name="client_id" id="msa_client_id">
            <option value="">Loading clientsâ€¦</option>
          </select>
        </div>
      </div>
      <div class="row">
        <label>Shift date</label>
        <div class="controls">
          <input type="date" class="input" name="shift_date" />
        </div>
      </div>
      <div class="row">
        <label>Amount (Â£)</label>
        <div class="controls">
          <input type="number" step="0.01" min="0" class="input" name="amount" />
        </div>
      </div>
      <div class="row">
        <label>Best-guess hours</label>
        <div class="controls split">
          <input type="time" class="input" name="best_guess_start" placeholder="Start" />
          <input type="time" class="input" name="best_guess_end" placeholder="End" />
        </div>
      </div>
      <div class="row">
        <label>Notes</label>
        <div class="controls">
          <textarea name="notes" rows="3" placeholder="Optional notesâ€¦"></textarea>
        </div>
      </div>
    </div>
  `;

  showModal(
    title,
    [{ key: 'main', title: 'Advance' }],
    () => formHtml,
    async () => {
      const form = document.getElementById('missingShiftAdvanceForm');
      if (!form) return false;

      const data = collectForm('#missingShiftAdvanceForm') || {};
      const client_id = (data.client_id || '').trim();
      const shift_date = (data.shift_date || '').trim();
      const amount = Number(data.amount || 0);
      const start  = (data.best_guess_start || '').trim();
      const end    = (data.best_guess_end   || '').trim();
      const notes  = (data.notes || '').trim();

      if (!client_id) { alert('Client is required.'); return { ok:false }; }
      if (!shift_date) { alert('Shift date is required.'); return { ok:false }; }
      if (!amount || amount <= 0) { alert('Amount must be greater than zero.'); return { ok:false }; }

      const payload = {
        client_id,
        shift_date,
        amount,
        best_guess_hours: (start || end) ? { start, end } : null,
        notes
      };

      const url = API(`/api/candidates/${encodeURIComponent(candId)}/advances/missing-shift`);
      const res = await authFetch(url, {
        method: 'POST',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify(payload)
      });
      if (!res.ok) {
        const msg = await res.text().catch(() => 'Failed to create missing-shift advance');
        alert(msg || 'Failed to create missing-shift advance');
        return { ok:false };
      }

      await fetchCandidateAdvances(candId);
      return { ok:true };
    },
    false,
    async () => {
      // onReturn: populate clients in dropdown
      try {
        const sel = document.getElementById('msa_client_id');
        if (!sel) return;

        sel.innerHTML = '<option value="">Loading clientsâ€¦</option>';

        const clients = await listClients({ page_size:'ALL' }).catch(() => []);
        if (!Array.isArray(clients) || clients.length === 0) {
          sel.innerHTML = '<option value="">(No clients found)</option>';
          return;
        }

        sel.innerHTML = '<option value="">Select clientâ€¦</option>' +
          clients.map(c =>
            `<option value="${escapeHtml(c.id || '')}">${escapeHtml(c.name || '')}</option>`
          ).join('');
      } catch (e) {
        console.warn('[ADVANCES] failed to populate client list', e);
        const sel = document.getElementById('msa_client_id');
        if (sel) {
          sel.innerHTML = '<option value="">(Failed to load clients)</option>';
        }
      }
    },
    { kind: 'candidate-advance-missing' }
  );
}


function openManualAdvanceModal(candidate) {
  const candId = candidate?.id;
  if (!candId) {
    alert('Save the candidate first before adding advances.');
    return;
  }

  const title = `New advance / loan for ${escapeHtml(candidate.display_name || `${candidate.first_name || ''} ${candidate.last_name || ''}`)}`;

  const formHtml = `
    <div class="form" id="manualAdvanceForm">
      <div class="row">
        <label>Client (optional)</label>
        <div class="controls">
          <select name="client_id" id="ma_client_id">
            <option value="">(None / multiple clients)</option>
          </select>
        </div>
      </div>
      <div class="row">
        <label>Amount (Â£)</label>
        <div class="controls">
          <input type="number" step="0.01" min="0" class="input" name="amount" />
        </div>
      </div>

      <div class="row">
        <label>Repayment mode</label>
        <div class="controls">
          <label class="mini">
            <input type="radio" name="mode" value="simple" checked> Spread over N weeks
          </label>
          <label class="mini" style="margin-left:10px;">
            <input type="radio" name="mode" value="custom"> Custom schedule
          </label>
        </div>
      </div>

      <div id="ma_simple_block">
        <div class="row">
          <label>Start week (Mon)</label>
          <div class="controls">
            <input type="date" class="input" name="start_week_start" />
          </div>
        </div>
        <div class="row">
          <label>Number of weeks</label>
          <div class="controls">
            <input type="number" class="input" name="weeks_count" min="1" value="4" />
          </div>
        </div>
      </div>

      <div id="ma_custom_block" style="display:none;">
        <div class="row">
          <label>Custom schedule</label>
          <div class="controls">
            <table class="grid mini" id="ma_schedule_table">
              <thead>
                <tr>
                  <th>Week start</th>
                  <th>Amount (Â£, deducted)</th>
                  <th></th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
            <button type="button" class="btn mini" data-act="ma-add-row">Add row</button>
            <div class="hint mini">
              Amounts should be positive; they will be treated as deductions from net pay.
            </div>
          </div>
        </div>
      </div>

      <div class="row">
        <label>Notes</label>
        <div class="controls">
          <textarea name="notes" rows="3" placeholder="Optional notesâ€¦"></textarea>
        </div>
      </div>
    </div>
  `;

  showModal(
    title,
    [{ key: 'main', title: 'Advance' }],
    () => formHtml,
    async () => {
      const form = document.getElementById('manualAdvanceForm');
      if (!form) return false;

      const data = collectForm('#manualAdvanceForm') || {};
      const client_id = (data.client_id || '').trim() || null;
      const amount = Number(data.amount || 0);
      const mode   = (data.mode || 'simple').toLowerCase();
      const notes  = (data.notes || '').trim();

      if (!amount || amount <= 0) {
        alert('Amount must be greater than zero.');
        return { ok:false };
      }

      const payload = { client_id, amount, notes };

      if (mode === 'simple') {
        const start = (data.start_week_start || '').trim();
        const weeksCount = Number(data.weeks_count || 0);
        if (!start) { alert('Start week is required for simple schedule.'); return { ok:false }; }
        if (!weeksCount || weeksCount < 1) { alert('Number of weeks must be at least 1.'); return { ok:false }; }

        const weeks = [];
        const base = new Date(`${start}T00:00:00Z`);
        if (Number.isNaN(base.getTime())) {
          alert('Start week must be a valid date.');
          return { ok:false };
        }
        for (let i = 0; i < weeksCount; i++) {
          const d = new Date(base.getTime());
          d.setUTCDate(d.getUTCDate() + i * 7);
          const y = d.getUTCFullYear();
          const m = String(d.getUTCMonth() + 1).padStart(2, '0');
          const dd = String(d.getUTCDate()).padStart(2, '0');
          weeks.push(`${y}-${m}-${dd}`);
        }
        payload.start_week_start = start;
        payload.weeks = weeks;
      } else {
        // custom schedule
        const tbody = document.querySelector('#ma_schedule_table tbody');
        const rows = Array.from(tbody?.querySelectorAll('tr') || []);
        if (!rows.length) {
          alert('Add at least one custom schedule row.');
          return { ok:false };
        }

        const custom_schedule = [];
        for (const tr of rows) {
          const wsInput = tr.querySelector('input[name="week_start"]');
          const amtInput = tr.querySelector('input[name="amount"]');
          const ws  = (wsInput?.value || '').trim();
          const amt = Number(amtInput?.value || 0);
          if (!ws) {
            alert('Each custom row must have a week start date.');
            return { ok:false };
          }
          if (!amt || amt <= 0) {
            alert('Each custom row amount must be greater than zero.');
            return { ok:false };
          }
          custom_schedule.push({ week_start: ws, amount: -Math.abs(amt) }); // negative for deduction
        }

        payload.custom_schedule = custom_schedule;
      }

      const url = API(`/api/candidates/${encodeURIComponent(candId)}/advances/manual`);
      const res = await authFetch(url, {
        method: 'POST',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify(payload)
      });
      if (!res.ok) {
        const msg = await res.text().catch(() => 'Failed to create manual advance');
        alert(msg || 'Failed to create manual advance');
        return { ok:false };
      }

      await fetchCandidateAdvances(candId);
      return { ok:true };
    },
    false,
    async () => {
      // onReturn: wire simple/custom toggle & add-row, populate clients
      try {
        const modeRadios = document.querySelectorAll('#manualAdvanceForm input[name="mode"]');
        const simpleBlock = document.getElementById('ma_simple_block');
        const customBlock = document.getElementById('ma_custom_block');
        const tableBody   = document.querySelector('#ma_schedule_table tbody');
        const addRowBtn   = document.querySelector('#ma_schedule_table').closest('.controls')?.querySelector('[data-act="ma-add-row"]');
        const clientSel   = document.getElementById('ma_client_id');

        // Populate clients
        try {
          if (clientSel) {
            const clients = await listClients({ page_size:'ALL' }).catch(() => []);
            clientSel.innerHTML = '<option value="">(None / multiple clients)</option>' +
              clients.map(c => `<option value="${escapeHtml(c.id || '')}">${escapeHtml(c.name || '')}</option>`).join('');
          }
        } catch (e) {
          console.warn('[ADVANCES] populate client list (manual) failed', e);
        }

        const switchMode = () => {
          const cur = Array.from(modeRadios).find(r => r.checked)?.value || 'simple';
          if (cur === 'custom') {
            simpleBlock.style.display = 'none';
            customBlock.style.display = '';
          } else {
            simpleBlock.style.display = '';
            customBlock.style.display = 'none';
          }
        };

        modeRadios.forEach(r => {
          r.addEventListener('change', switchMode);
        });
        switchMode();

        const addRow = () => {
          if (!tableBody) return;
          const tr = document.createElement('tr');
          tr.innerHTML = `
            <td><input type="date" class="input" name="week_start" /></td>
            <td><input type="number" step="0.01" min="0" class="input" name="amount" /></td>
            <td><button type="button" class="btn mini" data-act="ma-del-row">&times;</button></td>
          `;
          tableBody.appendChild(tr);
        };

        if (addRowBtn) {
          addRowBtn.addEventListener('click', addRow);
        }

        if (tableBody && !tableBody.__wiredDel) {
          tableBody.__wiredDel = true;
          tableBody.addEventListener('click', (e) => {
            const btn = e.target.closest('button[data-act="ma-del-row"]');
            if (!btn) return;
            const tr = btn.closest('tr');
            if (tr) tr.remove();
          });
        }

      } catch (e) {
        console.warn('[ADVANCES] openManualAdvanceModal onReturn wiring failed', e);
      }
    },
    { kind: 'candidate-advance-manual' }
  );
}
function openEditAdvanceScheduleModal(advance) {
  if (!advance || !advance.id) {
    alert('Advance record missing id.');
    return;
  }

  const advId = advance.id;
  const schedule = Array.isArray(advance.schedule_json) ? advance.schedule_json : [];
  const title = `Edit schedule â€“ advance Â£${(Number(advance.original_amount || 0)).toFixed(2)}`;

  const rowsHtml = schedule.map((e, idx) => `
    <tr data-i="${idx}">
      <td><input type="date" class="input" name="week_start" value="${escapeHtml(e.week_start || '')}"></td>
      <td><input type="number" step="0.01" class="input" name="amount" value="${Number(e.amount || 0)}"></td>
      <td><button type="button" class="btn mini" data-act="adv-row-del">&times;</button></td>
    </tr>
  `).join('');

  const formHtml = `
    <div class="form" id="advanceScheduleForm">
      <div class="row">
        <label>Schedule</label>
        <div class="controls">
          <table class="grid mini" id="adv_schedule_table">
            <thead>
              <tr>
                <th>Week start</th>
                <th>Amount (Â£)</th>
                <th></th>
              </tr>
            </thead>
            <tbody>${rowsHtml}</tbody>
          </table>
          <button type="button" class="btn mini" data-act="adv-row-add">Add row</button>
          <div class="hint mini">
            Amounts are stored as signed values (negative = deduction, positive = extra pay).
          </div>
        </div>
      </div>
    </div>
  `;

  showModal(
    title,
    [{ key: 'main', title: 'Schedule' }],
    () => formHtml,
    async () => {
      const tbody = document.querySelector('#adv_schedule_table tbody');
      if (!tbody) return false;

      const rows = Array.from(tbody.querySelectorAll('tr[data-i]') || []);
      const schedule_json = [];

      for (const tr of rows) {
        const ws = (tr.querySelector('input[name="week_start"]')?.value || '').trim();
        const amt = Number(tr.querySelector('input[name="amount"]')?.value || 0);
        if (!ws) {
          alert('Each row must have a week start date.');
          return { ok:false };
        }
        if (!amt && amt !== 0) {
          alert('Each row must have an amount (0 allowed).');
          return { ok:false };
        }
        schedule_json.push({ week_start: ws, amount: amt });
      }

      const payload = { schedule_json };

      const url = API(`/api/advances/${encodeURIComponent(advId)}`);
      const res = await authFetch(url, {
        method: 'PATCH',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify(payload)
      });
      if (!res.ok) {
        const msg = await res.text().catch(() => 'Failed to update advance schedule');
        alert(msg || 'Failed to update advance schedule');
        return { ok:false };
      }

      try {
        const candId = advance.candidate_id || window.modalCtx?.data?.id;
        if (candId) await fetchCandidateAdvances(candId);
      } catch (e) {
        console.warn('[ADVANCES] refresh after edit schedule failed', e);
      }

      return { ok:true };
    },
    false,
    () => {
      // onReturn: wire add/delete buttons
      try {
        const tbody = document.querySelector('#adv_schedule_table tbody');
        const addBtn = document.querySelector('[data-act="adv-row-add"]');
        if (addBtn && tbody) {
          addBtn.addEventListener('click', () => {
            const idx = tbody.querySelectorAll('tr[data-i]').length;
            const tr = document.createElement('tr');
            tr.setAttribute('data-i', String(idx));
            tr.innerHTML = `
              <td><input type="date" class="input" name="week_start"></td>
              <td><input type="number" step="0.01" class="input" name="amount"></td>
              <td><button type="button" class="btn mini" data-act="adv-row-del">&times;</button></td>
            `;
            tbody.appendChild(tr);
          });
        }
        if (tbody && !tbody.__wiredDel) {
          tbody.__wiredDel = true;
          tbody.addEventListener('click', (e) => {
            const btn = e.target.closest('button[data-act="adv-row-del"]');
            if (!btn) return;
            const tr = btn.closest('tr');
            if (tr) tr.remove();
          });
        }
      } catch (e) {
        console.warn('[ADVANCES] openEditAdvanceScheduleModal wiring failed', e);
      }
    },
    { kind: 'candidate-advance-schedule' }
  );
}
async function toggleAdvancePause(advance) {
  if (!advance || !advance.id) {
    alert('Advance record missing id.');
    return;
  }

  const id = advance.id;
  const candId = advance.candidate_id || window.modalCtx?.data?.id || null;
  const isActive = String(advance.status || '').toUpperCase() === 'ACTIVE';
  const path = isActive ? `/api/advances/${encodeURIComponent(id)}/pause`
                        : `/api/advances/${encodeURIComponent(id)}/resume`;

  if (isActive) {
    const ok = window.confirm('Pause repayments for this advance?');
    if (!ok) return;
  } else {
    const ok = window.confirm('Resume repayments for this advance?');
    if (!ok) return;
  }

  try {
    const res = await authFetch(API(path), { method: 'POST' });
    if (!res.ok) {
      const msg = await res.text().catch(() => 'Failed to update advance status');
      alert(msg || 'Failed to update advance status');
      return;
    }
    if (candId) {
      await fetchCandidateAdvances(candId);
    }
  } catch (e) {
    console.warn('[ADVANCES] toggleAdvancePause failed', e);
    alert(e?.message || 'Failed to update advance status');
  }
}

async function openCandidate(row) {
  // ===== Logging helpers (toggle with window.__LOG_MODAL = true/false) =====
  const LOG = (typeof window.__LOG_MODAL === 'boolean') ? window.__LOG_MODAL : false;
  const L  = (...a)=> { if (LOG) console.log('[OPEN_CANDIDATE]', ...a); };
  const W  = (...a)=> { if (LOG) console.warn('[OPEN_CANDIDATE]', ...a); };
  const E  = (...a)=> { if (LOG) console.error('[OPEN_CANDIDATE]', ...a); };

  const deep = (o)=> JSON.parse(JSON.stringify(o || {}));
  const incoming = deep(row || {});
  const seedId   = incoming?.id || null;

  L('ENTRY', { incomingKeys: Object.keys(incoming||{}), seedId });

  // helper to unwrap a single record from many common backend shapes
  const unwrapSingle = (data, key) => {
    if (Array.isArray(data)) return data[0] || null;
    if (data && key && data[key]) return unwrapSingle(data[key], null);
    if (data && Array.isArray(data.rows))  return data.rows[0]  || null;
    if (data && Array.isArray(data.items)) return data.items[0] || null;
    if (data && Array.isArray(data.data))  return data.data[0]  || null;
    return (data && typeof data === 'object') ? data : null;
  };

  // 1) Hydrate full record if we have an id
  let full = incoming;
  if (seedId) {
    try {
      const url = API(`/api/candidates/${encodeURIComponent(seedId)}`);
      L('[HTTP] GET', url);
      const res = await authFetch(url);
      L('[HTTP] status', res?.status, res?.ok);

      try {
        const raw = await res.clone().text();
        if (LOG) console.debug('[HTTP] raw body (â‰¤2KB):', raw.slice(0, 2048));
      } catch (peekErr) {
        W('[HTTP] raw peek failed', peekErr?.message || peekErr);
      }

      if (res.ok) {
        const data       = await res.json().catch((jErr)=>{ W('res.json() failed, using {}', jErr); return {}; });
        const candidate  = data.candidate || unwrapSingle(data, 'candidate');
        const job_titles = Array.isArray(data.job_titles) ? data.job_titles : [];
        const hr_aliases = Array.isArray(data.hr_aliases) ? data.hr_aliases : [];
        L('hydrated JSON keys', Object.keys(data||{}), 'candidate keys', Object.keys(candidate||{}));

        // Store hr_aliases on the hydrated object under a private key,
        // so we can seed modalCtx later without changing the DB schema.
        full = candidate
          ? { ...candidate, job_titles, __hr_aliases: hr_aliases }
          : incoming;
      } else {
        W('non-OK response, using incoming row');
      }

    } catch (e) {
      W('hydrate failed; using summary row', e);
    }
  } else {
    L('no seedId â€” create mode');
  }

  // Helper: build candidateMainModel used by bindCandidateMainFormEvents
  const buildCandidateMainModel = (srcRaw) => {
    const src = srcRaw || {};
    const toStr = (v) => (v == null ? '' : String(v));

    // Normalise job_titles into { job_title_id, is_primary } objects
    let jt = [];
    if (Array.isArray(src.job_titles)) {
      jt = src.job_titles
        .map(t => {
          if (!t) return null;
          const id =
            t.job_title_id ??
            t.id ??
            t.default_job_title_id ??
            null;
          if (!id) return null;
          return {
            job_title_id: id,
            is_primary: !!t.is_primary
          };
        })
        .filter(Boolean);
    }

    // Normalise NHSP/HR aliases into an array of strings
    let aliases = [];
    if (Array.isArray(src.nhsp_hr_name_aliases)) {
      aliases = src.nhsp_hr_name_aliases.filter(Boolean).map(toStr);
    } else if (src.nhsp_hr_name_aliases) {
      aliases = [toStr(src.nhsp_hr_name_aliases)];
    }

    return {
      // Core identity / contact
      first_name:       toStr(src.first_name),
      last_name:        toStr(src.last_name),
      email:            toStr(src.email),
      phone:            toStr(src.phone),
      display_name:     toStr(src.display_name),

      // Pay / rota fields
      pay_method:       src.pay_method || null,
      key_norm:         toStr(src.key_norm),

      // Aliases for NHSP / HealthRoster
      nhsp_hr_name_aliases: aliases,

      // CCR and NI / DOB / gender
      tms_ref:          src.tms_ref ?? null,
      ni_number:        toStr(src.ni_number),
      date_of_birth:    src.date_of_birth || null, // stored as ISO; binder will format
      gender:           toStr(src.gender),

      // Professional registration
      prof_reg_type:    src.prof_reg_type || null,
      prof_reg_number:  toStr(src.prof_reg_number),

      // Address
      address_line1:    toStr(src.address_line1),
      address_line2:    toStr(src.address_line2),
      address_line3:    toStr(src.address_line3),
      town_city:        toStr(src.town_city),
      county:           toStr(src.county),
      postcode:         toStr(src.postcode),
      country:          toStr(src.country),

      // Notes
      notes:            toStr(src.notes),

      // Job titles (normalised, primary will be enforced by binder)
      job_titles:       jt
    };
  };

  // 2) Build modal context from hydrated data
  const fullKeys    = Object.keys(full || {});
  const dbPayMethod = full && full.pay_method ? String(full.pay_method).toUpperCase() : null;

  L('seeding window.modalCtx', {
    entity: 'candidates',
    fullId: full?.id,
    fullKeys,
    dbPayMethod
  });

  // Normalise hr_name_mappings aliases into modalCtx.hrAliasState
  const hrAliasesExisting = Array.isArray(full.__hr_aliases)
    ? full.__hr_aliases
    : [];
  const selectedAliasId = hrAliasesExisting.length
    ? (hrAliasesExisting[0].id ?? null)
    : null;

  window.modalCtx = {
    entity: 'candidates',
    data:   deep(full),
    formState: { __forId: full?.id || null, main: {}, pay: {} },
    rolesState: Array.isArray(full?.roles) ? normaliseRolesForSave(full.roles) : [],
    overrides: { existing: [], stagedNew: [], stagedEdits: {}, stagedDeletes: new Set() },
    clientSettingsState: null,
    openToken: ((full?.id) || 'new') + ':' + Date.now(),
    // ðŸ”¹ Freeze the DB pay method for the lifetime of this modal
    dbPayMethod,
    // ðŸ”¹ Main candidate model used by bindCandidateMainFormEvents (create + edit)
    candidateMainModel: buildCandidateMainModel(full),
    // ðŸ”¹ HR name mappings (NHSP / HealthRoster) for this candidate
    hrAliasState: {
      existing: hrAliasesExisting,   // [{ id, hr_name_norm, hospital_or_trust, ... }, ...]
      stagedDeletes: [],             // alias IDs staged for delete
      selectedId: selectedAliasId    // currently selected alias in the dropdown
    }
  };

  L('window.modalCtx seeded', {
    entity: window.modalCtx.entity,
    dataId: window.modalCtx.data?.id,
    dataKeys: Object.keys(window.modalCtx.data||{}),
    formStateForId: window.modalCtx.formState?.__forId,
    openToken: window.modalCtx.openToken,
    dbPayMethod: window.modalCtx.dbPayMethod,
    candidateMainModelKeys: Object.keys(window.modalCtx.candidateMainModel || {})
  });

  // 3) Render modal
  L('calling showModal with hasId=', !!full?.id, 'rawHasIdArg=', full?.id);
  showModal(
    'Candidate',
    [
      { key:'main',     label:'Main Details' },
      { key:'rates',    label:'Care Packages' },
      { key:'pay',      label:'Payment details' },
      { key:'bookings', label:'Bookings' }
    ],
    (k, r) => {
      L('[renderCandidateTab] tab=', k, 'rowKeys=', Object.keys(r||{}), 'sample=', { first: r?.first_name, last: r?.last_name, id: r?.id });
      return renderCandidateTab(k, r);
    },
    async () => {
      L('[onSave] begin', { dataId: window.modalCtx?.data?.id, forId: window.modalCtx?.formState?.__forId });
      const isNew = !window.modalCtx?.data?.id;

      const fs   = window.modalCtx.formState || { __forId: null, main:{}, pay:{} };
      const hasId = !!window.modalCtx.data?.id;
      const same = hasId
        ? (fs.__forId === window.modalCtx.data.id)
        : (fs.__forId === window.modalCtx.openToken || fs.__forId == null);

      const stateMain = same ? (fs.main || {}) : {};
      const statePay  = same ? (fs.pay  || {}) : {};
      const main      = document.querySelector('#tab-main') ? collectForm('#tab-main') : {};
      const pay       = document.querySelector('#tab-pay')  ? collectForm('#tab-pay')  : {};
      const roles     = normaliseRolesForSave(window.modalCtx.rolesState || window.modalCtx.data?.roles || []);

      let payload   = { ...stateMain, ...statePay, ...main, ...pay, roles };

      // Strip internal-only fields before logging / sending to backend
      for (const k of Object.keys(payload)) {
        // Anything starting with "__" is a front-end staging key (e.g. __forMethod)
        if (k.startsWith('__')) {
          delete payload[k];
        }
      }

      L('[onSave] collected', {
        same,
        stateMainKeys: Object.keys(stateMain||{}),
        statePayKeys:  Object.keys(statePay||{}),
        mainKeys:      Object.keys(main||{}),
        payKeys:       Object.keys(pay||{}),
        rolesCount:    roles?.length || 0,
        bankSnapshot: {
          fromStatePay: {
            account_holder: statePay.account_holder ?? null,
            bank_name:      statePay.bank_name      ?? null,
            sort_code:      statePay.sort_code      ?? null,
            account_number: statePay.account_number ?? null
          },
          fromDomPay: {
            account_holder: pay.account_holder ?? null,
            bank_name:      pay.bank_name      ?? null,
            sort_code:      pay.sort_code      ?? null,
            account_number: pay.account_number ?? null
          }
        }
      });

      delete payload.umbrella_name;
      delete payload.tms_ref;

      if (!payload.first_name && full?.first_name) payload.first_name = full.first_name;
      if (!payload.last_name  && full?.last_name)  payload.last_name  = full.last_name;
      if (typeof payload.key_norm === 'undefined' && typeof full?.key_norm !== 'undefined') payload.key_norm = full.key_norm;

      // Run main tab validation (first/last, phone, email, NI, gender, address)
      const mainValid = validateCandidateMain(payload);
      if (!mainValid) {
        // Do not allow save; user can correct highlighted fields
        return { ok:false };
      }

      if (!payload.display_name) {
        const dn = [payload.first_name, payload.last_name].filter(Boolean).join(' ').trim();
        payload.display_name = dn || full?.display_name || null;
      }

      // Normalise pay_method, allow "Unknown" to mean "no pay method yet" (saved as null)
      let pm = (payload.pay_method || '').trim();
      if (!pm && full?.pay_method) pm = String(full.pay_method || '');
      pm = pm ? pm.toUpperCase() : '';

      if (pm === 'UNKNOWN' || pm === '') {
        payload.pay_method = null;
      } else if (pm === 'PAYE' || pm === 'UMBRELLA') {
        payload.pay_method = pm;
      } else {
        payload.pay_method = null;
      }

      if (payload.pay_method === 'UMBRELLA') {
        if ((!payload.umbrella_id || payload.umbrella_id === '') && full?.umbrella_id) {
          payload.umbrella_id = full.umbrella_id;
        }
        if (!payload.account_holder) {
          const umbNameEl = document.querySelector('#tab-pay #umbrella_name');
          if (umbNameEl && umbNameEl.value) payload.account_holder = umbNameEl.value;
        }
      }

      // PAYE â†’ clear umbrella; UMBRELLA â†’ must have umbrella_id
      if (payload.pay_method === 'PAYE') {
        payload.umbrella_id = null;
      } else if (payload.pay_method === 'UMBRELLA') {
        if (!payload.umbrella_id || payload.umbrella_id === '') {
          alert('Select an umbrella company for UMBRELLA pay.');
          return { ok:false };
        }
      }
      if (payload.umbrella_id === '') payload.umbrella_id = null;

      const originalMethod = (full && full.pay_method) ? String(full.pay_method).toUpperCase() : null;
      const newMethod      = payload.pay_method ? String(payload.pay_method).toUpperCase() : null;
      const hasExistingId  = !!full?.id;

      const isFlip = !!(
        hasExistingId &&
        originalMethod &&
        newMethod &&
        (originalMethod === 'PAYE' || originalMethod === 'UMBRELLA') &&
        (newMethod     === 'PAYE' || newMethod     === 'UMBRELLA') &&
        originalMethod !== newMethod
      );

      // Helper to force-clear candidate bank fields in a payload
      const clearBankOnPayload = (obj) => {
        obj.account_holder = null;
        obj.bank_name      = null;
        obj.sort_code      = null;
        obj.account_number = null;
      };

      // Helper: apply staged HR alias deletions for this candidate
         // Helper: apply staged HR alias deletions for this candidate
      const applyAliasDeletes = async (candId) => {
        try {
          const aliasState = window.modalCtx?.hrAliasState || null;
          const stagedRaw = (aliasState && Array.isArray(aliasState.stagedDeletes))
            ? aliasState.stagedDeletes
            : [];

          // Normalise to a clean list of mapping_ids (strings)
          const mappingIds = stagedRaw
            .map((id) => (id == null ? '' : String(id).trim()))
            .filter(Boolean);

          if (!candId || !mappingIds.length) return { ok: true };

          L('[onSave] deleting staged HR aliases', {
            candidateId: candId,
            stagedCount: mappingIds.length
          });

          const urlAliasDel = API(
            `/api/candidates/${encodeURIComponent(candId)}/aliases`
          );

          L('[onSave][DELETE hr_aliases batch]', {
            url: urlAliasDel,
            mapping_ids: mappingIds
          });

          const resAlias = await authFetch(urlAliasDel, {
            method: 'DELETE',
            headers: { 'content-type': 'application/json' },
            body: JSON.stringify({ mapping_ids: mappingIds })
          });

          if (!resAlias.ok) {
            const msg = await resAlias.text().catch(() => 'Failed to delete alias mappings');
            alert(msg);
            return { ok:false };
          }

          // Update local aliasState to reflect deletions
          if (aliasState) {
            const stagedSet = new Set(mappingIds.map(String));
            const remaining = Array.isArray(aliasState.existing)
              ? aliasState.existing.filter(a => a && !stagedSet.has(String(a.id)))
              : [];

            aliasState.existing      = remaining;
            aliasState.stagedDeletes = [];
            aliasState.selectedId    = remaining.length ? (remaining[0].id ?? null) : null;
          }

          return { ok:true };
        } catch (e) {
          W('applyAliasDeletes failed (non-fatal)', e);
          // Non-fatal: aliases are â€œnice to haveâ€; donâ€™t hard-block the candidate save
          return { ok:true };
        }
      };


      if (isFlip) {
        L('[onSave] detected PAYEâ†”UMBRELLA flip', {
          originalMethod,
          newMethod,
          candidateId: full.id,
          stagedPayAtFlip: {
            ...(window.modalCtx?.formState?.pay || {})
          }
        });

        const idForUpdate = window.modalCtx?.data?.id || full?.id || null;

        // â”€â”€ PAYE â†’ UMBRELLA special handling â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if (originalMethod === 'PAYE' && newMethod === 'UMBRELLA') {
          const effectiveUmbrellaId = payload.umbrella_id || full.umbrella_id || null;

          if (!effectiveUmbrellaId) {
            alert('Before switching to UMBRELLA, select an umbrella company on the Payment details tab and save again.');
            return { ok:false };
          }

          // Normalise DOB so blank "" becomes null before any pre-save
          if (Object.prototype.hasOwnProperty.call(payload, 'date_of_birth') &&
              !payload.date_of_birth) {
            payload.date_of_birth = null;
          }

          // Pre-save umbrella details (but keep pay_method as originalMethod) so the backend
          // bulk change endpoint passes its umbrella_id check.
          if (!full.umbrella_id && effectiveUmbrellaId && idForUpdate) {
            const prePayload = { ...payload };
            prePayload.pay_method = originalMethod;

            // Strip any remaining empty-string fields so we don't send "" to typed columns
            for (const k of Object.keys(prePayload)) {
              if (prePayload[k] === '') delete prePayload[k];
            }

            L('[onSave][FLIP Pâ†’U] pre-saving umbrella details', {
              candidateId: idForUpdate,
              prePayloadBank: {
                account_holder: prePayload.account_holder ?? null,
                bank_name:      prePayload.bank_name      ?? null,
                sort_code:      prePayload.sort_code      ?? null,
                account_number: prePayload.account_number ?? null,
                umbrella_id:    prePayload.umbrella_id    ?? null
              }
            });

            const preSaved = await upsertCandidate(prePayload, idForUpdate).catch(err => {
              E('pre upsertCandidate (umbrella before flip) failed', err);
              return null;
            });

            if (!preSaved || !preSaved.id) {
              alert('Failed to save umbrella details before pay-method change. Please try again.');
              return { ok:false };
            }

            full = { ...full, ...preSaved };
            try {
              window.modalCtx.data = { ...(window.modalCtx.data || {}), ...preSaved };
            } catch (err) {
              W('failed to sync modalCtx.data after pre-saving umbrella', err);
            }
          }

          // Leave the dropdown showing the new method (UMBRELLA) while the flip runs
          try {
            const confirmed = await openCandidatePayMethodChangeModal(full, {
              originalMethod,
              newMethod,
              candidate_id: full.id
            });

            if (!confirmed) {
              L('[onSave] pay-method change cancelled or failed, keeping candidate modal open');
              return { ok:false };
            }

            window.modalCtx.__payFlipDone = true;

            // After backend change, persist the final UMBRELLA state on candidate:
            const postFlipUmbPayload = {
              ...payload,
              pay_method: 'UMBRELLA',
              umbrella_id: effectiveUmbrellaId
            };
            clearBankOnPayload(postFlipUmbPayload);

            for (const k of Object.keys(postFlipUmbPayload)) {
              if (postFlipUmbPayload[k] === '') delete postFlipUmbPayload[k];
            }

            L('[onSave][FLIP Pâ†’U] postFlipUmbPayload', {
              candidateId: idForUpdate,
              pay_method: postFlipUmbPayload.pay_method,
              umbrella_id: postFlipUmbPayload.umbrella_id,
              bank: {
                account_holder: postFlipUmbPayload.account_holder ?? null,
                bank_name:      postFlipUmbPayload.bank_name      ?? null,
                sort_code:      postFlipUmbPayload.sort_code      ?? null,
                account_number: postFlipUmbPayload.account_number ?? null
              }
            });

            const savedUmb = await upsertCandidate(postFlipUmbPayload, idForUpdate).catch(err => {
              E('upsertCandidate after PAYEâ†’UMBRELLA flip failed', err);
              return null;
            });
            if (!savedUmb || !savedUmb.id) {
              alert('Pay-method changed, but failed to finalise UMBRELLA details. Please check and try again.');
              return { ok:false };
            }

            full = { ...full, ...savedUmb };
            try {
              window.modalCtx.data = { ...(window.modalCtx.data || {}), ...savedUmb };
              window.modalCtx.dbPayMethod = 'UMBRELLA';
            } catch (e) {
              W('failed to sync modalCtx.data/dbPayMethod after PAYEâ†’UMBRELLA flip', e);
            }

            L('[onSave] PAYEâ†’UMBRELLA change confirmed; closing candidate modal', {
              finalBank: {
                account_holder: window.modalCtx.data?.account_holder ?? null,
                bank_name:      window.modalCtx.data?.bank_name      ?? null,
                sort_code:      window.modalCtx.data?.sort_code      ?? null,
                account_number: window.modalCtx.data?.account_number ?? null
              }
            });

            const aliasResultFlipPU = await applyAliasDeletes(full.id || window.modalCtx.data?.id);
            if (!aliasResultFlipPU.ok) {
              return { ok:false };
            }

            return { ok:true, saved: window.modalCtx.data };

          } catch (err) {
            W('pay-method change flow (PAYEâ†’UMBRELLA) failed', err);
            alert(err?.message || 'Failed to process pay-method change.');
            return { ok:false };
          }
        }

        // â”€â”€ UMBRELLA â†’ PAYE special handling â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if (originalMethod === 'UMBRELLA' && newMethod === 'PAYE') {
          // Ensure dropdown shows the old method during the child modal
          try {
            const pmSel = document.querySelector('select[name="pay_method"]');
            if (pmSel && originalMethod) {
              pmSel.value = originalMethod;
            }
          } catch (err) {
            W('failed to reset pay_method select to originalMethod', err);
          }

          L('[onSave][FLIP Uâ†’P] starting UMBRELLAâ†’PAYE flow', {
            candidateId: full.id,
            originalMethod,
            newMethod,
            stagedPayBeforeModal: { ...(window.modalCtx?.formState?.pay || {}) }
          });

          try {
            const confirmed = await openCandidatePayMethodChangeModal(full, {
              originalMethod,
              newMethod,
              candidate_id: full.id
            });

            if (!confirmed) {
              L('[onSave] pay-method change cancelled or failed (UMBRELLAâ†’PAYE), keeping candidate modal open');
              return { ok:false };
            }

            window.modalCtx.__payFlipDone = true;

            // After backend change, we must now persist the *new PAYE bank details*.
            const idForUpdate2 = window.modalCtx?.data?.id || full?.id || null;

            // Re-read the staged Pay state in case anything changed between the first onSave and now.
            const fsAfter = window.modalCtx?.formState || {};
            const stagedPayAfter = fsAfter.pay || {};

            const postFlipPayePayload = {
              ...payload
            };

            // Prefer the freshest staged pay values for the PAYE bank fields
            if (Object.prototype.hasOwnProperty.call(stagedPayAfter, 'account_holder')) {
              postFlipPayePayload.account_holder = stagedPayAfter.account_holder;
            }
            if (Object.prototype.hasOwnProperty.call(stagedPayAfter, 'bank_name')) {
              postFlipPayePayload.bank_name = stagedPayAfter.bank_name;
            }
            if (Object.prototype.hasOwnProperty.call(stagedPayAfter, 'sort_code')) {
              postFlipPayePayload.sort_code = stagedPayAfter.sort_code;
            }
            if (Object.prototype.hasOwnProperty.call(stagedPayAfter, 'account_number')) {
              postFlipPayePayload.account_number = stagedPayAfter.account_number;
            }

            if (!postFlipPayePayload.umbrella_id) {
              postFlipPayePayload.umbrella_id = null;
            }
            postFlipPayePayload.pay_method = 'PAYE';

            for (const k of Object.keys(postFlipPayePayload)) {
              if (postFlipPayePayload[k] === '') delete postFlipPayePayload[k];
            }

            L('[onSave][FLIP Uâ†’P] postFlipPayePayload', {
              candidateId: idForUpdate2,
              bankFromStaged: {
                account_holder: stagedPayAfter.account_holder ?? null,
                bank_name:      stagedPayAfter.bank_name      ?? null,
                sort_code:      stagedPayAfter.sort_code      ?? null,
                account_number: stagedPayAfter.account_number ?? null
              },
              bankPersistedPayload: {
                account_holder: postFlipPayePayload.account_holder ?? null,
                bank_name:      postFlipPayePayload.bank_name      ?? null,
                sort_code:      postFlipPayePayload.sort_code      ?? null,
                account_number: postFlipPayePayload.account_number ?? null
              }
            });

            const savedPaye = await upsertCandidate(postFlipPayePayload, idForUpdate2).catch(err => {
              E('upsertCandidate after UMBRELLAâ†’PAYE flip failed', err);
              return null;
            });
            if (!savedPaye || !savedPaye.id) {
              alert('Pay-method changed, but failed to save new PAYE bank details. Please check and try again.');
              return { ok:false };
            }

            full = { ...full, ...savedPaye };
            try {
              window.modalCtx.data = { ...(window.modalCtx.data || {}), ...savedPaye };
              window.modalCtx.dbPayMethod = 'PAYE';
            } catch (e) {
              W('failed to sync modalCtx.data/dbPayMethod after UMBRELLAâ†’PAYE flip', e);
            }

            L('[onSave] UMBRELLAâ†’PAYE change confirmed; closing candidate modal', {
              finalBank: {
                account_holder: window.modalCtx.data?.account_holder ?? null,
                bank_name:      window.modalCtx.data?.bank_name      ?? null,
                sort_code:      window.modalCtx.data?.sort_code      ?? null,
                account_number: window.modalCtx.data?.account_number ?? null
              }
            });

            const aliasResultFlipUP = await applyAliasDeletes(full.id || window.modalCtx.data?.id);
            if (!aliasResultFlipUP.ok) {
              return { ok:false };
            }

            return { ok:true, saved: window.modalCtx.data };

          } catch (err) {
            W('pay-method change flow (UMBRELLAâ†’PAYE) failed', err);
            alert(err?.message || 'Failed to process pay-method change.');
            return { ok:false };
          }
        }

        // Fallback (should not usually hit here, but guard anyway)
        W('[onSave] flip detected with unsupported direction', { originalMethod, newMethod });
      }

      // â”€â”€ Normal save path (no PAYEâ†”UMBRELLA flip) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      // If we are saving as UMBRELLA in a non-flip scenario, always clear bank
      // details on the candidate record to avoid confusion with old PAYE data.
      if (payload.pay_method === 'UMBRELLA') {
        clearBankOnPayload(payload);
      }

      // Remove empty strings before sending
      for (const k of Object.keys(payload)) {
        if (payload[k] === '') delete payload[k];
      }

      // Sync Job Titles + Registration + DOB from candidateMainModel (unchanged)
      try {
        const cm = window.modalCtx?.candidateMainModel;
        if (cm && typeof cm === 'object') {
          let jobs = Array.isArray(cm.job_titles) ? cm.job_titles.slice() : [];
          jobs = jobs.filter(j => j && j.job_title_id);
          if (jobs.length) {
            let primaryIdx = jobs.findIndex(j => j.is_primary);
            if (primaryIdx === -1) primaryIdx = 0;
            jobs = jobs.map((j, idx) => ({
              ...j,
              is_primary: idx === primaryIdx
            }));
            if (primaryIdx !== 0) {
              const primary = jobs[primaryIdx];
              jobs.splice(primaryIdx, 1);
              jobs.unshift(primary);
            }
          }

          cm.job_titles = jobs;

          const jobIds = jobs.map(j => j.job_title_id).filter(Boolean);
          payload.job_titles   = jobIds;
          payload.job_title_id = jobIds.length ? jobIds[0] : null;

          if (Object.prototype.hasOwnProperty.call(cm, 'prof_reg_type')) {
            payload.prof_reg_type = cm.prof_reg_type || null;
          }
          if (Object.prototype.hasOwnProperty.call(cm, 'prof_reg_number')) {
            payload.prof_reg_number = cm.prof_reg_number || '';
          }
          if (Object.prototype.hasOwnProperty.call(cm, 'date_of_birth')) {
            payload.date_of_birth = cm.date_of_birth || null;
          }
        }
      } catch (err) {
        W('sync from candidateMainModel failed', err);
      }

      const idForUpdate = window.modalCtx?.data?.id || full?.id || null;
      const tokenAtSave = window.modalCtx.openToken;
      L('[onSave] upsertCandidate', {
        idForUpdate,
        payloadKeys: Object.keys(payload||{}),
        bankPayload: {
          account_holder: payload.account_holder ?? null,
          bank_name:      payload.bank_name      ?? null,
          sort_code:      payload.sort_code      ?? null,
          account_number: payload.account_number ?? null,
          pay_method:     payload.pay_method     ?? null,
          umbrella_id:    payload.umbrella_id    ?? null
        }
      });
      const saved = await upsertCandidate(payload, idForUpdate).catch(err => { E('upsertCandidate failed', err); return null; });
      const candidateId = idForUpdate || (saved && saved.id);
      L('[onSave] saved', {
        ok: !!saved,
        candidateId,
        savedKeys: Array.isArray(saved)?[]:Object.keys(saved||{}),
        savedBank: saved ? {
          account_holder: saved.account_holder ?? null,
          bank_name:      saved.bank_name      ?? null,
          sort_code:      saved.sort_code      ?? null,
          account_number: saved.account_number ?? null,
          pay_method:     saved.pay_method     ?? null,
          umbrella_id:    saved.umbrella_id    ?? null
        } : null
      });
      if (!candidateId) { alert('Failed to save candidate'); return { ok:false }; }

      // ===== validate & persist overrides (unchanged from your version) =====
      const O = window.modalCtx.overrides || { existing: [], stagedNew: [], stagedEdits: {}, stagedDeletes: new Set() };

      async function getCoveringDefault(client_id, role, band, date_from) {
        try {
          if (!client_id || !role || !date_from) return null;
          const list = await listClientRates(client_id, { active_on: date_from, only_enabled: true });
          const rows = Array.isArray(list) ? list.filter(w => !w.disabled_at_utc && String(w.role) === String(role)) : [];
          let win = rows.find(w => (w.band ?? null) === (band ?? null));
          if (!win && (band == null)) win = rows.find(w => w.band == null);
          return win || null;
        } catch { return null; }
      }
      const bucketLabel = { day:'Day', night:'Night', sat:'Sat', sun:'Sun', bh:'BH' };
      const erniMult = await (async ()=>{
        if (typeof window.__ERNI_MULT__ === 'number') return window.__ERNI_MULT__;
        try {
          if (typeof getSettingsCached === 'function') {
            const s = await getSettingsCached();
            let p = s?.erni_pct ?? s?.employers_ni_percent ?? 0;
            p = Number(p)||0;
            if (p>1) p=p/100;
            window.__ERNI_MULT__ = 1 + p;
            return window.__ERNI_MULT__;
          }
        } catch{}
        window.__ERNI_MULT__ = 1;
        return 1;
      })();

      // Validate EDITS
      for (const [editId, patchRaw] of Object.entries(O.stagedEdits || {})) {
        const original = (O.existing || []).find(x => String(x.id) === String(editId));
        if (!original) { alert('Cannot locate original override to validate'); return { ok:false }; }

        const eff = {
          client_id: patchRaw.client_id ?? original.client_id,
          role     : patchRaw.role      ?? original.role,
          band     : (patchRaw.hasOwnProperty('band') ? patchRaw.band : original.band),
          date_from: patchRaw.date_from ?? original.date_from,
          date_to  : patchRaw.hasOwnProperty('date_to') ? patchRaw.date_to : original.date_to,
          rate_type: (patchRaw.rate_type ?? original.rate_type ?? '').toUpperCase(),

          pay_day  : patchRaw.hasOwnProperty('pay_day')   ? patchRaw.pay_day   : original.pay_day,
          pay_night: patchRaw.hasOwnProperty('pay_night') ? patchRaw.pay_night : original.pay_night,
          pay_sat  : patchRaw.hasOwnProperty('pay_sat')   ? patchRaw.pay_sat   : original.pay_sat,
          pay_sun  : patchRaw.hasOwnProperty('pay_sun')   ? patchRaw.pay_sun   : original.pay_sun,
          pay_bh   : patchRaw.hasOwnProperty('pay_bh')    ? patchRaw.pay_bh    : original.pay_bh
        };

        const win = await getCoveringDefault(eff.client_id, eff.role, eff.band, eff.date_from);
        if (!win) { alert(`No active client default covers ${eff.role}${eff.band?` / ${eff.band}`:''} on ${formatIsoToUk(eff.date_from)}.`); return { ok:false }; }
        if (eff.date_to && win.date_to && eff.date_to > win.date_to) { alert(`Client rate ends on ${formatIsoToUk(win.date_to)} â€” override must end on or before this date.`); return { ok:false }; }

        for (const b of ['day','night','sat','sun','bh']) {
          const payB = eff[`pay_${b}`];
          const chg  = win[`charge_${b}`];
          if (payB != null && chg == null) { alert(`No client charge for ${bucketLabel[b]} on ${formatIsoToUk(eff.date_from)}.`); return { ok:false }; }
          if (payB != null && chg != null) {
            const margin = (eff.rate_type==='PAYE') ? (chg - (payB * erniMult)) : (chg - payB);
            if (margin < 0) { alert(`Margin would be negative for ${bucketLabel[b]}.`); return { ok:false }; }
          }
        }
      }

      // Validate NEW rows
      for (const nv of (O.stagedNew || [])) {
        const win = await getCoveringDefault(nv.client_id, nv.role, nv.band ?? null, nv.date_from);
        if (!win) { alert(`No active client default covers ${nv.role}${nv.band?` / ${nv.band}`:''} on ${formatIsoToUk(nv.date_from)}.`); return { ok:false }; }
        if (nv.date_to && win.date_to && nv.date_to > win.date_to) { alert(`Client rate ends on ${formatIsoToUk(win.date_to)} â€” override must end on or before this date.`); return { ok:false }; }
        for (const b of ['day','night','sat','sun','bh']) {
          const payB = nv[`pay_${b}`]; const chg = win[`charge_${b}`];
          if (payB != null && chg == null) { alert(`No client charge for ${bucketLabel[b]} on ${formatIsoToUk(win.date_from)}.`); return { ok:false }; }
          if (payB != null && chg != null) {
            const margin = (String(nv.rate_type).toUpperCase()==='PAYE') ? (chg - (payB * erniMult)) : (chg - payB);
            if (margin < 0) { alert(`Margin would be negative for ${bucketLabel[b]}.`); return { ok:false }; }
          }
        }
      }

      // ===== Persist staged overrides (DELETE uses routed path with candidate_id) =====
      const overridesRef = window.modalCtx.overrides || { existing: [], stagedNew: [], stagedEdits: {}, stagedDeletes: new Set() };
      L('[onSave] overrides', {
        deletes: Array.from(overridesRef.stagedDeletes || []),
        edits:   Object.keys(overridesRef.stagedEdits || {}),
        newCount: (overridesRef.stagedNew || []).length
      });

      // Deletes â€” preferred by id; fallback to legacy filter keys
      for (const delId of overridesRef.stagedDeletes || []) {
        const rowDel = (overridesRef.existing || []).find(r => String(r.id) === String(delId));
        if (!rowDel) continue;

        const q = new URLSearchParams();
        if (rowDel.id) q.set('id', String(rowDel.id));
        else {
          if (rowDel.client_id) q.set('client_id', String(rowDel.client_id));
          if (rowDel.role != null) q.set('role', String(rowDel.role));
          q.set('band', (rowDel.band == null || rowDel.band === '') ? '' : String(rowDel.band));
          if (rowDel.rate_type) q.set('rate_type', String(rowDel.rate_type).toUpperCase());
          if (rowDel.date_from) q.set('date_from', String(rowDel.date_from));
        }

        const urlDel = API(`/api/rates/candidate-overrides/${encodeURIComponent(candidateId)}?${q.toString()}`);
        L('[onSave][DELETE override]', urlDel);
        const resDel = await authFetch(urlDel, { method: 'DELETE' });
        if (!resDel.ok) {
          const msg = await resDel.text().catch(()=> 'Delete override failed');
          alert(msg);
          return { ok:false };
        }
      }

      // Edits â€” PATCH candidate_id in path + ORIGINAL keys in query, updates in body
      for (const [editId, patchRaw] of Object.entries(overridesRef.stagedEdits || {})) {
        const original = (overridesRef.existing || []).find(x => String(x.id) === String(editId));
        if (!original) { alert('Cannot locate original override to patch'); return { ok:false }; }

        const q = new URLSearchParams();
        if (original.client_id) q.set('client_id', original.client_id);
        if (original.role != null) q.set('role', String(original.role));
        q.set('band', (original.band == null || original.band === '') ? '' : String(original.band));
        if (original.rate_type) q.set('rate_type', String(original.rate_type).toUpperCase());

        const bodyPatch = {};
        for (const [k,v] of Object.entries(patchRaw || {})) {
          if (v === '' || v === undefined) continue;
          bodyPatch[k] = v;
        }
        bodyPatch.candidate_id = candidateId;

        const urlPatch = API(`/api/rates/candidate-overrides/${encodeURIComponent(candidateId)}?${q.toString()}`);
        L('[onSave][PATCH override]', { url: urlPatch, body: bodyPatch });
        const resPatch = await authFetch(urlPatch, {
          method:'PATCH',
          headers:{ 'content-type':'application/json' },
          body: JSON.stringify(bodyPatch)
        });
        if (!resPatch.ok) {
          const msg = await resPatch.text().catch(()=> 'Update override failed');
          alert(msg);
          return { ok:false };
        }
      }

      // Creates
      for (const nv of (overridesRef.stagedNew || [])) {
        if (!nv.client_id) { alert('Override must include client_id'); return { ok:false }; }
        const clean = {};
        for (const [k,v] of Object.entries(nv)) {
          if (k === '_tmpId' || v === '') continue;
          clean[k] = v;
        }
        const resCreate = await authFetch(
          API(`/api/rates/candidate-overrides`),
          { method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify({ ...clean, candidate_id: candidateId }) }
        );
        if (!resCreate.ok) {
          const msg = await resCreate.text().catch(()=> 'Create override failed');
          alert(msg);
          return { ok:false };
        }
      }

      // Refresh overrides list from server and clear staging
      try {
        const latest = await listCandidateRates(candidateId);
        if (tokenAtSave === window.modalCtx.openToken && window.modalCtx.data?.id === candidateId) {
          window.modalCtx.overrides.existing = Array.isArray(latest) ? latest : [];
          window.modalCtx.overrides.stagedEdits = {};
          window.modalCtx.overrides.stagedNew   = [];
          if (window.modalCtx.overrides.stagedDeletes?.clear) window.modalCtx.overrides.stagedDeletes.clear();
          const fr1 = window.__getModalFrame?.();
          if (fr1 && fr1.entity === 'candidates' && fr1.currentTabKey === 'rates') {
            await renderCandidateRatesTable();
          }
        }
      } catch (e) {
        W('post-save rates refresh failed', e);
      }

      // ===== Persist staged HR name alias deletions ========================
      const aliasResult = await applyAliasDeletes(candidateId);
      if (!aliasResult.ok) {
        return { ok:false };
      }

      const mergedRoles = (saved && saved.roles) || payload.roles || window.modalCtx.data?.roles || [];

      // Build a fresh job_titles array for modalCtx.data, based on the staged model
      let jobTitlesForCtx = [];
      try {
        const cm = window.modalCtx?.candidateMainModel;
        if (cm && Array.isArray(cm.job_titles)) {
          jobTitlesForCtx = cm.job_titles.map((t) => ({
            job_title_id: t.job_title_id,
            is_primary: !!t.is_primary
          }));
        } else if (Array.isArray(payload.job_titles)) {
          jobTitlesForCtx = payload.job_titles.map((id, idx) => ({
            job_title_id: id,
            is_primary: idx === 0
          }));
        }
      } catch (e) {
        W('onSave: building jobTitlesForCtx failed', e);
      }

      window.modalCtx.data = {
        ...(window.modalCtx.data || {}),
        ...(saved || {}),
        id: candidateId,
        roles: mergedRoles,
        job_titles: jobTitlesForCtx
      };
      window.modalCtx.formState  = { __ForId: candidateId, main: {}, pay: {} };
      window.modalCtx.rolesState = mergedRoles;

      // ðŸ”¹ Keep dbPayMethod in sync with the latest persisted value (if any)
      try {
        const persistedPm = window.modalCtx.data?.pay_method || null;
        window.modalCtx.dbPayMethod = persistedPm ? String(persistedPm).toUpperCase() : null;
      } catch {}

      L('[onSave] final window.modalCtx', {
        dataId: window.modalCtx.data?.id,
        rolesCount: Array.isArray(window.modalCtx.data?.roles) ? window.modalCtx.data.roles.length : 0,
        formStateForId: window.modalCtx.formState?.__ForId,
        dbPayMethod: window.modalCtx.dbPayMethod,
        finalBank: {
          account_holder: window.modalCtx.data?.account_holder ?? null,
          bank_name:      window.modalCtx.data?.bank_name      ?? null,
          sort_code:      window.modalCtx.data?.sort_code      ?? null,
          account_number: window.modalCtx.data?.account_number ?? null
        }
      });

      if (isNew) window.__pendingFocus = { section: 'candidates', ids: [candidateId], primaryIds:[candidateId] };

      return { ok: true, saved: window.modalCtx.data };

    },
    full?.id,
    () => {
      const fr = window.__getModalFrame?.();
      const isBookings = fr && fr.entity === 'candidates' && fr.currentTabKey === 'bookings';
      const candId = window.modalCtx?.data?.id;
      if (isBookings && candId) {
        try { renderCandidateCalendarTab(candId); } catch (e) { W('renderCandidateCalendarTab failed', e); }
      }
    }
  );
  L('showModal returned (sync)', { currentOpenToken: window.modalCtx.openToken });

  // 4) Optional async companion loads (unchanged)
  if (full?.id) {
    const token = window.modalCtx.openToken;
    const id    = full.id;

    try {
      L('[listCandidateRates] GET', { id, token });
      const existing = await listCandidateRates(id);
      L('[listCandidateRates] result', { count: Array.isArray(existing) ? existing.length : -1, sameToken: token === window.modalCtx.openToken, modalCtxId: window.modalCtx.data?.id });
      if (token === window.modalCtx.openToken && window.modalCtx.data?.id === id) {
        window.modalCtx.overrides.existing = Array.isArray(existing) ? existing : [];
        const fr2 = window.__getModalFrame?.();
        if (fr2 && fr2.entity === 'candidates' && fr2.currentTabKey === 'rates') {
          await renderCandidateRatesTable();
        }
      }
    } catch (e) { E('listCandidateRates failed', e); }
  } else {
    L('skip companion loads (no full.id)');
  }
}


// ====================== mountCandidatePayTab (FIXED) ======================
// FRONTEND â€” UPDATED
// mountCandidatePayTab: also keeps Account Holder in sync with umbrella name when UMNRELLA pay.
// ================== FIXED: openUmbrella (hydrate before showModal) ==================

async function renderCandidateRatesTable() {
  const LOG = !!window.__LOG_RATES;

  // Safety net: auto-create #ratesTable if missing
  let div = byId('ratesTable');
  if (!div) {
    const host = byId('modalBody');
    if (host) {
      div = document.createElement('div');
      div.id = 'ratesTable';
      host.appendChild(div);
      if (LOG) console.warn('[RATES][TABLE] created missing #ratesTable');
    } else {
      if (LOG) console.warn('[RATES][TABLE] no #ratesTable and no #modalBody; abort');
      return;
    }
  }

  const frame = _currentFrame();
  const parentEditable = frame && (frame.mode === 'edit' || frame.mode === 'create');
  if (LOG) console.log('[RATES][TABLE] parentEditable?', parentEditable, 'mode:', frame?.mode);

  // Resolve client names
  let clientsById = {};
  try {
    const clients = await listClientsBasic();
    clientsById = Object.fromEntries((clients || []).map(c => [c.id, c.name]));
  } catch (e) { console.error('[RATES][TABLE] load clients failed', e); }

  const O = (window.modalCtx.overrides ||= { existing: [], stagedNew: [], stagedEdits: {}, stagedDeletes: new Set() });

  if (LOG) console.log('[RATES][TABLE snapshot]', {
    existing: (O.existing||[]).length,
    stagedNew: (O.stagedNew||[]).length,
    stagedEdits: Object.keys(O.stagedEdits||{}).length,
    stagedDeletes: (O.stagedDeletes && O.stagedDeletes.size) || 0,
    peekExisting: (O.existing||[])[0],
    peekNew: (O.stagedNew||[])[0]
  });

  // Merge view
  const pendingDeleteIds = (O.stagedDeletes instanceof Set) ? O.stagedDeletes : new Set();

  const rows = [];
  for (const ex of (O.existing || [])) {
    const isPendingDelete = !!(pendingDeleteIds && ex && pendingDeleteIds.has(ex.id));
    rows.push({
      ...ex,
      ...(O.stagedEdits?.[ex.id] || {}),
      _edited: !!O.stagedEdits?.[ex.id],
      _pendingDelete: isPendingDelete
    });
  }
  for (const n of (O.stagedNew || [])) rows.push({ ...n, _isNew: true });

  if (!rows.length) {
    div.innerHTML = `
      <div class="hint" style="margin-bottom:8px">No candidate-specific overrides. Client defaults will apply.</div>
      <div class="actions">
        <button id="btnAddRate" class="btn mini"${parentEditable ? '' : ' disabled'}>
          Add rate override
        </button>
        ${parentEditable
          ? '<span class="hint">Changes are staged. Click â€œSaveâ€ in the main dialog to persist.</span>'
          : '<span class="hint">Read-only. Click â€œEditâ€ in the main dialog to add/modify overrides.</span>'}
      </div>
    `;
    const addBtn = byId('btnAddRate');
    if (addBtn && parentEditable) addBtn.onclick = () => openCandidateRateModal(window.modalCtx.data?.id);
    if (LOG) console.log('[RATES][TABLE] rendered empty view');
    return;
  }

  const fmt = v => (v==null || Number.isNaN(v)) ? 'â€”' : (Math.round(v*100)/100).toFixed(2);
  const mult = await (async ()=>{ if (typeof window.__ERNI_MULT__ === 'number') return window.__ERNI_MULT__; try { if (typeof getSettingsCached === 'function') { const s = await getSettingsCached(); let p = s?.erni_pct ?? s?.employers_ni_percent ?? 0; p = Number(p)||0; if (p>1) p=p/100; window.__ERNI_MULT__ = 1 + p; return window.__ERNI_MULT__; } } catch{} window.__ERNI_MULT__ = 1; return 1; })();

  const keyOf = r => [r.client_id, r.role || '', (r.band==null?'':String(r.band)), r.date_from || ''].join('|');
  const uniqueKeys = Array.from(new Set(rows.map(keyOf)));
  const chargeMap = Object.create(null);

  async function loadChargesForKey(key){
    const [client_id, role, bandKey, date_from] = key.split('|');
    const band = (bandKey === '' ? null : bandKey);
    if (!client_id || !role || !date_from) return null;
    try {
      const list = await listClientRates(client_id, { active_on: date_from, only_enabled: true });
      const filtered = Array.isArray(list) ? list.filter(w=>!w.disabled_at_utc && w.role===role) : [];
      let win = filtered.find(w => (w.band ?? null) === (band ?? null));
      if (!win && (band == null)) win = filtered.find(w => w.band == null);
      return win ? {
        day:   win.charge_day   ?? null,
        night: win.charge_night ?? null,
        sat:   win.charge_sat   ?? null,
        sun:   win.charge_sun   ?? null,
        bh:    win.charge_bh    ?? null
      } : null;
    } catch(e){ return null; }
  }
  await Promise.all(uniqueKeys.map(async k => { chargeMap[k] = await loadChargesForKey(k); }));

  // === NEW: check whether a covering client default exists TODAY (Europe/London), per (client,role,band)
  const todayIso = (() => {
    try {
      const s = new Intl.DateTimeFormat('en-GB', { timeZone: 'Europe/London', year:'numeric', month:'2-digit', day:'2-digit' }).format(new Date());
      const [dd, mm, yyyy] = s.split('/');
      return `${yyyy}-${mm}-${dd}`;
    } catch { // fallback
      const d = new Date(); const y = d.getFullYear(), m = String(d.getMonth()+1).padStart(2,'0'), day = String(d.getDate()).padStart(2,'0');
      return `${y}-${m}-${day}`;
    }
  })();
  const todayKeyOf = r => [r.client_id, r.role || '', (r.band==null?'':String(r.band))].join('|');
  const todayKeys = Array.from(new Set(rows.map(todayKeyOf)));
  const coverTodayMap = Object.create(null);
  async function loadCoverTodayForKey(key){
    const [client_id, role, bandKey] = key.split('|');
    const band = (bandKey === '' ? null : bandKey);
    if (!client_id || !role) return false;
    try {
      const list = await listClientRates(client_id, { active_on: todayIso, only_enabled: true });
      const filtered = Array.isArray(list) ? list.filter(w=>!w.disabled_at_utc && w.role===role) : [];
      let win = filtered.find(w => (w.band ?? null) === (band ?? null));
      if (!win && (band == null)) win = filtered.find(w => w.band == null);
      return !!win;
    } catch(e){ return false; }
  }
  await Promise.all(todayKeys.map(async k => { coverTodayMap[k] = await loadCoverTodayForKey(k); }));

  const cols    = ['client','role','band','rate_type','pay_day','pay_night','pay_sat','pay_sun','pay_bh','margin_day','margin_night','margin_sat','margin_sun','margin_bh','date_from','date_to','_state'];
  const headers = ['Client','Role','Band','Type','Pay Day','Pay Night','Pay Sat','Pay Sun','Pay BH','Margin Day','Margin Night','Margin Sat','Margin Sun','Margin BH','From','To','Status'];

  const tbl = document.createElement('table'); tbl.className = 'grid';
  const thead = document.createElement('thead'); const trh = document.createElement('tr');
  headers.forEach(h => { const th=document.createElement('th'); th.textContent=h; trh.appendChild(th); });
  thead.appendChild(trh); tbl.appendChild(thead);

  const tb = document.createElement('tbody');
  rows.forEach(r => {
    const tr = document.createElement('tr');
    if (parentEditable) tr.ondblclick = () => openCandidateRateModal(window.modalCtx.data?.id, r);

    const charges = chargeMap[keyOf(r)] || null;
    const isPAYE = String(r.rate_type || '').toUpperCase() === 'PAYE';

    const margin = {};
    ['day','night','sat','sun','bh'].forEach(b=>{
      const pay = r[`pay_${b}`]; const chg = charges ? charges[b] : null;
      margin[b] = (chg!=null && pay!=null) ? (isPAYE ? (chg - (pay * mult)) : (chg - pay)) : null;
    });

    let status =
      r._pendingDelete ? 'Pending delete (save to confirm)' :
      r._isNew        ? 'Staged (new)' :
      r._edited       ? 'Staged (edited)' : '';

    // Determine stale/orphan: (a) no covering client rate at override start OR (b) no covering client rate today
    const hasCoverAtStart = !!charges;
    const hasCoverToday = !!coverTodayMap[todayKeyOf(r)];
    const isStaleOrphan = (!hasCoverAtStart) || (!hasCoverToday);
    if (isStaleOrphan) status = 'Client rate no longer exists';

    // pay columns to 2dp
    const to2 = (v) => (v==null ? 'â€”' : fmt(Number(v)));

    const pretty = {
      client: clientsById[r.client_id] || '', role: r.role || '', band: r.band ?? '', rate_type: r.rate_type || '',
      pay_day: to2(r.pay_day), pay_night: to2(r.pay_night), pay_sat: to2(r.pay_sat), pay_sun: to2(r.pay_sun), pay_bh: to2(r.pay_bh),
      margin_day: fmt(margin.day), margin_night: fmt(margin.night), margin_sat: fmt(margin.sat), margin_sun: fmt(margin.sun), margin_bh: fmt(margin.bh),
      date_from: formatDisplayValue('date_from', r.date_from), date_to: formatDisplayValue('date_to', r.date_to),
      _state   : status
    };

    cols.forEach(c => { const td=document.createElement('td'); td.textContent=String(pretty[c] ?? ''); tr.appendChild(td); });

    // Shade & disable open if stale/orphan
    if (isStaleOrphan) {
      tr.style.opacity = '.55';
      tr.style.cursor = 'not-allowed';
      tr.ondblclick = null;
    }

    tb.appendChild(tr);
  });
  tbl.appendChild(tb);

  const actions = document.createElement('div');
  actions.className = 'actions';
  actions.innerHTML = `
    <button id="btnAddRate" class="btn mini"${parentEditable ? '' : ' disabled'}>
      Add rate override
    </button>
    ${parentEditable
      ? '<span class="hint">Changes are staged. Click â€œSaveâ€ in the main dialog to persist.</span>'
      : '<span class="hint">Read-only. Click â€œEditâ€ in the main dialog to add/modify overrides.</span>'}
  `;

  div.innerHTML = '';
  div.appendChild(tbl);
  div.appendChild(actions);

  const addBtn = byId('btnAddRate');
  if (addBtn && parentEditable) addBtn.onclick = () => openCandidateRateModal(window.modalCtx.data?.id);

  if (LOG) console.log('[RATES][TABLE rendered]', { rows: rows.length, firstState: rows[0]?._state || '(none)' });
}



// Replaces your current function
// =================== renderCandidateRatesTable (FIXED) ===================
// =================== CANDIDATE RATES TABLE (UPDATED) ===================
// âœ… UPDATED â€” renders from modalCtx.overrides (existing âŠ• staged edits/new âŠ– staged deletes)

// ==================================
// 2) renderCandidateRatesTable(...)
// ==================================
// Now computes margins for each override row by resolving client charges at date_from (memoized per render)



// === UPDATED: Candidate modal tabs (adds Roles editor placeholder on 'main') ===


// === DIRTY NAVIGATION GUARDS (add) ===
function isAnyModalDirty(){
  const st = window.__modalStack || [];
  return st.some(f => f && f.isDirty);
}
// ==================== discardAllModalsAndState (kept with geometry reset) ====================

function discardAllModalsAndState(){
  try {
    if (modalCtx && modalCtx._rolesUpdatedHandler) {
      window.removeEventListener('global-roles-updated', modalCtx._rolesUpdatedHandler);
      modalCtx._rolesUpdatedHandler = undefined;
    }
    if (modalCtx && modalCtx._payMethodChangedHandler) {
      window.removeEventListener('pay-method-changed', modalCtx._payMethodChangedHandler);
      modalCtx._payMethodChangedHandler = undefined;
    }
  } catch (e) {
    console.warn('[MODAL] listener cleanup failed', e);
  }

  // Detach any remaining frame-level listeners (dirty/global) from all frames
  try {
    if (Array.isArray(window.__modalStack)) {
      while (window.__modalStack.length) {
        const fr = window.__modalStack.pop();
        if (fr && fr._detachDirty)  { try { fr._detachDirty();  } catch(_) {} }
        if (fr && fr._detachGlobal) { try { fr._detachGlobal(); } catch(_) {} }
      }
    }
  } catch (_) {}

  // Clear any staged calendar changes for open contracts (defensive sweep)
  try {
    if (window.__calStage && typeof clearContractCalendarStageState === 'function') {
      for (const contractId of Object.keys(window.__calStage)) {
        try { clearContractCalendarStageState(contractId); } catch {}
      }
    }
  } catch (e) {
    console.warn('[MODAL] calendar stage cleanup failed', e);
  }

  // Reset modal geometry to prevent "snap to right" on the next open
  const modal = byId('modal');
  if (modal) {
    modal.style.position = '';
    modal.style.left = '';
    modal.style.top = '';
    modal.style.right = '';
    modal.style.bottom = '';
    modal.style.transform = '';
    modal.classList.remove('dragging');
    // Cancel any document-level drag handlers that might still be live
    document.onmousemove = null;
    document.onmouseup   = null;
  }

  // ðŸ”’ Clear any hidden modal DOM so stale inputs can't be read on next open
  const modalBody = document.getElementById('modalBody');
  if (modalBody) modalBody.replaceChildren();
  const modalTabs = document.getElementById('modalTabs');
  if (modalTabs) modalTabs.replaceChildren();
    const modalTitle = document.getElementById('modalTitle');
  if (modalTitle) modalTitle.textContent = '';

  // Clear any lingering bottom-right hint
  const modalHint = document.getElementById('modalHint');
  if (modalHint) {
    modalHint.textContent = '';
    modalHint.removeAttribute('data-tone');
    try { modalHint.classList.remove('ok', 'warn', 'err'); } catch {}
  }

  // Reset modal context
  modalCtx = {
    entity: null, data: null,
    formState: null, rolesState: null,
    ratesState: null, hospitalsState: null,
    clientSettingsState: null,
    openToken: null
  };

  // Hide overlay last
  const back = document.getElementById('modalBack');
  if (back) back.style.display = 'none';

  console.debug('[MODAL] hard reset complete');
}



function confirmDiscardChangesIfDirty(){
  if (!isAnyModalDirty()) return true; // not dirty â†’ acts as plain "Close" guard
  const ok = window.confirm('You have unsaved changes. Discard them and continue?');
  if (!ok) return false;

  // Sanitize geometry before teardown
  const m = byId('modal');
  if (m) {
    m.style.position = '';
    m.style.left = '';
    m.style.top = '';
    m.style.right = '';
    m.style.bottom = '';
    m.style.transform = '';
    m.classList.remove('dragging');
  }
  document.onmousemove = null;
  document.onmouseup   = null;

  // Discard also clears any staged calendar changes (handled inside)
  discardAllModalsAndState();
  return true;
}


async function commitContractCalendarStageIfPending(contractId) {
  const LOG_CAL = (typeof window.__LOG_CAL === 'boolean') ? window.__LOG_CAL : true;
  const L = (...a)=> { if (LOG_CAL) console.log('[CAL][commitIfPending]', ...a); };
  const W = (...a)=> { if ( LOG_CAL) console.warn('[CAL][commitIfPending]', ...a); };
  const E = (...a)=> { if ( LOG_CAL) console.error('[CAL][commitIfPending]', ...a); };

  try {
    const st = getContractCalendarStageState(contractId);
    const hasPending =
      !!st &&
      (st.add.size || st.remove.size || Object.keys(st.additional||{}).length || !!st.removeAll);
    if (!hasPending) {
      L('no pending calendar changes');
      return { ok: true, detail: 'no-op', removedAll: false };
    }

    // Build ranges + symmetry metadata
    const {
      addRanges,
      removeRanges,
      additionals,
      removeAll,
      needsLeftExtend,
      leftEdgeDate,
      rightEdgeDate
    } = buildPlanRangesFromStage(contractId);

    L('ranges from stage', { addRanges, removeRanges, additionals, removeAll });

    // Pull current contract & window from modal
    const contract     = (window.modalCtx && window.modalCtx.data) ? window.modalCtx.data : {};
    const contractStart = contract?.start_date   || null;
    const contractEnd   = contract?.end_date     || null;
    const candidateId   = contract?.candidate_id || null;

    // Special case: "remove all unsubmitted weeks" â†’ single bulk unplan then exit.
    if (removeAll) {
      if (removeRanges.length) {
        const payload = {
          when_timesheet_exists: 'skip',
          empty_week_action: 'delete',   // hard delete empty weeks
          ranges: removeRanges           // expect [{ from, to, days: [] }]
        };
        L('DELETE /plan-ranges (removeAll, IfPending)', payload);
        try {
          const resp = await contractsUnplanRanges(contractId, payload);
          L('DELETE /plan-ranges (removeAll, IfPending) â†', resp);
        } catch (err) {
          E('unplan-ranges (removeAll, IfPending) failed', err);
          return { ok: false, message: err?.message || 'Calendar commit failed', removedAll: true };
        }
      } else {
        L('removeAll=true but no removeRanges built (IfPending)');
      }

      // Stage will be completely rebuilt by next view; normalizeContractWindowToShifts
      // will run after this from the caller.
      try { clearContractCalendarStageState(contractId); } catch {}
      L('calendar commit ok (removeAll, IfPending)');
      return { ok: true, detail: 'calendar saved', removedAll: true };
    }

    // Optional preflight overlap check when extending left
    if (needsLeftExtend && candidateId) {
      const newStart = leftEdgeDate && contractStart ? (leftEdgeDate < contractStart ? leftEdgeDate : contractStart)
                                                     : (leftEdgeDate || contractStart);
      const newEnd   = rightEdgeDate && contractEnd ? (rightEdgeDate > contractEnd ? rightEdgeDate : contractEnd)
                                                    : (rightEdgeDate || contractEnd || newStart);

      const payload = {
        candidate_id:       candidateId,
        start_date:         newStart,
        end_date:           newEnd,
        ignore_contract_id: contractId
      };

      L('preflight overlap check', payload);
      const overlapRes = await authFetch(API('/api/contracts/check-overlap'), {
        method: 'POST',
        headers: { 'Content-Type':'application/json' },
        body: JSON.stringify(payload)
      });

      // authFetch returns JSON
      if (!overlapRes || overlapRes.error) {
        const msg = overlapRes?.error || 'Overlap check failed';
        console.warn('[CAL][commitIfPending] overlap preflight failed', msg);
        return { ok: false, message: msg, removedAll: false };
      }

      if (overlapRes.has_overlap) {
        const first = Array.isArray(overlapRes.overlaps) && overlapRes.overlaps[0] ? overlapRes.overlaps[0] : null;
        const baseMsg = first
          ? `This extension overlaps ${first.client_name} (${first.role}${first.band ? ' Band ' + first.band : ''}) window ${first.existing_start_date} â†’ ${first.existing_end_date}.`
          : 'This extension overlaps an existing contract window.';
        const proceed = confirm(`${baseMsg}\n\nProceed anyway and save with overlapping windows?`);
        if (!proceed) {
          L('overlap preflight: user cancelled save');
          return { ok: false, message: 'User cancelled due to overlap', removedAll: false, cancelled: true };
        }
        L('overlap preflight: user confirmed proceed');
      }
    }

    // === PLAN (adds) ===
    if (Array.isArray(addRanges) && addRanges.length) {
      const payload = {
        extend_contract_window: true,
        ranges: addRanges
      };
      L('POST /plan-ranges (IfPending)', { ranges: payload.ranges.length, extend_contract_window: true });
      try {
        const resp = await contractsPlanRanges(contractId, payload);
        L('POST /plan-ranges (IfPending) â†', resp);
      } catch (err) {
        E('plan-ranges (IfPending) failed', err);
        return { ok: false, message: err?.message || 'Calendar commit failed', removedAll: false };
      }
    } else {
      L('No addRanges to commit (IfPending)');
    }

    // === UNPLAN (removals) ===
    if (Array.isArray(removeRanges) && removeRanges.length) {
      const payload = {
        when_timesheet_exists: 'skip',
        empty_week_action: 'cancel',   // clear weeks + mark CANCELLED
        ranges: removeRanges
      };
      L('DELETE /plan-ranges (IfPending)', { ranges: payload.ranges.length });
      try {
        const resp = await contractsUnplanRanges(contractId, payload);
        L('DELETE /plan-ranges (IfPending) â†', resp);
      } catch (err) {
        E('unplan-ranges (IfPending) failed', err);
        return { ok: false, message: err?.message || 'Calendar commit failed', removedAll: false };
      }
    } else {
      L('No removeRanges to commit (IfPending)');
    }

    // === ADDITIONALS (split weeks) ===
    if (Array.isArray(additionals) && additionals.length) {
      L('Committing additional weeksâ€¦ (IfPending)', { count: additionals.length });
      for (const g of additionals) {
        try {
          L('Create additional for baseWeekId (IfPending)', g.baseWeekId, 'dates=', g.dates);
          const addRow = await contractWeekCreateAdditional(g.baseWeekId);
          L('additional created (IfPending) â†', addRow);
          const payload = { add: g.dates.map(d => ({ date: d })), merge: 'append' };
          L('PATCH /contract-weeks/:id/plan (IfPending)', { week_id: addRow.id, payload });
          const resp = await contractWeekPlanPatch(addRow.id, payload);
          L('PATCH /contract-weeks/:id/plan (IfPending) â†', resp);
        } catch (err) {
          E('additional week flow (IfPending) failed', err);
          return { ok: false, message: err?.message || 'Calendar commit failed', removedAll: false };
        }
      }
    } else {
      L('No additionals to commit (IfPending)');
    }

    // Optimistic in-memory window nudge (for immediate UI consistency)
    try {
      if (window.modalCtx && window.modalCtx.data) {
        if (leftEdgeDate && (!window.modalCtx.data.start_date || leftEdgeDate < window.modalCtx.data.start_date)) {
          window.modalCtx.data.start_date = leftEdgeDate;
        }
        if (rightEdgeDate && (!window.modalCtx.data.end_date || rightEdgeDate > window.modalCtx.data.end_date)) {
          window.modalCtx.data.end_date = rightEdgeDate;
        }
      }
    } catch {}

    // Clear staged state after a successful commit
    try { clearContractCalendarStageState(contractId); } catch {}

    L('calendar commit ok (IfPending)');
    return { ok: true, detail: 'calendar saved', removedAll: false };

  } catch (e) {
    console.warn('[CAL][commitIfPending] failed', e);
    return { ok: false, message: e?.message || 'Calendar commit failed', removedAll: false };
  }
}



// Stage a full-window delete of all TS-free weeks (committed on Save).
async function removeAllUnsubmittedWeeks(contractId, bounds) {
  const LOG_CAL = (typeof window.__LOG_CAL === 'boolean') ? window.__LOG_CAL : true;
  const L = (...a)=> { if (LOG_CAL) console.log('[CAL][removeAllUnsubmittedWeeks]', ...a); };

  const st = getContractCalendarStageState(contractId);

  const rawFrom = bounds?.from || window.modalCtx?.data?.start_date || null;
  const rawTo   = bounds?.to   || window.modalCtx?.data?.end_date   || null;

  const fromIso = (!rawFrom ? null : (rawFrom.includes('/') && typeof parseUkDateToIso === 'function') ? (parseUkDateToIso(rawFrom) || rawFrom) : rawFrom);
  const toIso   = (!rawTo   ? null : (rawTo.includes('/')   && typeof parseUkDateToIso === 'function') ? (parseUkDateToIso(rawTo)   || rawTo)   : rawTo);

  const wew = (window.modalCtx?.data?.week_ending_weekday_snapshot ?? 0);
  const endFrom = computeWeekEnding(fromIso || window.modalCtx?.data?.start_date, wew);
  const startFrom = addDays(endFrom, -6);
  const endTo = computeWeekEnding(toIso || window.modalCtx?.data?.end_date, wew);

  st.removeAll = { from: startFrom, to: endTo };
  st.remove.clear?.();
  st.add.clear?.();
  st.additional = {};

  L('staged removeAll', st.removeAll);
  try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
  return { ok: true, staged: true, bounds: st.removeAll };
}

// After a "remove-all" commit, rebound the contract dates to actuals
// Rule: if any timesheets exist => (start=min_ts, end=max_ts)
//       else => (end = start) leave start as-is.


async function normalizeContractWindowToShifts(contractId) {
  try {
    const r = await authFetch(API(`/api/contracts/${encodeURIComponent(contractId)}`), { method:'GET' });
    const data = await r.json().catch(()=>null);
    const contract = data?.contract || data || {};
    const currStart = contract.start_date || null;
    const currEnd   = contract.end_date   || null;
    if (!currStart || !currEnd) return { ok:false, reason:'no-window' };

    let minTs = null, maxTs = null;
    try {
      const bRes = await authFetch(API(`/api/contracts/check-timesheet-boundary`), {
        method:'POST',
        headers: { 'content-type':'application/json' },
        body: JSON.stringify({ contract_id: contractId, start_date: currStart, end_date: currEnd })
      });
      const b = await bRes.json().catch(()=>null);
      if (b) { minTs = b.min_ts_date || null; maxTs = b.max_ts_date || null; }
    } catch {}

    let newStart = currStart;
    let newEnd   = currEnd;

    if (minTs && maxTs) {
      newStart = minTs;
      newEnd   = maxTs;
    } else {
      try {
        const dRes = await authFetch(API(`/api/contracts/${encodeURIComponent(contractId)}/calendar?from=${encodeURIComponent(currStart)}&to=${encodeURIComponent(currEnd)}&granularity=day`), { method:'GET' });
        const d = await dRes.json().catch(()=>null);
        const items = Array.isArray(d?.items) ? d.items : [];
        const plannedDates = items
          .filter(it => String(it?.state||'').toUpperCase() === 'PLANNED')
          .map(it => it?.date)
          .filter(Boolean)
          .sort();
        if (plannedDates.length) {
          newStart = plannedDates[0];
          newEnd   = plannedDates[plannedDates.length - 1];
        } else {
          newEnd = currStart;
        }
      } catch {
        newEnd = currStart;
      }
    }

    if (newStart !== currStart || newEnd !== currEnd) {
      const payload = { id: contractId, start_date: newStart, end_date: newEnd };
      const saved = await upsertContract(payload, contractId);
      const savedContract = saved?.contract || saved || null;
      if (savedContract) {
        try { window.modalCtx.data = savedContract; } catch {}
        try {
          const fs = (window.modalCtx.formState ||= { __forId: (contractId || null), main:{}, pay:{} });
          fs.main ||= {};
          fs.main.start_date = savedContract.start_date || newStart;
          fs.main.end_date   = savedContract.end_date   || newEnd;
          const fr = window.__getModalFrame?.();
          const currentTab = fr?.currentTabKey || (document.querySelector('#modalTabs button.active')?.textContent?.toLowerCase() || '');
          if (currentTab === 'main' && typeof fr?.setTab === 'function') fr.setTab('main');
        } catch {}
      }
      return { ok:true, start_date: newStart, end_date: newEnd, changed:true };
    }

    return { ok:true, start_date: newStart, end_date: newEnd, changed:false };
  } catch (e) {
    return { ok:false, error: e?.message || String(e) };
  }
}



// ====================== mountCandidateRatesTab (FIXED) ======================
// =================== MOUNT CANDIDATE RATES TAB (unchanged flow) ===================

// ==============================
// 3) mountCandidateRatesTab(...)
// ==============================

// === UPDATED: Candidate Rate Override modal (Clientâ†’Role gated; bands; UK dates; date_to) ===
// ====================== openCandidateRateModal (FIXED) ======================
// =================== CANDIDATE OVERRIDE MODAL (UPDATED) ===================
// ==== CHILD MODAL (CANDIDATE RATE) â€” throw on errors; return true on success ====
// âœ… UPDATED â€” Apply (stage), gate against client defaults active at date_from,
//    auto-truncate incumbent of same rate_type at Nâˆ’1 (staged), NO persistence here
async function mountCandidateRatesTab() {
  const LOG = !!window.__LOG_RATES;
  const token = window.modalCtx.openToken;
  const id    = window.modalCtx.data?.id || null;
  if (LOG) console.log('[RATES][mountCandidateRatesTab] ENTRY', { token, id });

  // Ensure a host exists (only on Rates tab; this function is called from showModal setTab('rates'))
  const host = byId('modalBody');
  if (host && !byId('ratesTable')) {
    const c = document.createElement('div');
    c.id = 'ratesTable';
    host.appendChild(c);
    if (LOG) console.log('[RATES][mountCandidateRatesTab] injected #ratesTable host');
  }

  // CREATE flow
  if (!id) {
    window.modalCtx.overrides = window.modalCtx.overrides || { existing: [], stagedNew: [], stagedEdits: {}, stagedDeletes: new Set() };
    await renderCandidateRatesTable();
    if (LOG) console.log('[RATES][mountCandidateRatesTab] create-flow render (no id)');

    const btn = byId('btnAddRate');
    const frame = _currentFrame();
    if (btn && frame && (frame.mode === 'edit' || frame.mode === 'create')) btn.onclick = () => openCandidateRateModal(window.modalCtx.data?.id);
    return;
  }

  // EDIT flow â€” refresh ONLY existing; preserve stagedNew/Edits/Deletes
  const rates = await listCandidateRates(id);
  if (token !== window.modalCtx.openToken || window.modalCtx.data?.id !== id) {
    if (LOG) console.warn('[RATES][mountCandidateRatesTab] token/id changed mid-flight');
    return;
  }

  const O = window.modalCtx.overrides || (window.modalCtx.overrides = { existing: [], stagedNew: [], stagedEdits: {}, stagedDeletes: new Set() });
  if (Array.isArray(rates)) O.existing = rates.slice();

  await renderCandidateRatesTable();
  if (LOG) console.log('[RATES][mountCandidateRatesTab] renderCandidateRatesTable() called');

  const btn = byId('btnAddRate');
  const frame = _currentFrame();
  if (btn && frame && (frame.mode === 'edit' || frame.mode === 'create')) btn.onclick = () => openCandidateRateModal(window.modalCtx.data?.id);
}

// Mount logic for Contracts â†’ Rates tab (hide/show groups, compute margins, handle preset buttons)

function mountContractRatesTab() {
  const root = byId('contractRatesTab'); if (!root) return;

  const form = document.querySelector('#contractForm');
  const payMethodSel = form?.querySelector('select[name="pay_method_snapshot"], select[name="default_pay_method_snapshot"]');

  // Helper: normalise to 2dp if numeric, leave as-is otherwise
  const normaliseRateInput = (el) => {
    if (!el) return;
    let v = (el.value || '').trim();
    if (!v) return;
    const n = Number(v);
    if (!Number.isFinite(n)) return;
    const fixed = n.toFixed(2);
    if (fixed !== v) {
      el.value = fixed;
    }
  };

  try {
    const fs = (window.modalCtx.formState ||= { __forId:(window.modalCtx.data?.id ?? window.modalCtx.openToken ?? null), main:{}, pay:{} });
    if (!fs.pay || Object.keys(fs.pay).length === 0) {
      const saved = (window.modalCtx.data && window.modalCtx.data.rates_json) || {};
      const buckets = ['paye_day','paye_night','paye_sat','paye_sun','paye_bh','umb_day','umb_night','umb_sat','umb_sun','umb_bh','charge_day','charge_night','charge_sat','charge_sun','charge_bh'];
      fs.pay = fs.pay || {};
      for (const k of buckets) {
        const v = saved[k];
        if (v === 0 || (typeof v === 'number' && Number.isFinite(v))) {
          // store as 2dp string
          fs.pay[k] = Number(v).toFixed(2);
        }
      }
    }
  } catch {}

  const toggleCards = () => {
    const pm = (payMethodSel?.value || root.dataset.payMethod || 'PAYE').toUpperCase();
    const cardPAYE = byId('cardPAYE'), cardUMB = byId('cardUMB');
    if (cardPAYE) cardPAYE.style.display = (pm === 'PAYE') ? '' : 'none';
    if (cardUMB)  cardUMB.style.display  = (pm === 'PAYE') ? 'none' : '';
    return pm;
  };

  let payMethod = toggleCards();

  if (payMethodSel && !payMethodSel.__wired_pm) {
    payMethodSel.__wired_pm = true;
    payMethodSel.addEventListener('change', () => {
      payMethod = toggleCards();
      if (typeof computeContractMargins === 'function') computeContractMargins();
    });
  }

  const rateInputs = root.querySelectorAll('input[name^="paye_"], input[name^="umb_"], input[name^="charge_"]');

  rateInputs.forEach(el => {
    if (!el.__wired_mg) {
      el.__wired_mg = true;

      // Live margins on input
      el.addEventListener('input', () => {
        if (typeof computeContractMargins === 'function') computeContractMargins();
      });

      // Snap to 2dp on blur/tab away
      el.addEventListener('blur', () => {
        const before = el.value;
        normaliseRateInput(el);
        if (el.value !== before && typeof setContractFormValue === 'function') {
          setContractFormValue(el.name, el.value);
        } else if (typeof setContractFormValue === 'function') {
          // still stage even if unchanged, to keep formState in sync
          setContractFormValue(el.name, el.value);
        }
        if (typeof computeContractMargins === 'function') computeContractMargins();
      });
    }
  });

  // Mileage inputs: same behaviour (2dp on blur)
  const mileageInputs = root.querySelectorAll('input[name="mileage_pay_rate"], input[name="mileage_charge_rate"]');
  mileageInputs.forEach(el => {
    if (!el.__wired_mg) {
      el.__wired_mg = true;

      el.addEventListener('input', () => {
        // margins may or may not depend on mileage; cheap to recompute anyway
        if (typeof computeContractMargins === 'function') computeContractMargins();
      });

      el.addEventListener('blur', () => {
        const before = el.value;
        normaliseRateInput(el);
        if (typeof setContractFormValue === 'function') {
          setContractFormValue(el.name, el.value);
        }
        if (typeof computeContractMargins === 'function') computeContractMargins();
      });
    }
  });

  // One-time wiring for negative margin hints + bucket label updates
  if (!root.__wiredNeg) {
    root.__wiredNeg = true;
    window.addEventListener('contract-margins-updated', (ev) => {
      const s = ev?.detail || window.__contractMarginState || { hasNegativeMargins:false, negFlags:{} };
      Object.entries(s.negFlags||{}).forEach(([b,neg]) => {
        const row = document.querySelector(`#marginsTable tbody tr[data-b="${b}"]`);
        if (!row) return;
        const mgEl = row.querySelector('.mg');
        if (neg) {
          row.setAttribute('data-negative','1');
          if (mgEl && !mgEl.querySelector('.mini')) {
            const hint = document.createElement('div');
            hint.className='mini';
            hint.textContent='Margin canâ€™t be negative';
            mgEl.appendChild(hint);
          }
        } else {
          row.removeAttribute('data-negative');
          if (mgEl) {
            const hint = mgEl.querySelector('.mini');
            if (hint) hint.remove();
          }
        }
      });
    });
    window.addEventListener('bucket-labels-changed', () => {
      const merged = mergeContractStateIntoRow(window.modalCtx?.data||{});
      const LBL = merged?.bucket_labels_json || (window.modalCtx?.formState?.main ? {
        day:   window.modalCtx.formState.main.bucket_day || window.modalCtx.formState.main.bucket_label_day,
        night: window.modalCtx.formState.main.bucket_night || window.modalCtx.formState.main.bucket_label_night,
        sat:   window.modalCtx.formState.main.bucket_sat || window.modalCtx.formState.main.bucket_label_sat,
        sun:   window.modalCtx.formState.main.bucket_sun || window.modalCtx.formState.main.bucket_label_sun,
        bh:    window.modalCtx.formState.main.bucket_bh || window.modalCtx.formState.main.bucket_label_bh,
      } : {});
      const labelOf = (k, def) => (LBL && LBL[k]) ? LBL[k] : def;
      const map = { day:'Day', night:'Night', sat:'Sat', sun:'Sun', bh:'BH' };
      Object.entries(map).forEach(([k,def])=>{
        const rows = document.querySelectorAll(`#contractRatesTab .row > label.section, #contractRatesTab .row > label`);
        rows.forEach(lab=>{
          const n = lab.textContent?.trim()||'';
          if (n === def) lab.textContent = labelOf(k, def);
        });
        const tr = document.querySelector(`#marginsTable tbody tr[data-b="${k}"] td:first-child`);
        if (tr) tr.textContent = labelOf(k, def);
      });
      if (typeof computeContractMargins === 'function') computeContractMargins();
    });
  }

  // Initial normalisation pass for values already in the DOM
  try {
    // Rates
    rateInputs.forEach(el => {
      normaliseRateInput(el);
      if (typeof setContractFormValue === 'function') {
        setContractFormValue(el.name, el.value);
      }
    });
    // Mileage
    mileageInputs.forEach(el => {
      normaliseRateInput(el);
      if (typeof setContractFormValue === 'function') {
        setContractFormValue(el.name, el.value);
      }
    });
  } catch {}

  if (typeof computeContractMargins === 'function') computeContractMargins();
}

// Open preset picker (card grid) and return chosen data




async function fetchClientRatePresets({ client_id, role, band, active_on }) {
  if (!client_id) return [];
  const qs = new URLSearchParams();
  qs.set('client_id', client_id);
  if (role) qs.set('role', role);
  if (band != null && band !== '') qs.set('band', band);
  if (active_on) qs.set('active_on', active_on);
  const r = await authFetch(API(`/api/rates/client-defaults?${qs.toString()}`));
  const rows = toList(r) || [];
  return rows;
}

async function fetchCandidateRateOverrides({ candidate_id, client_id, role, band, active_on }) {
  if (!candidate_id) return [];
  const qs = new URLSearchParams();
  qs.set('candidate_id', candidate_id);
  if (client_id) qs.set('client_id', client_id);
  if (role) qs.set('role', role);
  if (band != null && band !== '') qs.set('band', band);
  if (active_on) qs.set('active_on', active_on);
  const r = await authFetch(API(`/api/rates/candidate-overrides?${qs.toString()}`));
  const rows = toList(r) || [];
  return rows;
}




async function computeContractMargins() {
  const fs = (window.modalCtx && window.modalCtx.formState) || { main:{}, pay:{} };
  const form = document.querySelector('#contractRatesTab')?.closest('form') || document.querySelector('#contractForm');

  const pmStaged = (fs.main && fs.main.pay_method_snapshot) || '';
  const payMethodSel = form ? form.querySelector('select[name="pay_method_snapshot"]') : null;
  const payMethod = ((payMethodSel && payMethodSel.value) || pmStaged || 'PAYE').toUpperCase();

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Ensure we have a sensible ERNI multiplier (1 + erni_pct)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let erniMult = 1;
  try {
    if (typeof window.__ERNI_MULT__ === 'number' && window.__ERNI_MULT__ > 0) {
      erniMult = window.__ERNI_MULT__;
    } else if (typeof window.getSettingsCached === 'function') {
      const s = await window.getSettingsCached();
      let p = s?.erni_pct ?? s?.employers_ni_percent ?? 0;
      p = Number(p) || 0;
      if (p > 1) p = p / 100; // support 15 vs 0.15
      erniMult = 1 + p;
      if (!Number.isFinite(erniMult) || erniMult <= 0) erniMult = 1;
      window.__ERNI_MULT__ = erniMult;
    }
  } catch {
    erniMult = 1;
    window.__ERNI_MULT__ = 1;
  }

  const get = (n) => {
    const domVal = form ? form.querySelector(`[name="${n}"]`)?.value : null;
    const staged = fs.pay ? fs.pay[n] : null;
    const v = (staged != null && staged !== '') ? staged : (domVal != null ? domVal : '');
    const num = Number(v);
    return Number.isFinite(num) ? num : 0;
  };

  const buckets = ['day','night','sat','sun','bh'];
  const negFlags = {};

  buckets.forEach(b => {
    const ch = get(`charge_${b}`);
    const py = (payMethod === 'PAYE') ? get(`paye_${b}`) : get(`umb_${b}`);

    let mg;

    // Prefer shared helper if present, but force ERNI in
    if (typeof window.calcDailyMargin === 'function') {
      try {
        const v = window.calcDailyMargin({
          bucket: b,
          charge: ch,
          pay:    py,
          method: payMethod,
          erniMultiplier: erniMult
        });
        mg = (v == null || !Number.isFinite(v)) ? null : v;
      } catch {
        mg = null;
      }
    }

    // Fallback if helper missing or returned null
    if (mg == null) {
      if (payMethod === 'PAYE') {
        mg = ch - (py * erniMult);
      } else {
        // UMBRELLA or unknown â†’ no ERNI
        mg = ch - py;
      }
    }

    const row = document.querySelector(`#marginsTable tbody tr[data-b="${b}"]`);
    if (row) {
      const chEl = row.querySelector('.ch');
      const pyEl = row.querySelector('.py');
      const mgEl = row.querySelector('.mg');

      if (pyEl) pyEl.textContent = (py || py === 0) ? py.toFixed(2) : '';
      if (chEl) chEl.textContent = (ch || ch === 0) ? ch.toFixed(2) : '';

      if (mgEl) {
        const showMg = Number.isFinite(mg) ? mg : null;
        mgEl.textContent = (showMg || showMg === 0) ? showMg.toFixed(2) : '';
        mgEl.style.color = (showMg < 0) ? 'var(--fail)' : '';

        if (showMg < 0) {
          mgEl.setAttribute('data-negative','1');
          if (!mgEl.querySelector('.mini')) {
            const hint = document.createElement('div');
            hint.className = 'mini';
            hint.textContent = 'Margin canâ€™t be negative';
            mgEl.appendChild(hint);
          }
          row.setAttribute('data-negative','1');
        } else {
          mgEl.removeAttribute('data-negative');
          const hint = mgEl.querySelector('.mini');
          if (hint) hint.remove();
          row.removeAttribute('data-negative');
        }
      }
    }

    negFlags[b] = (mg < 0);
  });

  const hasNegativeMargins = Object.values(negFlags).some(Boolean);
  window.__contractMarginState = { hasNegativeMargins, negFlags, method: payMethod };

  try { window.dispatchEvent(new CustomEvent('contract-margins-updated', { detail: window.__contractMarginState })); } catch {}
  try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
}



// ==============================
// 1) openCandidateRateModal(...)
// ==============================
// ========== CANDIDATE OVERRIDES ==========
// ========== CHILD MODAL (CANDIDATE OVERRIDE) WITH HEAVY LOGGING ==========


// ========== PARENT TABLE RENDER (WITH LOUD LOGS + SAFETY NET) ==========

async function openCandidateRateModal(candidate_id, existing) {
  const LOG = !!window.__LOG_RATES;
  const LOG_APPLY = (typeof window.__LOG_APPLY === 'boolean') ? window.__LOG_APPLY : LOG;
  const L  = (...a)=> { if (LOG) console.log('[RATES][openCandidateRateModal]', ...a); };
  const LG = (label, obj)=> { if (LOG) { console.groupCollapsed(`[RATES][openCandidateRateModal] ${label}`); console.log(obj); console.groupEnd(); } };

  L('ENTRY', { candidate_id, hasExisting: !!existing });

  const parentFrame   = _currentFrame();
  const parentEditable= parentFrame && (parentFrame.mode === 'edit' || parentFrame.mode === 'create');
  L('parent frame', { editable: !!parentEditable, mode: parentFrame?.mode });

  // ===== load clients =====
  const clients = await listClientsBasic().catch(e=>{ L('listClientsBasic failed', e); return []; });
  L('clients loaded', clients?.length || 0);
  const clientOptions = (clients||[]).map(c => `<option value="${c.id}">${c.name}</option>`).join('');
  const initialClientId = existing?.client_id || '';

  const defaultRateType = existing?.rate_type
    ? String(existing.rate_type).toUpperCase()
    : String(window.modalCtx?.data?.pay_method || 'PAYE').toUpperCase();

  const bucketLabel = { day:'Day', night:'Night', sat:'Sat', sun:'Sun', bh:'BH' };

  // Track the current in-form role/band so they don't reset when date/client changes
  let currentRole = existing?.role || '';
  let currentBand = (existing && existing.band != null) ? String(existing.band) : '';

  // ===== FORM =====
  const formHtml = html(`
    <div class="form" id="candRateForm">
      <div class="row">
        <label>Client (required)</label>
        <select name="client_id" id="cr_client_id" ${parentEditable ? '' : 'disabled'}>
          <option value="">Select clientâ€¦</option>
          ${clientOptions}
        </select>
      </div>

      <div class="row">
        <label>Rate type (required)</label>
        <select name="rate_type" id="cr_rate_type" ${parentEditable ? '' : 'disabled'}>
          <option ${defaultRateType==='PAYE'?'selected':''}>PAYE</option>
          <option ${defaultRateType==='UMBRELLA'?'selected':''}>UMBRELLA</option>
        </select>
      </div>

      <div class="row">
        <label>Role (required)</label>
        <select name="role" id="cr_role" required ${parentEditable ? '' : 'disabled'}>
          <option value="">Select roleâ€¦</option>
        </select>
      </div>

      <div class="row" id="cr_band_row">
        <label>Band (optional)</label>
        <select name="band" id="cr_band" ${parentEditable ? '' : 'disabled'}></select>
      </div>

      <div class="row">
        <label>Effective from (DD/MM/YYYY)</label>
        <input type="text" name="date_from" id="cr_date_from" placeholder="DD/MM/YYYY" ${parentEditable ? '' : 'disabled'} />
      </div>

      <div class="row">
        <label>Effective to (optional, DD/MM/YYYY)</label>
        <input type="text" name="date_to" id="cr_date_to" placeholder="DD/MM/YYYY" ${parentEditable ? '' : 'disabled'} />
        <div class="hint field-hint err" id="cr_date_to_err" style="display:none"></div>
      </div>

      ${['day','night','sat','sun','bh'].map(b => `
        <div class="row" data-bucket="${b}">
          <label>Pay (${b.toUpperCase()})</label>
          <div class="slot" id="slot_${b}">
            <div class="slot-input" id="slot_input_${b}" style="display:none">
              <input type="number" step="0.01" name="pay_${b}" id="pay_${b}"/>
            </div>
            <div class="slot-ph" id="slot_ph_${b}" style="opacity:.75">Not in client rate</div>
          </div>
        </div>`).join('')}

      <div class="row" style="grid-column:1 / -1; margin-top:10px">
        <table class="grid" id="cr_margins_tbl" style="width:100%">
          <thead><tr><th>Bucket</th><th>Margin</th><th class="hint">Uses client charge at start date</th></tr></thead>
          <tbody>
            ${['day','night','sat','sun','bh'].map(b=>`
              <tr><td>${b.toUpperCase()}</td><td><span id="cr_m_${b}">â€”</span></td><td></td></tr>`).join('')}
          </tbody>
        </table>
      </div>

      <div id="cr_err_panel" style="grid-column:1/-1; margin-top:10px; display:none; border:1px solid #7f1d1d; background:rgba(239,68,68,.08); color:#fecaca; padding:10px; border-radius:8px"></div>
    </div>
  `);

  // ===== helpers =====
  async function _erniMultiplier(){
    if (typeof window.__ERNI_MULT__ === 'number') return window.__ERNI_MULT__;
    try {
      if (typeof getSettingsCached === 'function') {
        const s = await getSettingsCached();
        let p = s?.erni_pct ?? s?.employers_ni_percent ?? 0;
        p = Number(p) || 0;
        if (p > 1) p = p / 100;
        window.__ERNI_MULT__ = 1 + p;
        return window.__ERNI_MULT__;
      }
    } catch {}
    window.__ERNI_MULT__ = 1;
    return 1;
  }
  function numOrNull(v){ if (v===undefined||v===null) return null; if (typeof v === 'string' && v.trim()==='') return null; const n=Number(v); return Number.isFinite(n) ? n : null; }
  const fmt = v => (v==null || Number.isNaN(v)) ? 'â€”' : (Math.round(v*100)/100).toFixed(2);
  function showInlineError(html){ const p = byId('cr_err_panel'); if (!p) return; if (html && String(html).trim() !== '') { p.innerHTML = html; p.style.display = ''; } else { p.innerHTML = ''; p.style.display = 'none'; } }
  function setFieldError(bucket,msg){
    const rowInput = document.querySelector(`#candRateForm input[name="pay_${bucket}"]`);
    if (!rowInput) return;
    let hint = rowInput.parentElement?.querySelector?.(`.field-hint.err[data-bucket="${bucket}"]`);
    if (msg) {
      if (!hint) {
        hint = document.createElement('div');
        hint.className = 'hint field-hint err';
        hint.setAttribute('data-bucket', bucket);
        rowInput.parentElement.appendChild(hint);
      }
      hint.textContent = msg;
    } else if (hint) hint.remove();
  }
  function setDateToError(msg){ const el = byId('cr_date_to_err'); if (!el) return; if (msg) { el.textContent = msg; el.style.display = ''; } else { el.textContent = ''; el.style.display = 'none'; } }
  function clearAllFieldErrors(){ document.querySelectorAll('#candRateForm .field-hint.err').forEach(el=>el.remove()); setDateToError(''); }

  async function resolveCoveringWindow(client_id, role, band, active_on){
    try {
      const list = await listClientRates(client_id, { active_on, only_enabled: true });
      const wins  = (Array.isArray(list) ? list.filter(w => !w.disabled_at_utc && w.role === role) : []);
      const filtered = wins;
      let win = filtered.find(w => (w.band ?? null) === (band ?? null));
      if (!win && (band == null)) win = filtered.find(w => w.band == null);
      return win ? {
        charges: { day:win.charge_day??null, night:win.charge_night??null, sat:win.charge_sat??null, sun:win.charge_sun??null, bh:win.charge_bh??null },
        capIso: win.date_to || null
      } : null;
    } catch(e){ L('resolveCoveringWindow err', e); return null; }
  }

  let lastApplyState = null;
  function setApplyEnabled(enabled, reasonSummary){
    // DO NOT directly toggle #btnSave here â€“ leave that to the modal framework
    // via _applyDesired and _updateButtons. We only broadcast the state.
    if (LOG_APPLY && lastApplyState !== enabled) {
      console.log('[RATES][APPLY] state â†’', enabled ? 'ENABLED' : 'DISABLED', reasonSummary || '');
      lastApplyState = enabled;
    }
    try {
      window.dispatchEvent(new CustomEvent('modal-apply-enabled', { detail:{ enabled } }));
    } catch {}
  }

  // ===== driver: recompute state (validations + overlap + preview) =====
  async function recomputeOverrideState(){
    const clientId = byId('cr_client_id')?.value || '';
    const role     = byId('cr_role')?.value || '';
    const bandSel  = byId('cr_band')?.value ?? '';
    const band     = (bandSel === '' ? null : bandSel);
    const isoFrom  = parseUkDateToIso(byId('cr_date_from')?.value || '');
    const isoTo    = parseUkDateToIso(byId('cr_date_to')?.value || '');
    const rateType = String(byId('cr_rate_type')?.value || '').toUpperCase();

    const buckets = ['day','night','sat','sun','bh'];
    const inputEl = (b)=> document.querySelector(`#candRateForm input[name="pay_${b}"]`);
    const slotIn  = (b)=> byId(`slot_input_${b}`);
    const slotPh  = (b)=> byId(`slot_ph_${b}`);

    showInlineError(''); clearAllFieldErrors();
    let canApply = true;

    const need = [];
    if (!clientId) need.push('clientId');
    if (!rateType) need.push('rateType');
    if (!role)     need.push('role');
    if (!isoFrom)  need.push('date_from');
    if (need.length) {
      buckets.forEach(b => {
        const inp = inputEl(b);
        if (inp) { inp.disabled = true; }
        if (slotIn(b)) slotIn(b).style.display = 'none';
        if (slotPh(b)) slotPh(b).style.display = '';
        const sp = byId(`cr_m_${b}`); if (sp) sp.textContent = 'â€”';
      });
      setApplyEnabled(false, 'not_ready');
      return;
    }

    const win = await resolveCoveringWindow(clientId, role, band, isoFrom);
    if (!win) {
      buckets.forEach(b => {
        const inp = inputEl(b);
        if (inp) { inp.disabled = true; }
        if (slotIn(b)) slotIn(b).style.display = 'none';
        if (slotPh(b)) slotPh(b).style.display = '';
        const sp = byId(`cr_m_${b}`); if (sp) sp.textContent = 'â€”';
      });
      showInlineError(`No active client default for <b>${escapeHtml(role)}</b>${band?` / <b>${escapeHtml(band)}</b>`:''} on <b>${formatIsoToUk(isoFrom)}</b>.`);
      setApplyEnabled(false, 'no_cover');
      return;
    }

    buckets.forEach(b => {
      const hasCharge = (win.charges[b] != null);
      const inp = inputEl(b);
      if (hasCharge) {
        if (slotPh(b)) slotPh(b).style.display = 'none';
        if (slotIn(b)) slotIn(b).style.display = '';
        if (inp) inp.disabled = false;
      } else {
        if (slotIn(b)) slotIn(b).style.display = 'none';
        if (slotPh(b)) slotPh(b).style.display = '';
        if (inp) { inp.value = ''; inp.disabled = true; }
      }
    });

    const mult = await _erniMultiplier();

    const invalid = [];
    buckets.forEach(b => {
      const el  = inputEl(b), chg = win.charges[b];
      if (!el || el.disabled) return;
      const pay = numOrNull(el.value);
      if (pay != null && chg == null) { invalid.push(b); setFieldError(b, `No client charge for ${bucketLabel[b]}.`); }
    });
    if (invalid.length) canApply = false;

    const neg = [];
    buckets.forEach(b => {
      const el  = inputEl(b), chg = win.charges[b];
      if (!el || el.disabled) return;
      const pay = numOrNull(el.value);
      if (pay == null || chg == null) return;
      const m = (rateType === 'PAYE') ? (chg - (pay * mult)) : (chg - pay);
      if (m < 0) { neg.push(b); setFieldError(b, `Margin would be negative for ${bucketLabel[b]}.`); }
    });
    if (neg.length) canApply = false;

    setDateToError('');
    if (isoTo && win.capIso && isoTo > win.capIso) {
      setDateToError(`Client rate ends on ${formatIsoToUk(win.capIso)} â€” override must end on/before this date.`);
      canApply = false;
    }

    const O = window.modalCtx.overrides || { existing: [], stagedNew: [], stagedEdits: {}, stagedDeletes: new Set() };
    const deletedIds = O.stagedDeletes || new Set();
    const unify = [];
    (O.existing||[]).forEach(ex => { if (!deletedIds.has(ex.id)) unify.push({ ...(ex||{}), ...(O.stagedEdits?.[ex.id]||{}) }); });
    (O.stagedNew||[]).forEach(n => unify.push({ ...(n||{}) }));

    const sameKey = (o) =>
      String(o.client_id||'') === clientId &&
      String(o.role||'')      === role &&
      String((o.rate_type||'').toUpperCase()) === rateType &&
      String(o.band??'')      === String(band??'');

    const isSelf = (o) => {
      if (!existing) return false;
      if (existing.id && o.id) return String(o.id) === String(existing.id);
      if (existing._tmpId && o._tmpId) return String(o._tmpId) === String(existing._tmpId);
      return false;
    };

    const conflicts = unify.filter(o => sameKey(o) && !isSelf(o) &&
      !((o.date_to||'9999-12-31') < (isoFrom||'0000-01-01') || (isoTo||'9999-12-31') < (o.date_from||'0000-01-01')));

    if (conflicts.length) {
      canApply = false;
      const ov = conflicts[0];
      const cutThis  = (()=>{ const d=new Date((ov.date_from||'')+'T00:00:00Z'); if(!isNaN(d)) d.setUTCDate(d.getUTCDate()-1); return isNaN(d)?null:`${d.getUTCFullYear()}-${String(d.getUTCMonth()+1).padStart(2,'0')}-${String(d.getUTCDate()).padStart(2,'0')}`; })();
      const cutOther = (()=>{ const d=new Date((isoFrom||'')+'T00:00:00Z'); if(!isNaN(d)) d.setUTCDate(d.getUTCDate()-1); return isNaN(d)?null:`${d.getUTCFullYear()}-${String(d.getUTCMonth()+1).padStart(2,'0')}-${String(d.getUTCDate()).padStart(2,'0')}`; })();

      let fixButtons = '';
      if (cutThis)  fixButtons += `<button id="cr_fix_this"  class="btn mini" style="margin-right:8px">Fix: Shorten <b>THIS</b> to ${formatIsoToUk(cutThis)}</button>`;
      if (cutOther) fixButtons += `<button id="cr_fix_other" class="btn mini">Fix: Shorten <b>OTHER</b> to ${formatIsoToUk(cutOther)}</button>`;

      showInlineError(`
        <div style="font-weight:700;margin-bottom:6px">Overlap detected</div>
        <div style="margin-bottom:8px">Another rate card exists in this category.<br/><span class="hint">Use Fix or adjust dates.</span></div>
        <div>${fixButtons || '<i>No safe automatic fix available.</i>'}</div>
      `);

      setTimeout(()=> {
        const inTo = byId('cr_date_to');
        const fixThis = byId('cr_fix_this');
        if (fixThis && cutThis) fixThis.onclick = ()=> { inTo.value = formatIsoToUk(cutThis); recomputeOverrideState(); };
        const fixOther = byId('cr_fix_other');
        if (fixOther && cutOther) fixOther.onclick = ()=> {
          try {
            const target = conflicts[0];
            const O2 = window.modalCtx.overrides || { existing: [], stagedNew: [], stagedEdits: {}, stagedDeletes: new Set() };
            if (target.id) {
              O2.stagedEdits[target.id] = { ...(O2.stagedEdits[target.id]||{}), date_to: cutOther };
            } else if (target._tmpId) {
              const ix = (O2.stagedNew||[]).findIndex(r=>r._tmpId===target._tmpId);
              if (ix>=0) O2.stagedNew[ix] = { ...O2.stagedNew[ix], date_to: cutOther };
            }
            renderCandidateRatesTable();
            recomputeOverrideState();
          } catch(e){ L('fixOther failed', e); }
        };
      }, 0);
    }

    // Preview margins (never NaN)
    const mult2 = mult;
    buckets.forEach(b => {
      const sp  = byId(`cr_m_${b}`), el = inputEl(b), chg = win.charges[b];
      const pay = (el && !el.disabled) ? numOrNull(el.value) : null;
      const m   = (chg != null && pay != null) ? ((rateType === 'PAYE') ? (chg - (pay * mult2)) : (chg - pay)) : null;
      if (sp) sp.textContent = (m==null ? 'â€”' : fmt(m));
    });

    if (LOG_APPLY) console.log('[RATES][APPLY] canApply?', canApply, { clientId, role, band, isoFrom, isoTo, rateType });
    setApplyEnabled(canApply, canApply ? 'ok' : 'violations');
  }

  showModal(
    existing ? 'Edit Candidate Rate Override' : 'Add Candidate Rate Override',
    [{ key:'form', label:'Form' }],
    () => formHtml,
    async () => {
      await recomputeOverrideState();
      if (lastApplyState === false) { L('Apply blocked by recompute'); return false; }

      const raw = collectForm('#candRateForm');
      LG('Apply collected form', raw);

      const client_id = (raw.client_id || '').trim();
      const role      = (raw.role || '').trim();
      const band      = (raw.band || '').trim() || null;
      const rate_type = String(raw.rate_type || '').toUpperCase();

      const date_from = parseUkDateToIso(raw.date_from);
      const date_to   = raw.date_to ? parseUkDateToIso(raw.date_to) : null;

      const mapPay = (k) => (Object.prototype.hasOwnProperty.call(raw, k) && raw[k] !== '' ? Number(raw[k]) : null);

      const stagedAll = {
        id: existing?.id,
        candidate_id,
        client_id,
        role, band, rate_type,
        date_from, date_to,
        pay_day   : mapPay('pay_day'),
        pay_night : mapPay('pay_night'),
        pay_sat   : mapPay('pay_sat'),
        pay_sun   : mapPay('pay_sun'),
        pay_bh    : mapPay('pay_bh')
      };

      const O = (window.modalCtx.overrides ||= { existing: [], stagedNew: [], stagedEdits: {}, stagedDeletes: new Set() });
      LG('STAGING before', { existing: (O.existing||[]).length, stagedNew:(O.stagedNew||[]).length, stagedEdits:Object.keys(O.stagedEdits||{}).length, stagedDeletes: O.stagedDeletes?.size || 0 });

      if (existing?.id) {
        O.stagedEdits[existing.id] = { ...(O.stagedEdits[existing.id]||{}), ...stagedAll };
      } else if (existing && !existing.id) {
        const tmpId = existing._tmpId || null;
        const idx   = tmpId ? (O.stagedNew||[]).findIndex(r => r._tmpId === tmpId) : -1;
        if (idx >= 0) O.stagedNew[idx] = { ...O.stagedNew[idx], ...stagedAll, _tmpId: tmpId };
        else          O.stagedNew.push({ ...stagedAll, _tmpId: tmpId || `tmp_${Date.now()}` });
      } else {
        O.stagedNew.push({ ...stagedAll, _tmpId: `tmp_${Date.now()}` });
      }

      LG('STAGING after', {
        existing: (O.existing||[]).length,
        stagedNew:(O.stagedNew||[]).length,
        stagedEdits:Object.keys(O.stagedEdits||{}).length,
        stagedDeletes: O.stagedDeletes?.size || 0,
        peekNew: (O.stagedNew||[])[(O.stagedNew||[]).length-1]
      });

      try { await renderCandidateRatesTable(); } catch {}
      try { window.dispatchEvent(new CustomEvent('modal-dirty')); } catch {}
      return true;
    },
    false,
    () => {
      const parent = _currentFrame();
      if (parent) { parent.currentTabKey = 'rates'; parent.setTab('rates'); }
    },
    { kind: 'candidate-override' }
  );

  // ===== prefill & wire =====
  const selClient = byId('cr_client_id');
  const selRateT  = byId('cr_rate_type');
  const selRole   = byId('cr_role');
  const selBand   = byId('cr_band');
  const inFrom    = byId('cr_date_from');
  const inTo      = byId('cr_date_to');

  if (initialClientId) selClient.value = initialClientId;
  if (existing?.date_from) inFrom.value = formatIsoToUk(existing.date_from);
  if (existing?.date_to)   inTo.value   = formatIsoToUk(existing.date_to);

  // Prefill ALL buckets that have values (2dp)
  ['day','night','sat','sun','bh'].forEach(b=>{
    const val = (existing && Number.isFinite(existing[`pay_${b}`])) ? existing[`pay_${b}`] : null;
    const el  = document.querySelector(`#candRateForm input[name="pay_${b}"]`);
    if (el && val != null) {
      const num = Number(val);
      el.value = Number.isFinite(num) ? (Math.round(num*100)/100).toFixed(2) : String(val);
    }
  });

  attachUkDatePicker(inFrom); attachUkDatePicker(inTo);

  async function refreshClientRoles(clientId) {
    selRole.innerHTML = `<option value="">Select roleâ€¦</option>`; selRole.disabled = true;
    selBand.innerHTML = `<option value=""></option>`;             selBand.disabled  = true;

    if (!clientId) { setApplyEnabled(false, 'no_client'); return; }

    const active_on = parseUkDateToIso(inFrom.value || '') || null;
    const list  = await listClientRates(clientId, { active_on, only_enabled: true }).catch(_=>[]);
    const wins  = (Array.isArray(list) ? list.filter(w => !w.disabled_at_utc) : []);
    const roles = new Set(); const bandsByRole = {};
    wins.forEach(w => {
      if (!w.role) return;
      roles.add(w.role);
      (bandsByRole[w.role] ||= new Set()).add(w.band==null ? '' : String(w.band));
    });

    const allowed = [...roles].sort((a,b)=> a.localeCompare(b));
    selRole.innerHTML = `<option value="">Select roleâ€¦</option>` + allowed.map(code => `<option value="${code}">${code}</option>`).join('');
    selRole.disabled = !parentEditable;

    // Choose a role in this order:
    // 1) currentRole if still valid
    // 2) existing.role if still valid
    // 3) blank
    let chosenRole = '';
    if (currentRole && allowed.includes(currentRole)) {
      chosenRole = currentRole;
    } else if (existing?.role && allowed.includes(existing.role)) {
      chosenRole = existing.role;
    }

    if (chosenRole) {
      selRole.value = chosenRole;
      currentRole = chosenRole;

      const bandSet = [...(bandsByRole[chosenRole] || new Set())];
      const hasNull = bandSet.includes('');
      selBand.innerHTML =
        (hasNull ? `<option value="">(none)</option>` : '') +
        bandSet
          .filter(b=>b!=='')
          .sort((a,b)=> String(a).localeCompare(String(b)))
          .map(b => `<option value="${b}">${b}</option>`).join('');
      selBand.disabled = !parentEditable;

      // Pick band: prefer currentBand if still valid; else existing.band
      let desiredBand = '';
      if (currentBand && bandSet.includes(currentBand)) {
        desiredBand = currentBand;
      } else if (existing && existing.band != null) {
        const asStr = String(existing.band);
        if (bandSet.includes(asStr)) desiredBand = asStr;
      }

      if (desiredBand && bandSet.includes(desiredBand)) {
        selBand.value = desiredBand;
        currentBand = desiredBand;
      } else {
        // leave at (none)
        currentBand = '';
      }
    } else {
      selBand.innerHTML = `<option value=""></option>`;
      selBand.disabled  = true;
      currentRole = '';
      currentBand = '';
    }

    await recomputeOverrideState();
  }

  selClient.addEventListener('change', async () => {
    L('[EVENT] client change');
    if (parentEditable) {
      currentRole = ''; // changing client invalidates previous role
      currentBand = '';
      await refreshClientRoles(selClient.value);
    }
  });
  selRateT .addEventListener('change',        () => {
    L('[EVENT] rate_type change');
    if (parentEditable) recomputeOverrideState();
  });
  inFrom   .addEventListener('change',  async () => {
    L('[EVENT] date_from change');
    if (parentEditable) {
      // date change may change which client windows apply, but we keep role/band if still valid
      await refreshClientRoles(selClient.value);
    }
  });
  selRole  .addEventListener('change',  async () => {
    L('[EVENT] role change');
    if (!parentEditable) return;
    currentRole = selRole.value || '';
    // changing role recalculates margins
    await recomputeOverrideState();
  });
  selBand  .addEventListener('change',        () => {
    L('[EVENT] band change');
    if (!parentEditable) return;
    currentBand = selBand.value || '';
    recomputeOverrideState();
  });
  ['pay_day','pay_night','pay_sat','pay_sun','pay_bh'].forEach(n=>{
    const el = document.querySelector(`#candRateForm input[name="${n}"]`);
    if (el) el.addEventListener('input', () => {
      if (LOG_APPLY) console.log('[RATES][EVENT] pay change', n, el.value);
      recomputeOverrideState();
    });
  });

  // Initial state: if there is a client, load its roles, otherwise just compute state
  if (initialClientId) {
    await refreshClientRoles(initialClientId);
  } else {
    await recomputeOverrideState();
  }

  (function wireDeleteButton(){
    const delBtn = byId('btnDelete');
    if (!delBtn) return;
    if (!existing || !existing.id) { delBtn.style.display='none'; return; }
    delBtn.style.display = '';
    delBtn.disabled = false;
    delBtn.onclick = () => {
      try {
        const O = (window.modalCtx.overrides ||= { existing: [], stagedNew: [], stagedEdits: {}, stagedDeletes: new Set() });
        (O.stagedDeletes ||= new Set()).add(existing.id);
        L('staged delete', { id: existing.id, size: O.stagedDeletes.size });
        try { renderCandidateRatesTable(); } catch {}
        try { window.dispatchEvent(new CustomEvent('modal-dirty')); } catch {}
        const closeBtn = byId('btnCloseModal'); if (closeBtn) closeBtn.click();
      } catch (e) { L('stage delete failed', e); }
    };
  })();
}



// ---- Client modal

// =========================== openClient (FIXED) ==========================
// =================== CLIENT MODAL (UPDATED: rates rate_type + hospitals staged-CRUD) ===================
// âœ… UPDATED â€” unified FE model; on load, convert server rows to unified; on save, validate overlaps, bridge to per-type API

// ================== FRONTEND: openClient (UPDATED) ==================
// ================== FIXED: openClient (hydrate before showModal) ==================
// ================== FIXED: openClient (hydrate before showModal) ==================

// ============================================================================
// OPEN CLIENT (parent modal) â€” skip posting disabled windows on Save
// (No delete button is added here; ensure any existing parent delete UI is removed elsewhere.)
// ============================================================================

// =================== CLIENT RATES TABLE (UPDATED) ===================
// âœ… UPDATED â€” unified table view, dbl-click opens unified modal
// ============================================================================
// RENDER CLIENT RATES TABLE (adds "Status" col; shows disabled who/when)
// ============================================================================



// Now shows derived PAYE & Umbrella margins per bucket in the table
async function openClient(row) {
  // ===== Logging helpers (toggle with window.__LOG_MODAL = true/false) =====
  const LOG = (typeof window.__LOG_MODAL === 'boolean') ? window.__LOG_MODAL : true;
  const APILOG = (typeof window !== 'undefined' && !!window.__LOG_API) || (typeof __LOG_API !== 'undefined' && !!__LOG_API);
  const L  = (...a)=> { if (LOG) console.log('[OPEN_CLIENT]', ...a); };
  const W  = (...a)=> { if (LOG) console.warn('[OPEN_CLIENT]', ...a); };
  const E  = (...a)=> { if (LOG) console.error('[OPEN_CLIENT]', ...a); };

  const deep = (o)=> JSON.parse(JSON.stringify(o || {}));
  const incoming = deep(row || {});
  const seedId   = incoming?.id || null;

  L('ENTRY', { incomingKeys: Object.keys(incoming||{}), seedId });

  const unwrapSingle = (data, key) => {
    if (Array.isArray(data)) return data[0] || null;
    if (data && key && data[key]) return unwrapSingle(data[key], null);
    if (data && Array.isArray(data.rows))  return data.rows[0]  || null;
    if (data && Array.isArray(data.items)) return data.items[0] || null;
    if (data && Array.isArray(data.data))  return data.data[0]  || null;
    return (data && typeof data === 'object') ? data : null;
  };

  // 1) Hydrate full client if we have an id
  let full = incoming;
  let settingsSeed = null;
  if (seedId) {
    try {
      const url = API(`/api/clients/${encodeURIComponent(seedId)}`);
      L('[HTTP] GET', url);
      const r = await authFetch(url);
      L('[HTTP] status', r?.status, r?.ok);

      try {
        const raw = await r.clone().text();
        if (LOG) console.debug('[HTTP] raw body (â‰¤2KB):', raw.slice(0, 2048));
      } catch (peekErr) { W('[HTTP] raw peek failed', peekErr?.message || peekErr); }

      if (r.ok) {
        const data = await r.json().catch(()=> ({}));
        const clientObj   = data?.client || unwrapSingle(data, 'client') || null;
        const settingsObj = data?.client_settings || data?.settings || null;
        settingsSeed = settingsObj ? deep(settingsObj) : null;
        full = clientObj || incoming;
        L('hydrated JSON keys', Object.keys(data||{}), 'client keys', Object.keys(clientObj||{}), 'hasSettingsSeed', !!settingsSeed);
      } else {
        W('non-OK response, using incoming row');
      }
    } catch (e) {
      W('openClient hydrate failed; using summary row', e);
    }
  } else {
    L('no seedId â€” create mode');
  }

  // 2) Seed modal context
  const fullKeys = Object.keys(full || {});
  L('seeding window.modalCtx', { entity: 'clients', fullId: full?.id, fullKeys });

  window.modalCtx = {
    entity: 'clients',
    data: deep(full),
    formState: { __forId: full?.id || null, main: {} },
    ratesState: [],
    ratesBaseline: [],
    hospitalsState: { existing: [], stagedNew: [], stagedEdits: {}, stagedDeletes: new Set() },
    clientSettingsState: settingsSeed ? deep(settingsSeed) : {},
    openToken: ((full?.id) || 'new') + ':' + Date.now(),
    // NEW: persistent set for staged client-rate deletes (survives refresh/merge)
    ratesStagedDeletes: (window.modalCtx && window.modalCtx.ratesStagedDeletes instanceof Set)
      ? window.modalCtx.ratesStagedDeletes
      : new Set()
  };

  L('window.modalCtx seeded', {
    entity: window.modalCtx.entity,
    dataId: window.modalCtx.data?.id,
    dataKeys: Object.keys(window.modalCtx.data||{}),
    formStateForId: window.modalCtx.formState?.__forId,
    openToken: window.modalCtx.openToken,
    preseededSettings: Object.keys(window.modalCtx.clientSettingsState||{})
  });

  // 3) Render modal
  L('calling showModal with hasId=', !!full?.id, 'rawHasIdArg=', full?.id);
  showModal(
    'Client',
    [
      {key:'main',     label:'Main'},
      {key:'rates',    label:'Care Package Rates'},
      {key:'settings', label:'Client settings'},
      {key:'hospitals',label:'Hospitals & wards'}
    ],
    (k, r) => { L('[renderClientTab] tab=', k, 'rowKeys=', Object.keys(r||{}), 'sample=', { name: r?.name, id: r?.id }); return renderClientTab(k, r); },
    async ()=> {
      L('[onSave] begin', { dataId: window.modalCtx?.data?.id, forId: window.modalCtx?.formState?.__forId });
      const isNew = !window.modalCtx?.data?.id;

      // Collect "main" form
      const fs = window.modalCtx.formState || { __forId: null, main:{} };
      const hasId = !!window.modalCtx.data?.id;
      const same = hasId ? (fs.__forId === window.modalCtx.data.id)
                         : (fs.__forId === window.modalCtx.openToken || fs.__forId == null);

      const stagedMain = same ? (fs.main || {}) : {};
      const liveMain   = byId('tab-main') ? collectForm('#tab-main') : {};
      const payload    = { ...stagedMain, ...liveMain };

      L('[onSave] collected', { same, stagedKeys: Object.keys(stagedMain||{}), liveKeys: Object.keys(liveMain||{}) });

      delete payload.but_let_cli_ref;
      if (!payload.name && full?.name) payload.name = full.name;

      // Validate client main tab
      const clientValid = validateClientMain(payload);
      if (!clientValid) {
        return { ok:false };
      }

      // Settings normalization (including BH hours)
      const baseline = window.modalCtx.clientSettingsState || {};
      const hasFormMounted = !!byId('clientSettingsForm');
      const hasFullBaseline = ['day_start','day_end','night_start','night_end'].every(k => typeof baseline[k] === 'string' && baseline[k] !== '');
      const shouldValidateSettings = hasFormMounted || hasFullBaseline;

      let pendingSettings = null;
      if (shouldValidateSettings) {
        let csMerged = { ...(baseline || {}) };
        if (hasFormMounted) {
          const liveSettings = collectForm('#clientSettingsForm', false);
          const normKeys = ['day_start','day_end','night_start','night_end','sat_start','sat_end','sun_start','sun_end','bh_start','bh_end'];
          normKeys.forEach(k=>{
            const v = liveSettings[k];
            if (typeof v === 'string' && v.trim() !== '') {
              csMerged[k] = v.trim();
            }
          });
          if (typeof liveSettings.timezone_id === 'string' && liveSettings.timezone_id.trim() !== '') {
            csMerged.timezone_id = liveSettings.timezone_id.trim();
          }
        }

        const { cleaned: csClean, invalid: csInvalid } = normalizeClientSettingsForSave(csMerged);
        if (APILOG) console.log('[OPEN_CLIENT] client_settings (mergedâ†’clean)', { csMerged, csClean, csInvalid, hasFormMounted, hasFullBaseline });
        if (csInvalid) { alert('Times must be HH:MM (24-hour).'); return { ok:false }; }
        if (Object.keys(csClean).length) pendingSettings = csClean;
      }

      // 3) Upsert client
      const idForUpdate = window.modalCtx?.data?.id || full?.id || null;
      if (APILOG) console.log('[OPEN_CLIENT] upsertClient â†’ request', { idForUpdate, payload });
      delete payload.client_settings;

      const clientResp  = await upsertClient(payload, idForUpdate).catch(err => { E('upsertClient failed', err); return null; });
      const clientId    = idForUpdate || (clientResp && clientResp.id);
      if (APILOG) console.log('[OPEN_CLIENT] upsertClient â† response', { ok: !!clientResp, clientId });
      if (!clientId) { alert('Failed to save client'); return { ok:false }; }

      const savedClient = clientResp && typeof clientResp === 'object' ? clientResp : { id: clientId, ...payload };
      window.modalCtx.data = { ...(window.modalCtx.data || {}), ...savedClient, id: clientId };

      // 4) Save Client settings (after client exists)
      try {
        if (pendingSettings && Object.keys(pendingSettings).length) {
          if (APILOG) console.log('[OPEN_CLIENT] upsertClient (settings) â†’ PUT /api/clients/:id', { clientId, pendingSettings });
          const upd = await upsertClient({ client_settings: pendingSettings }, clientId);
          if (!upd) throw new Error('Settings update failed');
          if (upd && typeof upd === 'object') window.modalCtx.data = { ...window.modalCtx.data, ...upd, id: clientId };
        }
      } catch (err) {
        alert(`Failed to save Client settings: ${String(err?.message || err)}`);
        return { ok:false };
      }

      // 5) Hospitals CRUD (typed-safe; skip when no staged changes)
      try {
        const hsRaw = window.modalCtx.hospitalsState || {};
        const hs = {
          existing     : Array.isArray(hsRaw.existing) ? hsRaw.existing : [],
          stagedNew    : Array.isArray(hsRaw.stagedNew) ? hsRaw.stagedNew : [],
          stagedEdits  : (hsRaw.stagedEdits && typeof hsRaw.stagedEdits === 'object') ? hsRaw.stagedEdits : {},
          stagedDeletes: (hsRaw.stagedDeletes instanceof Set)
            ? hsRaw.stagedDeletes
            : new Set(Array.isArray(hsRaw.stagedDeletes) ? hsRaw.stagedDeletes : Object.keys(hsRaw.stagedDeletes || {}))
        };

        const hasDel   = hs.stagedDeletes.size > 0;
        const hasEdits = Object.keys(hs.stagedEdits).length > 0;
        const hasNew   = hs.stagedNew.length > 0;

        if (hasDel || hasEdits || hasNew) {
          if (hasDel) {
            for (const hid of hs.stagedDeletes) {
              const url = API(`/api/clients/${encodeURIComponent(clientId)}/hospitals/${encodeURIComponent(hid)}`);
              if (APILOG) console.log('[OPEN_CLIENT] DELETE hospital â†’', url);
              const res = await authFetch(url, { method: 'DELETE' });
              if (!res.ok) throw new Error(await res.text());
            }
          }

          if (hasEdits) {
            for (const [hid, patchRaw] of Object.entries(hs.stagedEdits)) {
              const patch = {};
              if (patchRaw && Object.prototype.hasOwnProperty.call(patchRaw,'hospital_name_norm')) {
                const name = String(patchRaw.hospital_name_norm || '').trim();
                if (!name) throw new Error('Hospital name cannot be blank.');
                patch.hospital_name_norm = name;
              }
              if (patchRaw && Object.prototype.hasOwnProperty.call(patchRaw,'ward_hint')) {
                const hint = String(patchRaw.ward_hint ?? '').trim();
                patch.ward_hint = hint === '' ? null : hint;
              }
              if (Object.keys(patch).length === 0) continue;
              const url = API(`/api/clients/${encodeURIComponent(clientId)}/hospitals/${encodeURIComponent(hid)}`);
              if (APILOG) console.log('[OPEN_CLIENT] PATCH hospital â†’', url, patch);
              const res = await authFetch(url, { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(patch) });
              if (!res.ok) throw new Error(await res.text());
            }
          }

          if (hasNew) {
            for (const n of hs.stagedNew) {
              const body = { hospital_name_norm: String(n?.hospital_name_norm || '').trim(), ward_hint: (String(n?.ward_hint ?? '').trim() || null) };
              if (!body.hospital_name_norm) throw new Error('Hospital name cannot be blank.');
              const url = API(`/api/clients/${encodeURIComponent(clientId)}/hospitals`);
              if (APILOG) console.log('[OPEN_CLIENT] POST hospital â†’', url, body);
              const res = await authFetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
              if (!res.ok) throw new Error(await res.text());
            }
          }

          window.modalCtx.hospitalsState.stagedDeletes = new Set();
          window.modalCtx.hospitalsState.stagedEdits   = {};
          window.modalCtx.hospitalsState.stagedNew     = [];

          try {
            const fresh = await listClientHospitals(clientId);
            window.modalCtx.hospitalsState.existing = Array.isArray(fresh) ? fresh : [];
            try { renderClientHospitalsTable(); } catch {}
          } catch (e) {
            W('[OPEN_CLIENT] hospitals refresh failed', e);
          }
        }
      } catch (err) {
        alert(`Failed to save Hospitals & wards: ${String(err?.message || err)}`);
        return { ok:false };
      }

      // 6) DELETE staged client windows BEFORE toggles/edits/inserts
      try {
        const allWindows = Array.isArray(window.modalCtx.ratesState) ? window.modalCtx.ratesState : [];
        L('[onSave] delete phase', { windows: allWindows.length, stagedDeleteSet: window.modalCtx.ratesStagedDeletes?.size || 0 });
        const setIds = (window.modalCtx.ratesStagedDeletes instanceof Set) ? new Set([...window.modalCtx.ratesStagedDeletes]) : new Set();
        for (const w of allWindows) if (w && w.id && w.__delete === true) setIds.add(String(w.id));

        if (setIds.size) {
          if (APILOG) console.log('[OPEN_CLIENT] deleting staged client windows', [...setIds]);
          for (const id of setIds) {
            const url = API(`/api/rates/client-defaults/${encodeURIComponent(id)}`);
            const res = await authFetch(url, { method: 'DELETE' });
            if (res.status === 404) continue;
            if (!res.ok) {
              const body = await res.text().catch(()=> '');
              if (res.status === 409) alert(`Delete blocked: ${body || 'Associated data prevents deletion.'}`);
              else alert(`Failed to delete client rate window: ${body || res.status}`);
              return { ok:false };
            }
          }
          window.modalCtx.ratesState    = allWindows.filter(w => !(w && w.id && setIds.has(String(w.id))));
          window.modalCtx.ratesBaseline = (Array.isArray(window.modalCtx.ratesBaseline) ? window.modalCtx.ratesBaseline : [])
                                          .filter(b => !(b && b.id && setIds.has(String(b.id))));
          if (window.modalCtx.ratesStagedDeletes instanceof Set) {
            for (const id of setIds) window.modalCtx.ratesStagedDeletes.delete(id);
          }
        }
      } catch (errDel) {
        alert(`Failed to process deletions: ${String(errDel?.message || errDel || '')}`);
        return { ok:false };
      }

      // 7) Apply status toggles
      const baselineRates = Array.isArray(window.modalCtx.ratesBaseline) ? window.modalCtx.ratesBaseline : [];
      const prevById = new Map(baselineRates.filter(r => r && r.id).map(r => [String(r.id), r]));
      let windows = Array.isArray(window.modalCtx.ratesState) ? window.modalCtx.ratesState.slice() : [];

      const toggles = [];
      for (const w of windows) {
        if (!w?.id) continue;
        const prev = prevById.get(String(w.id));
        if (!prev) continue;
        if (!!prev.disabled_at_utc !== !!w.disabled_at_utc) toggles.push({ id: w.id, disabled: !!w.disabled_at_utc });
      }
      L('[onSave] toggle phase', { togglesCount: toggles.length, windows: windows.length, baseline: baselineRates.length });
      if (toggles.length) {
        if (APILOG) console.log('[OPEN_CLIENT] applying toggles', toggles);
        for (const t of toggles) {
          try { await patchClientDefault(t.id, { disabled: t.disabled }); }
          catch (e) {
            const msg = String(e?.message || e || '');
            if (msg.includes('duplicate')) alert('Cannot enable this window: another enabled window already starts on the same date for the same role/band.');
            else alert(`Failed to update status: ${msg}`);
            return { ok:false };
          }
        }
      }

      // 8) Negative-margin guard
      const erniMult = (async ()=> {
        if (typeof window.__ERNI_MULT__ === 'number') return window.__ERNI_MULT__;
        try {
          if (typeof getSettingsCached === 'function') {
            const s = await getSettingsCached();
            let p = s?.erni_pct ?? s?.employers_ni_percent ?? 0;
            p = Number(p) || 0; if (p > 1) p = p/100;
            window.__ERNI_MULT__ = 1 + p; return window.__ERNI_MULT__;
          }
        } catch {}
        return 1;
      })();
      const mult = await erniMult;
      for (const w of windows) {
        if (w.disabled_at_utc) continue;
        for (const b of ['day','night','sat','sun','bh']) {
          const chg  = w[`charge_${b}`], paye = w[`paye_${b}`], umb = w[`umb_${b}`];
          if (chg != null && paye != null && (chg - (paye * mult)) < 0) { alert(`PAYE margin would be negative for ${w.role}${w.band?` / ${w.band}`:''} (${b.toUpperCase()}). Fix before saving.`); return { ok:false }; }
          if (chg != null && umb  != null && (chg - umb) < 0)            { alert(`Umbrella margin would be negative for ${w.role}${w.band?` / ${w.band}`:''} (${b.toUpperCase()}). Fix before saving.`); return { ok:false }; }
        }
      }

      // 9) UPDATE existing, POST new (skip disabled)
      const toUpdate = windows.filter(w => w.id && !w.disabled_at_utc);
      const toCreate = windows.filter(w => !w.id && !w.disabled_at_utc);
      L('[onSave] upsert phase', { toUpdate: toUpdate.length, toCreate: toCreate.length });

      const buildBody = (w) => ({
        client_id : clientId,
        role      : w.role || '',
        band      : w.band ?? null,
        date_from : w.date_from || null,
        date_to   : w.date_to ?? null,

        charge_day   : w.charge_day   ?? null,
        charge_night : w.charge_night ?? null,
        charge_sat   : w.charge_sat   ?? null,
        charge_sun   : w.charge_sun   ?? null,
        charge_bh    : w.charge_bh    ?? null,

        paye_day     : w.paye_day     ?? null,
        paye_night   : w.paye_night   ?? null,
        paye_sat     : w.paye_sat     ?? null,
        paye_sun     : w.paye_sun     ?? null,
        paye_bh      : w.paye_bh      ?? null,

        umb_day      : w.umb_day      ?? null,
        umb_night    : w.umb_night    ?? null,
        umb_sat      : w.umb_sat      ?? null,
        umb_sun      : w.umb_sun      ?? null,
        umb_bh       : w.umb_bh       ?? null
      });

      // PUT updates
      for (const w of toUpdate) {
        if (!w.id) continue;
        try {
          const url = API(`/api/rates/client-defaults/${encodeURIComponent(w.id)}`);
          if (APILOG) console.log('[OPEN_CLIENT] PUT client-default window â†’', w.id);
          const res = await authFetch(url, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(buildBody(w))
          });
          if (!res.ok) {
            const body = await res.text().catch(()=> '');
            alert(`Failed to update client rate window: ${body || res.status}`);
            return { ok:false };
          }
        } catch (e) {
          alert(`Failed to update a client rate window: ${String(e?.message || e)}`); return { ok:false };
        }
      }

      // POST creates
      for (const w of toCreate) {
        try {
          if (APILOG) console.log('[OPEN_CLIENT] POST client-default window â†’', w);
          await upsertClientRate(buildBody(w));
        } catch (e) {
          E('Upsert client default window failed', w, e);
          alert('Failed to create a client rate window. See console for details.');
          return { ok:false };
        }
      }

      // 10) Refresh & rebuild baseline
      try {
        const refreshed = await listClientRates(clientId /* all incl. disabled */);
        const stagedDelIds = (window.modalCtx.ratesStagedDeletes instanceof Set) ? window.modalCtx.ratesStagedDeletes : new Set();
        window.modalCtx.ratesState = (Array.isArray(refreshed) ? refreshed.map(x => ({ ...x })) : []).map(x => {
          if (stagedDelIds.has(String(x.id))) x.__delete = true;
          return x;
        });
        window.modalCtx.ratesBaseline = JSON.parse(JSON.stringify(window.modalCtx.ratesState));
        L('[onSave] post-refresh', { refreshed: window.modalCtx.ratesState.length });
        try { renderClientRatesTable(); } catch {}
      } catch (e) {
        W('[openClient] post-save refresh failed', e);
      }

      window.modalCtx.formState = { __forId: clientId, main:{} };
      if (isNew) window.__pendingFocus = { section: 'clients', id: clientId };
      L('[onSave] EXIT ok=true');
      return { ok: true, saved: window.modalCtx.data };
    },
    full?.id
  );

  // 4) Post-paint async loads (merge metadata; preserve delete flags)
  if (full?.id) {
    const token = window.modalCtx.openToken;
    const id    = full.id;
    try {
      const unified = await listClientRates(id);
      if (token === window.modalCtx.openToken && window.modalCtx.data?.id === id) {
        const stagedDelIds = (window.modalCtx.ratesStagedDeletes instanceof Set) ? window.modalCtx.ratesStagedDeletes : new Set();
        const hasStaged = Array.isArray(window.modalCtx.ratesState) && window.modalCtx.ratesState.length > 0;
        if (!hasStaged) {
          window.modalCtx.ratesState = (Array.isArray(unified) ? unified.map(r => ({ ...r })) : []).map(r => {
            if (stagedDelIds.has(String(r.id))) r.__delete = true;
            return r;
          });
          window.modalCtx.ratesBaseline = JSON.parse(JSON.stringify(window.modalCtx.ratesState));
        } else {
          const staged = Array.isArray(window.modalCtx.ratesState) ? window.modalCtx.ratesState.slice() : [];
          const stagedById = new Map(staged.map(r => [String(r.id), r]));
          (Array.isArray(unified) ? unified : []).forEach(srv => {
            const s = stagedById.get(String(srv.id));
            if (s) {
              s.disabled_at_utc  = srv.disabled_at_utc ?? null;
              s.disabled_by_name = srv.disabled_by_name ?? null;
              if (stagedDelIds.has(String(srv.id))) s.__delete = true;
            } else {
              const row = { ...srv };
              if (stagedDelIds.has(String(row.id))) row.__delete = true;
              staged.push(row);
            }
          });
          window.modalCtx.ratesState = staged;
        }
        L('[POST-PAINT] rates merged', { count: window.modalCtx.ratesState.length });
        try { renderClientRatesTable(); } catch {}
      }
    } catch (e) { W('openClient POST-PAINT rates error', e); }

    try {
      const freshHosp = await listClientHospitals(id);
      if (token === window.modalCtx.openToken && window.modalCtx.data?.id === id) {
        window.modalCtx.hospitalsState.existing = Array.isArray(freshHosp) ? freshHosp : [];
        try { renderClientHospitalsTable(); } catch {}
      }
    } catch (e) { W('openClient POST-PAINT hospitals error', e); }

  } else {
    L('skip companion loads (no full.id)');
  }
}


function ensureSelectionStyles(){
  const ID = 'gridSelectionStyles';
  if (document.getElementById(ID)) return;
  const style = document.createElement('style');
  style.id = ID;
  style.textContent = `
    /* Subtle selected-row highlight â€” readable, not shouty */
    .grid tbody tr.selected {
      background: rgba(30,136,229,0.12) !important;  /* soft blue tint */
      color: inherit !important;                     /* keep text color */
      box-shadow: inset 0 0 0 1px rgba(29,78,216,.35); /* delicate rim */
    }
    .grid tbody tr.selected td { color: inherit !important; }

    /* Hover stays understated */
    .grid tbody tr:hover {
      background: rgba(0,0,0,0.04);
    }
  `;
  document.head.appendChild(style);
}

function renderClientTab(key, row = {}){
  if (key==='main') return html(`
    <div class="form" id="tab-main">
      ${input('name','Client name', row.name)}

      <!-- CLI: display-only, never posted -->
      <div class="row">
        <label>Client Ref (CLI-â€¦)</label>
        <input id="cli_ref_display"
               value="${row.cli_ref ? String(row.cli_ref) : 'Awaiting CLI number from server'}"
               disabled
               readonly
               style="opacity:.7" />
      </div>

      <div class="row" style="grid-column:1/-1"><label>Invoice address</label><textarea name="invoice_address">${row.invoice_address || ''}</textarea></div>
      ${input('primary_invoice_email','Primary invoice email', row.primary_invoice_email,'email')}
      ${input('ap_phone','A/P phone', row.ap_phone)}
      ${select('vat_chargeable','VAT chargeable', row.vat_chargeable? 'Yes' : 'No', ['Yes','No'])}
      ${input('payment_terms_days','Payment terms (days)', row.payment_terms_days || 30, 'number')}
    </div>
  `);

  if (key === 'rates') return html(`
  <div class="form" id="tab-rates">
    <div class="row">
      <label>Care Package Rates</label>
      <div class="controls">
        <div id="clientRates"></div>
      </div>
    </div>
  </div>
`);

if (key === 'settings') return html(`
  <div class="form" id="tab-settings">
    <div class="row">
      <label>Client settings</label>
      <div class="controls">
        <div id="clientSettings"></div>
      </div>
    </div>
  </div>
`);


  if (key==='hospitals') {
    // Ensure initial render AND first-mount fetch if needed, then render the table
    setTimeout(async () => {
      try {
        const id = window.modalCtx?.data?.id || null;
        const hs = window.modalCtx?.hospitalsState || {};
        const hasExisting = Array.isArray(hs.existing) && hs.existing.length > 0;

        if (id && !hasExisting) {
          const fresh = await listClientHospitals(id);
          if (window.modalCtx?.data?.id === id) {
            window.modalCtx.hospitalsState.existing = Array.isArray(fresh) ? fresh : [];
          }
        }
        try { renderClientHospitalsTable(); } catch {}
      } catch (_) {}
    }, 0);

    return html(`<div id="clientHospitals"></div>`);
  }

  return '';
}


// ===========================
// 5) mountCandidatePayTab(...)
// (auto-populate Umbrella or PAYE bank fields + logging)
// ===========================
// ========== PAY TAB (just extra logs; logic unchanged) ==========
// This function now RESOLVES ONLY AFTER prefill (when umbrella_id is known).
// In your modal's setTab/renderTab: `return mountCandidatePayTab();` and await it.

async function mountCandidatePayTab() {
  const LOG = !!window.__LOG_PAYTAB;
  const fr  = (window.__modalStack || [])[ (window.__modalStack || []).length - 1 ] || null;
  const mode = fr ? fr.mode : 'view';
  const isEdit = (mode === 'edit' || mode === 'create');

  // ðŸ”¹ Use the *frozen* DB pay method when available
  let persistedMethod = '';
  if (window.modalCtx && window.modalCtx.dbPayMethod) {
    persistedMethod = String(window.modalCtx.dbPayMethod || '').toUpperCase();
  } else if (window.modalCtx && window.modalCtx.data && window.modalCtx.data.pay_method) {
    persistedMethod = String(window.modalCtx.data.pay_method || '').toUpperCase();
  }

  const payMethod    = (window.modalCtx?.payMethodState || persistedMethod || 'PAYE').toUpperCase();
  const currentUmbId = window.modalCtx?.data?.umbrella_id || '';

  if (LOG) {
    console.log('[PAYTAB] ENTRY', {
      mode,
      isEdit,
      dbPayMethod: window.modalCtx?.dbPayMethod || null,
      dataPayMethod: window.modalCtx?.data?.pay_method || null,
      persistedMethod,
      payMethod
    });
  }

  const umbRow    = document.getElementById('umbRow');
  const nameInput = document.getElementById('umbrella_name');
  const listEl    = document.getElementById('umbList');
  const idHidden  = document.getElementById('umbrella_id');

  const accHolder = document.querySelector('#tab-pay input[name="account_holder"]');
  const bankName  = document.querySelector('#tab-pay input[name="bank_name"]');
  const sortCode  = document.querySelector('#tab-pay input[name="sort_code"]');
  const accNum    = document.querySelector('#tab-pay input[name="account_number"]');

  // ----- Ensure modalCtx + formState/pay exist (no optional-chaining on assignment) -----

  window.modalCtx = window.modalCtx || {};
  if (!window.modalCtx.formState) {
    window.modalCtx.formState = {
      __forId: (window.modalCtx.data?.id ?? window.modalCtx.openToken ?? null),
      main: {},
      pay:  {}
    };
  }

  const fs = window.modalCtx.formState;
  fs.pay = fs.pay || {};
  const stagedPay = fs.pay;

  if (LOG) {
    console.log('[PAYTAB] STATE@ENTRY', {
      persistedMethod,
      payMethod,
      currentUmbId,
      stagedPay: { ...stagedPay }
    });
  }

  // ----- Shared helpers ----------------------------------------------------

  const unwrapList = (data) => {
    if (Array.isArray(data)) return data;
    if (data && Array.isArray(data.items)) return data.items;
    if (data && Array.isArray(data.rows))  return data.rows;
    if (data && Array.isArray(data.data))  return data.data;
    return [];
  };

  function unwrapSingle(json) {
    if (!json) return null;
    if (Array.isArray(json)) return json[0] || null;
    if (json.data && Array.isArray(json.data)) return json.data[0] || null;
    if (Array.isArray(json.rows)) return json.rows[0] || null;
    if (json.item && typeof json.item === 'object' && !Array.isArray(json.item)) return json.item;
    const keys = Object.keys(json);
    if (keys.length === 1) {
      const only = json[keys[0]];
      if (only && typeof only === 'object' && !Array.isArray(only)) return only;
    }
    return json;
  }

  const normaliseSort = (v) => {
    if (!v) return '';
    const digits = String(v).replace(/\D+/g, '').slice(0, 6);
    if (digits.length !== 6) return v;
    return digits.replace(/(\d{2})(\d{2})(\d{2})/, '$1-$2-$3');
  };

  function setBankDisabled(disabled) {
    [accHolder, bankName, sortCode, accNum].forEach(el => { if (el) el.disabled = !!disabled; });
    const umbInput = document.getElementById('umbrella_name');
    // Umbrella name should still be editable when weâ€™re editing the candidate
    if (umbInput) umbInput.disabled = !isEdit;
    try { window.__BANK_FIELDS_DISABLED__ = !!disabled; } catch {}
    if (LOG) console.log('[PAYTAB] setBankDisabled', { disabled, isEdit });
  }

  // ----- Staging helpers ---------------------------------------------------

  function stageFromDom() {
    stagedPay.account_holder = accHolder ? accHolder.value : '';
    stagedPay.bank_name      = bankName  ? bankName.value  : '';
    stagedPay.sort_code      = sortCode  ? sortCode.value  : '';
    stagedPay.account_number = accNum    ? accNum.value    : '';
    stagedPay.umbrella_name  = nameInput ? nameInput.value : '';
    stagedPay.umbrella_id    = idHidden  ? idHidden.value  : '';
    stagedPay.__forMethod    = payMethod || null;   // tag staging with the *current* method
    if (LOG) console.log('[PAYTAB] stageFromDom', { ...stagedPay });
  }

  function clearBankAndUmbrella() {
    if (accHolder) accHolder.value = '';
    if (bankName)  bankName.value  = '';
    if (sortCode)  sortCode.value  = '';
    if (accNum)    accNum.value    = '';
    if (nameInput) nameInput.value = '';
    if (idHidden)  idHidden.value  = '';

    stagedPay.account_holder = '';
    stagedPay.bank_name      = '';
    stagedPay.sort_code      = '';
    stagedPay.account_number = '';
    stagedPay.umbrella_name  = '';
    stagedPay.umbrella_id    = '';
    stagedPay.__forMethod    = null;

    if (LOG) console.log('[PAYTAB] clearBankAndUmbrella (DOM + staged)');
  }

  function fillFromCandidate() {
    const d = window.modalCtx?.data || {};
    if (accHolder) accHolder.value = d.account_holder || '';
    if (bankName)  bankName.value  = d.bank_name      || '';
    if (sortCode)  sortCode.value  = normaliseSort(d.sort_code || '');
    if (accNum)    accNum.value    = d.account_number || '';

    stageFromDom();
    if (LOG) console.log('[PAYTAB] fillFromCandidate', {
      account_holder: accHolder?.value,
      bank_name:      bankName?.value,
      sort_code:      sortCode?.value,
      account_number: accNum?.value
    });
  }

  async function fetchUmbrellaById(id) {
    try {
      const res = await authFetch(API(`/api/umbrellas/${encodeURIComponent(id)}`));
      if (!res || !res.ok) return null;
      const json = await res.json().catch(() => null);
      const row = json && (json.umbrella || unwrapSingle(json));
      return row || null;
    } catch (e) {
      if (LOG) console.warn('[PAYTAB] fetchUmbrellaById failed', id, e);
      return null;
    }
  }

  function prefillUmbrellaBankFields(umb) {
    if (!umb) return;

    // IMPORTANT: no id guard here â€“ we want repeated prefill for the same umbrella after flips
    const bank = umb.bank_name || umb.bank || umb.bankName || '';
    const sc   = umb.sort_code || umb.bank_sort_code || umb.sortCode || '';
    const an   = umb.account_number || umb.bank_account_number || umb.accountNumber || '';
    const ah   = umb.name || umb.account_holder || umb.bank_account_name || umb.accountHolder || '';

    if (bankName)  bankName.value  = bank;
    if (sortCode)  sortCode.value  = normaliseSort(sc);
    if (accNum)    accNum.value    = an;
    if (accHolder) accHolder.value = ah;

    if (nameInput && !nameInput.value) {
      nameInput.placeholder = umb.name || nameInput.placeholder || '';
    }

    stagedPay.account_holder = accHolder ? accHolder.value : '';
    stagedPay.bank_name      = bankName  ? bankName.value  : '';
    stagedPay.sort_code      = sortCode  ? sortCode.value  : '';
    stagedPay.account_number = accNum    ? accNum.value    : '';
    stagedPay.umbrella_name  = nameInput ? (nameInput.value || umb.name || '') : (umb.name || '');
    stagedPay.umbrella_id    = umb.id || '';
    stagedPay.__forMethod    = payMethod || 'UMBRELLA';

    if (LOG) console.log('[PAYTAB] prefillUmbrellaBankFields', {
      umb_id: umb.id,
      name:   umb.name,
      bank, sc, an, ah,
      stagedPay: { ...stagedPay }
    });
  }

  async function fetchAndPrefill(id) {
    if (!id) return;
    const umb = await fetchUmbrellaById(id);
    if (umb) {
      if (idHidden) idHidden.value = umb.id || idHidden.value || '';
      prefillUmbrellaBankFields(umb);
    } else if (LOG) {
      console.warn('[PAYTAB] fetchAndPrefill: umbrella not found', id);
    }
  }

  async function loadUmbrellaList() {
    let umbrellas = [];
    try {
      const res = await authFetch(API('/api/umbrellas'));
      if (res && res.ok) {
        const j = await res.json().catch(()=>[]);
        umbrellas = unwrapList(j);
      }
    } catch (e) {
      if (LOG) console.warn('[PAYTAB] loadUmbrellaList failed', e);
      umbrellas = [];
    }
    if (LOG) console.log('[PAYTAB] umbrellas list loaded', umbrellas.length);

    if (listEl) {
      listEl.innerHTML = (umbrellas || []).map(u => {
        const label = u.name || u.remittance_email || u.id;
        return `<option data-id="${u.id}" value="${label}"></option>`;
      }).join('');
    }
  }

  function syncUmbrellaSelection() {
    const val = (nameInput && nameInput.value) ? nameInput.value.trim() : '';
    if (!val) {
      if (idHidden) idHidden.value = '';
      stagedPay.umbrella_name = '';
      stagedPay.umbrella_id   = '';
      stagedPay.__forMethod   = payMethod || null;
      if (LOG) console.log('[PAYTAB] selection cleared (umbrella_name empty)', {
        stagedPay: { ...stagedPay }
      });
      return;
    }

    const allOpts = Array.from((listEl && listEl.options) ? listEl.options : []);
    const hitOpt = allOpts.find(o => o.value === val);
    const id = hitOpt && hitOpt.getAttribute('data-id');

    if (id) {
      if (LOG) console.log('[PAYTAB] selected umbrella', { label: val, id });
      if (idHidden) idHidden.value = id;
      stagedPay.umbrella_name = val;
      stagedPay.umbrella_id   = id;
      stagedPay.__forMethod   = payMethod || 'UMBRELLA';
      fetchAndPrefill(id);
    } else {
      // User typed a label that does not match any option â€“ keep text, but clear id & bank
      if (LOG) console.warn('[PAYTAB] no exact label match; clearing id & bank fields', { typed: val });
      if (idHidden) idHidden.value = '';
      stagedPay.umbrella_name = val;
      stagedPay.umbrella_id   = '';
      if (bankName) bankName.value = '';
      if (sortCode) sortCode.value = '';
      if (accNum)   accNum.value   = '';
      stagedPay.bank_name      = '';
      stagedPay.sort_code      = '';
      stagedPay.account_number = '';
      stagedPay.__forMethod    = payMethod || null;
    }
  }

  // ----- Staged state helpers / flags --------------------------------------

  function hasAnyStagedPay() {
    return ['account_holder','bank_name','sort_code','account_number','umbrella_id','umbrella_name']
      .some(k => Object.prototype.hasOwnProperty.call(stagedPay, k) && stagedPay[k] !== '' && stagedPay[k] != null);
  }

  function hasStagedForCurrentMethod() {
    if (!hasAnyStagedPay()) return false;
    const m = stagedPay.__forMethod || null;
    if (!m) return true;           // legacy/untagged â€“ treat as for current method
    return m === payMethod;
  }

  const isFlipFromPersisted =
    !!(persistedMethod && payMethod && payMethod !== persistedMethod);

  const flipFromPAYEtoUMBRELLA =  isFlipFromPersisted && persistedMethod === 'PAYE'     && payMethod === 'UMBRELLA';
  const flipFromUMBRELLAtoPAYE =  isFlipFromPersisted && persistedMethod === 'UMBRELLA' && payMethod === 'PAYE';
  const atOriginalPAYE         = !isFlipFromPersisted && persistedMethod === 'PAYE'     && payMethod === 'PAYE';
  const atOriginalUMBRELLA     = !isFlipFromPersisted && persistedMethod === 'UMBRELLA' && payMethod === 'UMBRELLA';

  if (LOG) {
    console.log('[PAYTAB] FLAGS', {
      dbPayMethod: window.modalCtx?.dbPayMethod || null,
      dataPayMethod: window.modalCtx?.data?.pay_method || null,
      persistedMethod,
      payMethod,
      isFlipFromPersisted,
      flipFromPAYEtoUMBRELLA,
      flipFromUMBRELLAtoPAYE,
      atOriginalPAYE,
      atOriginalUMBRELLA,
      hasAnyStagedPay:      hasAnyStagedPay(),
      hasStagedForCurrent:  hasStagedForCurrentMethod(),
      stagedForMethod:      stagedPay.__forMethod || null
    });
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Pay-method change handler (fires while this tab is open)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const onPmChanged = () => {
    const pm = (window.modalCtx?.payMethodState || window.modalCtx?.data?.pay_method || 'PAYE').toUpperCase();
    const nowHasStaged = hasStagedForCurrentMethod();
    if (LOG) console.log('[PAYTAB] pay-method-changed', {
      pm,
      persistedMethod,
      nowHasStaged,
      stagedForMethod: stagedPay.__forMethod || null
    });

    // On a real flip, we DO want a clean slate for the new method
    clearBankAndUmbrella();

    if (pm === 'UMBRELLA') {
      if (umbRow) umbRow.style.display = '';
      setBankDisabled(true);

      // Only auto-restore original umbrella if this was originally UMBRELLA and there is no staged state
      if (!nowHasStaged && persistedMethod === 'UMBRELLA' && currentUmbId) {
        if (LOG) console.log('[PAYTAB] pay-method-changed â†’ restore original umbrella from DB');
        fetchAndPrefill(currentUmbId);
      }
    } else {
      if (umbRow) umbRow.style.display = 'none';
      setBankDisabled(!isEdit);

      // Only auto-restore original PAYE if this was originally PAYE and there is no staged state
      if (!nowHasStaged && persistedMethod === 'PAYE') {
        if (LOG) console.log('[PAYTAB] pay-method-changed â†’ restore original PAYE from candidate');
        fillFromCandidate();
      }
    }
  };

  try {
    if (window.__payTabOnPmChanged) {
      window.removeEventListener('pay-method-changed', window.__payTabOnPmChanged);
    }
    window.__payTabOnPmChanged = onPmChanged;
    window.addEventListener('pay-method-changed', onPmChanged);
  } catch (e) {
    if (LOG) console.warn('[PAYTAB] failed to attach pay-method-changed listener', e);
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Initial render (when Pay tab is entered)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  const hadStagedAtEntry = hasStagedForCurrentMethod();

  if (payMethod === 'UMBRELLA') {
    if (umbRow) umbRow.style.display = '';
    setBankDisabled(true);

    // Always ensure umbrella dropdown is populated
    loadUmbrellaList().catch(() => {});

    if (hadStagedAtEntry) {
      // We already have staged values *for UMBRELLA* â€“ do NOT clear them; just repaint DOM
      if (LOG) console.log('[PAYTAB] initial UMBRELLA using staged pay', {
        stagedPay: { ...stagedPay }
      });
      if (accHolder) accHolder.value = stagedPay.account_holder || '';
      if (bankName)  bankName.value  = stagedPay.bank_name      || '';
      if (sortCode)  sortCode.value  = normaliseSort(stagedPay.sort_code || '');
      if (accNum)    accNum.value    = stagedPay.account_number || '';
      if (nameInput) nameInput.value = stagedPay.umbrella_name  || '';
      if (idHidden)  idHidden.value  = stagedPay.umbrella_id    || '';
    } else {
      // No UMBRELLA-staged state â†’ we can safely clear and rebuild from DB/blank
      clearBankAndUmbrella();

      if (atOriginalUMBRELLA && currentUmbId) {
        if (LOG) console.log('[PAYTAB] initial/original UMBRELLA: prefill from candidate umbrella_id');
        await fetchAndPrefill(currentUmbId);
      } else if (flipFromPAYEtoUMBRELLA) {
        if (LOG) console.log('[PAYTAB] PAYEâ†’UMBRELLA flip: start blank');
      } else {
        if (LOG) console.log('[PAYTAB] UMBRELLA/unknown origin: blank');
      }
    }

    // Wiring for user selection & future changes
    if (nameInput) {
      nameInput.disabled = !isEdit;
      nameInput.oninput  = syncUmbrellaSelection;
      nameInput.onchange = syncUmbrellaSelection;
    }
    if (idHidden) {
      idHidden.onchange = () => fetchAndPrefill(idHidden.value);
    }

  } else {
    // PAYE branch
    if (umbRow) umbRow.style.display = 'none';
    setBankDisabled(!isEdit);

    if (hadStagedAtEntry) {
      // Only re-use staged pay when it belongs to PAYE
      if (LOG) console.log('[PAYTAB] initial PAYE using staged pay', {
        stagedPay: { ...stagedPay }
      });
      if (accHolder) accHolder.value = stagedPay.account_holder || '';
      if (bankName)  bankName.value  = stagedPay.bank_name      || '';
      if (sortCode)  sortCode.value  = normaliseSort(stagedPay.sort_code || '');
      if (accNum)    accNum.value    = stagedPay.account_number || '';
      if (nameInput) nameInput.value = stagedPay.umbrella_name  || '';
      if (idHidden)  idHidden.value  = stagedPay.umbrella_id    || '';
    } else {
      // No PAYE-staged state â†’ clear and rebuild from DB/blank
      clearBankAndUmbrella();
      if (nameInput && idHidden) { nameInput.value = ''; idHidden.value = ''; }

      if (atOriginalPAYE) {
        if (LOG) console.log('[PAYTAB] initial/original PAYE: fill from candidate');
        fillFromCandidate();
      } else if (flipFromUMBRELLAtoPAYE) {
        // This is the case you care about:
        // UMBRELLA â†’ PAYE flip â†’ always start BLANK, never reuse umbrella staging.
        if (LOG) console.log('[PAYTAB] UMBRELLAâ†’PAYE flip: start blank');
      } else {
        if (LOG) console.log('[PAYTAB] PAYE/unknown origin: blank');
      }
    }
  }

  if (LOG) {
    console.log('[PAYTAB] EXIT', {
      finalDom: {
        account_holder: accHolder?.value ?? null,
        bank_name:      bankName?.value  ?? null,
        sort_code:      sortCode?.value  ?? null,
        account_number: accNum?.value    ?? null,
        umbrella_name:  nameInput?.value ?? null,
        umbrella_id:    idHidden?.value  ?? null
      },
      finalStagedPay: { ...stagedPay }
    });
  }

  // IMPORTANT: async function â€“ resolves AFTER any umbrella prefill.
}


// ============================================================================
// CALENDAR â€“ SHARED HELPERS & STATE
// ============================================================================

window.__calState = window.__calState || {};     // per contract_id: { view, win, weekEndingWeekday }
window.__candCalState = window.__candCalState || {}; // per candidate_id
window.__calStage = window.__calStage || {};     // staged changes per contract_id

// ---------- Date utilities ----------
function ymd(d) { return (typeof d === 'string') ? d.slice(0,10) : (new Date(d)).toISOString().slice(0,10); }
function ymdToDate(ymdStr) { return new Date(ymdStr + 'T00:00:00Z'); }
function dateToYmd(dt) { return dt.toISOString().slice(0,10); }
// define once, both as window prop and local alias
// 1) Ensure a single global + local alias for toYmd
window.toYmd = window.toYmd || (
  (typeof dateToYmd === 'function')
    ? dateToYmd
    : (d) => {
        const y = d.getUTCFullYear();
        const m = String(d.getUTCMonth() + 1).padStart(2, '0');
        const day = String(d.getUTCDate()).padStart(2, '0');
        return `${y}-${m}-${day}`;
      }
);
var toYmd = window.toYmd; // avoids redeclare on re-exec

// 2) Define addDays (and expose globally)
window.addDays = window.addDays || function(ymdStr, delta){
  const d = ymdToDate(ymdStr);
  d.setUTCDate(d.getUTCDate() + Number(delta || 0));
  return toYmd(d);
};
var addDays = window.addDays; // optional local alias

function enumerateDates(fromYmd, toYmd) {
  const out = []; let d = ymdToDate(fromYmd), end = ymdToDate(toYmd);
  while (d <= end) { out.push(dateToYmd(d)); d.setUTCDate(d.getUTCDate() + 1); }
  return out;
}
function computeYearWindow(year)   { return { from: `${year}-01-01`, to: `${year}-12-31` }; }
function monthBounds(year, monthIndex) { const s = new Date(Date.UTC(year, monthIndex, 1)); const e = new Date(Date.UTC(year, monthIndex+1, 0)); return { from: dateToYmd(s), to: dateToYmd(e) }; }
function computeMonthWindow(year, monthIndex) { return monthBounds(year, monthIndex); }
function stepMonth(win, delta) { const s = ymdToDate(win.from); const n = new Date(Date.UTC(s.getUTCFullYear(), s.getUTCMonth()+delta, 1)); return monthBounds(n.getUTCFullYear(), n.getUTCMonth()); }

// ---------- Week ending ----------
function computeWeekEnding(ymdStr, weekEndingWeekday /* 0=Sun..6=Sat */) {
  const d = ymdToDate(ymdStr); const dow = d.getUTCDay(); const delta = (weekEndingWeekday - dow + 7) % 7; d.setUTCDate(d.getUTCDate() + delta); return dateToYmd(d);
}

// ---------- Colors / states ----------
function colorForState(state) {
  const s = String(state || 'EMPTY').toUpperCase();
  if (s === 'PLANNED')    return 'cal-planned';
  if (s === 'SUBMITTED')  return 'cal-submitted';
  if (s === 'AUTHORISED') return 'cal-authorised';
  if (s === 'INVOICED')   return 'cal-invoiced';
  if (s === 'PAID')       return 'cal-paid';
  return ''; // EMPTY -> white
}

// ---------- Selection helpers ----------
function initSelBucket(bucketKey) {
  const store = (bucketKey === 'cand') ? window.__candSel : window.__calSel;
  if (!store) {
    if (bucketKey === 'cand') window.__candSel = { set: new Set(), anchor: null };
    else window.__calSel = { set: new Set(), anchor: null };
  }
  return (bucketKey === 'cand') ? window.__candSel : window.__calSel;
}
function toggleDaySelected(bucketKey, ymdStr, additive = false) {
  const sel = initSelBucket(bucketKey);
  if (!additive) sel.set.clear();
  if (sel.set.has(ymdStr) && additive) sel.set.delete(ymdStr); else sel.set.add(ymdStr);
  sel.anchor = ymdStr;
}
function selectRange(bucketKey, fromYmd, toYmd, additive = false) {
  const sel = initSelBucket(bucketKey);
  if (!additive) sel.set.clear();
  const lo = (fromYmd < toYmd) ? fromYmd : toYmd;
  const hi = (fromYmd < toYmd) ? toYmd   : fromYmd;
  enumerateDates(lo, hi).forEach(d => sel.set.add(d));
}
function clearCalendarSelection(bucketKey) {
  const sel = initSelBucket(bucketKey); sel.set.clear(); sel.anchor = null;
}
function computeSelectionBounds(selection /* array of ymd */) {
  if (!selection?.length) return null;
  let lo = selection[0], hi = selection[0];
  for (const d of selection) { if (d < lo) lo = d; if (d > hi) hi = d; }
  return { from: lo, to: hi };
}

// ---------- Index builders ----------
function buildDateIndex(items) { const map = new Map(); for (const it of (items||[])) { const k = it.date; const arr = map.get(k) || []; arr.push(it); map.set(k, arr); } return map; }
function buildWeekIndex(weeks) {
  const m = new Map();
  for (const w of (weeks||[])) {
    const key = w.week_ending_date;
    const e = m.get(key) || { baseWeekId: null, baseHasTs: false, baseMode: 'ELECTRONIC', siblings: [] };
    e.siblings.push(w);
    if (Number(w.additional_seq||0) === 0) { e.baseWeekId = w.id; e.baseHasTs  = !!w.timesheet_id; e.baseMode   = w.submission_mode_snapshot || 'ELECTRONIC'; }
    m.set(key, e);
  }
  return m;
}

// ---------- Staging state ----------

function getContractCalendarStageState(contractId) {
  return (window.__calStage[contractId] ||= {
    add: new Set(),
    remove: new Set(),
    additional: {},
    weekEndingWeekday: (window.__calState[contractId]?.weekEndingWeekday || 0),
    removeAll: null
  });
}
function clearContractCalendarStageState(contractId) {
  window.__calStage[contractId] = {
    add: new Set(),
    remove: new Set(),
    additional: {},
    weekEndingWeekday: (window.__calState[contractId]?.weekEndingWeekday || 0),
    removeAll: null
  };
}
async function discardContractCalendarStage(contractId) {
  clearContractCalendarStageState(contractId);
  const last = window.__calState?.[contractId]?.win || computeYearWindow((new Date()).getUTCFullYear());
  await fetchAndRenderContractCalendar(contractId, { from: last.from, to: last.to, view: window.__calState?.[contractId]?.view || 'year' });
  return { ok:true };
}























async function fetchContractChangeRatesPreview(contract_id, cutoff_we) {
  const LOGC = (typeof window.__LOG_CONTRACTS === 'boolean') ? window.__LOG_CONTRACTS : false;

  if (!contract_id) {
    throw new Error('fetchContractChangeRatesPreview: contract_id is required');
  }

  const qs = new URLSearchParams();
  if (cutoff_we) {
    qs.set('cutoff_week_ending_date', String(cutoff_we));
  }

  const path = `/api/contracts/${_enc(contract_id)}/change-rates-outstanding${qs.toString() ? `?${qs.toString()}` : ''}`;
  const url  = API(path);

  if (LOGC) {
    console.log('[CONTRACTS] fetchContractChangeRatesPreview â†’', { contract_id, cutoff_we, url });
  }

  let res;
  try {
    res = await authFetch(url);
  } catch (err) {
    if (LOGC) console.error('[CONTRACTS] change-rates-outstanding preview network error', { url, err });
    throw err;
  }

  const text = await res.text().catch(() => '');
  if (!res.ok) {
    if (LOGC) {
      console.error('[CONTRACTS] change-rates-outstanding preview failed', {
        status: res.status,
        url,
        body: text
      });
    }
    throw new Error(text || 'Failed to load outstanding weeks for this contract');
  }

  let json;
  try {
    json = text ? JSON.parse(text) : null;
  } catch (e) {
    if (LOGC) console.warn('[CONTRACTS] change-rates-outstanding preview: non-JSON body', { text });
    json = null;
  }

  if (LOGC) {
    console.log('[CONTRACTS] fetchContractChangeRatesPreview â†', json);
  }

  // Backend returns { contract_id, weeks:[...], ... }; normalise to object
  return json || { contract_id, weeks: [] };
}

async function applyChangeContractRates(contract_id, payload) {
  const LOGC = (typeof window.__LOG_CONTRACTS === 'boolean') ? window.__LOG_CONTRACTS : false;

  if (!contract_id) {
    throw new Error('applyChangeContractRates: contract_id is required');
  }

  const path = `/api/contracts/${_enc(contract_id)}/change-rates-outstanding`;
  const url  = API(path);

  const body = payload || {};
  if (LOGC) {
    console.log('[CONTRACTS] applyChangeContractRates â†’', { contract_id, url, body });
  }

  let res;
  try {
    res = await authFetch(url, {
      method: 'POST',
      headers: { 'content-type': 'application/json' },
      body: _json(body)
    });
  } catch (err) {
    if (LOGC) console.error('[CONTRACTS] applyChangeContractRates network error', { url, err });
    throw err;
  }

  const text = await res.text().catch(() => '');
  if (!res.ok) {
    if (LOGC) {
      console.error('[CONTRACTS] applyChangeContractRates failed', {
        status: res.status,
        url,
        body: text
      });
    }
    throw new Error(text || 'Failed to change contract rates for outstanding weeks');
  }

  let json;
  try {
    json = text ? JSON.parse(text) : null;
  } catch (e) {
    if (LOGC) console.warn('[CONTRACTS] applyChangeContractRates: non-JSON body', { text });
    json = null;
  }

  if (LOGC) {
    console.log('[CONTRACTS] applyChangeContractRates â†', json);
  }

  // Backend returns { old_contract_id, new_contract_id, weeks_migrated, timesheets_migrated, ... }
  return json || {};
}

async function fetchCandidatePayMethodChangePreview(candidate_id, newMethod) {
  const LOG = (typeof window.__LOG_CAND === 'boolean')
    ? window.__LOG_CAND
    : (typeof window.__LOG_CONTRACTS === 'boolean' ? window.__LOG_CONTRACTS : false);

  if (!candidate_id) {
    throw new Error('fetchCandidatePayMethodChangePreview: candidate_id is required');
  }

  const method = String(newMethod || '').toUpperCase();
  if (method !== 'PAYE' && method !== 'UMBRELLA') {
    throw new Error('fetchCandidatePayMethodChangePreview: newMethod must be PAYE or UMBRELLA');
  }

  const qs   = new URLSearchParams({ new_method: method });
  const path = `/api/candidates/${_enc(candidate_id)}/pay-method-change-preview?${qs.toString()}`;
  const url  = API(path);

  if (LOG) {
    console.log('[CAND][PAY-METHOD] preview â†’', { candidate_id, method, url });
  }

  let res;
  try {
    res = await authFetch(url);
  } catch (err) {
    if (LOG) console.error('[CAND][PAY-METHOD] preview network error', { url, err });
    throw err;
  }

  const text = await res.text().catch(() => '');
  if (!res.ok) {
    if (LOG) {
      console.error('[CAND][PAY-METHOD] preview failed', {
        status: res.status,
        url,
        body: text
      });
    }
    throw new Error(text || 'Failed to preview pay-method change');
  }

  let json;
  try {
    json = text ? JSON.parse(text) : null;
  } catch (e) {
    if (LOG) console.warn('[CAND][PAY-METHOD] preview: non-JSON body', { text });
    json = null;
  }

  if (LOG) {
    console.log('[CAND][PAY-METHOD] preview â†', json);
  }

  // Backend: { candidate_id, original_method, new_method, contracts:[...] }
  return json || { candidate_id, original_method: null, new_method: method, contracts: [] };
}

async function applyCandidatePayMethodChange(candidate_id, body) {
  const LOG = (typeof window.__LOG_CAND === 'boolean')
    ? window.__LOG_CAND
    : (typeof window.__LOG_CONTRACTS === 'boolean' ? window.__LOG_CONTRACTS : false);

  if (!candidate_id) {
    throw new Error('applyCandidatePayMethodChange: candidate_id is required');
  }

  const payload = body || {};
  const method  = String(payload.new_method || '').toUpperCase();
  if (method !== 'PAYE' && method !== 'UMBRELLA') {
    throw new Error('applyCandidatePayMethodChange: payload.new_method must be PAYE or UMBRELLA');
  }

  const path = `/api/candidates/${_enc(candidate_id)}/pay-method-change`;
  const url  = API(path);

  if (LOG) {
    console.log('[CAND][PAY-METHOD] apply â†’', {
      candidate_id,
      url,
      payload: { ...payload, /* avoid logging huge arrays in full */ contract_ids_count: Array.isArray(payload.contract_ids) ? payload.contract_ids.length : 0 }
    });
  }

  let res;
  try {
    res = await authFetch(url, {
      method: 'POST',
      headers: { 'content-type': 'application/json' },
      body: _json(payload)
    });
  } catch (err) {
    if (LOG) console.error('[CAND][PAY-METHOD] apply network error', { url, err });
    throw err;
  }

  const text = await res.text().catch(() => '');
  if (!res.ok) {
    if (LOG) {
      console.error('[CAND][PAY-METHOD] apply failed', {
        status: res.status,
        url,
        body: text
      });
    }
    throw new Error(text || 'Failed to apply pay-method change');
  }

  let json;
  try {
    json = text ? JSON.parse(text) : null;
  } catch (e) {
    if (LOG) console.warn('[CAND][PAY-METHOD] apply: non-JSON body', { text });
    json = null;
  }

  if (LOG) {
    console.log('[CAND][PAY-METHOD] apply â†', json);
  }

  // Backend: { candidate_id, original_method, new_method, old_contract_ids, new_contract_ids, affected_timesheet_ids, summary:{...} }
  return json || {
    candidate_id,
    original_method: null,
    new_method: method,
    old_contract_ids: [],
    new_contract_ids: [],
    affected_timesheet_ids: [],
    summary: { contracts_changed: 0, weeks_migrated: 0 }
  };
}

async function openChangeContractRatesModal(contractId) {
  const LOGC = (typeof window.__LOG_CONTRACTS === 'boolean') ? window.__LOG_CONTRACTS : true;
  const L    = (...a)=> { if (LOGC) console.log('[CONTRACTS][CHANGE-RATES]', ...a); };
  const W    = (...a)=> { if (LOGC) console.warn('[CONTRACTS][CHANGE-RATES]', ...a); };
  const E    = (...a)=> { if (LOGC) console.error('[CONTRACTS][CHANGE-RATES]', ...a); };

  if (!contractId) {
    alert('No contract selected.');
    return;
  }

  let preview;
  try {
    preview = await fetchContractChangeRatesPreview(contractId, null);
  } catch (err) {
    E('preview failed', err);
    alert(err?.message || 'Could not load outstanding weeks for this contract.');
    return;
  }

  const weeks = Array.isArray(preview?.weeks) ? preview.weeks.slice() : [];
  if (!weeks.length) {
    alert('There are no outstanding weeks on this contract. Nothing to change.');
    return;
  }

  weeks.sort((a, b) => String(a.week_ending_date).localeCompare(String(b.week_ending_date)));

  const defaultCutoff = preview.cutoff_week_ending_date || weeks[0].week_ending_date;

  // Seed rates + schedule from current contract modalCtx if available
  const deep = (o)=> JSON.parse(JSON.stringify(o || {}));
  const baseContract =
    (window.modalCtx &&
     window.modalCtx.entity === 'contracts' &&
     window.modalCtx.data &&
     String(window.modalCtx.data.id || '') === String(contractId))
      ? deep(window.modalCtx.data)
      : deep(preview || {});

  const R = baseContract.rates_json || {};
  const payMethod = String(baseContract.pay_method_snapshot || 'PAYE').toUpperCase();
  const showPAYE = (payMethod === 'PAYE');
  const LBL = baseContract.bucket_labels_json || {};
  const labelOf = (k) => {
    if (k==='day') return (LBL.day||'Day');
    if (k==='night') return (LBL.night||'Night');
    if (k==='sat') return (LBL.sat||'Sat');
    if (k==='sun') return (LBL.sun||'Sun');
    if (k==='bh') return (LBL.bh||'BH');
    return k;
  };
  const numStr = (v) => (v == null ? '' : String(v));

  const sched = (() => {
    const src = baseContract.std_schedule_json || {};
    const out = {};
    ['mon','tue','wed','thu','fri','sat','sun'].forEach(d => {
      const day = src[d] || {};
      out[d] = {
        start: day.start || '',
        end:   day.end   || '',
        break_minutes: (day.break_minutes != null ? String(day.break_minutes) : '')
      };
    });
    return out;
  })();

  const weeksTableHtml = `
    <div class="group">
      <div class="row">
        <label>Outstanding weeks</label>
        <div class="controls">
          <div class="hint">Only weeks that are not invoiced and not paid will be moved onto the new contract.</div>
          <div style="max-height:220px;overflow:auto;border:1px solid var(--line);border-radius:10px;margin-top:6px">
            <table class="grid compact">
              <thead>
                <tr>
                  <th>Week ending</th>
                  <th>Status</th>
                  <th>Timesheet</th>
                  <th>Invoiced?</th>
                  <th>Paid?</th>
                </tr>
              </thead>
              <tbody>
                ${weeks.map(w => `
                  <tr>
                    <td>${w.week_ending_date || ''}</td>
                    <td>${w.status || ''}</td>
                    <td>${w.timesheet_id ? 'Yes' : 'No'}</td>
                    <td>${w.is_invoiced ? 'Yes' : 'No'}</td>
                    <td>${w.is_paid ? 'Yes' : 'No'}</td>
                  </tr>
                `).join('')}
              </tbody>
            </table>
          </div>
        </div>
      </div>
      <div class="row">
        <label>Apply new rates from</label>
        <div class="controls">
          <select class="input" name="cutoff_we">
            ${weeks.map(w => `
              <option value="${w.week_ending_date}" ${w.week_ending_date === defaultCutoff ? 'selected' : ''}>
                ${w.week_ending_date}
              </option>
            `).join('')}
          </select>
          <span class="mini">Weeks on or after this week-ending date will be moved to a new contract with the updated rates and schedule.</span>
          <div class="mini" id="cutoffSummary" style="margin-top:4px;"></div>
        </div>
      </div>
    </div>
  `;

  const ratesHtml = `
    <div class="group">
      <div class="row">
        <label>Rates</label>
        <div class="controls small">
          <div class="grid-5" style="margin-bottom:4px">
            <div></div>
            <div class="mini">PAYE</div>
            <div class="mini">Umbrella</div>
            <div class="mini">Charge</div>
            <div class="mini">Margin (info only)</div>
          </div>

          ${['day','night','sat','sun','bh'].map(b => `
            <div class="grid-5" data-bucket="${b}" style="margin-bottom:4px">
              <div class="split"><span class="mini">${labelOf(b)}</span></div>
              <div><input class="input" name="paye_${b}"   placeholder="PAYE"     value="${numStr(R[`paye_${b}`])}" ${showPAYE ? '' : 'disabled'} /></div>
              <div><input class="input" name="umb_${b}"    placeholder="Umbrella" value="${numStr(R[`umb_${b}`])}"  ${showPAYE ? 'disabled' : ''} /></div>
              <div><input class="input" name="charge_${b}" placeholder="Charge"   value="${numStr(R[`charge_${b}`])}" /></div>
              <div class="mini" data-role="margin-note"></div>
            </div>
          `).join('')}
          <div class="mini">You can change any pay/charge buckets here. Margins will be checked before applying, and recomputed automatically in TSFIN after the change.</div>
        </div>
      </div>
    </div>
  `;

  const scheduleHtml = `
    <div class="group">
      <div class="row"><label>Default weekly schedule (Monâ€“Sun)</label>
        <div class="controls small">
          <div class="grid-3">
            ${['mon','tue','wed','thu','fri','sat','sun'].map(d => {
              const lab = d.charAt(0).toUpperCase() + d.slice(1);
              const day = sched[d] || {};
              return `
                <div class="rp-day" data-day="${d}" style="margin-bottom:6px">
                  <div class="split">
                    <span class="mini">${lab} start</span>
                    <input class="input" name="${d}_start" value="${day.start || ''}" placeholder="HH:MM" />
                  </div>
                  <div class="split">
                    <span class="mini">${lab} end</span>
                    <input class="input" name="${d}_end" value="${day.end || ''}" placeholder="HH:MM" />
                  </div>
                  <div class="split">
                    <span class="mini">Break (min)</span>
                    <input class="input" type="number" min="0" step="1" name="${d}_break" value="${day.break_minutes || ''}" placeholder="0" />
                  </div>
                </div>
              `;
            }).join('')}
          </div>
          <div class="mini" style="margin-top:4px">Leave a day blank to clear it from the schedule on the new contract.</div>
        </div>
      </div>
    </div>
  `;

  const modalHtml = html(`
    <div class="tabc" id="changeContractRatesForm">
      <div class="hint" style="margin-bottom:8px">
        This will create a <strong>new successor contract</strong> with the updated rates and schedule.
        All outstanding weeks from the chosen cut-off week onward will be moved to the new contract.
        Historic (paid/invoiced) weeks stay on the original contract.
      </div>
      ${weeksTableHtml}
      ${ratesHtml}
      ${scheduleHtml}
    </div>
  `);

  const timeNorm = (raw) => {
    const t = String(raw || '').trim();
    if (!t) return '';
    const m = t.match(/^(\d{1,2})(?::?(\d{2}))$/);
    if (!m) return '';
    const h = +m[1], mi = +m[2];
    if (!Number.isFinite(h) || !Number.isFinite(mi) || h < 0 || h > 23 || mi < 0 || mi > 59) return '';
    return String(h).padStart(2, '0') + ':' + String(mi).padStart(2, '0');
  };

  const buildPayloadFromDom = () => {
    const root = document.getElementById('changeContractRatesForm');
    if (!root) return null;

    const cutoffSel = root.querySelector('select[name="cutoff_we"]');
    const cutoff_we = cutoffSel ? (cutoffSel.value || '').trim() : '';
    if (!cutoff_we) {
      if (typeof showModalHint === 'function') showModalHint('Choose a cut-off week ending date.', 'warn');
      else alert('Choose a cut-off week ending date.');
      return null;
    }

    // Collect rates
    const BUCKETS = ['day','night','sat','sun','bh'];
    const rateInputs = {};
    BUCKETS.forEach(b => {
      rateInputs[`paye_${b}`]   = root.querySelector(`input[name="paye_${b}"]`);
      rateInputs[`umb_${b}`]    = root.querySelector(`input[name="umb_${b}"]`);
      rateInputs[`charge_${b}`] = root.querySelector(`input[name="charge_${b}"]`);
    });

    const parseRate = (name) => {
      const el = rateInputs[name];
      if (!el) return null;
      const raw = (el.value || '').trim();
      if (!raw) return null;
      const n = Number(raw);
      return Number.isFinite(n) ? n : null;
    };

    const rates_json = {};
    BUCKETS.forEach(b => {
      const pd = parseRate(`paye_${b}`);
      const ud = parseRate(`umb_${b}`);
      const cd = parseRate(`charge_${b}`);
      if (pd != null) rates_json[`paye_${b}`] = pd;
      if (ud != null) rates_json[`umb_${b}`] = ud;
      if (cd != null) rates_json[`charge_${b}`] = cd;
    });

    // Schedule
    const days = ['mon','tue','wed','thu','fri','sat','sun'];
    const schedOut = {};
    let hasAny = false;

    days.forEach(d => {
      const sEl = root.querySelector(`input[name="${d}_start"]`);
      const eEl = root.querySelector(`input[name="${d}_end"]`);
      const bEl = root.querySelector(`input[name="${d}_break"]`);

      const sNorm = timeNorm(sEl ? sEl.value : '');
      const eNorm = timeNorm(eEl ? eEl.value : '');
      const brRaw = bEl ? (bEl.value || '').trim() : '';

      if (sNorm && eNorm) {
        const brNum = Math.max(0, Number(brRaw || 0) || 0);
        schedOut[d] = { start: sNorm, end: eNorm, break_minutes: brNum };
        hasAny = true;
      }
    });

    const std_schedule_json = hasAny ? schedOut : null;

    return {
      cutoff_week_ending_date: cutoff_we,
      rates_json,
      std_schedule_json
    };
  };

  // Helper to ensure we have ERNI multiplier from settings (used for margin check)
  const ensureErniMult = async () => {
    if (typeof window.__ERNI_MULT__ === 'number' && window.__ERNI_MULT__ > 0) {
      return window.__ERNI_MULT__;
    }
    try {
      if (typeof getSettingsCached === 'function') {
        const s = await getSettingsCached();
        let p = s?.erni_pct ?? s?.employers_ni_percent ?? 0;
        p = Number(p) || 0;
        if (p > 1) p = p / 100;
        window.__ERNI_MULT__ = 1 + p;
        return window.__ERNI_MULT__;
      }
    } catch (e) {
      W('ensureErniMult failed, defaulting to 1', e);
    }
    window.__ERNI_MULT__ = 1;
    return 1;
  };

  // Margin validation before submit (per bucket)
  const validateMargins = async (ratesOverride) => {
    const BUCKETS = ['day','night','sat','sun','bh'];
    const erniMult = await ensureErniMult();
    const bad = [];

    for (const b of BUCKETS) {
      const chargeKey  = `charge_${b}`;
      const payPayeKey = `paye_${b}`;
      const payUmbKey  = `umb_${b}`;

      const rawCharge =
        (ratesOverride && ratesOverride.hasOwnProperty(chargeKey))
          ? ratesOverride[chargeKey]
          : R[chargeKey];

      const rawPay =
        payMethod === 'PAYE'
          ? ((ratesOverride && ratesOverride.hasOwnProperty(payPayeKey)) ? ratesOverride[payPayeKey] : R[payPayeKey])
          : ((ratesOverride && ratesOverride.hasOwnProperty(payUmbKey))  ? ratesOverride[payUmbKey]  : R[payUmbKey]);

      const ch = Number(rawCharge);
      const pa = Number(rawPay);

      if (!Number.isFinite(ch) || !Number.isFinite(pa)) continue;

      let margin;
      if (payMethod === 'PAYE') {
        margin = ch - pa * erniMult;
      } else {
        margin = ch - pa;
      }

      // Allow tiny floating point wiggle; treat anything < -0.001 as negative
      if (margin < -0.001) {
        bad.push(labelOf(b));
      }
    }

    return bad;
  };

  showModal(
    'Change Contract Rates',
    [{ key:'main', label:'Change' }],
    () => modalHtml,
    async () => {
      const payload = buildPayloadFromDom();
      if (!payload) return false;

      // ðŸ”¹ Validate margins before applying
      try {
        const badBuckets = await validateMargins(payload.rates_json || {});
        if (badBuckets.length) {
          const msg =
            'One or more buckets would have a negative margin with the new rates:\n\n' +
            badBuckets.map(b => `â€¢ ${b}`).join('\n') +
            '\n\nPlease adjust pay and/or charge so that margins remain non-negative.';
          alert(msg);
          return false;
        }
      } catch (err) {
        W('margin validation failed (non-fatal, but blocking apply)', err);
        alert('Could not validate margins. Please try again or adjust rates.');
        return false;
      }

      try {
        const resp = await applyChangeContractRates(contractId, payload);
        L('applyChangeContractRates success', resp);

        // Seed pending focus so when user closes out, Contracts summary highlights old/new contracts
        try {
          const oldId = resp?.old_contract_id;
          const newId = resp?.new_contract_id;
          const ids = [];
          if (newId) ids.push(newId);
          if (oldId && oldId !== newId) ids.push(oldId);

          if (ids.length) {
            window.__pendingFocus = {
              section: 'contracts',
              ids: ids,
              primaryIds: newId ? [newId] : []
            };
          }
        } catch (e) {
          W('failed to set pending focus (non-fatal)', e);
        }

        try { window.__toast && window.__toast('New contract created; outstanding weeks moved.'); } catch {}

        return true; // close child modal
      } catch (err) {
        E('applyChangeContractRates failed', err);
        alert(err?.message || 'Failed to change contract rates.');
        return false;
      }
    },
    false,
    null,
    { kind:'contract-change-rates', noParentGate:true, forceEdit:true }
  );

  // ðŸ”¹ After the modal is mounted, wire up the cut-off summary text
  setTimeout(() => {
    try {
      const root = document.getElementById('changeContractRatesForm');
      if (!root) return;
      const sel = root.querySelector('select[name="cutoff_we"]');
      const summary = root.querySelector('#cutoffSummary');
      if (!sel || !summary) return;

      const updateSummary = () => {
        const v = sel.value || '';
        if (!v) {
          summary.textContent = 'Choose a week ending date for the new contract to start applying.';
        } else {
          summary.textContent = `New rates and schedule will apply to weeks on or after week ending ${v}.`;
        }
      };

      sel.addEventListener('change', updateSummary);
      updateSummary();
    } catch (e) {
      W('failed to wire cutoffSummary (non-fatal)', e);
    }
  }, 0);
}

async function openCandidatePayMethodChangeModal(candidate, context = {}) {
  const LOG = (typeof window.__LOG_CAND === 'boolean')
    ? window.__LOG_CAND
    : (typeof window.__LOG_MODAL === 'boolean' ? window.__LOG_MODAL : false);
  const L  = (...a)=> { if (LOG) console.log('[CAND][PAY-METHOD][MODAL]', ...a); };
  const W  = (...a)=> { if (LOG) console.warn('[CAND][PAY-METHOD][MODAL]', ...a); };
  const E  = (...a)=> { if (LOG) console.error('[CAND][PAY-METHOD][MODAL]', ...a); };

  const cand = candidate || {};
  const candidateId = cand.id || context.candidate_id || context.id;
  if (!candidateId) {
    alert('Candidate id missing for pay-method change.');
    return false;
  }

  const origMethod = String(context.originalMethod || cand.pay_method || '').toUpperCase() || null;
  const newMethodRaw = context.newMethod || context.new_method || '';
  const newMethod = String(newMethodRaw).toUpperCase();

  L('ENTRY', {
    candidateId,
    origMethod,
    newMethodRaw,
    newMethod,
    contextKeys: Object.keys(context || {})
  });

  if (!newMethod || (newMethod !== 'PAYE' && newMethod !== 'UMBRELLA')) {
    alert('New pay method must be PAYE or UMBRELLA.');
    return false;
  }
  if (!origMethod || (origMethod !== 'PAYE' && origMethod !== 'UMBRELLA')) {
    alert('Current pay method must be PAYE or UMBRELLA to use this change flow.');
    return false;
  }
  if (origMethod === newMethod) {
    alert('New pay method is the same as the current one.');
    return false;
  }

  let preview;
  try {
    L('preview â†’ fetchCandidatePayMethodChangePreview', { candidateId, newMethod });
    preview = await fetchCandidatePayMethodChangePreview(candidateId, newMethod);
    L('preview â†', {
      candidate_id: preview?.candidate_id,
      original_method: preview?.original_method,
      new_method: preview?.new_method,
      contractsCount: Array.isArray(preview?.contracts) ? preview.contracts.length : 0
    });
  } catch (err) {
    E('preview failed', err);
    alert(err?.message || 'Failed to preview pay-method change.');
    return false;
  }

  const contracts = Array.isArray(preview?.contracts) ? preview.contracts.slice() : [];
  const directionLabel = `${origMethod} â†’ ${newMethod}`;
  const candName =
    (cand.display_name || `${cand.first_name || ''} ${cand.last_name || ''}`).trim() ||
    (cand.tms_ref || cand.id || '');

  // No contracts to touch â†’ simple confirm, then call apply endpoint (which will just flip pay_method)
  if (!contracts.length) {
    const msg = [
      `You are changing ${candName}'s pay method from ${origMethod} to ${newMethod}.`,
      '',
      'There are no weekly contracts with outstanding weeks that need adjusting.',
      'Only the candidateâ€™s pay method will be changed.',
      '',
      'Do you want to proceed?'
    ].join('\n');
    const ok = window.confirm(msg);
    if (!ok) {
      // User cancelled â†’ caller should keep Candidate modal open
      L('[NO-CONTRACTS] user cancelled simple flip dialog');
      return false;
    }

    try {
      L('[NO-CONTRACTS] applyCandidatePayMethodChange â†’', {
        candidateId,
        newMethod
      });
      const resp = await applyCandidatePayMethodChange(candidateId, { new_method: newMethod, contract_ids: [] });
      L('[NO-CONTRACTS] applyCandidatePayMethodChange â†', {
        candidate_id: resp?.candidate_id,
        original_method: resp?.original_method,
        new_method: resp?.new_method,
        summary: resp?.summary || null
      });
      focusContractsAfterBulkChange(resp);
      try { window.__toast && window.__toast('Pay method changed.'); } catch {}
      // Flip confirmed
      return true;
    } catch (err) {
      E('applyCandidatePayMethodChange failed (no contracts)', err);
      alert(err?.message || 'Failed to apply pay-method change.');
      return false;
    }
  }

  contracts.sort((a, b) => {
    const aFrom = String(a?.date_range?.start_date || '');
    const bFrom = String(b?.date_range?.start_date || '');
    return aFrom.localeCompare(bFrom);
  });

  const sanitize = (typeof window !== 'undefined' && typeof window.sanitize === 'function')
    ? window.sanitize
    : (s => String(s ?? '').replace(/&/g,'&amp;')
                           .replace(/</g,'&lt;')
                           .replace(/>/g,'&gt;')
                           .replace(/"/g,'&quot;')
                           .replace(/'/g,'&#39;'));

  const tableHtml = `
    <div class="group">
      <div class="row">
        <label>Affected weekly contracts</label>
        <div class="controls">
          <div class="hint">
            The following contracts have outstanding weeks (not yet invoiced or paid) that will be moved
            to successor contracts with pay method <strong>${newMethod}</strong>.
          </div>
          <div style="max-height:260px;overflow:auto;border:1px solid var(--line);border-radius:10px;margin-top:6px">
            <table class="grid compact">
              <thead>
                <tr>
                  <th>Client</th>
                  <th>Role / Band</th>
                  <th>Date range</th>
                  <th>Current snapshot</th>
                  <th>Outstanding weeks</th>
                  <th>First W/E</th>
                  <th>Last W/E</th>
                </tr>
              </thead>
              <tbody>
                ${contracts.map(c => {
                  const dr = c.date_range || {};
                  const range = [dr.start_date || '', dr.end_date || ''].filter(Boolean).join(' â†’ ');
                  return `
                    <tr>
                      <td>${sanitize(c.client_name || '')}</td>
                      <td>${sanitize(c.role || '')}${c.band ? ` (Band ${sanitize(c.band)})` : ''}</td>
                      <td>${sanitize(range)}</td>
                      <td>${sanitize(c.pay_method_snapshot || '')}</td>
                      <td>${c.outstanding_weeks || 0}</td>
                      <td>${c.first_outstanding_we || ''}</td>
                      <td>${c.last_outstanding_we || ''}</td>
                    </tr>
                  `;
                }).join('')}
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
  `;

  const bodyHtml = html(`
    <div class="tabc" id="candPayMethodChange">
      <div class="hint" style="margin-bottom:8px">
        You are changing <strong>${sanitize(candName)}</strong> from <strong>${sanitize(origMethod)}</strong> to
        <strong>${sanitize(newMethod)}</strong>.
        <br/>
        For each contract below, a new successor contract will be created with the new pay method, and
        all outstanding weeks will be moved over. Pay rates will be adjusted so that the <em>margin per bucket</em>
        remains the same where possible.
      </div>
      ${tableHtml}
      <div class="hint" style="margin-top:8px">
        If youâ€™d like different rates than the automatically calculated ones, you can adjust them later on the new contracts directly.
      </div>
    </div>
  `);

  const contractIds = contracts.map(c => c.contract_id).filter(Boolean).map(String);

  // Wrap showModal in a Promise so the caller can know if the user confirmed or cancelled
  return await new Promise((resolve) => {
    let settled = false;
    const done = (ok) => {
      if (settled) return;
      settled = true;
      L('RESOLVE', { candidateId, confirmed: !!ok, origMethod, newMethod });
      resolve(!!ok);
    };

    showModal(
      `Change pay method â€” ${directionLabel}`,
      [{ key:'main', label:'Summary' }],
      () => bodyHtml,
      async () => {
        // Called when user clicks Apply/Save on this modal
        try {
          L('APPLY â†’ applyCandidatePayMethodChange', {
            candidateId,
            newMethod,
            contractIds
          });
          const resp = await applyCandidatePayMethodChange(candidateId, {
            new_method: newMethod,
            contract_ids: contractIds
          });
          L('APPLY â† applyCandidatePayMethodChange', {
            candidate_id: resp?.candidate_id,
            original_method: resp?.original_method,
            new_method: resp?.new_method,
            summary: resp?.summary || null,
            old_contract_ids: resp?.old_contract_ids || [],
            new_contract_ids: resp?.new_contract_ids || []
          });

          // Prepare Contracts section to focus the before/after contracts
          focusContractsAfterBulkChange(resp);

          try { window.__toast && window.__toast('Pay method changed and contracts updated.'); } catch {}

          done(true);   // flip confirmed
          return true;  // close this modal
        } catch (err) {
          E('applyCandidatePayMethodChange failed', err);
          alert(err?.message || 'Failed to apply pay-method change.');
          done(false);  // treat as not-confirmed
          return false; // keep this modal open
        }
      },
      false,  // hasId
      () => {
        // onReturn is called when the modal is closed via X/Cancel etc.
        // If we get here and haven't already resolved, treat it as cancel.
        W('[CAND][PAY-METHOD][MODAL] closed without confirmation (cancel)');
        done(false);
      },
      { kind: 'candidate-pay-method-change', noParentGate: true, forceEdit: true }
    );
  });
}
function focusContractsAfterBulkChange(info) {
  if (!info || typeof info !== 'object') info = {};
  const newIds = Array.isArray(info.new_contract_ids) ? info.new_contract_ids.map(String) : [];
  const oldIds = Array.isArray(info.old_contract_ids) ? info.old_contract_ids.map(String) : [];

  const ids = [];
  newIds.forEach(id => { if (id && !ids.includes(id)) ids.push(id); });
  oldIds.forEach(id => { if (id && !ids.includes(id)) ids.push(id); });

  const primaryIds = newIds.filter(id => !!id);

  // Seed pending focus so renderSummary() can highlight once modals close
  if (ids.length) {
    window.__pendingFocus = {
      section: 'contracts',
      ids,
      primaryIds
    };
  }

  // Narrow Contracts list to just the affected contracts (old + new),
  // falling back to candidate_id only if we somehow have no ids.
  const candId = info.candidate_id || info.candidateId || null;
  window.__listState = window.__listState || {};
  const st = (window.__listState.contracts ||= {
    page: 1,
    pageSize: 50,
    total: null,
    hasMore: false,
    filters: null,
    sort: { key: null, dir: 'asc' }
  });

  if (!st.sort || typeof st.sort !== 'object') {
    st.sort = { key: null, dir: 'asc' };
  }

  if (!st.filters || typeof st.filters !== 'object') {
    st.filters = {};
  }

  if (ids.length) {
    // Use ids of affected contracts so we only see old+new
    st.filters.ids = ids;          // loadSection should turn this into ?ids=uuid1,uuid2,...
    st.page = 1;
    // (candidate_id is redundant at this point, so we can drop it if present)
    delete st.filters.candidate_id;
  } else if (candId) {
    // Fallback: narrow to candidate if no contract ids were provided
    st.filters.candidate_id = String(candId);
    st.page = 1;
  }

  // When jumping here from a bulk change, prefer "All" so the affected
  // contracts are visible regardless of previous status tab.
  st.filters.status = 'all';

  // Jump section to Contracts; renderAll() will be invoked either:
  // - by caller explicitly, or
  // - after the last modal is closed (see close logic that checks __pendingFocus).
  try {
    currentSection = 'contracts';
  } catch {}

  // We intentionally do NOT call renderAll() here so that
  // modal close logic can handle it once the stack is torn down.
}










































function stageContractCalendarBookings(contractId, dates /* array of ymd */) {
  const st = getContractCalendarStageState(contractId);
  for (const d of dates) { st.remove.delete(d); st.add.add(d); }
}
function stageContractCalendarUnbookings(contractId, dates /* array of ymd */) {
  const st = getContractCalendarStageState(contractId);
  for (const d of dates) { st.add.delete(d); st.remove.add(d); }
}
function stageContractCalendarAdditional(contractId, baseWeekId, dates /* array of ymd */) {
  const st = getContractCalendarStageState(contractId);
  const set = (st.additional[baseWeekId] ||= new Set());
  for (const d of dates) set.add(d);
}

// Overlay staged colors onto fetched items (without persisting)
function applyStagedContractCalendarOverlay(contractId, itemsByDate /* Map<date, [items]> */, weekIndex) {
  const st = getContractCalendarStageState(contractId);
  const overlay = new Map(itemsByDate ? itemsByDate : []);
  const addDates = [...st.add];
  const remDates = [...st.remove];

  const ensureArr = (k) => { const a = overlay.get(k) || []; overlay.set(k, a); return a; };
  const strong = (x) => ['SUBMITTED','AUTHORISED','INVOICED','PAID'].includes(String(x.state||'EMPTY').toUpperCase());

  if (st.removeAll && (st.removeAll.from || st.removeAll.to)) {
    const from = st.removeAll.from || '0000-01-01';
    const to   = st.removeAll.to   || '9999-12-31';
    const dates = enumerateDates(from, to);
    for (const d of dates) {
      const we = computeWeekEnding(d, st.weekEndingWeekday || 0);
      let wi = weekIndex.get(we);

      if (!wi) {
        const weStart = addDays(we, -6);
        let hasStrongForThis = false;
        for (let i=0;i<7;i++){
          const dd = addDays(weStart, i);
          const arr = overlay.get(dd) || [];
          if (arr.some(x => String(x.contract_id||'')===String(contractId) && strong(x))) { hasStrongForThis = true; break; }
        }
        if (hasStrongForThis) {
          wi = { baseHasTs: true };
        } else {
          wi = { baseHasTs: false };
        }
      }

      const arr = ensureArr(d);
      if (wi.baseHasTs) continue;
      const filtered = arr.filter(x => !(String(x.contract_id || '') === String(contractId)
                                      && String(x.state || 'EMPTY').toUpperCase() === 'PLANNED'));
      overlay.set(d, filtered);
    }
  }

  for (const d of addDates) {
    const arr = ensureArr(d);
    const hasStrong = arr.some(strong);
    if (!hasStrong) {
      arr.push({ date:d, state:'PLANNED', contract_id: contractId });
    }
  }

  for (const d of remDates) {
    const arr = ensureArr(d);
    const top = topState(arr);
    if (top === 'PLANNED') overlay.set(d, []);
  }

  for (const [baseWeekId, set] of Object.entries(st.additional)) {
    for (const d of set) {
      const arr = ensureArr(d);
      const hasStrong = arr.some(strong);
      if (!hasStrong) {
        arr.push({ date:d, state:'PLANNED', contract_id: contractId });
      }
    }
  }

  return overlay;
}

// NEW â€” stage "Add missing weeks" (preview only)
// Decides dates from bounds and current template (std_schedule_json / __template),
// adds them into st.add; UI repaints via fetchAndRenderContractCalendar.
async function stageAddMissingWeeks(contractId, bounds) {
  const LOG_CAL = (typeof window.__LOG_CAL === 'boolean') ? window.__LOG_CAL : true;
  const L = (...a)=> { if (LOG_CAL) console.log('[CAL][stageAddMissingWeeks]', ...a); };

  const st = getContractCalendarStageState(contractId);

  const rawFrom = bounds?.from || window.modalCtx?.data?.start_date || null;
  const rawTo   = bounds?.to   || window.modalCtx?.data?.end_date   || null;
  if (!rawFrom || !rawTo) return { ok:false, reason:'no-bounds' };

  const from = (rawFrom.includes('/') && typeof parseUkDateToIso === 'function') ? (parseUkDateToIso(rawFrom) || rawFrom) : rawFrom;
  const to   = (rawTo.includes('/')   && typeof parseUkDateToIso === 'function') ? (parseUkDateToIso(rawTo)   || rawTo)   : rawTo;

  let template = (window.modalCtx?.data?.std_schedule_json && typeof window.modalCtx.data.std_schedule_json === 'object')
    ? window.modalCtx.data.std_schedule_json
    : null;
  if (!template) {
    try {
      const fsT = window.modalCtx?.formState?.main?.__template;
      if (fsT && typeof fsT === 'object') template = fsT;
    } catch {}
  }
  if (!template || typeof template !== 'object') return { ok:false, reason:'no-template' };

  const activeDows = new Set();
  const valid = (d) => d && typeof d.start === 'string' && d.start && typeof d.end === 'string' && d.end;
  if (valid(template.sun)) activeDows.add(0);
  if (valid(template.mon)) activeDows.add(1);
  if (valid(template.tue)) activeDows.add(2);
  if (valid(template.wed)) activeDows.add(3);
  if (valid(template.thu)) activeDows.add(4);
  if (valid(template.fri)) activeDows.add(5);
  if (valid(template.sat)) activeDows.add(6);

  st.removeAll = null;

  const days = enumerateDates(from, to);
  let added = 0;
  for (const d of days) {
    const dow = ymdToDate(d).getUTCDay();
    if (!activeDows.has(dow)) continue;
    st.remove.delete(d);
    if (!st.add.has(d)) { st.add.add(d); added++; }
  }

  try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
  L('staged add-missing', { from, to, added });
  return { ok:true, added, from, to };
}


function topState(arr) {
  if (!arr?.length) return 'EMPTY';
  const prio = { EMPTY:0, PLANNED:1, SUBMITTED:2, AUTHORISED:3, INVOICED:4, PAID:5 };
  let s = 'EMPTY';
  for (const it of arr) { const st = String(it.state||'EMPTY').toUpperCase(); if ((prio[st]||0) > (prio[s]||0)) s = st; }
  return s;
}

// Build payloads for commit
function buildPlanRangesFromStage(contractId) {
  const LOG_CAL = (typeof window.__LOG_CAL === 'boolean') ? window.__LOG_CAL : true;
  const L = (...a)=> { if (LOG_CAL) console.log('[CAL][buildRanges]', ...a); };

  const st = getContractCalendarStageState(contractId);
  const adds = [...st.add].sort();
  const rems = [...st.remove].sort();

  const boundsOf = (arr) => computeSelectionBounds(arr);

  const isConsecutiveDailyRun = (arr) => {
    if (arr.length < 2) return false;
    const ONE = 24*60*60*1000;
    for (let i = 1; i < arr.length; i++) {
      const prev = new Date(arr[i-1] + 'T00:00:00Z').getTime();
      const curr = new Date(arr[i]   + 'T00:00:00Z').getTime();
      if ((curr - prev) !== ONE) return false;
    }
    return true;
  };

  // Current contract window in modal (ISO YYYY-MM-DD)
  const contract = (window.modalCtx && window.modalCtx.data) ? window.modalCtx.data : {};
  const contractStart = contract?.start_date || null;
  const contractEnd   = contract?.end_date   || null;

  // Template (std_schedule_json) if present
  let template = (window.modalCtx?.data?.std_schedule_json && typeof window.modalCtx.data.std_schedule_json === 'object')
    ? window.modalCtx.data.std_schedule_json
    : null;
  if (!template) {
    try {
      const fsT = window.modalCtx?.formState?.main?.__template;
      if (fsT && typeof fsT === 'object') template = fsT;
    } catch {}
  }

  const activeDows = (() => {
    const s = new Set();
    if (!template) return s;
    const valid = (d) => d && typeof d.start === 'string' && d.start && typeof d.end === 'string' && d.end;
    if (valid(template.sun)) s.add(0);
    if (valid(template.mon)) s.add(1);
    if (valid(template.tue)) s.add(2);
    if (valid(template.wed)) s.add(3);
    if (valid(template.thu)) s.add(4);
    if (valid(template.fri)) s.add(5);
    if (valid(template.sat)) s.add(6);
    return s;
  })();

  // If 'Remove All' was staged, build a single removal range across the (possibly current) contract window.
  if (st.removeAll) {
    const removeRanges = [];
    const from = st.removeAll.from || contractStart || null;
    const to   = st.removeAll.to   || contractEnd   || null;
    removeRanges.push({ from, to, days: [] });
    L('removeRanges (removeAll)', { bounds: { from, to } });
    return {
      addRanges: [],
      removeRanges,
      additionals: [],
      removeAll: true,
      // meta for symmetry callers
      needsLeftExtend: false,
      leftEdgeDate: null,
      rightEdgeDate: null
    };
  }

  // ---- Add ranges (with left-extend symmetry) ----
  const addRanges = [];
  let leftEdgeDate  = null;
  let rightEdgeDate = null;
  let needsLeftExtend = false;

  if (adds.length) {
    leftEdgeDate  = adds[0];
    rightEdgeDate = adds[adds.length - 1];

    // Detect if any add is strictly before the current contract start
    if (contractStart && leftEdgeDate < contractStart) {
      needsLeftExtend = true; // <-- symmetry trigger
    }

    const b = boundsOf(adds);
    const LONG_CONSECUTIVE_THRESHOLD = 10;
    const consecutive = isConsecutiveDailyRun(adds);

    // IMPORTANT: never produce an empty explicitDays when no template exists.
    // Only use weekday-compression if a valid template is present.
    const haveTemplate = activeDows.size > 0;
    let explicitDays;

    if (consecutive && adds.length >= LONG_CONSECUTIVE_THRESHOLD && haveTemplate) {
      explicitDays = adds
        .filter(d => activeDows.has(new Date(d + 'T00:00:00Z').getUTCDay()))
        .map(d => ({ date: d }));
    } else {
      // Always send explicit days when:
      // - no template, or
      // - selection is short/not long-consecutive, or
      // - we need left-extend (ensure backend sees concrete pre-start dates)
      explicitDays = adds.map(d => ({ date: d }));
    }

    addRanges.push({
      from: b.from,
      to:   b.to,
      days: explicitDays,
      merge: 'append',
      when_timesheet_exists: 'create_additional'
    });
    L('addRanges', { bounds: b, count: explicitDays.length, sample: explicitDays.slice(0, 5), needsLeftExtend });
  } else {
    L('addRanges: none');
  }

  // ---- Remove ranges ----
  const removeRanges = [];
  if (rems.length) {
    const b = boundsOf(rems);
    removeRanges.push({
      from: b.from,
      to:   b.to,
      days: rems
    });
    L('removeRanges', { bounds: b, count: rems.length, sample: rems.slice(0, 5) });
  } else {
    L('removeRanges: none');
  }

  // ---- Additional days (for split weeks) ----
  const additionals = Object.entries(st.additional).map(([baseWeekId, set]) => ({
    baseWeekId, dates: [...set].sort()
  }));
  L('additionals', { count: additionals.length, sample: additionals.slice(0, 3) });

  return {
    addRanges,
    removeRanges,
    additionals,
    removeAll: false,
    // symmetry meta for the commit path
    needsLeftExtend,
    leftEdgeDate,
    rightEdgeDate
  };
}
function revertContractCalendarStage(contractId) {
  clearContractCalendarStageState(contractId);
}

// ============================================================================
// CALENDAR â€“ API WRAPPERS
// ============================================================================

async function getContractCalendar(contract_id, opts) {
  const qs = new URLSearchParams();
  if (typeof opts === 'number') {
    qs.set('year', String(opts));
  } else if (opts && typeof opts === 'object') {
    if (opts.from) qs.set('from', String(opts.from));
    if (opts.to) qs.set('to',   String(opts.to));
    if (opts.granularity) qs.set('granularity', String(opts.granularity)); else qs.set('granularity', 'week');
    if (!opts.from && !opts.to && opts.year) qs.set('year', String(opts.year));
  } else {
    qs.set('year', String((new Date()).getUTCFullYear()));
  }
  const url = `/api/contracts/${_enc(contract_id)}/calendar?` + qs.toString();
  const r = await authFetch(API(url));
  if (!r?.ok) throw new Error('Calendar fetch failed');
  return r.json();
}
async function getContractCalendarRange(contract_id, from, to, granularity = 'day') {
  return getContractCalendar(contract_id, { from, to, granularity });
}
// Thin wrapper to match existing call sites.
// Backend returns day-level items; granularity is ignored for now.
async function getCandidateCalendarRange(candidate_id, from, to, granularity = 'day') {
  const qs = new URLSearchParams(); qs.set('from', from); qs.set('to', to);
  try {
    const r = await authFetch(API(`/api/candidates/${_enc(candidate_id)}/calendar?` + qs.toString()));
    if (!r || !r.ok) {
      try { const err = await r.json(); console.warn('[CAL][candidate] non-200', err); } catch {}
      return { from, to, items: [] };
    }
    const data = await r.json().catch(()=>null);
    if (!data || !Array.isArray(data.items)) return { from, to, items: [] };
    return data;
  } catch (e) {
    console.warn('[CAL][candidate] fetch failed', e);
    return { from, to, items: [] };
  }
}


async function getCandidateCalendar(candidate_id, from, to) {
  const qs = new URLSearchParams(); qs.set('from', from); qs.set('to', to);
  const r = await authFetch(API(`/api/candidates/${_enc(candidate_id)}/calendar?` + qs.toString()));
  if (!r?.ok) throw new Error('Candidate calendar fetch failed');
  return r.json();
}
async function contractsPlanRanges(contract_id, payload) {
  const r = await authFetch(API(`/api/contracts/${_enc(contract_id)}/plan-ranges`), { method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify(payload) });
  if (!r?.ok) throw new Error(await r.text()); return r.json();
}
async function contractsUnplanRanges(contract_id, payload) {
  const r = await authFetch(API(`/api/contracts/${_enc(contract_id)}/plan-ranges`), { method:'DELETE', headers:{'content-type':'application/json'}, body: JSON.stringify(payload) });
  if (!r?.ok) throw new Error(await r.text()); return r.json();
}
async function contractWeekPlanPatch(week_id, payload) {
  const r = await authFetch(API(`/api/contract-weeks/${_enc(week_id)}/plan`), { method:'PATCH', headers:{'content-type':'application/json'}, body: JSON.stringify(payload) });
  if (!r?.ok) throw new Error(await r.text()); return r.json();
}

// ============================================================================
// CALENDAR â€“ CONTEXT MENU
// ============================================================================
function openCalendarContextMenu({ anchorEl, bucketKey, selection, capabilities, onAction }) {
  const LOG_CAL = (typeof window.__LOG_CAL === 'boolean') ? window.__LOG_CAL : true;
  const L = (...a)=> { if (LOG_CAL) console.log('[CAL][ctx]', ...a); };

  // Remove any existing menu first
  document.getElementById('calCtxMenu')?.remove();

  // Create menu
  const menu = document.createElement('div');
  menu.id = 'calCtxMenu';
  menu.className = 'ctx-menu';

  // Position
  const r = anchorEl.getBoundingClientRect();
  menu.style.position = 'absolute';
  menu.style.zIndex = 10000;
  menu.style.top  = (window.scrollY + r.bottom) + 'px';
  menu.style.left = (window.scrollX + r.left) + 'px';

  // Dark, bordered, legible styling (inline so it works even without CSS)
  menu.style.minWidth = '180px';
  menu.style.padding = '6px';
  menu.style.border = '1px solid var(--line)';
  menu.style.borderRadius = '10px';
  menu.style.background = 'rgba(12, 21, 42, 0.98)'; // slightly lighter than page bg
  menu.style.boxShadow = '0 12px 28px rgba(0,0,0,.45), inset 0 0 0 1px rgba(255,255,255,.02)';
  menu.style.backdropFilter = 'blur(6px) saturate(120%)';

  // Items
  menu.innerHTML = `
    <div class="ctx-item ${capabilities.canBook ? '' : 'disabled'}"  data-act="book">Book</div>
    <div class="ctx-item ${capabilities.canUnbook ? '' : 'disabled'}" data-act="unbook">Unbook</div>
    <div class="ctx-item ${capabilities.canAddAdditional ? '' : 'disabled'}" data-act="additional">Add additional sheet</div>
  `;

  // Minimal inline item styles + hover
  [...menu.querySelectorAll('.ctx-item')].forEach((el, i) => {
    el.style.color = 'var(--text)';
    el.style.padding = '8px 10px';
    el.style.borderRadius = '8px';
    el.style.cursor = el.classList.contains('disabled') ? 'not-allowed' : 'pointer';
    el.style.userSelect = 'none';
    el.style.lineHeight = '1.25';
    if (i > 0) el.style.marginTop = '4px';
    el.addEventListener('mouseenter', () => { if (!el.classList.contains('disabled')) el.style.background = 'var(--hover)'; });
    el.addEventListener('mouseleave', () => { el.style.background = 'transparent'; });
    if (el.classList.contains('disabled')) { el.style.opacity = '.45'; el.style.filter = 'saturate(0.6) brightness(0.9)'; }
  });

  document.body.appendChild(menu);

  // Diagnostic log
  L('open', {
    bucketKey,
    selection: selection.slice(),
    capabilities
  });

  // Close + dispatch
  const close = () => { try { menu.remove(); } catch {} };
  menu.addEventListener('click', (e) => {
    const act = e.target?.getAttribute?.('data-act');
    if (!act || e.target.classList.contains('disabled')) return;
    close();
    onAction && onAction({ type: act, selection });
  });

  // Dismiss when clicking outside
  const onDoc = (e) => {
    if (!menu.contains(e.target)) {
      close();
      document.removeEventListener('mousedown', onDoc, true);
    }
  };
  setTimeout(() => document.addEventListener('mousedown', onDoc, true), 0);
}


// ============================================================================
// CALENDAR â€“ GENERIC DAY GRID
// ============================================================================
function renderDayGrid(hostEl, opts) {
  if (!hostEl) return;
  const { from, to, itemsByDate, view, bucketKey } = opts;
  const sel = initSelBucket(bucketKey);
  const isContractBucket = (typeof bucketKey === 'string') && bucketKey.startsWith('c:');
  const currentKey = isContractBucket ? bucketKey.slice(2) : null;
  const interactive = (typeof opts.isInteractive === 'boolean') ? opts.isInteractive : true;

  hostEl.tripwire && hostEl.tripwire.abort?.();
  const controller = new AbortController();
  hostEl.tripwire = controller;

  hostEl.innerHTML = '';
  const toolbar = document.createElement('div');
  toolbar.className = 'row';
  toolbar.style.justifyContent = 'space-between';
  toolbar.style.alignItems = 'center';
  toolbar.innerHTML = `
    <div class="actions">
      <button id="calPrev">â—€</button>
      <button id="calNext">â–¶</button>
      <button id="calToggle">${view === 'year' ? 'Month view' : 'Year view'}</button>
    </div>
    <div class="hint">${from} â†’ ${to}</div>`;
  hostEl.appendChild(toolbar);

  const wrap = document.createElement('div');
  wrap.className = (view === 'year') ? 'year-wrap' : 'month-wrap';
  hostEl.appendChild(wrap);

  const months = [];
  if (view === 'year') {
    const y = ymdToDate(from).getUTCFullYear();
    for (let m = 0; m < 12; m++) months.push({ y, m });
  } else {
    const d0 = ymdToDate(from);
    months.push({ y: d0.getUTCFullYear(), m: d0.getUTCMonth() });
  }

  for (const { y, m } of months) {
    const box = document.createElement('div');
    box.className = 'month';
    box.innerHTML = `<h4>${new Date(Date.UTC(y, m, 1)).toLocaleString(undefined, { month: 'long' })} ${y}</h4>`;
    const days = document.createElement('div');
    days.className = (view === 'year') ? 'days' : 'days days-large';

    const first = new Date(Date.UTC(y, m, 1));
    for (let i = 0; i < first.getUTCDay(); i++) {
      days.appendChild(document.createElement('div'));
    }
    const daysInMonth = new Date(Date.UTC(y, m + 1, 0)).getUTCDate();

    for (let d = 1; d <= daysInMonth; d++) {
      const cell = document.createElement('div');
      cell.className = 'd';
      const dYmd = `${y}-${String(m + 1).padStart(2, '0')}-${String(d).padStart(2, '0')}`;
      const items = itemsByDate.get(dYmd) || [];

      // â”€â”€ NEW: colour source selection
      // Candidate view â†’ derive colour from ALL items (unchanged).
      // Contract view  â†’ derive colour ONLY from current contract's items.
      let finalState = 'EMPTY';
      let ownedByCurrent = false;
      if (isContractBucket) {
        const keyStr = String(currentKey || '');
        const owned = items.filter(it => String(it?.contract_id || '') === keyStr);
        ownedByCurrent = owned.length > 0;
        if (ownedByCurrent) {
          finalState = (typeof topState === 'function') ? topState(owned) : 'EMPTY';
        } else {
          // When a day is occupied only by other contracts, we keep the state as EMPTY
          // (no coloured class) and add a light-grey overlay class below.
          finalState = 'EMPTY';
        }
      } else {
        finalState = (typeof topState === 'function') ? topState(items) : 'EMPTY';
      }

      const stateClass = (typeof colorForState === 'function') ? colorForState(finalState) : null;
      if (stateClass) cell.classList.add(stateClass);

      // Only apply â€œoccupied-otherâ€ greying in *contract* calendars and only when the day has
      // items but NONE belong to the current contract.
      if (isContractBucket) {
        const keyStr = String(currentKey || '');
        const occupiedByOtherOnly =
          !ownedByCurrent &&
          items.some(it => {
            const cid = String(it?.contract_id || '');
            return !!cid && cid !== keyStr;
          });
        if (occupiedByOtherOnly) {
          cell.classList.add('occupied-other'); // style this as your light grey
        }
      }

      if (sel.set.has(dYmd)) cell.className += ' selected';

      const dow = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'][new Date(Date.UTC(y, m, d)).getUTCDay()];
      cell.innerHTML = `<div class="ico"><div class="dow">${dow.slice(0, 3)}</div><div class="num">${d}</div></div>`;
      cell.setAttribute('data-date', dYmd);

      if (interactive) {
        const onClick = (ev) => {
          if (controller.signal.aborted) return;
          const additive = ev.ctrlKey || ev.metaKey;
          const bucket = bucketKey;
          const anchor = initSelBucket(bucket).anchor;
          const useRange = ev.shiftKey && !!(anchor);
          if (useRange) {
            selectRange(bucket, anchor, dYmd, additive);
          } else {
            toggleDaySelected(bucket, dYmd, additive);
          }
          wrap.querySelectorAll('.d.selected').forEach(n => n.classList.remove('selected'));
          initSelBucket(bucket).set.forEach(s => {
            const dom = wrap.querySelector(`.d[data-date="${CSS.escape(s)}"]`);
            if (dom) dom.classList.add('selected');
          });
        };
        const onCtx = (ev) => {
          if (controller.signal.aborted) return;
          ev.preventDefault();
          const bucket = bucketKey;
          const selSet = initSelBucket(bucket).set;
          if (!selSet.has(dYmd)) {
            clearCalendarSelection(bucket);
            toggleDaySelected(bucket, dYmd, false);
            cell.classList.add('selected');
          }
          opts.onCellContextMenu && opts.onCellContextMenu(dYmd, ev);
        };
        cell.addEventListener('click', onClick, { signal: controller.signal });
        cell.addEventListener('contextmenu', onCtx, { signal: controller.signal });
      }

      days.appendChild(cell);
    }

    box.appendChild(days);
    wrap.appendChild(box);
  }

  toolbar.querySelector('#calPrev')?.addEventListener('click', () => {
    if (!controller.signal.aborted) opts.onNav && opts.onNav(-1);
  }, { signal: controller.signal });

  toolbar.querySelector('#calNext')?.addEventListener('click', () => {
    if (!controller.signal.aborted) opts.onNav && opts.onNav(1);
  }, { signal: controller.signal });

  toolbar.querySelector('#calToggle')?.addEventListener('click', () => {
    if (!controller.signal.aborted) opts.onToggleView && opts.onToggleView();
  }, { signal: controller.signal });
}

// ============================================================================
// CALENDAR â€“ LEGEND
// ============================================================================
function renderCalendarLegend(container) {
  if (!container) return;
  container.innerHTML = `
    <div class="legend">
      <span class="chip cal-planned">Planned</span>
      <span class="chip cal-submitted">Submitted</span>
      <span class="chip cal-authorised">Authorised</span>
      <span class="chip cal-invoiced">Invoiced</span>
      <span class="chip cal-paid">Paid</span>
      <span class="chip">Not booked</span>
    </div>`;
}

// ============================================================================
// CONTRACTS â€“ FETCH & RENDER (DAY CALENDAR) with STAGING
// ============================================================================


// Calendar Save/Discard is deprecated â€” keep as a no-op to avoid breaking older calls.
function wireContractCalendarSaveControls(contractId, holder, weekIndex) {
  // Remove old bar if present, and do not render anything new
  holder.querySelector('#calSaveBar')?.remove();
  // No-op: Big Save (modal) is responsible for committing calendar changes now.
}

// ============================================================================
// CONTRACTS â€“ TAB RENDERER
// ============================================================================

function renderContractCalendarTab(ctx) {
  const LOGM = !!window.__LOG_MODAL;
  const c = ctx?.data || {};
  const holderId = 'contractCalendarHolder';

  const currentKey = (c.id || window.modalCtx?.openToken || null);
  const candId = c.candidate_id
              || (window.modalCtx?.formState?.main?.candidate_id || '').trim()
              || (document.querySelector('#contractForm input[name="candidate_id"]')?.value || '').trim();

  const weekEnding = (c.week_ending_weekday_snapshot ?? window.modalCtx?.formState?.main?.week_ending_weekday_snapshot ?? 0);

  const fr = (typeof window.__getModalFrame === 'function') ? window.__getModalFrame() : null;
  const inViewMode = !!(fr && fr.mode === 'view');

  // --- actions (includes Duplicate + Change Rates)
  const actionsHtml = (c.id
    ? `<div class="actions" style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap">
         ${inViewMode ? `` : `<button id="btnAddMissing">Add missing weeks</button>
         <button id="btnRemoveAll">Remove all weeks</button>`}
         ${inViewMode ? `<button id="btnCloneExtend">Clone & Extendâ€¦</button>
         <button id="btnDuplicateContract">Duplicate Contractâ€¦</button>
         <button id="btnChangeRatesOutstanding">Change Contract Ratesâ€¦</button>` : ``}
       </div>`
    : ``);

  // --- early hint ONLY for brand-new contracts with no candidate
  const hasId = !!c.id;
  if (!hasId && !candId) {
    if (LOGM) console.log('[CAL][contract] no candidate yet for NEW contract; render hint');
    return `
      <div id="${holderId}" class="tabc">
        <div class="info-row" style="margin:0 0 8px 0;font-size:13px;">
          <strong>Candidate:</strong>
          <span class="unassigned" style="color:var(--danger,#c0392b);margin-left:6px;">&lt;Unassigned&gt;</span>
        </div>
        <div class="hint">Pick a candidate to view and stage calendar dates.</div>
        ${actionsHtml}
      </div>`;
  }

  setTimeout(async () => {
    try {
      const y = (new Date()).getUTCFullYear();
      const win = computeYearWindow(y);
      const el = byId(holderId); if (!el) return;

      el.innerHTML = `
        <div class="tabc" style="display:flex;flex-direction:column;gap:8px;height:calc(72vh);max-height:calc(72vh)">
          <div class="info-row" style="font-size:13px;">
            <strong>Candidate:</strong>
            <span id="__calCandidateName" style="margin-left:6px;"></span>
          </div>
          <div id="__calScroll" style="flex:1;min-height:0;overflow:auto;border:1px solid var(--line,#e5e5e5);border-radius:8px;padding:4px;">
            <div id="__contractCal"></div>
          </div>
          ${actionsHtml}
        </div>`;

      // Render the candidate label (supports <Unassigned>)
      try {
        const nameEl = el.querySelector('#__calCandidateName');
        if (nameEl) {
          const stagedLabel = (window.modalCtx?.formState?.main?.candidate_display || '').trim();
          const rowLabel    = (c.candidate_display || c.candidate_name || '').trim();
          const label       = stagedLabel || rowLabel || '';
          if (label) {
            nameEl.textContent = label;
          } else {
            nameEl.textContent = '<Unassigned>';
            nameEl.style.color = 'var(--danger,#c0392b)';
          }
        }
      } catch {}

      if (c.id) {
        // EXISTING contract â†’ always render calendar, even if candidate_id is null
        if (LOGM) console.log('[CAL][contract] render with real contract id', { id: c.id, win });
        await fetchAndRenderContractCalendar(c.id, { from: win.from, to: win.to, view: 'year' });
      } else {
        // CREATE mode with candidate â†’ candidate-wide planner
        if (LOGM) console.log('[CAL][contract] render in CREATE mode (candidate-wide) with token bucket', { token: currentKey, candId, weekEnding });
        await fetchAndRenderCandidateCalendarForContract(
          currentKey,
          candId,
          { from: win.from, to: win.to, view: 'year', weekEnding: Number(weekEnding) }
        );
      }

      if (c.id) {
        const btnAdd = el.querySelector('#btnAddMissing');
        if (btnAdd && !btnAdd.__wired) {
          btnAdd.__wired = true;
          btnAdd.addEventListener('click', async () => {
            if (typeof stageAddMissingWeeks === 'function') {
              if (LOGM) console.log('[CAL][contract] stage add missing weeks', { id: c.id, from: c.start_date || win.from, to: c.end_date || win.to });
              await stageAddMissingWeeks(c.id, { from: c.start_date || win.from, to: c.end_date || win.to });
              try { showModalHint?.('Missing weeks staged (preview only). Save to persist.', 'warn'); } catch {}
            }
            const prev = byId('__calScroll')?.scrollTop || 0;
            await fetchAndRenderContractCalendar(
              c.id,
              {
                from: window.__calState[c.id]?.win?.from,
                to:   window.__calState[c.id]?.win?.to,
                view: window.__calState[c.id]?.view
              }
            );
            const sb = byId('__calScroll'); if (sb) sb.scrollTop = prev;
          });
        }

        const btnRem = el.querySelector('#btnRemoveAll');
        if (btnRem && !btnRem.__wired) {
          btnRem.__wired = true;
          btnRem.addEventListener('click', async () => {
            if (!window.confirm('Remove all unsubmitted weeks for this contract?')) return;
            if (typeof removeAllUnsubmittedWeeks === 'function') {
              if (LOGM) console.log('[CAL][contract] stage remove all unsubmitted weeks', { id: c.id, from: c.start_date || null, to: c.end_date || null });
              await removeAllUnsubmittedWeeks(c.id, { from: c.start_date || null, to: c.end_date || null });
              try { showModalHint?.('All unsubmitted weeks staged for removal (preview only). Save to persist.', 'warn'); } catch {}
            }
            const prev = byId('__calScroll')?.scrollTop || 0;
            await fetchAndRenderContractCalendar(
              c.id,
              {
                from: window.__calState[c.id]?.win?.from,
                to:   window.__calState[c.id]?.win?.to,
                view: window.__calState[c.id]?.view
              }
            );
            const sb = byId('__calScroll'); if (sb) sb.scrollTop = prev;
          });
        }

        const btnCE = el.querySelector('#btnCloneExtend');
        if (btnCE && !btnCE.__wired) {
          btnCE.__wired = true;
          btnCE.addEventListener('click', () => {
            if (LOGM) console.log('[CAL][contract] open clone & extend', { id: c.id });
            openContractCloneAndExtend(c.id);
          });
        }

        // NEW: Change Contract Rates (outstanding weeks)
        const btnCR = el.querySelector('#btnChangeRatesOutstanding');
        if (btnCR && !btnCR.__wired) {
          btnCR.__wired = true;
          btnCR.addEventListener('click', () => {
            if (typeof openChangeContractRatesModal === 'function') {
              if (LOGM) console.log('[CAL][contract] open change contract rates', { id: c.id });
              openChangeContractRatesModal(c.id);
            } else {
              alert('Change Contract Rates is not available in this build.');
            }
          });
        }

        // Duplicate Contractâ€¦
        const btnDup = el.querySelector('#btnDuplicateContract');
        if (btnDup && !btnDup.__wired) {
          btnDup.__wired = true;
          btnDup.addEventListener('click', async () => {
            try {
              const countStr = window.prompt(
                'How many duplicate contracts do you require? (1â€“10)',
                '1'
              );
              if (countStr == null) return; // user hit Cancel

              const n = Number(countStr);
              if (!Number.isInteger(n) || n < 1 || n > 10) {
                alert('Please enter a whole number between 1 and 10.');
                return;
              }

              if (typeof duplicateContract !== 'function') {
                alert('Duplicate action is unavailable in this build.');
                return;
              }

              const res = await duplicateContract(c.id, { count: n });
              const ok  = !!(res && (res.ok === undefined ? true : res.ok));
              if (!ok) {
                const msg = res && res.message ? res.message : 'Duplicate failed';
                alert(msg);
                return;
              }

              const created = (res && Number.isInteger(res.count)) ? res.count : n;
              try {
                window.__toast?.(
                  `${created} duplicate contract${created > 1 ? 's' : ''} created`
                );
              } catch {}

              // Refresh list (and hence calendars/rows)
              try { await renderAll(); } catch {}
            } catch (e) {
              if (LOGM) console.warn('[CAL][contract] duplicate failed', e);
              alert(e?.message || 'Duplicate failed');
            }
          });
        }
      }
    } catch (e) {
      const el = byId(holderId); if (el) el.innerHTML = `<div class="error">Calendar load failed.</div>`;
      if (LOGM) console.warn('[CAL][contract] calendar render failed', e);
    }
  }, 0);

  return `
    <div id="${holderId}" class="tabc">
      <div class="info-row" style="margin:0 0 8px 0;font-size:13px;">
        <strong>Candidate:</strong>
        <span id="__calCandidateName" style="margin-left:6px;"></span>
      </div>
      <div class="hint">Loading calendarâ€¦</div>
      ${actionsHtml}
    </div>`;
}


function isConsecutiveDailyRun(dates) {
  if (!Array.isArray(dates) || dates.length < 2) return false;
  const arr = [...dates].sort();
  let hasPair = false;
  for (let i = 1; i < arr.length; i++) {
    const a = ymdToDate(arr[i - 1]);
    const b = ymdToDate(arr[i]);
    const diff = Math.round((b - a) / 86400000);
    if (diff === 1) hasPair = true;
  }
  return hasPair;
}

function updateCalendarInteractivity(isInteractive) {
  window.__calInteractive = !!isInteractive;
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 5) Optional thin wrapper if you prefer not to call the API
//    directly throughout the UI (used by calendar wrapper).
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function fetchCandidateCalendarForRange(candidateId, fromYmd, toYmd) {
  if (typeof getCandidateCalendarRange !== 'function') return { items: [] };
  try {
    return await getCandidateCalendarRange(candidateId, fromYmd, toYmd, 'day');
  } catch {
    return { items: [] };
  }
}
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 4) Unbooking helper (present in some snippets, ensure available)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function stageContractCalendarUnbookings(contractId, dates /* array of ymd */) {
  const st = getContractCalendarStageState(contractId);
  for (const d of dates) { st.add.delete(d); st.remove.add(d); }
}
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 3) Stage adoption helper (token â†’ real id) for create flow
//    You can use this inside openContract.onSave to simplify.
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function adoptCalendarStageFromToken(openToken, contractId) {
  const LOG_CAL = (typeof window.__LOG_CAL === 'boolean') ? window.__LOG_CAL : false;
  if (!openToken || !contractId || typeof getContractCalendarStageState !== 'function') return false;
  try {
    const stToken = getContractCalendarStageState(openToken);
    if (!stToken) return false;
    const has = (stToken.add?.size || stToken.remove?.size || Object.keys(stToken.additional||{}).length);
    if (!has) return false;
    const stId = getContractCalendarStageState(contractId);
    for (const d of stToken.add)    stId.add.add(d);
    for (const d of stToken.remove) stId.remove.add(d);
    stId.additional = { ...(stId.additional||{}), ...(stToken.additional||{}) };
    stToken.add?.clear?.(); stToken.remove?.clear?.(); stToken.additional = {};
    if (LOG_CAL) console.log('[CAL][adopt] token â†’ id', { openToken, contractId });
    return true;
  } catch (e) {
    if (LOG_CAL) console.warn('[CAL][adopt] failed', e);
    return false;
  }
}
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 2) Candidate-wide calendar renderer for the contract modal
//    Always renders ALL bookings for the candidate and stages
//    against currentKey (contract.id or openToken).
//    (Used by renderContractCalendarTab and openContract repaint)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function computeContractSaveEligibility() {
  try {
    const fs   = (window.modalCtx && window.modalCtx.formState) || { main:{}, pay:{} };
    const data = (window.modalCtx && window.modalCtx.data) || {};
    const form = document.querySelector('#contractForm');

    const val = (name) => {
      const staged = fs.main && fs.main[name];
      if (staged !== undefined && staged !== null && String(staged).trim() !== '') return String(staged).trim();
      const el = form ? form.querySelector(`[name="${name}"]`) : null;
      return el ? String(el.value || '').trim() : '';
    };

    const hasText = (s) => !!(s && String(s).trim().length);

    // -------- Required entities with fallback to saved data
    const candidateOk = hasText(val('candidate_id')) || !!data.candidate_id;
    const clientOk    = hasText(val('client_id'))    || !!data.client_id;
    const roleOk      = hasText(val('role'))         || !!data.role;

    // -------- Dates (with fallback to saved row, and awareness of pending auto-expand)
    const toIso = (uk) => {
      if (!uk) return '';
      try { return (typeof parseUkDateToIso === 'function') ? (parseUkDateToIso(uk) || '') : uk; }
      catch { return uk; }
    };
    const vSd = val('start_date'), vEd = val('end_date');
    const sdIsoRaw = toIso(vSd) || (data.start_date || '');
    const edIsoRaw = toIso(vEd) || (data.end_date   || '');

    const bothDatesProvided = /^\d{4}-\d{2}-\d{2}$/.test(sdIsoRaw) && /^\d{4}-\d{2}-\d{2}$/.test(edIsoRaw);
    const dateOrderOk       = (!bothDatesProvided) || (sdIsoRaw <= edIsoRaw);

    const pendingExpand = (window.modalCtx && window.modalCtx.__windowExpand && window.modalCtx.__windowExpand.start && window.modalCtx.__windowExpand.end) ? window.modalCtx.__windowExpand : null;

    // -------- Is there any staged calendar?
    let hasStaged = false;
    try {
      const key = data.id || window.modalCtx?.openToken || null;
      if (key && typeof getContractCalendarStageState === 'function') {
        const st = getContractCalendarStageState(key);
        hasStaged = !!(st && (st.add?.size || st.remove?.size || (st.additional && Object.keys(st.additional).length)));
      }
    } catch {}

    // -------- Schedule validation (pending time format supported) with template fallback
    const reValidHHMM   = /^(\d{1,2}):(\d{2})$/;
    const rePendingOnly = /^\d{3,4}$/;
    const hhmm = (s) => {
      const m = String(s||'').match(reValidHHMM);
      if (!m) return null;
      const h = +m[1], mi = +m[2];
      if (h<0 || h>23 || mi<0 || mi>59) return null;
      return [h,mi];
    };

    const days = ['mon','tue','wed','thu','fri','sat','sun'];
    let hasValidPair   = false;
    let hasPendingPair = false;
    const pendingFields = [];
    const pendingDays   = [];

    for (const d of days) {
      const s = val(`${d}_start`);
      const e = val(`${d}_end`);
      if (!s || !e) continue;

      const sValid   = !!hhmm(s);
      const eValid   = !!hhmm(e);
      const sPending = rePendingOnly.test(s);
      const ePending = rePendingOnly.test(e);

      if (sValid && eValid) {
        hasValidPair = true;
      } else if ((sValid || sPending) && (eValid || ePending)) {
        hasPendingPair = true;
        if (sPending) pendingFields.push(`${d}_start`);
        if (ePending) pendingFields.push(`${d}_end`);
        pendingDays.push(d);
      }
    }

    const hasTemplate = !!(data.std_schedule_json && typeof data.std_schedule_json === 'object' && Object.keys(data.std_schedule_json).length);
    const scheduleOk = (hasValidPair || hasPendingPair || hasStaged || hasTemplate);
    const pendingTimeFormat = hasPendingPair || pendingFields.length > 0;

    // -------- Finance checks (with fallback to saved rates_json)
    const payMethod = ((val('pay_method_snapshot') || data.pay_method_snapshot || 'PAYE')).toUpperCase();

    const getNum = (n) => {
      if (fs.pay && Object.prototype.hasOwnProperty.call(fs.pay, n)) {
        const rawS = fs.pay[n];
        if (rawS !== '' && rawS !== null && rawS !== undefined) {
          const numS = Number(rawS);
          if (Number.isFinite(numS)) return numS;
        }
      }
      if (form) {
        const el = form.querySelector(`[name="${n}"]`);
        if (el && el.value !== '' && el.value !== null && el.value !== undefined) {
          const numD = Number(el.value);
          if (Number.isFinite(numD)) return numD;
        }
      }
      try {
        const saved = (window.modalCtx && window.modalCtx.data && window.modalCtx.data.rates_json) || {};
        const v = saved[n];
        if (v === 0 || (typeof v === 'number' && Number.isFinite(v))) return Number(v);
      } catch {}
      return null;
    };

    const payBuckets = (payMethod === 'PAYE')
      ? ['paye_day','paye_night','paye_sat','paye_sun','paye_bh']
      : ['umb_day','umb_night','umb_sat','umb_sun','umb_bh'];
    const chargeBuckets = ['charge_day','charge_night','charge_sat','charge_sun','charge_bh'];

    const anyPay    = payBuckets.some(b => getNum(b) !== null);
    const anyCharge = chargeBuckets.some(b => getNum(b) !== null);

    let hasNegativeMargins = false;
    if (window.__contractMarginState && typeof window.__contractMarginState.hasNegativeMargins === 'boolean') {
      hasNegativeMargins = !!window.__contractMarginState.hasNegativeMargins;
    } else {
      for (const cb of chargeBuckets) {
        const b  = cb.split('_')[1];
        const ch = getNum(`charge_${b}`);
        const py = getNum(`${payMethod === 'PAYE' ? 'paye' : 'umb'}_${b}`);
        if (ch !== null && py !== null && (ch - py) < 0) { hasNegativeMargins = true; break; }
      }
    }

    // -------- Timesheet boundary guard (uses cached result)
    let tsBoundaryViolation = false;
    let tsBoundaryMsg = null;
    try {
      const tsRes = window.__tsBoundaryResult;
      if (data?.id && tsRes && tsRes.ok === false) {
        tsBoundaryViolation = true;
        const v = tsRes.violations || [];
        if (v.length) {
          const sample = v.slice(0,3).map(x => {
            const nm = x.client_name || 'Client';
            const dt = x.date || '';
            const st = x.status || '';
            return `${nm} ${dt}${st?` (${st})`:''}`;
          }).join(' â€¢ ');
          tsBoundaryMsg = `Dates exclude existing timesheets: ${sample}${v.length>3? 'â€¦':''}`;
        } else if (tsRes.min_ts_date || tsRes.max_ts_date) {
          tsBoundaryMsg = `Dates exclude timesheets in range ${tsRes.min_ts_date||''} â†’ ${tsRes.max_ts_date||''}.`;
        } else {
          tsBoundaryMsg = 'Dates exclude existing timesheets.';
        }
      }
    } catch {}

    // -------- Compose eligibility & reasons (with pending auto-expand awareness)
    const reasons = [];

    if (!candidateOk) reasons.push({ code:'MISSING_CANDIDATE', message:'Pick a candidate.' });
    if (!clientOk)    reasons.push({ code:'MISSING_CLIENT',    message:'Pick a client.' });
    if (!roleOk)      reasons.push({ code:'MISSING_ROLE',      message:'Enter a role.' });

    const hasWindowExpand = !!pendingExpand;

    if (!bothDatesProvided && !hasStaged && !hasWindowExpand) {
      reasons.push({ code:'DATES_OR_STAGE_REQUIRED', message:'Provide start & end dates or stage calendar changes.' });
    } else if (bothDatesProvided && !dateOrderOk) {
      reasons.push({ code:'DATE_ORDER_INVALID', message:'Start date must be on or before end date.' });
    }

    if (!scheduleOk) {
      reasons.push({ code:'SCHEDULE_REQUIRED', message:'Add at least one day with Start & End (or stage calendar changes).' });
    }

    if (!anyPay)    reasons.push({ code:'MISSING_PAY_RATES',    message:'Enter at least one pay bucket.' });
    if (!anyCharge) reasons.push({ code:'MISSING_CHARGE_RATES', message:'Enter at least one charge bucket.' });
    if (hasNegativeMargins) reasons.push({ code:'NEGATIVE_MARGIN', message:'One or more buckets produce a negative margin.' });

    if (tsBoundaryViolation) {
      reasons.push({ code:'TS_BOUNDARY_VIOLATION', message: tsBoundaryMsg || 'Dates exclude existing timesheets.' });
    }

    // âœ… FINAL ELIGIBILITY:
    //   â€¢ Candidate is NO LONGER a hard requirement here (still warned via reasons).
    const ok =
      /* candidateOk && */            // <-- removed from hard gate
      clientOk &&
      roleOk &&
      (
        (bothDatesProvided ? dateOrderOk : true) // dates ok if provided & ordered
        || hasStaged
        || hasWindowExpand
      ) &&
      scheduleOk &&
      anyPay &&
      anyCharge &&
      !hasNegativeMargins &&
      !tsBoundaryViolation;

    const detail = {
      ok,
      pendingTimeFormat,
      pending: {
        timeFormat: pendingTimeFormat,
        fields: pendingFields,
        days: pendingDays
      },
      checkpoints: {
        candidateOk, clientOk, roleOk,
        dates: { bothDatesProvided, dateOrderOk, hasStagedCalendar: hasStaged, tsBoundaryOk: !tsBoundaryViolation, willAutoExpand: !!hasWindowExpand },
        schedule: { hasValidPair, hasPendingPair, hasStagedCalendar: hasStaged, hasTemplate },
        finance: { anyPay, anyCharge, hasNegativeMargins, payMethod }
      },
      reasons,
      tip: pendingTimeFormat ? 'Weâ€™ll format times like 0900 â†’ 09:00 when you tab out or save.' : null
    };

    window.__contractEligibility = detail;
    return ok;
  } catch (e) {
    window.__contractEligibility = { ok:false, reasons:[{ code:'INTERNAL_ERROR', message:String(e && e.message || e || 'unknown error') }] };
    return false;
  }
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 1) Non-blocking date-window overlap checker (Main tab hint)
//    Call from renderContractMainTab on start/end date change.
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function callCheckContractWindowOverlap(candidate_id, start_date_iso, end_date_iso, exclude_contract_id) {
  const LOGC = (typeof window.__LOG_CONTRACTS === 'boolean') ? window.__LOG_CONTRACTS : false;
  const payload = {
    candidate_id: candidate_id || null,
    start_date  : start_date_iso || null,
    end_date    : end_date_iso || null,
    ignore_contract_id: exclude_contract_id || null
  };
  if (!candidate_id || !start_date_iso || !end_date_iso) return { has_overlap: false, overlaps: [] };
  if (typeof checkContractOverlap !== 'function') { if (LOGC) console.warn('[CONTRACTS] checkContractOverlap missing'); return { has_overlap:false, overlaps:[] }; }
  try {
    if (LOGC) console.log('[CONTRACTS] callCheckContractWindowOverlap â†’ req', payload);
    const res = await checkContractOverlap(payload);
    if (LOGC) console.log('[CONTRACTS] callCheckContractWindowOverlap â† res', res);
    return res || { has_overlap:false, overlaps:[] };
  } catch (e) {
    if (LOGC) console.warn('[CONTRACTS] window overlap check failed', e);
    return { has_overlap:false, overlaps:[] };
  }
}


async function fetchAndRenderCandidateCalendarForContract(currentKey, candidateId, opts) {
  const LOG_CAL = (typeof window.__LOG_CAL === 'boolean') ? window.__LOG_CAL : true;
  const L = (...a)=> { if (LOG_CAL) console.log('[CAL][candidate-wide]', ...a); };

  const state = (window.__calState[currentKey] ||= {
    view: (opts?.view || 'year'),
    win:  (opts?.from && opts?.to) ? { from: opts.from, to: opts.to } : computeYearWindow((new Date()).getUTCYear ? (new Date()).getUTCFullYear() : (new Date()).getFullYear()),
    weekEndingWeekday: (typeof opts?.weekEnding !== 'undefined' ? Number(opts.weekEnding) : (window.modalCtx?.data?.week_ending_weekday_snapshot ?? 0)),
    scrollTop: 0
  });

  if (opts?.view) state.view = opts.view;
  if (opts?.from && opts?.to) state.win = { from: opts.from, to: opts.to };
  if (typeof opts?.weekEnding !== 'undefined') state.weekEndingWeekday = Number(opts.weekEnding);

  const holder = byId('contractCalendarHolder'); if (!holder) return;
  const scrollBox = byId('__calScroll') || holder;
  state.scrollTop = scrollBox.scrollTop || 0;

  const contractId   = (window.modalCtx?.data?.id && String(currentKey) === String(window.modalCtx.data.id)) ? window.modalCtx.data.id : null;
  const currentStart = window.modalCtx?.data?.start_date || null;
  const currentEnd   = window.modalCtx?.data?.end_date   || null;

  let dayItems = [];
  try {
    if (typeof getCandidateCalendarRange === 'function') {
      const resp = await getCandidateCalendarRange(candidateId, state.win.from, state.win.to, 'day');
      dayItems = Array.isArray(resp?.items) ? resp.items : [];
    } else {
      dayItems = [];
    }
  } catch (e) {
    L('getCandidateCalendarRange failed; fallback to empty', e);
    dayItems = [];
  }

  const itemsByDate = buildDateIndex(dayItems);

  if (contractId && typeof getContractCalendar === 'function') {
    try {
      const cday = await getContractCalendar(contractId, { from: state.win.from, to: state.win.to, granularity:'day' });
      const cItems = Array.isArray(cday?.items) ? cday.items : [];
      for (const it of cItems) {
        const d = it?.date;
        if (!d) continue;
        const arr = itemsByDate.get(d) || [];
        if (it && !it.contract_id) it.contract_id = contractId;
        arr.push(it);
        itemsByDate.set(d, arr);
      }
      if (LOG_CAL) L('[CAL] merged contract-day items', { count: cItems.length });
    } catch (e) {
      L('getContractCalendar(day) failed; proceeding with candidate-only', e);
    }
  }

  let weekIndex = null;
  if (contractId && typeof getContractCalendar === 'function' && typeof buildWeekIndex === 'function') {
    try {
      const weeks = (await getContractCalendar(contractId, { from: state.win.from, to: state.win.to, granularity:'week' })).items || [];
      weekIndex = buildWeekIndex(weeks);
    } catch (e) {
      L('week index fetch failed; proceeding without TS lock context', e);
      weekIndex = null;
    }
  }

  const overlayedMap = applyStagedContractCalendarOverlay(currentKey, itemsByDate, new Map());

  const gridHost = document.createElement('div'); gridHost.id = 'contractDayGrid';
  const container = byId('__contractCal') || holder;
  if (container === holder) holder.innerHTML = '';
  container.innerHTML = '';
  container.appendChild(gridHost);

  renderDayGrid(gridHost, {
    from: state.win.from,
    to: state.win.to,
    itemsByDate: overlayedMap,
    view: state.view,
    bucketKey: `c:${currentKey}`,
    isInteractive: !!window.__calInteractive,
    onNav: async (delta) => {
      if (state.view === 'year') {
        const y = ymdToDate(state.win.from).getUTCFullYear() + delta;
        const nextWin = computeYearWindow(y);
        await fetchAndRenderCandidateCalendarForContract(currentKey, candidateId, { from: nextWin.from, to: nextWin.to, weekEnding: state.weekEndingWeekday, view: 'year' });
      } else {
        const nextWin = stepMonth(state.win, delta);
        await fetchAndRenderCandidateCalendarForContract(currentKey, candidateId, { from: nextWin.from, to: nextWin.to, weekEnding: state.weekEndingWeekday, view: 'month' });
      }
    },
    onToggleView: async () => {
      const newView = (state.view === 'year') ? 'month' : 'year';
      let win = state.win;
      if (newView === 'year') { const y = ymdToDate(state.win.from).getUTCFullYear(); win = computeYearWindow(y); }
      else { const dt = ymdToDate(state.win.from); win = computeMonthWindow(dt.getUTCFullYear(), dt.getUTCMonth()); }
      await fetchAndRenderCandidateCalendarForContract(currentKey, candidateId, { from: win.from, to: win.to, view: newView, weekEnding: state.weekEndingWeekday });
    },
    onCellContextMenu: (theDate, ev) => {
      if (!window.__calInteractive) return;
      const sel = initSelBucket(`c:${currentKey}`).set; const selArr = [...sel];

      const selMin = selArr.length ? selArr.reduce((a,b)=> a < b ? a : b) : null;
      const selMax = selArr.length ? selArr.reduce((a,b)=> a > b ? a : b) : null;
      let willExpand = false;
      let expStart = currentStart || selMin || null;
      let expEnd   = currentEnd   || selMax || null;

      if (currentStart && selMin && selMin < currentStart) { expStart = selMin; willExpand = true; }
      if (currentEnd   && selMax && selMax > currentEnd)   { expEnd   = selMax; willExpand = true; }

      if (willExpand && expStart && expEnd) {
        window.modalCtx.__windowExpand = { start: expStart, end: expEnd };
        const toUk = (iso) => { try { return (typeof formatIsoToUk === 'function') ? (formatIsoToUk(iso) || iso) : iso; } catch { return iso; } };
        const banner = byId('calExpandBanner');
        if (banner) banner.textContent = `These selections are outside the current window (${toUk(currentStart)||'â€”'} â†’ ${toUk(currentEnd)||'â€”'}). Weâ€™ll extend to ${toUk(expStart)} â†’ ${toUk(expEnd)} on Save.`;
      } else {
        window.modalCtx.__windowExpand = null;
        const banner = byId('calExpandBanner');
        if (banner) banner.textContent = '';
      }

      const itemsByDate = overlayedMap; // already overlaid

      const mine = String(window.modalCtx?.data?.id || currentKey);
      const ownedByCurrent = (d) => {
        const arr = itemsByDate.get(d) || [];
        return arr.some(it => String(it.contract_id || '') === mine);
      };
      const occupiedByOtherOnly = (d) => {
        const arr = itemsByDate.get(d) || [];
        return arr.some(it => {
          const cid = String(it.contract_id || '');
          return cid && cid !== mine;
        }) && !ownedByCurrent(d);
      };

      const anyGrey = selArr.some(occupiedByOtherOnly);
      const resolveFinalState = (d) => topState(overlayedMap.get(d) || []);

      const eligible = (d) => {
        const st = resolveFinalState(d);
        if (st === 'PLANNED') return true;
        return false;
      };
      const anyEligible = selArr.some(eligible);
      const allEligible = selArr.every(eligible);
      const blockMode = isConsecutiveDailyRun(selArr);

      const capabilities = {
        canBook: true,
        canUnbook: blockMode ? anyEligible : allEligible,
        canAddAdditional: false
      };

      openCalendarContextMenu({
        anchorEl: ev.target,
        bucketKey: `c:${currentKey}`,
        selection: selArr,
        capabilities,
        onAction: async ({ type, selection }) => {
          try {
            if (type === 'book') {
              if (anyGrey) {
                const names = [];
                for (const d of selection) {
                  if (!occupiedByOtherOnly(d)) continue;
                  const arr = itemsByDate.get(d) || [];
                  arr.forEach(it => {
                    const cid = String(it.contract_id || '');
                    if (cid && cid !== mine) names.push(it.client_name || 'Other client');
                  });
                }
                const hint = names.length
                  ? `This would clash with existing contract(s): ${[...new Set(names)].join(', ')}. Continue?`
                  : 'This would clash with an existing contract. Continue?';
                if (!window.confirm(hint)) return;
              }
              stageContractCalendarBookings(currentKey, selection);
            }
            if (type === 'unbook') {
              const toUnbook = selection.filter(eligible);
              if (toUnbook.length) stageContractCalendarUnbookings(currentKey, toUnbook);
            }
            try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
            const prev = (byId('__calScroll') || holder).scrollTop || 0;
            await fetchAndRenderCandidateCalendarForContract(currentKey, candidateId, { from: state.win.from, to: state.win.to, view: state.view, weekEnding: state.weekEndingWeekday });
            (byId('__calScroll') || holder).scrollTop = prev;
          } catch (e) {
            alert(e?.message || e);
          }
        }
      });
    }
  });

  (byId('__calScroll') || holder).scrollTop = state.scrollTop;
}



// ============================================================================
// CANDIDATE â€“ RENDER CALENDAR TAB
// ============================================================================
async function fetchAndRenderContractCalendar(contractId, opts) {
  const LOG_CAL = (typeof window.__LOG_CAL === 'boolean') ? window.__LOG_CAL : true;
  const L = (...a)=> { if (LOG_CAL) console.log('[CAL][contract]', ...a); };

  const state = (window.__calState[contractId] ||= { view:'year', win: computeYearWindow((new Date()).getUTCFullYear()), weekEndingWeekday: (window.modalCtx?.data?.week_ending_weekday_snapshot ?? 0), scrollTop: 0 });

  if (opts?.view) state.view = opts.view;
  if (opts?.from && opts?.to) state.win = { from: opts.from, to: opts.to };

  const holder = byId('contractCalendarHolder'); if (!holder) return;
  const scrollBox = byId('__calScroll') || holder;
  state.scrollTop = scrollBox.scrollTop || 0;

  const candidateId = window.modalCtx?.data?.candidate_id || window.modalCtx?.formState?.main?.candidate_id || null;

  let candidateItems = [];
  try {
    if (candidateId && typeof getCandidateCalendarRange === 'function') {
      const resp = await getCandidateCalendarRange(candidateId, state.win.from, state.win.to, 'day');
      candidateItems = Array.isArray(resp?.items) ? resp.items : [];
    }
  } catch (e) {
    L('getCandidateCalendarRange failed', e);
    candidateItems = [];
  }
  const itemsByDate = buildDateIndex(candidateItems);

  const dayResp = await getContractCalendarRange(contractId, state.win.from, state.win.to, 'day');
  const dayItems = Array.isArray(dayResp?.items) ? dayResp.items : [];
  for (const it of dayItems) {
    const d = it?.date; if (!d) continue;
    const arr = itemsByDate.get(d) || [];
    if (it && !it.contract_id) it.contract_id = contractId;
    arr.push(it);
    itemsByDate.set(d, arr);
  }

  const bufFrom = addDays(state.win.from, -7);
  const bufTo   = addDays(state.win.to,   +7);
  const weeksForIndex = (await getContractCalendar(contractId, { from: bufFrom, to: bufTo, granularity:'week' })).items || [];
  const weekIndex = buildWeekIndex(weeksForIndex);

  const overlayedMap = applyStagedContractCalendarOverlay(contractId, itemsByDate, weekIndex);

  const gridHost = document.createElement('div'); gridHost.id = 'contractDayGrid';
  const container = byId('__contractCal') || holder;
  if (container === holder) holder.innerHTML = '';
  container.innerHTML = '';
  container.appendChild(gridHost);

  renderDayGrid(gridHost, {
    from: state.win.from,
    to: state.win.to,
    itemsByDate: overlayedMap,
    view: state.view,
    bucketKey: `c:${contractId}`,
    isInteractive: !!window.__calInteractive,
    onNav: async (delta) => {
      if (state.view === 'year') {
        const y = ymdToDate(state.win.from).getUTCFullYear() + delta;
        const nextWin = computeYearWindow(y);
        await fetchAndRenderContractCalendar(contractId, { from: nextWin.from, to: nextWin.to, view: 'year' });
      } else {
        const nextWin = stepMonth(state.win, delta);
        await fetchAndRenderContractCalendar(contractId, { from: nextWin.from, to: nextWin.to, view: 'month' });
      }
    },
    onToggleView: async () => {
      const newView = (state.view === 'year') ? 'month' : 'year';
      let win = state.win;
      if (newView === 'year') { const y = ymdToDate(state.win.from).getUTCFullYear(); win = computeYearWindow(y); }
      else { const dt = ymdToDate(state.win.from); win = computeMonthWindow(dt.getUTCFullYear(), dt.getUTCMonth()); }
      await fetchAndRenderContractCalendar(contractId, { from: win.from, to: win.to, view: newView });
    },
    onCellContextMenu: (theDate, ev) => {
      if (!window.__calInteractive) return;
      const sel = initSelBucket(`c:${contractId}`).set; const selArr = [...sel];

      const ownedByCurrent = (d) => {
        const arr = itemsByDate.get(d) || [];
        return arr.some(it => String(it.contract_id || '') === String(contractId));
      };
      const occupiedByOtherOnly = (d) => {
        const arr = itemsByDate.get(d) || [];
        return arr.some(it => {
          const cid = String(it.contract_id || '');
          return cid && cid !== String(contractId);
        }) && !ownedByCurrent(d);
      };
      const anyGrey = selArr.some(occupiedByOtherOnly);

      const resolveFinalState = (d) => topState(overlayedMap.get(d) || []);

      const eligibleUnbook = (d) => {
        if (!ownedByCurrent(d)) return false;
        const we = computeWeekEnding(d, state.weekEndingWeekday);
        const w = weekIndex.get(we);
        const st = resolveFinalState(d);
        return st === 'PLANNED' && w && !w.baseHasTs;
      };
      const anyEligible = selArr.some(eligibleUnbook);
      const allEligible = selArr.every(eligibleUnbook);
      const blockMode = isConsecutiveDailyRun(selArr);

      const canBook = selArr.every(d => !ownedByCurrent(d));
      const canUnbook = blockMode ? anyEligible : allEligible;

      const canAddAdditional = selArr.some(d => {
        const st = resolveFinalState(d);
        const we = computeWeekEnding(d, state.weekEndingWeekday);
        const w = weekIndex.get(we);
        return st === 'EMPTY' && w && w.baseHasTs && w.baseWeekId;
      });

      openCalendarContextMenu({
        anchorEl: ev.target,
        bucketKey: `c:${contractId}`,
        selection: selArr,
        capabilities: { canBook, canUnbook, canAddAdditional },
        onAction: async ({ type, selection }) => {
          try {
            if (type === 'book') {
              if (anyGrey) {
                if (!window.confirm('This would clash with an existing contract on some selected dates. Continue?')) return;
              }
              stageContractCalendarBookings(contractId, selection);
            }
            if (type === 'unbook') {
              const toUnbook = selection.filter(eligibleUnbook);
              if (toUnbook.length) stageContractCalendarUnbookings(contractId, toUnbook);
            }
            if (type === 'additional') {
              const byBase = {};
              for (const d of selection) {
                const we = computeWeekEnding(d, state.weekEndingWeekday);
                const wi = weekIndex.get(we);
                if (!wi || !wi.baseWeekId || !wi.baseHasTs) continue;
                (byBase[wi.baseWeekId] ||= []).push(d);
              }
              for (const [baseWeekId, dates] of Object.entries(byBase)) {
                stageContractCalendarAdditional(contractId, baseWeekId, dates);
              }
            }
            try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
            const prev = (byId('__calScroll') || holder).scrollTop || 0;
            await fetchAndRenderContractCalendar(contractId, { from: state.win.from, to: state.win.to, view: state.view });
            (byId('__calScroll') || holder).scrollTop = prev;
          } catch (e) {
            alert(e?.message || e);
          }
        }
      });
    }
  });

  (byId('__calScroll') || holder).scrollTop = state.scrollTop;
}
async function renderCandidateCalendarTab(candidateId) {
  const holderId = 'candidateCalendarHolder';
  const host = byId(holderId);
  if (!host) return;

  // Compute initial window (year view)
  const y = (new Date()).getUTCFullYear();
  const win = typeof computeYearWindow === 'function'
    ? computeYearWindow(y)
    : { from: `${y}-01-01`, to: `${y}-12-31` };

  // Build inner scaffold: scroll box + grid mount + legend
  host.innerHTML = `
    <div class="tabc" style="display:flex;flex-direction:column;gap:8px;height:calc(72vh);max-height:calc(72vh)">
      <div id="__candCalScroll" style="flex:1;min-height:0;overflow:auto;border:1px solid var(--line,#e5e5e5);border-radius:8px;padding:4px;">
        <div id="__candCal"></div>
      </div>
      <div id="__candCalLegend"></div>
    </div>
  `;

  // Render legend
  const legendHost = byId('__candCalLegend');
  if (legendHost && typeof renderCalendar === 'undefined') {
    // Reuse existing legend helper (does full overwrite of target node)
    if (typeof renderCalendarLegend === 'function') {
      renderCalendarLegend(legendHost);
    } else {
      // Fallback: minimal legend if helper is missing
      legendHost.innerHTML = `
        <div class="legend">
          <span class="chip cal-planned">Planned</span>
          <span class="chip cal-submitted">Submitted</span>
          <span class="chip cal-authorised">Certified</span>
          <span class="chip cal-invoiced">Invoiced</span>
          <span class="chip cal-paid">Paid</span>
          <span class="chip">Not booked</span>
        </div>`;
    }
  }

  // Draw initial window
  await fetchAndRenderCandidateCalendar(candidateId, { from: win.from, to: win.to, view: 'year' });
}
async function fetchAndRenderCandidateCalendar(candidateId, opts) {
  const LOG_CAL = (typeof window.__LOG_CAL === 'boolean') ? window.__LOG_CAL : true;
  const L = (...a)=> { if (LOG_CAL) console.log('[CAL][candidate]', ...a); };

  const key = `cand:${candidateId}`;

  // Persist per-view state (separate from any contract bucket).
  const state = (window.__calState[key] ||= {
    view: (opts && typeof opts.view === 'string') ? opts.view : 'year',
    win:  (opts && opts.from && opts.to)
            ? { from: opts.from, to: opts.to }
            : (typeof computeYearWindow === 'function'
                ? computeYearWindow((new Date()).getUTCFullYear())
                : { from: `${(new Date()).getFullYear()}-01-01`, to: `${(new Date()).getFullYear()}-12-31` }),
    scrollTop: 0
  });

  // Allow caller to change view/window
  if (opts && typeof opts.view === 'string') state.view = opts.view;
  if (opts && opts.from && opts.to) state.win = { from: opts.from, to: opts.to };

  const holder = byId('candidateCalendarHolder');
  if (!holder) return;

  // Correct scroll box id (and legacy fallback to container)
  const scrollBox = byId('__candCalScroll') || holder;

  // Remember current scroll
  try { state.scrollTop = (typeof scrollBox.scrollTop === 'number') ? scrollBox.scrollTop : 0; } catch {}

  // Fetch candidate-wide day feed (all contracts; read-only render)
  let items = [];
  try {
    if (typeof getCandidateCalendarRange === 'function') {
      const r = await getCandidateCalendarRange(candidateId, state.win.from, state.win.to, 'day');
      items = Array.isArray(r?.items) ? r.items : [];
    } else if (typeof fetchCandidateCalendarForRange === 'function') {
      const r = await fetchCandidateCalendarForRange(candidateId, state.win.from, state.win.to);
      items = Array.isArray(r?.items) ? r.items : [];
    } else if (typeof getCandidateCalendar === 'function') {
      const r = await getCandidateCalendar(candidateId, state.win.from, state.win.to);
      items = Array.isArray(r?.items) ? r.items : [];
    }
  } catch (e) {
    L('candidate calendar fetch failed', e);
  }

  // Build map: date â†’ [items]
  const itemsByDate = (typeof buildDateIndex === 'function')
    ? buildDateIndex(items)
    : (() => {
        const m = new Map();
        for (const it of items) {
          if (!it?.date) continue;
          const arr = m.get(it.date) || [];
          arr.push(it);
          m.set(it.date, arr);
        }
        return m;
      })();

  // Render grid (read-only)
  const gridHost = byId('__candCal') || (() => {
    const d = document.createElement('div'); d.id = '__candCal'; holder.appendChild(d); return d;
  })();
  gridHost.innerHTML = '';

  if (typeof renderDayGrid !== 'function') {
    gridHost.innerHTML = `<div class="hint">Calendar renderer not available.</div>`;
    return;
  }

  renderDayGrid(gridHost, {
    from: state.win.from,
    to:   state.win.to,
    itemsByDate,
    view: state.view,          // 'year' | 'month'
    bucketKey: key,            // not a contract id â†’ no â€œotherâ€ greying
    isInteractive: false,      // candidate view is read-only
    onNav: async (delta) => {
      if (state.view === 'year') {
        const y = (new Date(state.win.from)).getUTCFullYear() + delta;
        const nextWin = (typeof computeYearWindow === 'function')
          ? computeYearWindow(y)
          : { from: `${y}-01-01`, to: `${y}-12-31` };
        await fetchAndRenderCandidateCalendar(candidateId, { from: nextWin.from, to: nextWin.to, view: 'year' });
      } else {
        const nextWin = (typeof stepMonth === 'function')
          ? stepMonth(state.win, delta)
          : (function () {
              const d = new Date(state.win.from);
              d.setUTCMonth(d.getUTCMonth() + delta, 1);
              const y = d.getUTCFullYear(), m = d.getUTCMonth();
              return (typeof computeMonthWindow === 'function')
                ? computeMonthWindow(y, m)
                : { from: `${y}-${String(m+1).padStart(2,'0')}-01`, to: `${y}-${String(m+1).padStart(2,'0')}-28` };
            })();
        await fetchAndRenderCandidateCalendar(candidateId, { from: nextWin.from, to: nextWin.to, view: 'month' });
      }
    },
    onToggleView: async () => {
      const newView = (state.view === 'year') ? 'month' : 'year';
      let nextWin;
      if (newView === 'year') {
        const y = (new Date(state.win.from)).getUTCFullYear();
        nextWin = (typeof computeYearWindow === 'function')
          ? computeYearWindow(y)
          : { from: `${y}-01-01`, to: `${y}-12-31` };
      } else {
        const d = new Date(state.win.from);
        const y = d.getUTCFullYear(), m = d.getUTCMonth();
        nextWin = (typeof computeMonthWindow === 'function')
          ? computeMonthWindow(y, m)
          : { from: `${y}-${String(m+1).padStart(2,'0')}-01`, to: `${y}-${String(m+1).padStart(2,'0')}-28` };
      }
      await fetchAndRenderCandidateCalendar(candidateId, { from: nextWin.from, to: nextWin.to, view: newView });
    }
  });

  // Restore scroll
  try { if (typeof scrollBox.scrollTop === 'number') scrollBox.scrollTop = state.scrollTop; } catch {}
}


function renderCandidateContractList(container, contractMap, handlers) {
  container.innerHTML = '';
  const title = document.createElement('div'); title.className='hint'; title.textContent='Contracts in view:'; container.appendChild(title);

  const list = document.createElement('div'); list.className='list';
  contractMap.forEach((v, cid) => {
    const row = document.createElement('div'); row.className='row item'; row.tabIndex = 0;
    row.innerHTML = `
      <span class="txt">${(v.client_name || 'Client')} â€¢ ${(v.role||'Role')}${v.band?` â€¢ ${v.band}`:''} â€¢ ${v.from} â†’ ${v.to}</span>
      <span class="act"><button data-act="filter">Show only</button> <button data-act="open">Open</button></span>`;
    row.querySelector('[data-act="filter"]')?.addEventListener('click', () => handlers.onClick && handlers.onClick(cid));
    row.querySelector('[data-act="open"]')?.addEventListener('click', () => handlers.onDblClick && handlers.onDblClick(cid));
    row.addEventListener('dblclick', () => handlers.onDblClick && handlers.onDblClick(cid));
    list.appendChild(row);
  });
  container.appendChild(list);

  if (!contractMap.size) {
    const none = document.createElement('div'); none.className='hint'; none.textContent='No contracts in this window.'; container.appendChild(none);
  }

  const clear = document.createElement('div'); clear.className='actions';
  clear.innerHTML = `<button id="candClearFilter">Clear filter</button>`; container.appendChild(clear);
  clear.querySelector('#candClearFilter')?.addEventListener('click', () => handlers.onClear && handlers.onClear());
}


// =================== MOUNT CLIENT RATES TAB (unchanged glue) ===================
async function mountClientRatesTab() {
  const LOG_RATES = !!window.__LOG_RATES;
  const DBG = (...a)=> { if (LOG_RATES) console.log('[RATES][mountClientRatesTab]', ...a); };

  const ctx = window.modalCtx; // use canonical context
  DBG('ENTRY', { ctxEntity: ctx?.entity, ctxId: ctx?.data?.id });

  // render uses ctx.ratesState directly; no args needed
  try { await renderClientRatesTable(); DBG('renderClientRatesTable done'); } catch (e) { DBG('renderClientRatesTable error', e); }

  // Always resolve a real client id before opening the modal
  const btn = byId('btnAddClientRate');
  if (btn) {
    btn.onclick = () => {
      const cid = (ctx && ctx.data && (ctx.data.id || ctx.data.client_id)) || null;
      DBG('openClientRateModal from button', { cid });
      return openClientRateModal(cid);
    };
    DBG('wired btnAddClientRate');
  } else {
    DBG('btnAddClientRate not present');
  }
}



// =================== MOUNT HOSPITALS TAB (unchanged glue) ===================
function mountClientHospitalsTab() {
  const ctx = window.modalCtx; // ðŸ”§ use canonical context
  const H = ctx.hospitalsState || (ctx.hospitalsState = { existing: [], stagedNew: [], stagedEdits: {}, stagedDeletes: new Set() });

  // â¬‡ï¸ Key change: normalise stagedDeletes as a Set on mount (handles JSON-cloned arrays)
  if (!(H.stagedDeletes instanceof Set)) {
    H.stagedDeletes = new Set(Array.isArray(H.stagedDeletes) ? H.stagedDeletes : Object.keys(H.stagedDeletes || {}));
  }

  renderClientHospitalsTable();

  const addBtn = byId('btnAddClientHospital');
  if (addBtn) addBtn.onclick = () => openClientHospitalModal(ctx.data?.id);

  const wrap = byId('clientHospitals');
  if (wrap && !wrap.__wiredDelete) {
    wrap.addEventListener('click', (ev) => {
      const t = ev.target;
      const el = t && (t.closest('[data-action="delete"]') || t.closest('.btnDelHospital'));
      if (!el) return;

      const hid = el.getAttribute('data-hid') || el.getAttribute('data-id');
      if (!hid) return;

      // â¬‡ï¸ Ensure Set semantics before use
      if (!(H.stagedDeletes instanceof Set)) {
        H.stagedDeletes = new Set(Array.isArray(H.stagedDeletes) ? H.stagedDeletes : Object.keys(H.stagedDeletes || {}));
      }
      H.stagedDeletes.add(String(hid));

      try { window.dispatchEvent(new CustomEvent('modal-dirty')); } catch {}
      renderClientHospitalsTable();
    }, true);
    wrap.__wiredDelete = true;
  }
}


async function openClientRateModal(client_id, existing) {
  const parentFrame = _currentFrame();
  const parentEditable = parentFrame && (parentFrame.mode === 'edit' || parentFrame.mode === 'create');
  const APILOG = (typeof window !== 'undefined' && !!window.__LOG_API) || (typeof __LOG_API !== 'undefined' && !!__LOG_API);
  const LOG_RATES = !!window.__LOG_RATES;
  const DBG = (...a)=> { if (LOG_RATES) console.log('[RATES][openClientRateModal]', ...a); };

  const ctx = window.modalCtx || {};
  const resolvedClientId =
    client_id ||
    (existing && existing.client_id) ||
    (ctx && ctx.data && (ctx.data.id || ctx.data.client_id)) ||
    null;

  if (APILOG) console.log('[openClientRateModal] resolvedClientId', resolvedClientId, { passed: client_id, existing });
  DBG('ENTRY', { parentEditable, hasExisting: !!existing, resolvedClientId, ctxEntity: ctx?.entity, ctxId: ctx?.data?.id });

  const globalRoles = await loadGlobalRoleOptions();
  const roleOptions = globalRoles.map(r => `<option value="${r}">${r}</option>`).join('') + `<option value="__OTHER__">+ Add new roleâ€¦</option>`;
  DBG('loaded role options', { count: globalRoles.length });

  const ex  = existing || {};
  const who = ex.disabled_by_name || '';
  const when = ex.disabled_at_utc ? formatIsoToUk(String(ex.disabled_at_utc).slice(0,10)) : '';
  const isDisabled = !!ex.disabled_at_utc;
  DBG('existing status', { isDisabled, who, when, id: ex.id });

  const statusBlock = `
    <div class="row" id="cl_status_row" style="align-items:center; gap:8px;">
      <div>
        ${isDisabled ? `
          <span class="pill tag-fail" id="cl_status_pill">âŒ Disabled</span>
          <div class="hint" id="cl_status_meta">${who ? `by ${escapeHtml(who)}` : ''} ${when ? `on ${escapeHtml(when)}` : ''}</div>`
      : `
          <span class="pill tag-ok" id="cl_status_pill">âœ“ Active</span>
          <div class="hint" id="cl_status_meta">&nbsp;</div>`}
      </div>
      ${parentEditable && ex.id ? `<div><button id="cl_toggle_btn" class="btn btn-outline btn-sm">${isDisabled ? 'Enable' : 'Disable'}</button></div>` : ''}
    </div>`;

  function sameRow(a, b) {
    const eq = !!(a && b && ((a === b) || (a.id && b.id && String(a.id) === String(b.id)) || (a.__localKey && b.__localKey && String(a.__localKey) === String(b.__localKey))));
    if (LOG_RATES) console.log('[RATES][sameRow]', { aId:a?.id, bId:b?.id, aKey:a?.__localKey, bKey:b?.__localKey, eq });
    return eq;
  }

  // INLINE panel for client-rate warnings/fixes
  const formHtml = html(`
    <div class="form" id="clientRateForm">
      ${statusBlock}
      <div class="row">
        <label>Role (required)</label>
        <select name="role" id="cl_role" required ${parentEditable ? '' : 'disabled'}>
          <option value="">Select roleâ€¦</option>
          ${roleOptions}
        </select>
      </div>
      <div class="row" id="cl_role_new_row" style="display:none">
        <label>New role code</label>
        <input type="text" id="cl_role_new" placeholder="e.g. RMN-Lead" ${parentEditable ? '' : 'disabled'} />
        <div class="hint">Uppercase letters/numbers/[-_/ ] recommended.</div>
      </div>
      <div class="row"><label>VBR5809: Band (optional)</label>
        <input type="text" name="band" id="cl_band" value="${ex.band ?? ''}" ${parentEditable ? '' : 'disabled'} />
      </div>
      <div class="row"><label>Effective from (DD/MM/YYYY)</label>
        <input type="text" name="date_from" id="cl_date_from" placeholder="DD/MM/YYYY" ${parentEditable ? '' : 'disabled'} />
      </div>
      <div class="row"><label>Effective to (optional, DD/MM/YYYY)</label>
        <input type="text" name="date_to" id="cl_date_to" placeholder="DD/MM/YYYY" ${parentEditable ? '' : 'disabled'} />
      </div>
      <div class="row" style="grid-column: 1 / -1">
        <table class="grid" style="width:100%;border-collapse:collapse">
          <thead><tr><th>Bucket</th><th>PAYE pay</th><th>Umbrella pay</th><th>Charge</th></tr></thead>
          <tbody>
            ${['day','night','sat','sun','bh'].map(b => `
              <tr>
                <td style="white-space:nowrap">${b.toUpperCase()}</td>
                <td><input type="number" step="0.01" name="paye_${b}" ${parentEditable ? '' : 'disabled'} /></td>
                <td><input type="number" step="0.01" name="umb_${b}"  ${parentEditable ? '' : 'disabled'} /></td>
                <td><input type="number" step="0.01" name="charge_${b}" ${parentEditable ? '' : 'disabled'} /></td>
              </tr>`).join('')}
          </tbody>
        </table>
      </div>
      <div class="row" style="grid-column:1 / -1; margin-top:10px">
        <table class="grid" id="cl_margins_tbl" style="width:100%">
          <thead><tr><th>Bucket</th><th>PAYE margin</th><th>Umbrella margin</th></tr></thead>
          <tbody>
            ${['day','night','sat','sun','bh'].map(b=>`
              <tr><td>${b.toUpperCase()}</td><td><span id="m_paye_${b}">â€”</span></td><td><span id="m_umb_${b}">â€”</span></td></tr>`).join('')}
          </tbody>
        </table>
        <div class="hint" id="cl_delete_hint" style="display:none;margin-top:6px"></div>
      </div>

      <div id="cl_err_panel" style="grid-column:1/-1; margin-top:10px; display:none; border:1px solid #7f1d1d; background:rgba(239,68,68,.08); color:#fecaca; padding:10px; border-radius:8px"></div>
    </div>
  `);

  // ERNI
  async function _erniMultiplier(){
    if (typeof window.__ERNI_MULT__ === 'number') return window.__ERNI_MULT__;
    try {
      if (typeof getSettingsCached === 'function') {
        const s = await getSettingsCached();
        let p = s?.erni_pct ?? s?.employers_ni_percent ?? 0;
        p = Number(p) || 0; if (p > 1) p = p/100;
        window.__ERNI_MULT__ = 1 + p;
        return window.__ERNI_MULT__;
      }
    } catch {}
    window.__ERNI_MULT__ = 1;
    return 1;
  }

  function setApplyEnabled(enabled){
    if (LOG_RATES) console.log('[RATES][setApplyEnabled]', { enabled });
    try {
      const btn = document.querySelector('#modal .btn-save, #modal .actions .primary, #modal .actions .btn-primary, .modal .btn-save');
      if (btn) { btn.disabled = !enabled; btn.classList.toggle('disabled', !enabled); }
    } catch (e) { if (LOG_RATES) console.warn('[RATES][setApplyEnabled] button toggle failed', e); }
    // Inform parent showModal so child Save can proceed
    try { window.dispatchEvent(new CustomEvent('modal-apply-enabled', { detail: { enabled } })); } catch (e) { if (LOG_RATES) console.warn('[RATES][setApplyEnabled] dispatch failed', e); }
  }
  const numOrNull = v => { if (v===undefined||v===null) return null; if (typeof v === 'string' && v.trim()==='') return null; const n=Number(v); return Number.isFinite(n) ? n : null; };
  const fmt = v => (v==null || Number.isNaN(v)) ? 'â€”' : (Math.round(v*100)/100).toFixed(2);

  function showClientInlineError(html){
    const p = byId('cl_err_panel');
    if (!p) return;
    if (html && String(html).trim() !== '') {
      p.innerHTML = html;
      p.style.display = '';
    } else {
      p.innerHTML = '';
      p.style.display = 'none';
    }
  }
  function isoMinusOneDay(iso){
    if (!iso) return null;
    const d = new Date(iso + 'T00:00:00Z');
    d.setUTCDate(d.getUTCDate() - 1);
    const y = d.getUTCFullYear();
    const m = String(d.getUTCMonth()+1).padStart(2,'0');
    const dd= String(d.getUTCDate()).padStart(2,'0');
    return `${y}-${m}-${dd}`;
  }
  function rangesOverlap(a0,a1,b0,b1){
    const A0 = a0 || '0000-01-01', A1 = a1 || '9999-12-31';
    const B0 = b0 || '0000-01-01', B1 = b1 || '9999-12-31';
    return !(A1 < B0 || B1 < A0);
  }

  // Gate inputs + margins + Apply + overlap inline fixes
  async function recomputeClientState(){
    const mult = await _erniMultiplier();
    const roleVal = (byId('cl_role')?.value || '').trim();
    const fromIso = parseUkDateToIso(byId('cl_date_from')?.value || '');
    const toIso   = parseUkDateToIso(byId('cl_date_to')?.value || '');

    DBG('recomputeClientState: ENTRY', { roleVal, fromIso, toIso, exId: ex?.id });

    const getIn = sel => document.querySelector(sel);
    const payeInputs = ['day','night','sat','sun','bh'].map(b => getIn(`#clientRateForm input[name="paye_${b}"]`));
    const umbInputs  = ['day','night','sat','sun','bh'].map(b => getIn(`#clientRateForm input[name="umb_${b}"]`));
    const chgInputs  = ['day','night','sat','sun','bh'].map(b => getIn(`#clientRateForm input[name="charge_${b}"]`));
    const allInputs  = [...payeInputs, ...umbInputs, ...chgInputs].filter(Boolean);

    let canApply = true;
    showClientInlineError('');

    if (!roleVal || !fromIso) {
      DBG('recomputeClientState: NOT_READY', { roleVal, fromIso });
      allInputs.forEach(inp => { inp.disabled = true; });
      // clear preview
      ['day','night','sat','sun','bh'].forEach(b=>{
        const spP = byId(`m_paye_${b}`), spU = byId(`m_umb_${b}`);
        if (spP) spP.textContent = 'â€”';
        if (spU) spU.textContent = 'â€”';
      });
      setApplyEnabled(false);
      return;
    }

    // keep inputs enabled
    allInputs.forEach(inp => { inp.disabled = true === false; });

    // Compute & render margins preview (2dp), while validating
    let hasNegative = false;
    const fmt2 = (v) => (v==null || Number.isNaN(v)) ? 'â€”' : (Math.round(v*100)/100).toFixed(2);

    ['day','night','sat','sun','bh'].forEach(bucket=>{
      const paye = numOrNull(getIn(`#clientRateForm input[name="paye_${bucket}"]`)?.value);
      const umb  = numOrNull(getIn(`#clientRateForm input[name="umb_${bucket}"]`)?.value);
      const chg  = numOrNull(getIn(`#clientRateForm input[name="charge_${bucket}"]`)?.value);

      const payeMargin = (paye!=null && chg!=null) ? (chg - (paye * mult)) : null;
      const umbMargin  = (umb!=null  && chg!=null) ? (chg - umb)          : null;

      const spP = byId(`m_paye_${bucket}`), spU = byId(`m_umb_${bucket}`);
      if (spP) spP.textContent = fmt2(payeMargin);
      if (spU) spU.textContent = fmt2(umbMargin);

      if ((payeMargin != null && payeMargin < 0) || (umbMargin != null && umbMargin < 0)) hasNegative = true;
    });

    if (hasNegative) { canApply = false; showClientInlineError('One or more buckets would have a negative margin. Adjust pay/charge.'); }

    // Overlap detection + Fix buttons
    const staged = Array.isArray(ctx.ratesState) ? ctx.ratesState.slice() : [];
    const sameCat  = r => String(r.role||'') === roleVal && String(r.band??'') === String((byId('cl_band')?.value||'').trim()||'');
    const isSelf   = r => existing ? sameRow(r, existing) : false;

    const conflicts = staged
      .filter(r => !r.disabled_at_utc && sameCat(r) && !isSelf(r))
      .filter(r => rangesOverlap(r.date_from||null, r.date_to||null, fromIso, toIso||null));

    if (conflicts.length) {
      canApply = false;
      const ov = conflicts[0];
      const overlapStart = (fromIso > (ov.date_from||'0000-01-01')) ? fromIso : (ov.date_from||'');
      const overlapEnd   = ((toIso||'9999-12-31') < (ov.date_to||'9999-12-31')) ? (toIso||'') : (ov.date_to||'');
      const cutThis      = isoMinusOneDay(ov.date_from||'');
      const cutOther     = isoMinusOneDay(fromIso);

      let fixButtons = '';
      if (cutThis && (!fromIso || cutThis >= fromIso)) {
        fixButtons += `<button id="cl_fix_this" class="btn" style="margin-right:8px">Fix: Shorten <b>THIS</b> to ${formatIsoToUk(cutThis)}</button>`;
      }
      if (cutOther && (!ov.date_from || cutOther >= (ov.date_from))) {
        fixButtons += `<button id="cl_fix_other" class="btn">Fix: Shorten <b>OTHER</b> to ${formatIsoToUk(cutOther)}</button>`;
      }

      const msg = `
        <div style="font-weight:700;margin-bottom:6px">Overlap detected</div>
        <div style="margin-bottom:6px">
          Another client-default window exists for <b>${escapeHtml(roleVal)}</b>${(byId('cl_band')?.value||'').trim()?` / <b>${escapeHtml((byId('cl_band')?.value||'').trim())}</b>`:''}.<br/>
          <span class="hint" style="color:#fecaca">Overlap span:</span> <b>${formatIsoToUk(overlapStart)} â€“ ${formatIsoToUk(overlapEnd)}</b>.
        </div>
        <div style="margin-bottom:8px">To proceed, adjust dates, or use a Fix:</div>
        <div>${fixButtons || '<i>No safe automatic fix available. Please adjust dates.</i>'}</div>
      `;
      showClientInlineError(msg);

      setTimeout(() => {
        const fromEl = byId('cl_date_from');
        const toEl   = byId('cl_date_to');
        const fixThis = byId('cl_fix_this');
        if (fixThis && cutThis) fixThis.onclick = () => {
          try { toEl.value = formatIsoToUk(cutThis); recomputeClientState(); } catch {}
        };
        const fixOther = byId('cl_fix_other');
        if (fixOther && cutOther) fixOther.onclick = () => {
          try {
            // stage OTHER truncate (stays staged until parent Save)
            if (ov.id) {
              const idx = staged.findIndex(r => r.id === ov.id);
              if (idx >= 0) ctx.ratesState[idx] = { ...ctx.ratesState[idx], date_to: cutOther };
            } else if (ov.__localKey) {
              const idx = staged.findIndex(r => r.__localKey === ov.__localKey);
              if (idx >= 0) ctx.ratesState[idx] = { ...ctx.ratesState[idx], date_to: cutOther };
            }
            try { renderClientRatesTable(); } catch {}
            recomputeClientState();
          } catch {}
        };
      }, 0);
    }

    DBG('recomputeClientState: EXIT', { canApply });
    setApplyEnabled(canApply);
  }

  const formTabLabel = `Form â€” ${isDisabled ? 'Inactive' : 'Active'}`;

  // showModal (child) â€” persist staged edits only; no popups for errors
  showModal(
    existing ? 'Edit Client Default Window' : 'Add/Upsert Client Default Window',
    [{ key:'form', label: formTabLabel }],
    () => formHtml,
    async () => {
      const stack = window.__modalStack || [];
      const pf = stack.length > 1 ? stack[stack.length - 2] : null;
      DBG('onSave ENTRY', { stackLen: stack.length, hasParent: !!pf, parentMode: pf?.mode });

      if (!pf || (pf.mode !== 'edit' && pf.mode !== 'create')) {
        DBG('onSave BLOCKED: parent not editable');
        return false;
      }

      // Re-validate live state; rely on validation result (do not read DOM disabled state)
      await recomputeClientState();
      DBG('onSave proceeding after recompute');

      const raw = collectForm('#clientRateForm');
      DBG('onSave collected', { raw });

      let role = (raw.role || '').trim();
      const newRole = (document.getElementById('cl_role_new')?.value || '').trim();
      if (role === '__OTHER__') {
        if (!newRole) { showClientInlineError('Enter a new role code.'); setApplyEnabled(false); DBG('onSave BLOCKED: newRole missing'); return false; }
        role = newRole.toUpperCase();
        if (typeof invalidateGlobalRoleOptionsCache === 'function') {
          try { invalidateGlobalRoleOptionsCache(); window.dispatchEvent(new CustomEvent('global-roles-updated')); } catch {}
        }
      }
      if (!role) { showClientInlineError('Role is required.'); setApplyEnabled(false); DBG('onSave BLOCKED: role missing'); return false; }

      const isoFrom = parseUkDateToIso(raw.date_from);
      if (!isoFrom) { showClientInlineError('Invalid â€œEffective fromâ€ date.'); setApplyEnabled(false); DBG('onSave BLOCKED: date_from invalid'); return false; }
      let isoTo = null;
      if (raw.date_to) {
        isoTo = parseUkDateToIso(raw.date_to);
        if (!isoTo) { showClientInlineError('Invalid â€œEffective toâ€ date.'); setApplyEnabled(false); DBG('onSave BLOCKED: date_to invalid'); return false; }
        if (isoTo < isoFrom) { showClientInlineError('â€œEffective toâ€ cannot be before â€œEffective fromâ€.'); setApplyEnabled(false); DBG('onSave BLOCKED: date order invalid'); return false; }
      }

      const staged = {
        id: existing?.id || undefined,
        client_id: resolvedClientId,
        role,
        band: (raw.band || '').trim() || null,
        date_from: isoFrom,
        date_to:   isoTo,

        charge_day  : raw['charge_day']  !== '' ? Number(raw['charge_day'])  : null,
        charge_night: raw['charge_night']!== '' ? Number(raw['charge_night']) : null,
        charge_sat  : raw['charge_sat']  !== '' ? Number(raw['charge_sat'])  : null,
        charge_sun  : raw['charge_sun']  !== '' ? Number(raw['charge_sun'])  : null,
        charge_bh   : raw['charge_bh']   !== '' ? Number(raw['charge_bh'])   : null,

        paye_day    : raw['paye_day']    !== '' ? Number(raw['paye_day'])    : null,
        paye_night  : raw['paye_night']  !== '' ? Number(raw['paye_night'])  : null,
        paye_sat    : raw['paye_sat']    !== '' ? Number(raw['paye_sat'])    : null,
        paye_sun    : raw['paye_sun']    !== '' ? Number(raw['paye_sun'])    : null,
        paye_bh     : raw['paye_bh']     !== '' ? Number(raw['paye_bh'])     : null,

        umb_day     : raw['umb_day']     !== '' ? Number(raw['umb_day'])     : null,
        umb_night   : raw['umb_night']   !== '' ? Number(raw['umb_night'])   : null,
        umb_sat     : raw['umb_sat']     !== '' ? Number(raw['umb_sat'])     : null,
        umb_sun     : raw['umb_sun']     !== '' ? Number(raw['umb_sun'])     : null,
        umb_bh      : raw['umb_bh']      !== '' ? Number(raw['umb_bh'])      : null,

        // carry through disabled status + pending toggle marker (for UI/meta)
        disabled_at_utc : ex.disabled_at_utc ?? null,
        disabled_by_name: ex.disabled_by_name ?? null,
        __toggle        : ex.__toggle || undefined,
        __localKey      : existing?.__localKey || undefined,
        __delete        : existing?.__delete || false
      };

      if (ex.__toggle === 'enable') {
        staged.disabled_at_utc = null;
      } else if (ex.__toggle === 'disable') {
        staged.disabled_at_utc = staged.disabled_at_utc || new Date().toISOString().slice(0,10);
      }

      // Stage only (persist on parent Save)
      const before = { len: Array.isArray(ctx.ratesState) ? ctx.ratesState.length : 0 };
      ctx.ratesState = Array.isArray(ctx.ratesState) ? ctx.ratesState : [];
      if (existing) {
        const idx = ctx.ratesState.findIndex(r => sameRow(r, existing));
        if (idx >= 0) ctx.ratesState[idx] = staged; else ctx.ratesState.push(staged);
      } else {
        const already = ctx.ratesState.findIndex(r => sameRow(r, staged));
        if (already >= 0) ctx.ratesState[already] = staged; else ctx.ratesState.push(staged);
      }
      const after = { len: ctx.ratesState.length };
      DBG('onSave STAGED', { before, after, stagedId: staged.id, stagedRole: staged.role, toggle: staged.__toggle });

      try { const parent = _currentFrame(); if (parent && typeof parent.setTab === 'function') { parent.currentTabKey = 'rates'; parent.setTab('rates'); DBG('onSave: parent.setTab(rates)'); } } catch{}
      try { window.dispatchEvent(new CustomEvent('modal-dirty')); DBG('onSave: dispatched modal-dirty'); } catch {}
      try { await renderClientRatesTable(); DBG('onSave: renderClientRatesTable done'); } catch (e) { DBG('onSave: renderClientRatesTable error', e); }

      DBG('onSave EXIT ok=true');
      return true;
    },
    false,
    () => {
      const parent = _currentFrame();
      if (parent) { parent.currentTabKey = 'rates'; parent.setTab('rates'); DBG('onReturn: parent.setTab(rates)'); }
    },
    { kind: 'client-rate' }
  );

  // Hydrate & wire listeners
  const roleSel   = byId('cl_role');
  const roleNew   = byId('cl_role_new');
  const roleNewRow= byId('cl_role_new_row');
  const bandEl    = byId('cl_band');
  const fromEl    = byId('cl_date_from');
  const toEl      = byId('cl_date_to');

  attachUkDatePicker(fromEl); attachUkDatePicker(toEl);
  if (existing?.date_from) fromEl.value = formatIsoToUk(existing.date_from);
  if (existing?.date_to)   toEl.value   = formatIsoToUk(existing.date_to);

  if (existing?.role) {
    if (globalRoles.includes(existing.role)) {
      roleSel.value = existing.role;
      roleNewRow.style.display = 'none';
      roleNew.value = '';
    } else {
      roleSel.value = '__OTHER__';
      roleNewRow.style.display = '';
      roleNew.value = existing.role;
    }
  } else {
    roleNewRow.style.display = 'none';
  }

  // ===== Prefill with two-decimal rendering (no other changes) =====
  ['day','night','sat','sun','bh'].forEach(b=>{
    const set = (name, val) => {
      const el = document.querySelector(`#clientRateForm input[name="${name}_${b}"]`);
      if (el && typeof val !== 'undefined' && val !== null) {
        const num = Number(val);
        el.value = Number.isFinite(num) ? (Math.round(num*100)/100).toFixed(2) : String(val);
      }
    };
    set('paye',   existing?.[`paye_${b}`]);
    set('umb',    existing?.[`umb_${b}`]);
    set('charge', existing?.[`charge_${b}`]);
  });

  // Recompute once on mount
  DBG('mount: recomputeClientState');
  await recomputeClientState();

  roleSel.addEventListener('change', async ()=>{
    DBG('EVENT: role change', { value: roleSel.value });
    if (roleSel.value === '__OTHER__') { roleNewRow.style.display = ''; }
    else { roleNewRow.style.display = 'none'; roleNew.value=''; }
    await recomputeClientState();
  });
  bandEl.addEventListener('input',  () => { DBG('EVENT: band input', { value: bandEl.value }); recomputeClientState(); });
  fromEl.addEventListener('change', () => { DBG('EVENT: date_from change', { value: fromEl.value }); recomputeClientState(); });
  toEl.addEventListener('change',   () => { DBG('EVENT: date_to change', { value: toEl.value }); recomputeClientState(); });
  ['day','night','sat','sun','bh'].forEach(b=>{
    ['paye','umb','charge'].forEach(kind=>{
      const el = document.querySelector(`#clientRateForm input[name="${kind}_${b}"]`);
      if (el) el.addEventListener('input', () => { DBG('EVENT: pay input', { kind, bucket: b, value: el.value }); recomputeClientState(); });
    });
  });

  // Wire the Active/Inactive toggle button
  (function wireToggleButton(){
    const btn = byId('cl_toggle_btn');
    if (!btn || !parentEditable || !ex || !ex.id) return;
    DBG('wireToggleButton: ready', { id: ex.id, disabled: !!ex.disabled_at_utc });
    btn.onclick = () => {
      const pill = byId('cl_status_pill');
      const meta = byId('cl_status_meta');
      const currentlyDisabled = !!ex.disabled_at_utc;

      if (currentlyDisabled) {
        ex.__toggle = 'enable';
        ex.disabled_at_utc = null;
        if (pill) { pill.textContent = 'âœ“ Active'; pill.className = 'pill tag-ok'; }
        if (meta) meta.innerHTML = '&nbsp;';
        btn.textContent = 'Disable';
      } else {
        ex.__toggle = 'disable';
        ex.disabled_at_utc = new Date().toISOString().slice(0,10);
        if (pill) { pill.textContent = 'âŒ Disabled'; pill.className = 'pill tag-fail'; }
        if (meta) meta.textContent = 'pending save';
        btn.textContent = 'Enable';
      }
      DBG('toggle clicked', { newToggle: ex.__toggle, newDisabledAt: ex.disabled_at_utc });
      setApplyEnabled(true);
    };
  })();

  // DELETE button logic (unchanged; staged delete until parent Save)
  (async function wireDeleteButton(){
    const delBtn = byId('btnDelete');
    if (!delBtn) return;
    if (!existing || !existing.id) { delBtn.style.display='none'; return; }

    const today = new Date(); const yyyy = today.getFullYear(); const mm = String(today.getMonth()+1).padStart(2,'0'); const dd = String(today.getDate()).padStart(2,'0');
    const todayIso = `${yyyy}-${mm}-${dd}`;
    const isFutureOrToday = !!existing.date_from && String(existing.date_from) >= todayIso;

    let deletable = isFutureOrToday;
    let reason = '';
    if (!deletable) {
      deletable = true; // allow delete in UI; real guard happens on Save server-side
      reason = '';
    }

    delBtn.style.display = '';
    delBtn.disabled = false;
    delBtn.onclick = () => {
      try {
        existing.__delete = true;
        DBG('delete staged', { id: existing.id });
        if (window.modalCtx && window.modalCtx.ratesStagedDeletes instanceof Set && existing.id) {
          window.modalCtx.ratesStagedDeletes.add(String(existing.id));
        }
        try { renderClientRatesTable(); } catch {}
        try { window.dispatchEvent(new CustomEvent('modal-dirty')); } catch {}
        const closeBtn = byId('btnCloseModal'); if (closeBtn) closeBtn.click();
      } catch (e) { DBG('delete stage failed', e); }
    };
  })();
}


// === UPDATED: Client Default Rate modal (Role dropdown + new-role option; UK dates; date_to) ===
// ======================== openClientRateModal (FIXED) ========================
// =================== CLIENT DEFAULT RATE MODAL (UPDATED) ===================
// âœ… UPDATED â€” unified 3Ã—5 grid (PAYE | Umbrella | Charge), date prefill, staged Nâˆ’1 truncation of incumbent window

// ============================================================================
// CLIENT RATE MODAL (child) â€” adds status block + enable/disable button;
// overlap/rollback logic now IGNORES disabled rows
// ============================================================================

// ========== CLIENT DEFAULT RATES ==========

async function renderClientRatesTable() {
  const LOG_RATES = !!window.__LOG_RATES;
  const DBG = (...a)=> { if (LOG_RATES) console.log('[RATES][renderClientRatesTable]', ...a); };

  const div = byId('clientRates'); if (!div) { DBG('no #clientRates host, bail'); return; }

  const ctx = window.modalCtx;
  const staged = Array.isArray(ctx.ratesState) ? ctx.ratesState : [];
  const frame = _currentFrame();
  const parentEditable = frame && (frame.mode === 'edit' || frame.mode === 'create');

  DBG('ENTRY', { stagedLen: staged.length, parentEditable, ctxEntity: ctx?.entity });

  async function _erniMultiplier(){
    if (typeof window.__ERNI_MULT__ === 'number') return window.__ERNI_MULT__;
    try {
      if (typeof getSettingsCached === 'function') {
        const s = await getSettingsCached();
        let p = s?.erni_pct ?? s?.employers_ni_percent ?? 0;
        p = Number(p) || 0; if (p > 1) p = p/100;
        window.__ERNI_MULT__ = 1 + p;
        return window.__ERNI_MULT__;
      }
    } catch {}
    window.__ERNI_MULT__ = 1;
    return 1;
  }
  const mult = await _erniMultiplier();
  const fmt = v => (v==null || Number.isNaN(v)) ? 'â€”' : (Math.round(v*100)/100).toFixed(2);

  div.innerHTML = '';

  if (!staged.length) {
    DBG('no staged rows â†’ show empty state');
    div.innerHTML = `
      <div class="hint" style="margin-bottom:8px">No client default windows yet.</div>
      <div class="actions">
        <button id="btnAddClientRate" class="btn mini"${parentEditable ? '' : ' disabled'}>
          Add / Upsert client window
        </button>
        ${parentEditable
          ? '<span class="hint">Changes are staged. Click â€œSaveâ€ in the main dialog to persist.</span>'
          : '<span class="hint">Read-only. Click â€œEditâ€ in the main dialog to add/modify windows.</span>'}
      </div>
    `;
    const addBtn = byId('btnAddClientRate');
    if (addBtn && parentEditable) {
      addBtn.onclick = () => {
        const cid = (ctx && ctx.data && (ctx.data.id || ctx.data.client_id)) || null;
        return openClientRateModal(cid);
      };
    }
    return;
  }

  // Build a quick baseline lookup (used only for the new last-column status)
  const baseline = Array.isArray(ctx.ratesBaseline) ? ctx.ratesBaseline : [];
  const baselineById = new Map(baseline.filter(b => b && b.id).map(b => [String(b.id), b]));
  const stagedDelSet = (ctx.ratesStagedDeletes instanceof Set) ? ctx.ratesStagedDeletes : new Set();

  const cols = [
    'status',
    'role','band',
    'paye_day','paye_night','paye_sat','paye_sun','paye_bh',
    'umb_day','umb_night','umb_sat','umb_sun','umb_bh',
    'charge_day','charge_night','charge_sat','charge_sun','charge_bh',
    'paye_margin_day','paye_margin_night','paye_margin_sat','paye_margin_sun','paye_margin_bh',
    'umb_margin_day','umb_margin_night','umb_margin_sat','umb_margin_sun','umb_margin_bh',
    'date_from','date_to',
    // NEW: final column to reflect staged change status
    'change_status'
  ];
  const headers = [
    'Status',
    'Role','Band',
    'PAYE Day','PAYE Night','PAYE Sat','PAYE Sun','PAYE BH',
    'UMB Day','UMB Night','UMB Sat','UMB Sun','UMB BH',
    'Charge Day','Charge Night','Charge Sat','Charge Sun','Charge BH',
    'PAYE M Day','PAYE M Night','PAYE M Sat','PAYE M Sun','PAYE M BH',
    'UMB M Day','UMB M Night','UMB M Sat','UMB M Sun','UMB M BH',
    'From','To',
    // NEW header aligned with the final column
    'Change'
  ];

  const tbl   = document.createElement('table'); tbl.className='grid';
  const thead = document.createElement('thead');
  const trh   = document.createElement('tr');
  headers.forEach(h => { const th=document.createElement('th'); th.textContent = h; trh.appendChild(th); });
  thead.appendChild(trh);
  tbl.appendChild(thead);

  const tb = document.createElement('tbody');

  // Helper to detect field differences against baseline
  const DIFF_FIELDS = [
    'role','band','date_from','date_to',
    'charge_day','charge_night','charge_sat','charge_sun','charge_bh',
    'paye_day','paye_night','paye_sat','paye_sun','paye_bh',
    'umb_day','umb_night','umb_sat','umb_sun','umb_bh'
  ];
  const differsFromBaseline = (row) => {
    if (!row || !row.id) return false; // creations are handled separately
    const base = baselineById.get(String(row.id));
    if (!base) return true; // no baseline match means it's effectively different
    for (const f of DIFF_FIELDS) {
      const a = row[f]; const b = base[f];
      const na = (a === '' || a == null) ? null : a;
      const nb = (b === '' || b == null) ? null : b;
      if (String(na) !== String(nb)) return true;
    }
    return false;
  };

  // 2dp formatter for numeric cells that arenâ€™t margins
  const to2 = v => (v==null || v==='') ? 'â€”' : fmt(Number(v));

  staged.forEach((r, idx) => {
    const tr = document.createElement('tr');
    if (r.disabled_at_utc) tr.classList.add('row-disabled');
    if (r.__delete) tr.classList.add('row-delete-pending');

    if (parentEditable) tr.ondblclick = () => {
      const cid = (ctx && ctx.data && (ctx.data.id || ctx.data.client_id)) || r.client_id || null;
      return openClientRateModal(cid, r);
    };

    cols.forEach(c => {
      const td = document.createElement('td');

      if (c === 'status') {
        if (r.__delete) {
          td.innerHTML = `<span class="pill tag-fail" aria-label="Pending delete">ðŸ—‘ Pending delete (save to confirm)</span>`;
        } else if (r.disabled_at_utc) {
          const pending = r.__toggle ? ' (pending save)' : '';
          td.innerHTML = `<span class="pill tag-fail" aria-label="Disabled">âŒ Disabled${pending}</span>`;
        } else {
          const pending = r.__toggle ? ' (pending save)' : '';
          td.innerHTML = `<span class="pill tag-ok" aria-label="Active">âœ“ Active${pending}</span>`;
        }

      } else if (c.startsWith('paye_margin_') || c.startsWith('umb_margin_')) {
        const bucket = c.split('_').pop();
        const charge = r[`charge_${bucket}`];
        const paye   = r[`paye_${bucket}`];
        const umb    = r[`umb_${bucket}`];

        // âœ… Use global helper when present; fallback preserves existing behaviour
        let val = null;
        if (typeof calcDailyMargin === 'function') {
          if (c.startsWith('paye_margin_')) {
            val = calcDailyMargin({ bucket, charge, pay: paye, method: 'PAYE', erniMultiplier: mult });
          } else {
            val = calcDailyMargin({ bucket, charge, pay: umb,  method: 'UMBRELLA' });
          }
        } else {
          if (c.startsWith('paye_margin_')) val = (charge!=null && paye!=null) ? (charge - (paye * mult)) : null;
          else                               val = (charge!=null && umb!=null)  ? (charge - umb)          : null;
        }
        td.textContent = fmt(val);

      } else if (
        c.startsWith('charge_') ||
        c.startsWith('paye_')   ||
        c.startsWith('umb_')
      ) {
        // 2dp formatting for charge_* and paye_*/umb_* columns
        td.textContent = to2(r[c]);

      } else if (c === 'change_status') {
        let label = '';
        if (r.__delete || (r.id && stagedDelSet.has(String(r.id)))) {
          label = 'Pending delete (save to confirm)';
        } else if (r && r.__toggle === 'enable') {
          label = 'Pending enable';
        } else if (r && r.__toggle === 'disable') {
          label = 'Pending disable';
        } else if (!r.id) {
          label = 'Pending create';
        } else if (differsFromBaseline(r)) {
          label = 'Pending update';
        } else {
          label = '';
        }
        td.textContent = label;

      } else {
        td.textContent = formatDisplayValue(c, r[c]);
      }

      tr.appendChild(td);
    });

    tb.appendChild(tr);
    if (idx === 0) DBG('first row preview', r);
  });

  tbl.appendChild(tb);

  const actions = document.createElement('div');
  actions.className = 'actions';
  actions.innerHTML = `
    <button id="btnAddClientRate" class="btn mini"${parentEditable ? '' : ' disabled'}>
      Add / Upsert client window
    </button>
    ${parentEditable ? '' : '<span class="hint">Read-only. Click â€œEditâ€ in the main dialog to add/modify windows.</span>'}
  `;

  div.appendChild(tbl);
  div.appendChild(actions);
  DBG('EXIT render', { stagedLen: staged.length });
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Global margin helpers (safe, contracts-only consumers can use immediately)
// - calcDailyMargin({ bucket, charge, pay, method, erniMultiplier? }) -> number|null
// - calcDailyMarginsForBuckets({ method, charge:{...}, pay:{...}, erniMultiplier? }) -> {day,night,sat,sun,bh}
// - ensureErniMultiplier() -> Promise<number>  (optional bootstrap to memoise ERNI)
// Notes:
//   â€¢ Pure calc (ex-VAT). No rounding, no styling. Callers format to 2dp.
//   â€¢ For PAYE, margin = charge âˆ’ (pay Ã— ERNI_MULTIPLIER). For Umbrella, margin = charge âˆ’ pay.
//   â€¢ If any operand is missing/NaN returns null.
//   â€¢ Respects existing memo: window.__ERNI_MULT__ (fallback 1.0). Does not force async lookups.
//   â€¢ Non-breaking: only defines helpers if not already present.
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
(() => {
  const W = (typeof window !== 'undefined') ? window : globalThis;

  // Normalise to number or null (treat '', undefined, NaN as null)
  const toNum = (v) => {
    if (v === '' || v === null || v === undefined) return null;
    const n = Number(v);
    return Number.isFinite(n) ? n : null;
  };

  // Optional async bootstrap to memoise ERNI multiplier once (1 + percent)
  // Uses your existing getSettingsCached if available. Safe to call multiple times.
  if (typeof W.ensureErniMultiplier !== 'function') {
    W.ensureErniMultiplier = async function ensureErniMultiplier() {
      if (typeof W.__ERNI_MULT__ === 'number') return W.__ERNI_MULT__;
      try {
        if (typeof W.getSettingsCached === 'function') {
          const s = await W.getSettingsCached();
          let p = s?.erni_pct ?? s?.employers_ni_percent ?? 0;
          p = Number(p) || 0;
          if (p > 1) p = p / 100;           // support 13.8 vs 0.138
          W.__ERNI_MULT__ = 1 + p;
          return W.__ERNI_MULT__;
        }
      } catch {}
      W.__ERNI_MULT__ = 1;
      return 1;
    };
  }

  // Core per-bucket margin calculator (synchronous)
  if (typeof W.calcDailyMargin !== 'function') {
    /**
     * @param {Object} args
     * @param {'day'|'night'|'sat'|'sun'|'bh'} [args.bucket]
     * @param {number|null} args.charge
     * @param {number|null} args.pay    // PAYE pay or Umbrella pay for the bucket
     * @param {'PAYE'|'UMBRELLA'|string} args.method
     * @param {number} [args.erniMultiplier] // optional override; otherwise uses window.__ERNI_MULT__||1
     * @returns {number|null}
     */
    W.calcDailyMargin = function calcDailyMargin({ bucket, charge, pay, method, erniMultiplier } = {}) {
      const ch = toNum(charge);
      const py = toNum(pay);
      if (ch === null || py === null) return null;

      const m = (typeof erniMultiplier === 'number')
        ? erniMultiplier
        : (typeof W.__ERNI_MULT__ === 'number' ? W.__ERNI_MULT__ : 1);

      const meth = (method || 'PAYE').toString().toUpperCase();
      if (meth === 'PAYE') {
        return ch - (py * m);
      } else if (meth === 'UMBRELLA') {
        return ch - py;
      }
      // Unknown method â†’ treat like Umbrella (no ERNI)
      return ch - py;
    };
  }

  // Convenience: compute margins for all five buckets in one call
  if (typeof W.calcDailyMarginsForBuckets !== 'function') {
    /**
     * @param {Object} args
     * @param {'PAYE'|'UMBRELLA'|string} args.method
     * @param {Object} args.charge  // {day,night,sat,sun,bh}
     * @param {Object} args.pay     // {day,night,sat,sun,bh}  (PAYE pay or Umbrella pay)
     * @param {number} [args.erniMultiplier]
     * @returns {{day:number|null,night:number|null,sat:number|null,sun:number|null,bh:number|null}}
     */
    W.calcDailyMarginsForBuckets = function calcDailyMarginsForBuckets({ method, charge = {}, pay = {}, erniMultiplier } = {}) {
      const buckets = ['day','night','sat','sun','bh'];
      const out = {};
      const meth = (method || 'PAYE').toString().toUpperCase();
      const m = (typeof erniMultiplier === 'number')
        ? erniMultiplier
        : (typeof W.__ERNI_MULT__ === 'number' ? W.__ERNI_MULT__ : 1);

      buckets.forEach(b => {
        out[b] = W.calcDailyMargin({
          bucket: b,
          charge: charge[b],
          pay:    pay[b],
          method: meth,
          erniMultiplier: m
        });
      });
      return out;
    };
  }
})();


// NEW
async function endContractSafely(contractId, desiredEnd) {
  const LOGC = (typeof window !== 'undefined' && window.__IS_TESTING_LOG) || (typeof window !== 'undefined' && !!window.__LOG_CONTRACTS);
  const url   = `${window.BROKER_BASE_URL}/api/contracts/${encodeURIComponent(String(contractId))}/truncate-tail`;
  const body  = { id: String(contractId), desired_end: String(desiredEnd) };

  if (LOGC) {
    console.groupCollapsed('[TRIM_CALL][frontend] dispatch');
    console.log('request', { url, body, hasAuthFetch: typeof window !== 'undefined' && typeof window.authFetch === 'function' });
  }

  let result;
  try {
    if (typeof window !== 'undefined' && typeof window.authFetch === 'function') {
      const resp = await window.authFetch({
        url,
        method: 'POST',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify(body)
      });
      // normalise possible shapes from authFetch
      if (resp && typeof resp === 'object' && 'ok' in resp && 'json' in resp && typeof resp.json === 'function') {
        const json = await resp.json().catch(() => null);
        result = (json && typeof json === 'object') ? { ...json } : { ok: !!resp.ok, status: resp.status ?? 200 };
      } else {
        result = resp;
      }
    } else {
      const r = await fetch(url, {
        method: 'POST',
        headers: { 'content-type': 'application/json', ...(window?.sbHeaders || {}) },
        body: JSON.stringify(body)
      });
      const data = await r.json().catch(() => null);
      if (!r.ok) {
        const msg = (data && (data.error || data.message)) || `HTTP ${r.status}`;
        throw new Error(msg);
      }
      result = data ?? { ok: true };
    }

    if (LOGC) console.log('response', result);
    return result;
  } catch (err) {
    if (LOGC) console.warn('[TRIM_CALL][frontend] error', err);
    throw err;
  } finally {
    if (LOGC) console.groupEnd?.();
  }
}

// Ensure a window-bound handle exists even when this file is bundled as an ES module
if (typeof window !== 'undefined') {
  if (typeof window.endContractScrub === 'function' && !window.endContractSafely) {
    // legacy alias safeguard if you had a prior name
    window.endContractSafely = window.endContractScrub;
  } else if (typeof window.endContractSafely !== 'function') {
    window.endContractSafely = endContractSafely;
  }
}

// NEW
async function refetchContract(id) {
  const url = `${window.BROKER_BASE_URL}/api/contracts/${encodeURIComponent(id)}`;
  if (typeof authFetch === 'function') {
    const res = await authFetch({ url, method: 'GET', headers: { 'content-type': 'application/json' } });
    return res?.contract || res || null;
  }
  const r = await fetch(url, { headers: { ...(window.sbHeaders || {}) } });
  if (!r.ok) return null;
  const j = await r.json().catch(() => null);
  return j?.contract || j || null;
}

// NEW
function updateContractsListCache(id, row) {
  try {
    if (Array.isArray(window.currentRows)) {
      const i = window.currentRows.findIndex(x => String(x.id) === String(id));
      if (i >= 0) window.currentRows[i] = row;
      (window.__lastSavedAtById ||= {})[String(id)] = Date.now();
    }
  } catch {}
}

// NEW
function showTailClampWarning(safeEnd, desiredEnd) {
  const msg = `End date adjusted to ${safeEnd} due to existing timesheet(s). (Requested ${desiredEnd})`;
  if (typeof showModalHint === 'function') showModalHint(msg, 'warn');
  try { window.__toast?.(msg); } catch {}
}

// NEW
function clearCloneIntent() {
  try {
    const token = window.modalCtx?.openToken || null;
    if (window.modalCtx && window.modalCtx.__cloneIntent) delete window.modalCtx.__cloneIntent;
    if (token && window.__cloneIntents) delete window.__cloneIntents[token];
  } catch {}
}
// NEW
async function refreshOldContractAfterTruncate(oldContractId) {
  const LOGC = (typeof window.__LOG_CONTRACTS === 'boolean') ? window.__LOG_CONTRACTS : true;
  const row = await refetchContract(oldContractId);
  if (!row) return;

  updateContractsListCache(oldContractId, row);

  try {
    const fr = (typeof window.__getModalFrame === 'function') ? window.__getModalFrame() : null;
    if (fr && window.modalCtx && window.modalCtx.entity === 'contracts' && String(window.modalCtx?.data?.id || '') === String(oldContractId)) {
      window.modalCtx.data = { ...(window.modalCtx.data || {}), ...row };
      try { window.dispatchEvent(new Event('contracts-main-rendered')); } catch {}
    }
  } catch {}

  try {
    const st = (window.__calState || {})[oldContractId];
    const win = st && st.win ? st.win : null;
    if (typeof fetchAndRenderContractCalendar === 'function') {
      if (win) {
        await fetchAndRenderContractCalendar(oldContractId, { from: win.from, to: win.to, view: st.view });
      } else {
        const y = (new Date()).getUTCFullYear();
        const def = (typeof computeYearWindow === 'function') ? computeYearWindow(y) : { from: `${y}-01-01`, to: `${y}-12-31` };
        await fetchAndRenderContractCalendar(oldContractId, { from: def.from, to: def.to, view: 'year' });
      }
    }
  } catch (e) {
    if (LOGC) console.warn('[CONTRACTS] refreshOldContractAfterTruncate calendar refresh failed', e);
  }
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UPDATED: showModal (adds contract-modal class toggling for Contracts dialogs)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function showModal(title, tabs, renderTab, onSave, hasId, onReturn, options) {

  const LOG = (typeof window.__LOG_MODAL === 'boolean') ? window.__LOG_MODAL : true;
  const L  = (...a)=> { if (LOG) console.log('[MODAL]', ...a); };
  const GC = (label)=> { if (LOG) console.groupCollapsed('[MODAL]', label); };
  const GE = ()=> { if (LOG) console.groupEnd(); };

  const stack = () => (window.__modalStack ||= []);
  const currentFrame = () => stack()[stack().length - 1] || null;
  const parentFrame  = () => (stack().length > 1 ? stack()[stack().length - 2] : null);
  const deep = (o) => JSON.parse(JSON.stringify(o));

  let opts = options || {};
  if (onReturn && typeof onReturn === 'object' && options === undefined) { opts = onReturn; onReturn = undefined; }

  const stripEmpty = (obj) => { const out={}; for (const [k,v] of Object.entries(obj||{})) { if (v===''||v==null) continue; out[k]=v; } return out; };

function setFormReadOnly(root, ro) {
  if (!root || !document.contains(root)) { L('setFormReadOnly(skip: invalid root)', { ro }); return; }
  const _allBefore = root.querySelectorAll('input, select, textarea, button');
  const beforeDisabled = Array.from(_allBefore).filter(el => el.disabled).length;

  root.querySelectorAll('input, select, textarea, button').forEach((el) => {
    const isDisplayOnly = el.id === 'tms_ref_display' || el.id === 'cli_ref_display';

  if (el.type === 'button') {
  const allow = new Set(['btnCloseModal','btnDelete','btnEditModal','btnSave','btnRelated']);

  // Keep Timesheet action buttons (data-ts-action) enabled even when ro === true
  try {
    const top = (typeof currentFrame === 'function') ? currentFrame() : null;

    const isTimesheetFrame = !!(top && top.entity === 'timesheets');
    const hasTsAction      = !!el.getAttribute('data-ts-action');

    if (isTimesheetFrame && hasTsAction) {
      // Do not force-disable Timesheet action buttons (Authorise, Open PDF, etc.)
      return;
    }
  } catch {}

  if (!allow.has(el.id)) el.disabled = !!ro;
  return;
}


    if (isDisplayOnly) {
      el.setAttribute('disabled','true');
      el.setAttribute('readonly','true');
      return;
    }
    if (ro) {
      el.setAttribute('disabled','true');
      el.setAttribute('readonly','true');
    } else {
      el.removeAttribute('disabled');
      el.removeAttribute('readonly');
    }
  });

  const _allAfter = root.querySelectorAll('input, select, textarea, button');
  const afterDisabled = Array.from(_allAfter).filter(el => el.disabled).length;
  try {
    const pc = root.querySelector('#btnPickCandidate');
    const pl = root.querySelector('#btnPickClient');
    L('setFormReadOnly snapshot', {
      ro,
      beforeDisabled,
      afterDisabled,
      picks: {
        btnPickCandidate: { exists: !!pc, disabled: !!(pc && pc.disabled) },
        btnPickClient:    { exists: !!pl, disabled: !!(pl && pl.disabled) }
      }
    });
  } catch {}
}



  function sanitizeModalGeometry() {
    const m = byId('modal');
    if (m) {
      m.classList.remove('dragging');
      const anchor = (window.__modalAnchor || null);
      if (anchor) {
        L('sanitizeModalGeometry: applying saved anchor', anchor);
        m.style.position = 'fixed';
        m.style.left     = anchor.left + 'px';
        m.style.top      = anchor.top  + 'px';
        m.style.right    = 'auto';
        m.style.bottom   = 'auto';
        m.style.transform= 'none';
      } else {
        L('sanitizeModalGeometry: reset to default (no anchor)');
        m.style.position = '';
        m.style.left = '';
        m.style.top = '';
        m.style.right = '';
        m.style.bottom = '';
        m.style.transform = '';
      }
    }
    document.onmousemove = null; document.onmouseup = null;
  }

  const modalEl = byId('modal');
  if (modalEl) {
    modalEl.style.position = ''; modalEl.style.left = ''; modalEl.style.top = '';
    modalEl.style.right = '';    modalEl.style.bottom = '';
    modalEl.style.transform = ''; modalEl.classList.remove('dragging');
    L('showModal: reset #modal initial geometry');
  }

  // Allow staging children (Clone & Extend) to be fully editable regardless of parent mode
  if (opts && opts.kind === 'contract-clone-extend') {
    opts.noParentGate = true;
    if (!opts.forceEdit) opts.forceEdit = true;
    L('showModal(kind=contract-clone-extend): enable noParentGate + forceEdit', { noParentGate: opts.noParentGate, forceEdit: opts.forceEdit });
  }

  // Import summary modals: always behave as independent utility panels
  // - they must NOT gate the parent
  // - they stack under contract edit modals but stay open across navigation
  if (opts && typeof opts.kind === 'string' && opts.kind.startsWith('import-summary-')) {
    opts.noParentGate   = true;
    opts.stayOpenOnSave = false;
    L('showModal(kind=import-summary-*) â†’ utility modal (noParentGate=true)', { kind: opts.kind });
  }

  // Treat the Rate Presets **picker** as a normal, interactive child:
  // - do NOT set noParentGate or _loadOnly here
  // - dirty should propagate to the parent while the picker is open
  if (opts && opts.kind === 'rate-presets-picker') {
    L('showModal(kind=rate-presets-picker): interactive child (noParentGate=false)');
  }




const frame = {
  _token: `f:${Date.now()}:${Math.random().toString(36).slice(2)}`,
  _ctxRef: window.modalCtx,
  title,
  tabs: Array.isArray(tabs) ? tabs.slice() : [],
  renderTab,
  onSave,
  onReturn,
  hasId: !!hasId,
  entity: (window.modalCtx && window.modalCtx.entity) || null,

  noParentGate: !!opts.noParentGate,
  forceEdit:    !!opts.forceEdit,
  kind:         opts.kind || null,
  stayOpenOnSave: !!opts.stayOpenOnSave,
    currentTabKey: (Array.isArray(tabs) && tabs.length ? tabs[0].key : null),

  mode: (() => {
  if (opts.forceEdit) return 'edit';
  if (!hasId && opts.kind === 'rate-preset') return 'edit';

  // NEW: utility modals â€“ always view-only, no Save/Edit
  const isUtilityKind =
    opts.kind === 'timesheets-resolve' ||
    opts.kind === 'resolve-candidate'  ||
    opts.kind === 'resolve-client'     ||
    (typeof opts.kind === 'string' && opts.kind.startsWith('import-summary-'));

  if (isUtilityKind) {
    return 'view';
  }


  // Special case: planned timesheet week (no timesheet_id yet)
  const ent = window.modalCtx?.entity || null;
  if (!hasId && ent === 'timesheets') {
    const d = window.modalCtx?.data || {};
    const hasWeek  = !!(d.contract_week_id || d.week_id || d.week_ending_date);
    const hasTsId  = !!d.timesheet_id;
    if (hasWeek && !hasTsId) {
      // Planned weekly/daily stub: open in VIEW mode, require explicit Edit
      return 'view';
    }
  }

  // Default for everything else
  return hasId ? 'view' : 'create';
})(),

    isDirty:false, _snapshot:null, _detachDirty:null, _detachGlobal:null, _hasMountedOnce:false, _wired:false, _closing:false, _saving:false, _confirmingDiscard:false,
    _applyDesired:null,

persistCurrentTabState() {
  L('persistCurrentTabState ENTER', { mode: this.mode, currentTabKey: this.currentTabKey });
  if (!window.modalCtx || this.mode === 'view') { L('persist(skip)', { reason:'mode=view or no modalCtx', mode:this.mode }); return; }

  const sentinel = window.modalCtx?.openToken || null;
  const initial  = (window.modalCtx.data?.id ?? sentinel);
  const fs = window.modalCtx.formState || { __forId: initial, main:{}, pay:{} };
  if (fs.__forId == null) fs.__forId = initial;

  // Preserve schedule inputs even when blank ('') so cleared days don't get dropped
  const keepScheduleBlanks = (obj) => {
    const out = {};
    const days = ['mon','tue','wed','thu','fri','sat','sun'];
    const parts = ['start','end','break'];
    days.forEach(d => {
      parts.forEach(p => {
        const k = `${d}_${p}`;
        if (Object.prototype.hasOwnProperty.call(obj, k)) {
          out[k] = (obj[k] == null ? '' : String(obj[k]));
        }
      });
    });
    return out;
  };

   if (this.currentTabKey === 'main') {
    const sel = byId('tab-main') ? '#tab-main' : (byId('contractForm') ? '#contractForm' : null);
    if (sel) {
      const c = collectForm(sel);
      // keep existing behavior for most fields, then re-add schedule blanks explicitly
      const merged = { ...stripEmpty(c) };
      const sched  = keepScheduleBlanks(c);
      fs.main = { ...(fs.main||{}), ...merged, ...sched };
    }
  }

 if (this.currentTabKey === 'pay' && byId('tab-pay')) {
  const c = collectForm('#tab-pay');
  // For the Pay tab we must preserve blanks so cleared bank/umbrella fields
  // donâ€™t spring back from the DB when hopping between tabs.
  // Do NOT strip empty values here.
  if (LOG) {
    console.log('[MODAL][persistCurrentTabState] PAY TAB collected', {
      raw: { ...c },
      prevPay: { ...(fs.pay || {}) }
    });
  }
  fs.pay = { ...(fs.pay || {}), ...c };
  if (LOG) {
    console.log('[MODAL][persistCurrentTabState] PAY TAB updated fs.pay', {
      payKeys: Object.keys(fs.pay || {}),
      fsPay: { ...fs.pay }
    });
  }
}



  // NEW: capture Care Packages tab (candidates/rates) into main form state
  if (this.entity === 'candidates' && this.currentTabKey === 'rates' && byId('tab-rates')) {
    const c = collectForm('#tab-rates');
    // GCK (key_norm) and any future Care Packages fields are treated
    // as part of the candidate "main" payload
    fs.main = { ...(fs.main || {}), ...stripEmpty(c) };
  }

  // Persist contract-specific state when leaving Rates **or** Additional Rates
if (this.entity === 'contracts' && (this.currentTabKey === 'rates' || this.currentTabKey === 'extras')) {
  try {
    // Only bother capturing the paye/umb/charge_* fields from the Rates tab itself
    if (this.currentTabKey === 'rates') {
      const rt = byId('contractRatesTab');
      if (rt) {
        const rForm = {};
        rt.querySelectorAll('input, select, textarea').forEach(el => {
          if (el.name) {
            rForm[el.name] = (el.type === 'checkbox'
              ? (el.checked ? 'on' : '')
              : el.value);
          }
        });
        const onlyRates = {};
        for (const [k, v] of Object.entries(rForm)) {
          if (/^(paye_|umb_|charge_)/.test(k)) {
            onlyRates[k] = v;
          }
        }
        fs.pay = { ...(fs.pay || {}), ...stripEmpty(onlyRates) };
      }
    }

    // Always collect the full contract form so Main + Additional Rates fields are staged
    const mainSel = byId('contractForm') ? '#contractForm' : null;
    if (mainSel) {
      const m = collectForm(mainSel);
      // keep existing behavior for most fields, then re-add schedule blanks explicitly
      const mergedMain = { ...stripEmpty(m) };
      const sched      = keepScheduleBlanks(m);
      fs.main = { ...(fs.main || {}), ...mergedMain, ...sched };
    }
  } catch (e) {
    L('persistCurrentTabState contracts/rates+extras failed', e);
  }
}



  window.modalCtx.formState = fs;
  L('persistCurrentTabState EXIT', { forId: fs.__forId, mainKeys: Object.keys(fs.main||{}), payKeys: Object.keys(fs.pay||{}) });
},

// inside showModal(...), in the `const frame = { ... }` object:
mergedRowForTab(k) {
  L('mergedRowForTab ENTER', { k });
  const base = { ...(window.modalCtx?.data || {}) };
  const fs   = (window.modalCtx?.formState || {});
  const rid  = window.modalCtx?.data?.id ?? null;
  const fid  = fs.__forId ?? null;
  const sentinel = window.modalCtx?.openToken ?? null;
  const same = (fid===rid) || (rid==null && (fid===sentinel || fid==null));

  const mainStaged = same ? (fs.main || {}) : {};
  const payStaged  = same ? (fs.pay  || {}) : {};

  // Default merge (drops empty strings via stripEmpty)
  const out = { ...base, ...stripEmpty(mainStaged) };

  // Keep non-DOM baselines visible, but let staged template override base schedule
  try {
    // ðŸ”¹ CHANGE: always prefer the staged __template if present
    if (mainStaged.__template) {
      out.std_schedule_json = mainStaged.__template;
    }

    if (!out.std_hours_json && mainStaged.__hours) {
      out.std_hours_json = mainStaged.__hours;
    }

    if (Object.prototype.hasOwnProperty.call(mainStaged, '__bucket_labels')) {
      out.bucket_labels_json = mainStaged.__bucket_labels;
    }
  } catch {}

  // âœ¨ Preserve schedule fields even when blank
  // (so an applied preset with missing days truly overwrites prior values to empty)
  try {
    const days = ['mon','tue','wed','thu','fri','sat','sun'];
    const parts = ['start','end','break'];
    days.forEach(d => {
      parts.forEach(p => {
        const key = `${d}_${p}`;
        if (Object.prototype.hasOwnProperty.call(mainStaged, key)) {
          // Use the staged value verbatim, including ''
          out[key] = mainStaged[key];
        }
      });
    });
  } catch {}

  // Rates: merge staged pay/charge families into view row
  try {
    const mergedRates = { ...(out.rates_json || base.rates_json || {}) };
    for (const [kk, vv] of Object.entries(payStaged)) {
      if (/^(paye_|umb_|charge_)/.test(kk)) mergedRates[kk] = vv;
    }
    out.rates_json = mergedRates;
  } catch (e) {
    L('mergedRowForTab rates merge failed', e);
  }

  L('mergedRowForTab STATE', {
    rid, fid, sentinel, same,
    stagedMainKeys: Object.keys(mainStaged||{}),
    stagedPayKeys: Object.keys(payStaged||{}),
    ratesKeys: Object.keys(out.rates_json || {})
  });
  return out;
},


   _attachDirtyTracker() {
    if (this._detachDirty) { try { this._detachDirty(); } catch {} this._detachDirty = null; }
    const root = byId('modalBody'); if (!root) { L('_attachDirtyTracker(skip: no modalBody)'); return; }
    const onDirty = (ev) => {
      if (ev && !ev.isTrusted) return;

     // Allow presets picker to mark the *parent* dirty (only ignore truly load-only frames)
if (this._loadOnly === true) return;

      const isChild = (stack().length > 1);
      if (isChild) {
        if (this.noParentGate) {
          if (this.mode === 'edit' || this.mode === 'create') {
            this.isDirty = true;
            this._updateButtons && this._updateButtons();
          }
        } else {
          const p = parentFrame();
          if (p && (p.mode === 'edit' || p.mode === 'create')) {
            p.isDirty = true;
            p._updateButtons && p._updateButtons();
          }
        }
      } else {
        if (this.mode === 'edit' || this.mode === 'create') {
          this.isDirty = true;
          this._updateButtons && this._updateButtons();
        }
      }
      try { const t=currentFrame(); if (t && t.entity==='candidates' && t.currentTabKey==='rates') { renderCandidateRatesTable?.(); } } catch {}
    };
    root.addEventListener('input', onDirty, true);
    root.addEventListener('change',onDirty, true);
    this._detachDirty = ()=>{ root.removeEventListener('input',onDirty,true); root.removeEventListener('change',onDirty,true); };
    L('_attachDirtyTracker: attached');
  },

async setTab(k) {
  GC(`setTab(${k})`);
  L('setTab ENTER', {
    k,
    prevKey: this.currentTabKey,
    entity: this.entity,
    mode: this.mode,
    hasMounted: this._hasMountedOnce
  });

  const prevDirty = this.isDirty;
  this._suppressDirty = true;

  const persist = this._hasMountedOnce;
  if (persist) this.persistCurrentTabState();

   const merged = this.mergedRowForTab(k);
  if (this.entity === 'contracts' && k === 'main' && this.mode !== 'edit' && this.mode !== 'create') {
    if (window.modalCtx?.data?.start_date) merged.start_date = window.modalCtx.data.start_date;
    if (window.modalCtx?.data?.end_date)   merged.end_date   = window.modalCtx.data.end_date;
    try {
      const fs = (window.modalCtx.formState ||= {
        __forId: (window.modalCtx?.data?.id || window.modalCtx?.openToken || null),
        main: {},
        pay: {}
      });
      fs.main ||= {};
      if (merged.start_date) fs.main.start_date = merged.start_date;
      if (merged.end_date)   fs.main.end_date   = merged.end_date;
    } catch {}
  }

  byId('modalBody').innerHTML = this.renderTab(k, merged) || '';

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Imports: Main tab wiring (dropzones) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (this.entity === 'imports' && this.kind === 'imports' && k === 'main') {
    try {
      if (typeof wireImportDropzones === 'function') {
        wireImportDropzones();
      }
    } catch (e) {
      console.warn('[IMPORTS][WIRE] wireImportDropzones failed', e);
    }
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Clients: Rates tab wiring â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (this.entity === 'clients' && k === 'rates') {
    try {
      typeof renderClientRatesTable === 'function' && renderClientRatesTable();
    } catch (e) {
      console.warn('[CLIENT][RATES] renderClientRatesTable failed', e);
    }
  }



  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Clients: Settings tab wiring â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (this.entity === 'clients' && k === 'settings') {
    try {
      // Use the actual client settings renderer, seeded from modalCtx
      if (typeof renderClientSettingsUI === 'function') {
        const seed = (window.modalCtx && window.modalCtx.clientSettingsState) || {};
        renderClientSettingsUI(seed);
      }
    } catch (e) {
      console.warn('[CLIENT][SETTINGS] renderClientSettingsUI failed', e);
    }
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Candidates: Main tab wiring (NI / DOB / aliases / job titles) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (this.entity === 'candidates' && k === 'main') {
    try {
      const container = document.getElementById('tab-main');
      if (container && typeof bindCandidateMainFormEvents === 'function') {
        // Ensure we have a candidateMainModel (openCandidate now seeds this)
        if (!window.modalCtx.candidateMainModel || typeof window.modalCtx.candidateMainModel !== 'object') {
          window.modalCtx.candidateMainModel = {};
        }
        bindCandidateMainFormEvents(container, window.modalCtx.candidateMainModel);
      }
    } catch (e) {
      console.warn('[CAND][MAIN] bindCandidateMainFormEvents failed', e);
    }
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Candidates: Bookings tab wiring â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   if (this.entity === 'candidates' && k === 'bookings') {
    try {
      const candId =
        window.modalCtx?.data?.id ||
        merged.id ||
        null;

      if (candId && typeof loadCandidateCalendar === 'function') {
        const holder = document.getElementById('candidateCalendarHolder');
        if (holder) {
          loadCandidateCalendar(holder, candId).catch(err => {
            console.warn('[CAND][BOOKINGS] loadCandidateCalendar failed', err);
            holder.innerHTML = '<span class="mini">Failed to load calendar.</span>';
          });
        }
      }
    } catch (e) {
      console.warn('[CAND][BOOKINGS] wiring failed', e);
    }
  }

   // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Candidates: Pay tab (Advances summary + Umbrella wiring) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (this.entity === 'candidates' && k === 'pay') {
    try {
      // Wire Umbrella input + datalist (searchable picker)
      if (typeof mountCandidatePayTab === 'function') {
        await mountCandidatePayTab();
      }

      const candId =
        window.modalCtx?.data?.id ||
        merged.id ||
        null;

      if (candId) {
        window.appState = window.appState || {};
        const cache = (window.appState.candidateAdvances ||= {});

        if (cache[candId]) {
          // Already cached this session â†’ repaint into fresh DOM
          updateCandidateAdvancesUI(candId);
        } else {
          // First time on this candidate â†’ fetch from backend
          fetchCandidateAdvances(candId).catch(err => {
            console.warn('[CAND][PAY][ADVANCES] fetch failed', err);
          });
        }
        // No button wiring here: this tab is read-only for advances.
        // Editing happens via right-click on the candidate row â†’ openCandidateAdvancesModal.
      }
    } catch (e) {
      console.warn('[CAND][PAY][ADVANCES] wiring failed', e);
    }
  }


  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Candidates: Rates tab (Rota Roles + overrides) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (this.entity === 'candidates' && k === 'rates') {
    try {
      // Rota Roles editor
      const container = document.getElementById('rolesEditor');
      if (container && typeof loadGlobalRoleOptions === 'function' && typeof renderRolesEditor === 'function') {
        const allRoles = await loadGlobalRoleOptions();

        const currentRoles =
          (Array.isArray(window.modalCtx?.rolesState) && window.modalCtx.rolesState.length)
            ? window.modalCtx.rolesState
            : (Array.isArray(window.modalCtx?.data?.roles) ? window.modalCtx.data.roles : []);

        renderRolesEditor(container, currentRoles, allRoles);

        // Optional: keep options fresh if global roles list changes
        if (!window.modalCtx._rolesUpdatedHandler) {
          window.modalCtx._rolesUpdatedHandler = async () => {
            try {
              const updated = await loadGlobalRoleOptions();
              if (container.__rolesEditor && typeof container.__rolesEditor.updateOptions === 'function') {
                container.__rolesEditor.updateOptions(updated);
              }
            } catch {
              // non-fatal
            }
          };
          window.addEventListener('global-roles-updated', window.modalCtx._rolesUpdatedHandler);
        }
      }

      // Candidate-specific rate overrides table
      if (typeof mountCandidateRatesTab === 'function') {
        await mountCandidateRatesTab();
      }
    } catch (e) {
      console.warn('[CAND][RATES] wiring failed', e);
    }
  }



  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Timesheets: Overview tab wiring â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Timesheets: Overview tab wiring â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if (this.entity === 'timesheets' && k === 'overview') {
  const { LOGM, L: LT } = getTsLoggers('[TS][OVERVIEW][WIRE]');
  const root = byId('modalBody');
  if (!root) {
    if (LOGM) LT('no modalBody root, skip wiring');
  } else {
    try {
      const mc   = window.modalCtx || {};
      const tsId   = mc.data?.timesheet_id || null;              // REAL timesheet id only
      const weekId = mc.data?.contract_week_id || null;          // contract_week id for planned weeks
      const mode   = this.mode || 'view';

      if (!tsId && !weekId) {
        if (LOGM) LT('no tsId/contract_week_id on modalCtx.data, skip overview wiring');
      } else {
        const authoriseBtn       = root.querySelector('button[data-ts-action="authorise"]');
        const unauthoriseBtn     = root.querySelector('button[data-ts-action="unauthorise"]');
        const switchManualBtn    = root.querySelector('button[data-ts-action="switch-manual"]');
        const holdOnBtn          = root.querySelector('button[data-ts-action="pay-hold-on"]');
        const holdOffBtn         = root.querySelector('button[data-ts-action="pay-hold-off"]');
        const markPaidBtn        = root.querySelector('button[data-ts-action="mark-paid"]');
        const refInput           = root.querySelector('input[name="ts_reference"]');
        const payHoldInput       = root.querySelector('input[name="ts_pay_hold"]');
        const payHoldReasonInput = root.querySelector('input[name="ts_pay_hold_reason"]');
        const markPaidInput      = root.querySelector('input[name="ts_mark_paid"]');

        // NEW: extra action buttons for timesheets
        const revertElecBtn      = root.querySelector('button[data-ts-action="revert-electronic"]');
        const deleteReopenBtn    = root.querySelector('button[data-ts-action="delete-manual-reopen"]');
        const deletePermBtn      = root.querySelector('button[data-ts-action="delete-permanent"]');

        const det   = mc.timesheetDetails || {};
        const ts    = det.timesheet || {};
        const tsfin = det.tsfin || {};
        const sheetScope = (det.sheet_scope || mc.data?.sheet_scope || ts.sheet_scope || '').toUpperCase();
        const subMode    = (ts.submission_mode || mc.data?.submission_mode || '').toUpperCase();

        // contract-week context for weekly manual delete+reopen
        const cwId            = det.contract_week_id || mc.data?.contract_week_id || null;
        const hasContractWeek = !!cwId;

        const isAuthorised     = !!ts.authorised_at_server;
        const locked           = !!(tsfin.locked_by_invoice_id || tsfin.paid_at_utc);
        const alreadyPaid      = !!tsfin.paid_at_utc;

        const hasTs           = !!tsId;
        const isWeekly        = (sheetScope === 'WEEKLY');
        const isDaily         = (sheetScope === 'DAILY');
        const weeklyElectronicWithTs =
          isWeekly && subMode === 'ELECTRONIC' && hasTs;
        const weeklyElectronicPlanned =
          isWeekly && subMode === 'ELECTRONIC' && !hasTs && !!weekId;

        // NEW: simple front-end gating; backend still enforces final rules
        const canRevertElectronic =
          !!tsId && !locked && subMode === 'MANUAL';

        const canDeleteManualReopen =
          !!tsId && !locked && isWeekly && subMode === 'MANUAL' && hasContractWeek;

        const canDeletePermanent =
          !!tsId && !locked;

        if (LOGM) {
          LT('overview wiring snapshot', {
            tsId,
            weekId,
            mode,
            sheetScope,
            subMode,
            isAuthorised,
            locked,
            weeklyElectronicWithTs,
            weeklyElectronicPlanned,
            hasAuthorise: !!authoriseBtn,
            hasUnauthorise: !!unauthoriseBtn,
            hasSwitchManual: !!switchManualBtn,
            hasRefInput: !!refInput,
            hasPayHoldInput: !!payHoldInput,
            hasMarkPaidInput: !!markPaidInput
          });
        }

        const viewEls = root.querySelectorAll('[data-view-only="true"]');
        const editEls = root.querySelectorAll('[data-edit-only="true"]');
        if (mode === 'edit' || mode === 'create') {
          viewEls.forEach(el => { el.style.display = 'none'; });
          editEls.forEach(el => { el.style.display = ''; });
        } else {
          viewEls.forEach(el => { el.style.display = ''; });
          editEls.forEach(el => { el.style.display = 'none'; });
        }

        // Hide legacy buttons
        if (holdOnBtn)   holdOnBtn.style.display  = 'none';
        if (holdOffBtn)  holdOffBtn.style.display = 'none';
        if (markPaidBtn) markPaidBtn.style.display= 'none';

        // â”€â”€ Authorise / Unauthorise â”€â”€
        if (authoriseBtn) {
          authoriseBtn.style.display = (!isAuthorised && !locked && mode === 'view' && hasTs) ? '' : 'none';
          if (!authoriseBtn.__tsWired) {
            authoriseBtn.__tsWired = true;
            authoriseBtn.addEventListener('click', async () => {
              try {
                await authoriseTimesheet(tsId);
                window.__toast && window.__toast('Timesheet authorised');
              } catch (err) {
                if (LOGM) console.warn('[TS][OVERVIEW] authoriseTimesheet failed', err);
                alert(err?.message || 'Failed to authorise timesheet.');
              }
            });
          }
        }

        if (unauthoriseBtn) {
          unauthoriseBtn.style.display = (isAuthorised && !locked && mode === 'view' && hasTs) ? '' : 'none';
          if (!unauthoriseBtn.__tsWired) {
            unauthoriseBtn.__tsWired = true;
            unauthoriseBtn.addEventListener('click', async () => {
              const ok = window.confirm('Unauthorise this timesheet? It will return to a pending state.');
              if (!ok) return;
              try {
                await unauthoriseTimesheet(tsId);
                window.__toast && window.__toast('Timesheet unauthorised');
              } catch (err) {
                if (LOGM) console.warn('[TS][OVERVIEW] unauthoriseTimesheet failed', err);
                alert(err?.message || 'Failed to unauthorise timesheet.');
              }
            });
          }
        }

        // â”€â”€ Convert to manual (two paths) â”€â”€
        if (switchManualBtn) {
          // Show the button for:
          // - existing weekly electronic TS, OR
          // - planned weekly electronic week (no TS yet, but has contract_week_id)
          const showSwitch =
            mode === 'view' &&
            !locked &&
            isWeekly &&
            subMode === 'ELECTRONIC' &&
            (!!tsId || !!weekId);

          switchManualBtn.style.display = showSwitch ? '' : 'none';

          if (!switchManualBtn.__tsWired) {
            switchManualBtn.__tsWired = true;
            switchManualBtn.addEventListener('click', async () => {
              const ok = window.confirm(
                'Convert this weekly electronic timesheet to MANUAL?\n\n' +
                'For existing timesheets, the signed electronic version is preserved as a separate version.\n' +
                'For planned/open weeks, the week will be marked as MANUAL so you can enter manual hours.'
              );
              if (!ok) return;

              try {
                const mc2    = window.modalCtx || {};
                const tsId2  = mc2.data?.timesheet_id || null;
                const weekId2= mc2.data?.contract_week_id || null;
                const det2   = mc2.timesheetDetails || {};
                const ts2    = det2.timesheet || {};
                const sheetScope2 = (det2.sheet_scope || mc2.data?.sheet_scope || ts2.sheet_scope || '').toUpperCase();
                const subMode2    = (ts2.submission_mode || mc2.data?.submission_mode || '').toUpperCase();

                const hasTs2           = !!tsId2;
                const weeklyElectronicWithTs2 =
                  sheetScope2 === 'WEEKLY' && subMode2 === 'ELECTRONIC' && hasTs2;
                const weeklyElectronicPlanned2 =
                  sheetScope2 === 'WEEKLY' && subMode2 === 'ELECTRONIC' && !hasTs2 && !!weekId2;

                if (weeklyElectronicWithTs2 && tsId2) {
                  // Existing electronic timesheet â†’ /api/timesheets/:id/switch-to-manual
                  await switchTimesheetToManual(tsId2);
                  try {
                    mc2.data.submission_mode = 'MANUAL';
                    if (mc2.timesheetDetails && mc2.timesheetDetails.timesheet) {
                      mc2.timesheetDetails.timesheet.submission_mode = 'MANUAL';
                    }
                  } catch {}
                } else if (weeklyElectronicPlanned2 && weekId2) {
                  // Planned/open weekly slot â†’ /api/contract-weeks/:id/switch-mode
                  await switchContractWeekToManual(weekId2);
                  try {
                    mc2.data.submission_mode_snapshot = 'MANUAL';
                    if (mc2.timesheetDetails && mc2.timesheetDetails.contract_week) {
                      mc2.timesheetDetails.contract_week.submission_mode_snapshot = 'MANUAL';
                    }

                    // ðŸ”¹ Keep timesheetMeta in sync so Edit gating works *without* reopening
                    if (mc2.timesheetMeta && typeof mc2.timesheetMeta === 'object') {
                      mc2.timesheetMeta.cw_submission_mode_snapshot = 'MANUAL';
                      mc2.timesheetMeta.sheetScope  = 'WEEKLY';
                      mc2.timesheetMeta.subMode     = 'MANUAL';
                      mc2.timesheetMeta.isPlannedWeek = true;
                      mc2.timesheetMeta.hasTs      = false;
                    }
                  } catch {}
                } else {
                  throw new Error('This week is not an electronic weekly slot; cannot convert to manual.');
                }

                window.__toast && window.__toast(
                  'Weekly week is now in MANUAL mode. Click Edit to enter manual hours.'
                );

                // Refresh the summary grid so planned/real rows show MANUAL status
                try {
                  await renderAll();
                } catch (e) {
                  if (LOGM) LT('switchManual: renderAll() after convert failed (non-fatal)', e);
                }

                // Repaint Overview in VIEW mode so that pills & actions update;
                // Edit button remains available to go into manual edit.
                try {
                  if (typeof window.__getModalFrame === 'function') {
                    const fr = window.__getModalFrame();
                    if (fr && fr.entity === 'timesheets') {
                      fr.mode = 'view';
                      fr._suppressDirty = true;
                      fr.setTab('overview');
                      fr._suppressDirty = false;
                      fr._updateButtons && fr._updateButtons();
                    }
                  }
                } catch (e) {
                  if (LOGM) LT('switchManual: repaint after convert failed (non-fatal)', e);
                }

              } catch (err) {
                if (LOGM) console.warn('[TS][OVERVIEW] switch to manual failed', err);
                alert(err?.message || 'Failed to switch to manual.');
              }
            });
          }
        }

        // â”€â”€ Revert to original electronic (versioned) â€” VIEW mode only â”€â”€
        if (revertElecBtn) {
          revertElecBtn.style.display =
            (mode === 'view' && canRevertElectronic) ? '' : 'none';

          if (!revertElecBtn.__tsWired) {
            revertElecBtn.__tsWired = true;
            revertElecBtn.addEventListener('click', async () => {
              const ok = window.confirm(
                'Restore the original signed electronic version of this timesheet?\n\n' +
                'Any manual overrides will be kept in history but no longer current.'
              );
              if (!ok) return;
              try {
                await revertTimesheetToElectronic(tsId);
                window.__toast && window.__toast('Original electronic timesheet restored.');
                try { byId('btnCloseModal').click(); } catch {}
                try { await renderAll(); } catch {}
              } catch (err) {
                if (LOGM) console.warn('[TS][OVERVIEW] revertTimesheetToElectronic failed', err);
                alert(err?.message || 'Failed to restore electronic timesheet.');
              }
            });
          }
        }

        // â”€â”€ Delete manual TS & reopen week for e-submission â€” VIEW mode only â”€â”€
        if (deleteReopenBtn) {
          deleteReopenBtn.style.display =
            (mode === 'view' && canDeleteManualReopen) ? '' : 'none';

          if (!deleteReopenBtn.__tsWired) {
            deleteReopenBtn.__tsWired = true;
            deleteReopenBtn.addEventListener('click', async () => {
              const ok = window.confirm(
                'Delete this manual weekly timesheet and reopen the week for electronic submission?\n\n' +
                'The manual version and its financials will be removed. The week will appear as OPEN/PLANNED again.'
              );
              if (!ok) return;
              try {
                await deleteManualTimesheetAndReopenWeek(tsId, cwId);
                window.__toast && window.__toast('Manual timesheet deleted and week reopened for electronic submission.');
                try { byId('btnCloseModal').click(); } catch {}
                try { await renderAll(); } catch {}
              } catch (err) {
                if (LOGM) console.warn('[TS][OVERVIEW] deleteManualTimesheetAndReopenWeek failed', err);
                alert(err?.message || 'Failed to delete manual timesheet and reopen week.');
              }
            });
          }
        }

        // â”€â”€ Delete permanently â€” any unlocked TS, VIEW mode only â”€â”€
        if (deletePermBtn) {
          deletePermBtn.style.display =
            (mode === 'view' && canDeletePermanent) ? '' : 'none';

          if (!deletePermBtn.__tsWired) {
            deletePermBtn.__tsWired = true;
            deletePermBtn.addEventListener('click', async () => {
              const ok = window.confirm(
                'Permanently delete this timesheet?\n\n' +
                'This will remove all versions and financial snapshots for this timesheet_id.\n' +
                'This action cannot be undone.'
              );
              if (!ok) return;
              try {
                await deleteTimesheetPermanent(tsId);
                alert('Timesheet record deleted.');
                try { byId('btnCloseModal').click(); } catch {}
                try { await renderAll(); } catch {}
              } catch (err) {
                if (LOGM) console.warn('[TS][OVERVIEW] deleteTimesheetPermanent failed', err);
                alert(err?.message || 'Failed to delete timesheet.');
              }
            });
          }
        }

        // â”€â”€ Daily QR send button (DAILY, ELECTRONIC, unlocked, VIEW mode) â”€â”€
        try {
          const dailyQrBtn = root.querySelector('button[data-ts-action="send-daily-qr"]');

          const canSendDailyQr =
            !!tsId &&
            mode === 'view' &&
            isDaily &&
            subMode === 'ELECTRONIC' &&
            !locked;

          if (dailyQrBtn) {
            dailyQrBtn.style.display = canSendDailyQr ? '' : 'none';

            if (!dailyQrBtn.__tsWired) {
              dailyQrBtn.__tsWired = true;
              dailyQrBtn.addEventListener('click', async () => {
                if (!tsId) {
                  alert('Timesheet id missing; cannot generate daily QR timesheet.');
                  return;
                }

                const ok = window.confirm(
                  'Generate a DAILY QR timesheet for this shift?\n\n' +
                  'This will switch the daily timesheet into MANUAL mode and generate a QR-coded PDF.'
                );
                if (!ok) return;

                const encId = encodeURIComponent(tsId);

                try {
                  // 1) Switch DAILY electronic â†’ MANUAL
                  {
                    const res = await authFetch(
                      API(`/api/timesheets/${encId}/switch-daily-to-manual`),
                      { method: 'POST' }
                    );
                    const txt = await res.text().catch(() => '');
                    if (!res.ok) {
                      throw new Error(txt || 'Failed to switch daily timesheet to manual.');
                    }
                  }

                  // 2) Generate DAILY QR printable
                  {
                    const res = await authFetch(
                      API(`/api/timesheets/${encId}/daily-qr-printable`),
                      {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({})
                      }
                    );
                    const txt = await res.text().catch(() => '');
                    if (!res.ok) {
                      throw new Error(txt || 'Failed to generate daily QR timesheet.');
                    }
                  }

                  window.__toast && window.__toast('Daily QR timesheet generated. Evidence is now required via QR scan.');

                  // Refresh summary and (optionally) repaint the modal
                  try { await renderAll(); } catch (e) {
                    if (LOGM) LT('[TS][OVERVIEW] renderAll() after daily QR failed (non-fatal)', e);
                  }
                  try {
                    if (typeof window.__getModalFrame === 'function') {
                      const fr = window.__getModalFrame();
                      if (fr && fr.entity === 'timesheets') {
                        fr.mode = 'view';
                        fr._suppressDirty = true;
                        fr.setTab('overview');
                        fr._suppressDirty = false;
                        fr._updateButtons && fr._updateButtons();
                      }
                    }
                  } catch (e) {
                    if (LOGM) LT('[TS][OVERVIEW] repaint after daily QR failed (non-fatal)', e);
                  }
                } catch (err) {
                  if (LOGM) console.warn('[TS][OVERVIEW] send-daily-qr failed', err);
                  alert(err?.message || 'Failed to generate daily QR timesheet.');
                }
              });
            }
          }
        } catch (e) {
          if (LOGM) LT('[TS][OVERVIEW] QR wiring failed (non-fatal)', e);
        }

        // â”€â”€ Pay-hold + mark-paid staging in edit/create (unchanged) â”€â”€
        if (mode === 'edit' || mode === 'create') {
          if (!mc.timesheetState || typeof mc.timesheetState !== 'object') {
            mc.timesheetState = {
              reference: '',
              payHoldDesired: null,
              payHoldReason: '',
              markPaid: false,
              segmentOverrides: {},
              segmentInvoiceTargets: {},
              manualHours: {},
              additionalRates: (mc.timesheetState && mc.timesheetState.additionalRates) || {},
              schedule: (mc.timesheetState && mc.timesheetState.schedule) || null
            };
          }
          const state = mc.timesheetState;

          if (payHoldInput && !payHoldInput.__tsWired) {
            payHoldInput.__tsWired = true;
            const currentOnHold = !!(tsfin && tsfin.pay_on_hold);
            if (state.payHoldDesired == null) {
              payHoldInput.checked = currentOnHold;
              state.payHoldDesired = currentOnHold;
            } else {
              payHoldInput.checked = !!state.payHoldDesired;
            }

            payHoldInput.addEventListener('change', () => {
              state.payHoldDesired = !!payHoldInput.checked;
              if (payHoldReasonInput) {
                state.payHoldReason = String(payHoldReasonInput.value || '');
              }
              if (LOGM) {
                LT('pay hold staged', {
                  tsId,
                  payHoldDesired: state.payHoldDesired,
                  payHoldReason: state.payHoldReason
                });
              }
              try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
            });
          }

          if (payHoldReasonInput && !payHoldReasonInput.__tsWired) {
            payHoldReasonInput.__tsWired = true;
            payHoldReasonInput.addEventListener('input', () => {
              if (!mc.timesheetState || typeof mc.timesheetState !== 'object') return;
              mc.timesheetState.payHoldReason = String(payHoldReasonInput.value || '');
              if (LOGM) {
                LT('pay hold reason staged', {
                  tsId,
                  payHoldReason: mc.timesheetState.payHoldReason
                });
              }
              try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
            });
          }

          if (markPaidInput && !markPaidInput.__tsWired) {
            markPaidInput.__tsWired = true;
            if (alreadyPaid) {
              markPaidInput.checked = true;
              markPaidInput.disabled = true;
            } else {
              markPaidInput.checked = !!state.markPaid;
            }
            markPaidInput.addEventListener('change', () => {
              const alreadyPaidLocal = !!(mc.timesheetDetails && mc.timesheetDetails.tsfin && mc.timesheetDetails.tsfin.paid_at_utc);
              if (alreadyPaidLocal) {
                markPaidInput.checked = true;
                markPaidInput.disabled = true;
                return;
              }
              state.markPaid = !!markPaidInput.checked;
              if (LOGM) {
                LT('mark paid staged', {
                  tsId,
                  markPaid: state.markPaid
                });
              }
              try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
            });
          }
        } else {
          if (payHoldInput)       payHoldInput.disabled       = true;
          if (payHoldReasonInput) payHoldReasonInput.disabled = true;
          if (markPaidInput)      markPaidInput.disabled      = true;
        }

        if (refInput && !refInput.__tsRefWired) {
          refInput.__tsRefWired = true;
          refInput.addEventListener('input', () => {
            const mc2 = window.modalCtx || {};
            if (!mc2.timesheetState || typeof mc2.timesheetState !== 'object') {
              mc2.timesheetState = {
                reference: '',
                payHoldDesired: null,
                payHoldReason: '',
                markPaid: false,
                segmentOverrides: {},
                segmentInvoiceTargets: {},
                manualHours: {},
                additionalRates: {}
              };
            }
            mc2.timesheetState.reference = String(refInput.value || '');
            if (LOGM) {
              LT('reference staged', {
                tsId,
                reference: mc2.timesheetState.reference
              });
            }
            try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
          });
        }
      }
    } catch (err) {
      if ((typeof window.__LOG_MODAL === 'boolean') ? window.__LOG_MODAL : false) {
        console.warn('[TS][OVERVIEW][WIRE] failed', err);
      }
    }
  }
}


 // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Timesheets: Lines tab wiring â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if (this.entity === 'timesheets' && k === 'lines') {
  const { LOGM, L: LT } = getTsLoggers('[TS][LINES][WIRE]');
  const root = byId('modalBody');
  if (!root) {
    if (LOGM) LT('no modalBody root, skip wiring');
  } else {
    try {
      const mc = window.modalCtx || {};
      if (!mc.timesheetState || typeof mc.timesheetState !== 'object') {
        mc.timesheetState = {
          reference: null,
          payHoldDesired: null,
          payHoldReason: '',
          markPaid: false,
          segmentOverrides: {},
          segmentInvoiceTargets: {},
          manualHours: {},
          additionalRates: {},
          schedule: null
        };
      }
      const state = mc.timesheetState;

      // â”€â”€ Seed schedule from existing TS or contract_week if not already set â”€â”€
      try {
        const det = mc.timesheetDetails || {};
        const ts  = det.timesheet || {};

        if (!state.schedule) {
          if (ts.actual_schedule_json) {
            if (Array.isArray(ts.actual_schedule_json) || typeof ts.actual_schedule_json === 'object') {
              state.schedule = JSON.parse(JSON.stringify(ts.actual_schedule_json));
            } else if (typeof ts.actual_schedule_json === 'string') {
              try {
                const parsed = JSON.parse(ts.actual_schedule_json);
                if (Array.isArray(parsed) || typeof parsed === 'object') {
                  state.schedule = parsed;
                }
              } catch {}
            }
          } else if (det.contract_week && det.contract_week.std_schedule_json) {
            const std = det.contract_week.std_schedule_json;
            if (Array.isArray(std) || typeof std === 'object') {
              state.schedule = JSON.parse(JSON.stringify(std));
            } else if (typeof std === 'string') {
              try {
                const parsedStd = JSON.parse(std);
                if (Array.isArray(parsedStd) || typeof parsedStd === 'object') {
                  state.schedule = parsedStd;
                }
              } catch {}
            }
          }
        }

        // NEW: derive extraBreakCount from the schedule's breaks[] arrays
        if (Array.isArray(state.schedule)) {
          let maxExtra = 0;
          state.schedule.forEach(entry => {
            if (entry && Array.isArray(entry.breaks) && entry.breaks.length > 1) {
              const extra = entry.breaks.length - 1; // everything beyond the primary break
              if (extra > maxExtra) maxExtra = extra;
            }
          });
          state.extraBreakCount = maxExtra;
        } else if (state.extraBreakCount == null) {
          state.extraBreakCount = 0;
        }
      } catch (e) {
        if (LOGM) LT('schedule seed in setTab(lines) failed (non-fatal)', e);
      }

      // NEW: wiring per-day reference ("Ref #") inputs
      try {
        if (!state.dayReferences || typeof state.dayReferences !== 'object') {
          state.dayReferences = {};
        }
        const refInputs = root.querySelectorAll('input[data-day-ref]');
        if (LOGM) LT('wiring day-ref inputs', { count: refInputs.length });

        refInputs.forEach(inp => {
          if (inp.__tsDayRefWired) return;
          inp.__tsDayRefWired = true;

          inp.addEventListener('input', () => {
            const ymd = inp.dataset.dayRef || '';
            if (!ymd) return;
            if (!state.dayReferences || typeof state.dayReferences !== 'object') {
              state.dayReferences = {};
            }
            const val = String(inp.value || '').trim();
            state.dayReferences[ymd] = val || null;

            try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
          });
        });
      } catch (e) {
        if (LOGM) LT('day-ref wiring failed (non-fatal)', e);
      }

      // Segments exclude_from_pay
      const checkboxes = root.querySelectorAll('input[name="seg_exclude_from_pay"][data-segment-id]');

      if (LOGM) LT('wiring checkboxes', { count: checkboxes.length });
      checkboxes.forEach(cb => {
        if (cb.__tsWired) return;
        cb.__tsWired = true;
        cb.addEventListener('change', () => {
          const segId = cb.getAttribute('data-segment-id') || '';
          if (!segId) return;
          const originalSeg = (mc.timesheetDetails && Array.isArray(mc.timesheetDetails.segments))
            ? mc.timesheetDetails.segments.find(s => String(s.segment_id) === segId)
            : null;
          const origVal = originalSeg ? !!originalSeg.exclude_from_pay : false;
          const newVal  = !!cb.checked;

          if (!state.segmentOverrides || typeof state.segmentOverrides !== 'object') {
            state.segmentOverrides = {};
          }

          if (newVal === origVal) {
            if (state.segmentOverrides[segId]) {
              delete state.segmentOverrides[segId];
            }
          } else {
            state.segmentOverrides[segId] = { exclude_from_pay: newVal };
          }

          if (LOGM) {
            LT('segment override changed', {
              segId,
              origExclude: origVal,
              newExclude: newVal,
              overridesKeys: Object.keys(state.segmentOverrides || {})
            });
          }

          try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
        });
      });

      // Invoice week / Pause selects (per segment)
      const weekSelects = root.querySelectorAll('select[name="seg_invoice_week"][data-segment-id]');
      if (LOGM) LT('wiring invoice-week selects', { count: weekSelects.length });
      weekSelects.forEach(sel => {
        if (sel.__tsWeekWired) return;
        sel.__tsWeekWired = true;

        const segId = sel.getAttribute('data-segment-id') || '';
        if (!segId) return;

        if (state.segmentInvoiceTargets && typeof state.segmentInvoiceTargets === 'object') {
          const staged = state.segmentInvoiceTargets[segId];
          if (staged) sel.value = staged;
        }

        sel.addEventListener('change', () => {
          if (!state.segmentInvoiceTargets || typeof state.segmentInvoiceTargets !== 'object') {
            state.segmentInvoiceTargets = {};
          }
          const newVal = (sel.value || '').trim();
          state.segmentInvoiceTargets[segId] = newVal;

          if (LOGM) {
            LT('invoice week staged', {
              segId,
              week_start: newVal,
              keys: Object.keys(state.segmentInvoiceTargets || {})
            });
          }

          try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
        });
      });

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Weekly schedule grid (Start/End/Break) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const schedTable = root.querySelector('#tsWeeklySchedule');
      if (schedTable && !schedTable.__tsSchedWired) {
        schedTable.__tsSchedWired = true;

        const normaliseHHMM = (raw) => {
          let s = String(raw || '').trim();
          if (!s) return '';
          if (/^\d{1,2}:\d{2}$/.test(s)) {
            const [h, m] = s.split(':');
            const hh = String(Number(h) || 0).padStart(2, '0');
            const mm = String(Number(m) || 0).padStart(2, '0');
            return `${hh}:${mm}`;
          }
          s = s.replace(':', '');
          if (!/^\d{1,4}$/.test(s)) return '';
          if (s.length <= 2) {
            const h = Number(s);
            if (!Number.isFinite(h)) return '';
            return `${String(h).padStart(2, '0')}:00`;
          }
          const mm = s.slice(-2);
          const h  = s.slice(0, -2);
          const hh = String(Number(h) || 0).padStart(2, '0');
          const mm2 = String(Number(mm) || 0).padStart(2, '0');
          return `${hh}:${mm2}`;
        };

        const hhmmToMinutes = (hhmm) => {
          if (!hhmm || typeof hhmm !== 'string') return null;
          const m = hhmm.trim();
          const parts = m.split(':');
          if (parts.length !== 2) return null;
          const h = Number(parts[0]);
          const mm = Number(parts[1]);
          if (!Number.isFinite(h) || !Number.isFinite(mm)) return null;
          return h * 60 + mm;
        };

        const updateScheduleFromRow = (tr) => {
          if (!tr) return;
          const date = tr.getAttribute('data-date') || null;
          if (!date) return;

          const inputs = tr.querySelectorAll('input[data-sched-field]');
          const fields = {};
          inputs.forEach(inp => {
            const field = inp.getAttribute('data-sched-field') || '';
            fields[field] = String(inp.value || '').trim();
          });

          const startStrRaw      = fields.start || '';
          const endStrRaw        = fields.end || '';
          const breakStartRaw    = fields.break_start || '';
          const breakEndRaw      = fields.break_end || '';
          let   breakMinsStr     = fields.break_mins || '';

          const startStr      = normaliseHHMM(startStrRaw);
          const endStr        = normaliseHHMM(endStrRaw);
          const breakStartStr = normaliseHHMM(breakStartRaw);
          const breakEndStr   = normaliseHHMM(breakEndRaw);

          const startInp      = tr.querySelector('input[data-sched-field="start"]');
          const endInp        = tr.querySelector('input[data-sched-field="end"]');
          const breakStartInp = tr.querySelector('input[data-sched-field="break_start"]');
          const breakEndInp   = tr.querySelector('input[data-sched-field="break_end"]');
          const breakMinsInp  = tr.querySelector('input[data-sched-field="break_mins"]');

          if (startInp)      startInp.value      = startStr;
          if (endInp)        endInp.value        = endStr;
          if (breakStartInp) breakStartInp.value = breakStartStr;
          if (breakEndInp)   breakEndInp.value   = breakEndStr;

          // Collect extra break windows (if any)
          const extraStarts = tr.querySelectorAll('input[data-extra-break="start"]');
          const extraEnds   = tr.querySelectorAll('input[data-extra-break="end"]');
          const extraMap = {};

          extraStarts.forEach(inp => {
            const idx = Number(inp.getAttribute('data-extra-index') || '0');
            const raw = String(inp.value || '').trim();
            const norm = normaliseHHMM(raw);
            inp.value = norm;
            if (!extraMap[idx]) extraMap[idx] = {};
            extraMap[idx].start = norm;
          });

          extraEnds.forEach(inp => {
            const idx = Number(inp.getAttribute('data-extra-index') || '0');
            const raw = String(inp.value || '').trim();
            const norm = normaliseHHMM(raw);
            inp.value = norm;
            if (!extraMap[idx]) extraMap[idx] = {};
            extraMap[idx].end = norm;
          });

          const sMin = hhmmToMinutes(startStr);
          const eMin = hhmmToMinutes(endStr);

          let shiftMinutes = null;
          if (sMin != null && eMin != null) {
            shiftMinutes = eMin - sMin;
            if (shiftMinutes < 0) shiftMinutes += 24 * 60; // overnight
          }

          // Build list of break windows: primary (index -1) + extras (0..N)
          const breakWindows = [];

          if (breakStartStr || breakEndStr) {
            breakWindows.push({
              start: breakStartStr,
              end:   breakEndStr
            });
          }

          Object.keys(extraMap)
            .map(k => Number(k))
            .sort((a, b) => a - b)
            .forEach(idx => {
              const b = extraMap[idx] || {};
              if (b.start || b.end) {
                breakWindows.push({
                  start: b.start || '',
                  end:   b.end   || ''
                });
              }
            });

          // Compute break minutes from any complete windows; otherwise use floating Break (mins)
          let breakMinutes       = 0;
          let hasFullBreakWindow = false;
          let hasAnyBreakTimes   = false;

          for (const bw of breakWindows) {
            const bs = bw.start ? hhmmToMinutes(bw.start) : null;
            const be = bw.end   ? hhmmToMinutes(bw.end)   : null;
            if (bw.start || bw.end) {
              hasAnyBreakTimes = true;
            }
            if (bs != null && be != null) {
              let diff = be - bs;
              if (diff < 0) diff += 24 * 60;
              breakMinutes += Math.max(0, diff);
              hasFullBreakWindow = true;
            }
          }

          if (hasFullBreakWindow) {
            // Any complete break times: break_minutes is authoritative; lock numeric field
            breakMinsStr = String(breakMinutes);
            if (breakMinsInp) {
              breakMinsInp.value = breakMinsStr;
              breakMinsInp.disabled = true;
            }
          } else if (!hasAnyBreakTimes) {
            // No break times at all â†’ floating break from numeric field
            if (breakMinsInp) breakMinsInp.disabled = false;
            const bNum = Number(breakMinsStr || 0);
            breakMinutes = Number.isFinite(bNum) && bNum > 0 ? bNum : 0;
          } else {
            // Some partial times but no complete windows: treat as 0 break; keep Break (mins) editable
            breakMinutes = 0;
            if (breakMinsInp) breakMinsInp.disabled = false;
          }

          let paidHoursText = '';
          if (shiftMinutes != null) {
            const paidMin = Math.max(0, shiftMinutes - breakMinutes);
            if (paidMin > 0) {
              paidHoursText = (Math.round((paidMin / 60) * 100) / 100).toFixed(2);
            } else {
              paidHoursText = '0.00';
            }
          }

          const paidEl = tr.querySelector('.sched-paid-hours');
          if (paidEl) paidEl.textContent = paidHoursText;

          // Update schedule array
          let sched = state.schedule;
          if (!Array.isArray(sched)) sched = [];
          let entry = sched.find(s => s && s.date === date);
          if (!entry) {
            entry = { date };
            sched.push(entry);
          }

          entry.start       = startStr || null;
          entry.end         = endStr   || null;
          entry.break_start = breakStartStr || null;
          entry.break_end   = breakEndStr   || null;
          entry.break_mins  = breakMinutes || 0;
          // Backend resolver expects break_minutes; keep both for compatibility
          entry.break_minutes = breakMinutes || 0;

          // Persist full list of break windows (primary + extras)
          const entryBreaks = [];
          for (const bw of breakWindows) {
            if (bw.start || bw.end) {
              entryBreaks.push({
                start: bw.start || null,
                end:   bw.end   || null
              });
            }
          }
          entry.breaks = entryBreaks;

          state.schedule = sched;

          try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
        };

        // Wire change/blur on schedule fields
        schedTable.addEventListener('change', (ev) => {
          const inp = ev.target.closest('input[data-sched-field]');
          if (!inp) return;
          const tr = inp.closest('tr[data-row-idx]');
          updateScheduleFromRow(tr);
        });

        schedTable.addEventListener('blur', (ev) => {
          const inp = ev.target.closest('input[data-sched-field]');
          if (!inp) return;
          const tr = inp.closest('tr[data-row-idx]');
          updateScheduleFromRow(tr);
        }, true);

              // Reset schedule + Extra Breaks + / - buttons
        root.addEventListener('click', (ev) => {
          const btn = ev.target.closest('button[data-ts-action]');
          if (!btn) return;

          const action = btn.getAttribute('data-ts-action');

          // Reset schedule
          if (action === 'reset-schedule') {
            state.schedule = [];
            const rows = schedTable.querySelectorAll('tbody tr[data-row-idx]');
            rows.forEach(tr => {
              const inputs = tr.querySelectorAll('input[data-sched-field]');
              inputs.forEach(inp => {
                inp.value = '';
                if (inp.name === 'sched_break_mins') inp.disabled = false;
              });

              // Clear any extra break inputs as well
              const extraInputs = tr.querySelectorAll('input[data-extra-break]');
              extraInputs.forEach(inp => { inp.value = ''; inp.remove(); });

              const paidEl = tr.querySelector('.sched-paid-hours');
              if (paidEl) paidEl.textContent = '';
            });
            state.extraBreakCount = 0;
            try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
            return;
          }

          // Add an extra break line for all rows
          if (action === 'extra-break-add') {
            const current = Number(state.extraBreakCount || 0);
            const newIndex = current;
            state.extraBreakCount = current + 1;

            const rows = schedTable.querySelectorAll('tbody tr[data-row-idx]');
            rows.forEach(tr => {
              const date = tr.getAttribute('data-date') || '';

              const startCell = tr.querySelector('input[name="sched_break_start"]')?.parentElement;
              const endCell   = tr.querySelector('input[name="sched_break_end"]')?.parentElement;
              if (!startCell || !endCell) return;

              let startBox = startCell.querySelector('.extra-breaks');
              if (!startBox) {
                startBox = document.createElement('div');
                startBox.className = 'extra-breaks';
                startCell.appendChild(startBox);
              }

              let endBox = endCell.querySelector('.extra-breaks');
              if (!endBox) {
                endBox = document.createElement('div');
                endBox.className = 'extra-breaks';
                endCell.appendChild(endBox);
              }

              const startExtra = document.createElement('input');
              startExtra.type = 'text';
              startExtra.className = 'input mini';
              startExtra.name = `sched_break_start_extra_${newIndex}`;
              startExtra.setAttribute('data-extra-break', 'start');
              startExtra.setAttribute('data-extra-index', String(newIndex));
              if (date) startExtra.setAttribute('data-date', date);
              startBox.appendChild(startExtra);

              const endExtra = document.createElement('input');
              endExtra.type = 'text';
              endExtra.className = 'input mini';
              endExtra.name = `sched_break_end_extra_${newIndex}`;
              endExtra.setAttribute('data-extra-break', 'end');
              endExtra.setAttribute('data-extra-index', String(newIndex));
              if (date) endExtra.setAttribute('data-date', date);
              endBox.appendChild(endExtra);
            });

            try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
            return;
          }

          // Remove the right-most extra break line (without touching the primary break fields)
          if (action === 'extra-break-remove') {
            let current = Number(state.extraBreakCount || 0);
            if (!Number.isFinite(current) || current <= 0) {
              // No extra break lines â†’ nothing to remove (primary stays)
              return;
            }
            const removeIndex = current - 1;

            const rows = schedTable.querySelectorAll('tbody tr[data-row-idx]');
            rows.forEach(tr => {
              const startExtra = tr.querySelector(
                `input[data-extra-break="start"][data-extra-index="${removeIndex}"]`
              );
              const endExtra = tr.querySelector(
                `input[data-extra-break="end"][data-extra-index="${removeIndex}"]`
              );

              if (startExtra) {
                startExtra.value = '';
                startExtra.remove();
              }
              if (endExtra) {
                endExtra.value = '';
                endExtra.remove();
              }

              // Recalculate schedule for this row after removing the window
              updateScheduleFromRow(tr);
            });

            state.extraBreakCount = removeIndex;
            try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
            return;
          }
        });

      }

      // Manual weekly hours inputs (legacy support)
      const hoursInputs = root.querySelectorAll('input[name^="manual_hours_"]');
      if (LOGM) LT('wiring manual hours inputs', { count: hoursInputs.length });
      hoursInputs.forEach(input => {
        if (input.__tsHoursWired) return;
        input.__tsHoursWired = true;
        const name = String(input.name || '');
        const key  = name.replace(/^manual_hours_/i, '').toLowerCase();
        input.addEventListener('input', () => {
          const raw   = input.value;
          const val   = raw === '' ? '' : Number(raw);
          const safe  = (raw === '' || !Number.isFinite(val)) ? '' : val;
          state.manualHours = state.manualHours || {};
          state.manualHours[key] = safe;
          if (LOGM) {
            LT('manual hours staged', {
              key,
              value: safe
            });
          }
          try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
        });
      });

      // Additional Rates: weekly extras inputs
      const extraInputs = root.querySelectorAll('input[name^="extra_units_"]');
      if (LOGM) LT('wiring additional rates inputs', { count: extraInputs.length });
      extraInputs.forEach(input => {
        if (input.__tsExtraWired) return;
        input.__tsExtraWired = true;

        const name      = String(input.name || '');
        const codeName  = name.replace(/^extra_units_/i, '').toUpperCase();
        const codeAttr  = (input.getAttribute('data-extra-code') || '').toUpperCase();
        const code      = codeAttr || codeName;
        if (!code) return;

        if (!state.additionalRates || typeof state.additionalRates !== 'object') {
          state.additionalRates = {};
        }

        if (state.additionalRates[code] && typeof state.additionalRates[code].units_week === 'number') {
          input.value = String(state.additionalRates[code].units_week);
        }

        input.addEventListener('input', () => {
          const raw   = input.value;
          const units = raw === '' ? 0 : Number(raw);
          const unitsNum = Number.isFinite(units) ? units : 0;

          const prev = state.additionalRates[code] || { code };
          state.additionalRates[code] = {
            ...prev,
            code,
            units_week: unitsNum
          };

          if (LOGM) {
            LT('additional rate staged', {
              code,
              units_week: unitsNum
            });
          }

          try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
        });
      });

    } catch (err) {
      if ((typeof window.__LOG_MODAL === 'boolean') ? window.__LOG_MODAL : false) {
        console.warn('[TS][LINES][WIRE] failed', err);
      }
    }
  }
}

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Timesheets: Evidence tab (open PDF + drag/drop) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Timesheets: Evidence tab (open PDF + drag/drop + remove) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (this.entity === 'timesheets' && k === 'evidence') {
    const { LOGM, L: LT } = getTsLoggers('[TS][EVIDENCE][WIRE]');
    const root = byId('modalBody');
    if (!root) {
      if (LOGM) LT('no modalBody root, skip wiring');
    } else {
      try {
        const btn = root.querySelector('button[data-ts-action="open-pdf"][data-timesheet-id]');
        if (btn && !btn.__tsPdfWired) {
          btn.__tsPdfWired = true;
          const tsId = btn.getAttribute('data-timesheet-id') || '';
          if (LOGM) LT('wire open-pdf button', { tsId });
          btn.addEventListener('click', async () => {
            try {
              await openTimesheetPdf(tsId);
            } catch (err) {
              if (LOGM) console.warn('[TS][EVIDENCE] openTimesheetPdf failed', err);
              alert(err?.message || 'Failed to open timesheet PDF.');
            }
          });
        } else if (LOGM && !btn) {
          LT('no open-pdf button found in Evidence tab');
        }

        const dz = root.querySelector('[data-ts-drop-zone="evidence"]');
        if (dz && !dz.__tsDropWired) {
          dz.__tsDropWired = true;

          const prevent = (ev) => {
            ev.preventDefault();
            ev.stopPropagation();
          };

          const onDragOver = (ev) => {
            prevent(ev);
            dz.classList && dz.classList.add('ts-drop-hover');
          };

          const onDragLeave = (ev) => {
            prevent(ev);
            dz.classList && dz.classList.remove('ts-drop-hover');
          };

          const onDrop = async (ev) => {
            prevent(ev);
            dz.classList && dz.classList.remove('ts-drop-hover');

            const files = (ev.dataTransfer && ev.dataTransfer.files)
              ? Array.from(ev.dataTransfer.files)
              : [];
            const file = files[0] || null;
            if (!file) return;

            const type = String(file.type || '').toLowerCase();
            if (!type.startsWith('image/') && type !== 'application/pdf') {
              alert('Please drop a PDF or image file.');
              return;
            }

            const mc = window.modalCtx || {};
            const tsId = mc.data?.timesheet_id || mc.data?.id || null;
            if (!tsId) {
              alert('Timesheet context missing; cannot replace evidence.');
              return;
            }

            const tsfin = mc.timesheetDetails && mc.timesheetDetails.tsfin ? mc.timesheetDetails.tsfin : {};
            const locked = !!(tsfin.locked_by_invoice_id || tsfin.paid_at_utc);
            if (locked) {
              alert('This timesheet is locked (paid or invoiced); evidence cannot be replaced.');
              return;
            }

            try {
              await openTimesheetEvidenceReplaceDialog(file);
            } catch (err) {
              if (LOGM) console.warn('[TS][EVIDENCE][DROP] replace dialog failed', err);
              alert(err?.message || 'Failed to process dropped file.');
            }
          };

          dz.addEventListener('dragenter', onDragOver);
          dz.addEventListener('dragover', onDragOver);
          dz.addEventListener('dragleave', onDragLeave);
          dz.addEventListener('drop', onDrop);

          if (LOGM) LT('drag/drop wired on evidence drop zone');
        } else if (LOGM && !dz) {
          LT('no evidence drop zone found (data-ts-drop-zone="evidence")');
        }

        // NEW: wire evidence Remove buttons (multi-evidence list)
        const removeBtns = root.querySelectorAll('button[data-evidence-remove]');
        if (LOGM) LT('wiring evidence remove buttons', { count: removeBtns.length });
        removeBtns.forEach(btn => {
          if (btn.__tsEvRemoveWired) return;
          btn.__tsEvRemoveWired = true;
          btn.addEventListener('click', async (ev) => {
            ev.preventDefault();
            try {
              // Uses the global handler we defined earlier
              await handleTimesheetEvidenceRemoveClick(ev);
            } catch (err) {
              if (LOGM) console.warn('[TS][EVIDENCE] remove evidence failed', err);
              alert(err?.message || 'Failed to remove evidence item.');
            }
          });
        });

      } catch (err) {
        if ((typeof window.__LOG_MODAL === 'boolean') ? window.__LOG_MODAL : false) {
          console.warn('[TS][EVIDENCE][WIRE] failed', err);
        }
      }
    }
  }

    // Finalise setTab
  this.currentTabKey = k;
  this._attachDirtyTracker();

  const isChild = (stack().length > 1);

  // Utility modals (resolve/import summaries) should keep inner buttons active
  const isUtilityKindForThis =
    this.kind === 'timesheets-resolve' ||
    this.kind === 'resolve-candidate'  ||
    this.kind === 'resolve-client'     ||
    (typeof this.kind === 'string' && this.kind.startsWith('import-summary-'));

  if (this.noParentGate) {
    const ro = isUtilityKindForThis
      ? false
      : (this.mode === 'view' || this.mode === 'saving');
    setFormReadOnly(byId('modalBody'), ro);
  } else if (isChild) {
    const p = parentFrame();
    setFormReadOnly(byId('modalBody'), !(p && (p.mode === 'edit' || p.mode === 'create')));
  } else {
    setFormReadOnly(byId('modalBody'), (this.mode === 'view' || this.mode === 'saving'));
  }


  try {
    const pc = document.getElementById('btnPickCandidate');
    const pl = document.getElementById('btnPickClient');
    L('setTab EXIT snapshot', {
      currentTabKey: this.currentTabKey,
      pickButtons: {
        btnPickCandidate: { exists: !!pc, disabled: !!(pc && pc.disabled) },
        btnPickClient:    { exists: !!pl, disabled: !!(pl && pl.disabled) }
      }
    });
  } catch {}

  try {
    if (this.entity === 'contracts' && k === 'main') {
      window.dispatchEvent(new Event('contracts-main-rendered'));
    }
  } catch {}

  this._hasMountedOnce = true;
  this._suppressDirty  = false;
  this.isDirty         = prevDirty;

  if (typeof this._updateButtons === 'function') this._updateButtons();

  GE();
}




};
function setFrameMode(frameObj, mode) {
  L('setFrameMode ENTER', {
    prevMode: frameObj.mode,
    nextMode: mode,
    isChild: (stack().length > 1),
    noParentGate: frameObj.noParentGate
  });

  const prev    = frameObj.mode;
  frameObj.mode = mode;

  const isChild = (stack().length > 1);
  const isTop   = (currentFrame && currentFrame() === frameObj);

  // â–¶ Special case: planned timesheet week (no timesheet_id yet, but has a contract_week)
  // We want to allow "view without id" here, so do NOT auto-convert to create/edit.
  let isPlannedTimesheetStub = false;
  try {
    if (frameObj.entity === 'timesheets' && !frameObj.hasId) {
      // Prefer the frame's own ctxRef, then fall back to global modalCtx
      const ctx = frameObj._ctxRef || window.modalCtx || {};
      const d   = ctx.data || {};
      const hasWeek = !!(d.contract_week_id || d.week_id || d.week_ending_date);
      const hasTsId = !!d.timesheet_id;
      if (hasWeek && !hasTsId) {
        isPlannedTimesheetStub = true;
      }
    }
  } catch (e) {
    // Non-fatal; treat as normal frame if detection fails
    isPlannedTimesheetStub = false;
  }

 // â–¶ correct accidental 'view' on brand-new frames (e.g., successor create)
//    but DO NOT do this for planned timesheet weeks or utility modals where we *want* view+no id.
const isUtilityKind =
  frameObj.kind === 'timesheets-resolve' ||
  frameObj.kind === 'resolve-candidate'  ||
  frameObj.kind === 'resolve-client'     ||
  (typeof frameObj.kind === 'string' && frameObj.kind.startsWith('import-summary-'));

if (!frameObj.hasId && mode === 'view' && !isPlannedTimesheetStub && !isUtilityKind) {
  mode = frameObj.forceEdit ? 'edit' : 'create';
  frameObj.mode = mode;
}


   // â–¶ Only toggle read-only on the DOM that actually belongs to the top frame.
  //    When updating a non-top frame (e.g., the parent while a picker is open),
  //    do not flip the global #modalBody to avoid UI flicker/regressions.
  if (isTop) {
    const isUtilityKindForFrame =
      frameObj.kind === 'timesheets-resolve' ||
      frameObj.kind === 'resolve-candidate'  ||
      frameObj.kind === 'resolve-client'     ||
      (typeof frameObj.kind === 'string' && frameObj.kind.startsWith('import-summary-'));

    if (!isChild && (mode === 'create' || mode === 'edit')) {
      setFormReadOnly(byId('modalBody'), false);
    } else if (frameObj.noParentGate) {
      const ro = isUtilityKindForFrame
        ? false
        : (mode === 'view' || mode === 'saving');
      setFormReadOnly(byId('modalBody'), ro);
    } else if (isChild) {
      const p = parentFrame();
      setFormReadOnly(byId('modalBody'), !(p && (p.mode === 'edit' || p.mode === 'create')));
    } else {
      setFormReadOnly(byId('modalBody'), (mode === 'view' || mode === 'saving'));
    }
  } else {
    L('setFrameMode (non-top): skipped read-only toggle to avoid affecting current child');
  }


  if (typeof frameObj._updateButtons === 'function') frameObj._updateButtons();

  try {
    const idx = stack().indexOf(frameObj);
    window.dispatchEvent(new CustomEvent('modal-frame-mode-changed', {
      detail: { frameIndex: idx, mode }
    }));
  } catch {}

  const repaint = !!(frameObj._hasMountedOnce && frameObj.currentTabKey);
  L('setFrameMode', {
    prevMode: prev,
    nextMode: mode,
    _hasMountedOnce: frameObj._hasMountedOnce,
    willRepaint: repaint,
    isPlannedTimesheetStub
  });

  try {
    const pc = document.getElementById('btnPickCandidate');
    const pl = document.getElementById('btnPickClient');
    L('setFrameMode picker snapshot', {
      pickCandidate: { exists: !!pc, disabled: !!(pc && pc.disabled) },
      pickClient:    { exists: !!pl, disabled: !!(pl && pl.disabled) }
    });
  } catch {}

  updateCalendarInteractivity(mode === 'edit' || mode === 'create');

  if (repaint) {
    // Just repaint the current tab; do NOT call onReturn here
    Promise
      .resolve(frameObj.setTab(frameObj.currentTabKey))
      .catch(() => {});
  }
}

const parentOnOpen = currentFrame();
frame._parentModeOnOpen = parentOnOpen ? parentOnOpen.mode : null;

stack().push(frame);
byId('modalBack').style.display='flex';


function renderTop() {
  const LOG = (typeof window.__LOG_MODAL === 'boolean') ? window.__LOG_MODAL : true;
  const L  = (...a)=> { if (LOG) console.log('[MODAL]', ...a); };
  const GC = (label)=> { if (LOG) console.groupCollapsed('[MODAL]', label); };
  const GE = ()=> { if (LOG) console.groupEnd(); };

  GC('renderTop()');

  const hintEl = document.getElementById('modalHint');
  if (hintEl) {
    hintEl.textContent = '';
    hintEl.removeAttribute('data-tone');
    try { hintEl.classList.remove('ok','warn','err'); } catch {}
  }

  const isChild = (stack().length > 1);
  const top     = currentFrame();
  const parent  = parentFrame();

  // restore the parent/owner context for whatever frame is now on top
  if (top && top._ctxRef) window.modalCtx = top._ctxRef;

  if (typeof top._detachGlobal === 'function') { try { top._detachGlobal(); } catch {} top._wired = false; }

  L('renderTop state (global)', { entity: top?.entity, kind: top?.kind, mode: top?.mode, hasId: top?.hasId, currentTabKey: top?.currentTabKey });
  byId('modalTitle').textContent = top.title;

  const tabsEl = byId('modalTabs'); tabsEl.innerHTML='';
  (top.tabs||[]).forEach((t,i)=>{
    const b=document.createElement('button'); b.textContent = t.label||t.title||t.key;
    if (i===0 && !top.currentTabKey) top.currentTabKey = t.key;
    if (t.key===top.currentTabKey || (i===0 && !top.currentTabKey)) b.classList.add('active');
    b.onclick = ()=>{ if (top.mode==='saving') return; tabsEl.querySelectorAll('button').forEach(x=>x.classList.remove('active')); b.classList.add('active'); top.setTab(t.key); };
    tabsEl.appendChild(b);
  });
  L('renderTop tabs (global)', { count: (top.tabs||[]).length, active: top.currentTabKey });

  if (top.currentTabKey) top.setTab(top.currentTabKey);
  else if (top.tabs && top.tabs[0]) top.setTab(top.tabs[0].key);
  else byId('modalBody').innerHTML = top.renderTab('form',{})||'';

  const btnSave  = byId('btnSave');
  const btnClose = byId('btnCloseModal');
  const btnDel   = byId('btnDelete');
  const header   = byId('modalDrag');
  const modalNode= byId('modal');

   const LOGC = (typeof window.__LOG_CONTRACTS === 'boolean') ? window.__LOG_CONTRACTS : true;
   if (modalNode) {
    const parentIsContracts =
      !!(parent && ((parent.entity === 'contracts') || (parent.kind === 'contracts')));
    const isContracts =
      (top.entity === 'contracts') ||
      (top.kind === 'contracts')  ||
      parentIsContracts;

    // Import summary utility panels must not be styled as "contract" modals,
    // even if opened from Contracts.
    const isImportSummary =
      typeof top.kind === 'string' && top.kind.startsWith('import-summary-');

    modalNode.classList.toggle('contract-modal', !!(isContracts && !isImportSummary));
    if (LOGC && isContracts && !isImportSummary) {
      console.log('[CONTRACTS][MODAL] contract-modal class applied to #modal (inherited:', parentIsContracts, ')');
    }

    // Job Titles: apply narrower modal sizing
    const isJobTitles = (top.kind === 'job-titles');
    modalNode.classList.toggle('jobtitles-modal', !!isJobTitles);

    // Evidence replace: temporarily use a larger modal footprint
    const isEvidenceReplace = (top.kind === 'timesheet-evidence-replace');
    modalNode.classList.toggle('evidence-modal', !!isEvidenceReplace);

    // Candidate Advances: use a slightly wider modal footprint
    const isAdvances = (top.kind === 'candidate-advances');
    modalNode.classList.toggle('advances-modal', !!isAdvances);
  }




  if (modalNode) {
    const anchor = (window.__modalAnchor || null);
    if (!anchor) {
      const R = modalNode.getBoundingClientRect();
      window.__modalAnchor = { left: R.left, top: R.top };
      modalNode.style.position = 'fixed';
      modalNode.style.left = R.left + 'px';
      modalNode.style.top  = R.top  + 'px';
      modalNode.style.right = 'auto';
      modalNode.style.bottom= 'auto';
      modalNode.style.transform = 'none';
      L('renderTop: anchored modal (global/new)', window.__modalAnchor);
    } else {
      modalNode.style.position = 'fixed';
      modalNode.style.left = window.__modalAnchor.left + 'px';
      modalNode.style.top  = window.__modalAnchor.top  + 'px';
      modalNode.style.right = 'auto';
      modalNode.style.bottom= 'auto';
      modalNode.style.transform = 'none';
      L('renderTop: anchored modal (global/reuse)', window.__modalAnchor);
    }
  }

  const showChildDelete = isChild && (top.kind==='client-rate' || top.kind==='candidate-override') && top.hasId;
  btnDel.style.display = showChildDelete ? '' : 'none'; btnDel.onclick = null;

  let btnEdit = byId('btnEditModal');
  if (!btnEdit) {
    btnEdit=document.createElement('button');
    btnEdit.id='btnEditModal'; btnEdit.type='button'; btnEdit.className='btn btn-outline btn-sm'; btnEdit.textContent='Edit';
    const bar = btnSave?.parentElement || btnClose?.parentElement; if (bar) bar.insertBefore(btnEdit, btnSave);
    L('renderTop (global): created btnEdit');
  }

  (function dragWire() {
    if (!header || !modalNode) return;

    const onDown = (e) => {
      if ((e.button !== 0 && e.type === 'mousedown') || e.target.closest('button')) return;

      const R = modalNode.getBoundingClientRect();
      modalNode.style.position = 'fixed';
      modalNode.style.left     = R.left + 'px';
      modalNode.style.top      = R.top  + 'px';
      modalNode.style.right    = 'auto';
      modalNode.style.bottom   = 'auto';
      modalNode.style.transform= 'none';
      modalNode.classList.add('dragging');

      const ox = e.clientX - R.left;
      const oy = e.clientY - R.top;

      // Measure header relative to the modal so we can keep it mostly visible
      const headerRect    = header.getBoundingClientRect();
      const headerOffsetY = headerRect.top - R.top;   // distance from modal top to header top
      const headerHeight  = headerRect.height || 0;

      document.onmousemove = (ev) => {
        let l = ev.clientX - ox;
        let t = ev.clientY - oy;

        const vw = window.innerWidth;
        const vh = window.innerHeight;

        // Horizontal: allow up to ~80% off-screen, keep ~20% visible
        const minLeft = -R.width * 0.8;         // up to ~80% off the left
        const maxLeft = vw - R.width * 0.2;     // leave ~20% visible on the right

        // Vertical (critical bit):
        // Ensure the header top never goes above -20% of its height.
        // i.e. at least 80% of the header remains visible.
        // headerTopInViewport = t + headerOffsetY
        const minTop = -headerOffsetY - headerHeight * 0.2;

        // Bottom clamp: keep the whole modal roughly within the viewport height
        const maxTop = vh - R.height;

        if (l < minLeft) l = minLeft;
        if (l > maxLeft) l = maxLeft;
        if (t < minTop)  t = minTop;
        if (t > maxTop)  t = maxTop;

        modalNode.style.left = l + 'px';
        modalNode.style.top  = t + 'px';
      };

      document.onmouseup = () => {
        modalNode.classList.remove('dragging');
        const R2 = modalNode.getBoundingClientRect();
        window.__modalAnchor = { left: R2.left, top: R2.top };
        document.onmousemove = null;
        document.onmouseup   = null;
        L('dragWire (global): saved new anchor', window.__modalAnchor);
      };

      e.preventDefault();
    };

    const onDbl = (e) => {
      if (!e.target.closest('button')) sanitizeModalGeometry();
    };

    header.addEventListener('mousedown', onDown);
    header.addEventListener('dblclick',  onDbl);

    const prev = top._detachGlobal;
    top._detachGlobal = () => {
      try { header.removeEventListener('mousedown', onDown); } catch {}
      try { header.removeEventListener('dblclick',  onDbl); } catch {}
      document.onmousemove = null;
      document.onmouseup   = null;
      if (typeof prev === 'function') {
        try { prev(); } catch {}
      }
    };
  })();

   const wantApply =
    (isChild && !top.noParentGate) ||
    (
      top.kind === 'client-rate'       ||
      top.kind === 'candidate-override'||
      top.kind === 'rate-presets-picker' ||
      top.kind === 'candidate-picker'  ||
      top.kind === 'client-picker'
    );

  const defaultPrimary =
    (top.kind === 'contract-clone-extend')      ? 'Create'
  : (top.kind === 'advanced-search')            ? 'Search'
  : (top.kind === 'selection-load')             ? 'Load'
  : (top.kind === 'timesheet-evidence-replace') ? 'Save evidence'
  : (wantApply ? 'Apply' : 'Save');



  btnSave.textContent = defaultPrimary; btnSave.setAttribute('aria-label', defaultPrimary);
  L('showModal defaultPrimary', { kind: top.kind, defaultPrimary });
const setCloseLabel = ()=> {
const isUtilityKind =
  top.kind === 'timesheets-resolve' ||
  top.kind === 'resolve-candidate'  ||
  top.kind === 'resolve-client'     ||
  (typeof top.kind === 'string' && top.kind.startsWith('import-summary-'));


  const label =
    (top.kind === 'advanced-search')
      ? 'Close'
    : (top.kind === 'timesheet-evidence-replace')
      ? 'Discard'
    : isUtilityKind
      ? 'Close'
      : (top.isDirty ? 'Discard' : 'Close');

  btnClose.textContent = label;
  btnClose.setAttribute('aria-label', label);
  btnClose.setAttribute('title', label);
};



  top._updateButtons = ()=>{
    try {
      const h = document.getElementById('modalHint');
      if (h) {
        h.textContent = '';
        h.removeAttribute('data-tone');
        h.classList.remove('ok','warn','err');
      }
    } catch {}

    const parentEditable = top.noParentGate ? true : (parent ? (parent.mode==='edit' || parent.mode==='create') : true);
    const relatedBtn = byId('btnRelated');

    // NEW: hide Preset Manager's "New" button whenever a child is open or when the top frame isn't the manager
    try {
      const rpNew = byId('btnRpNew');
      if (rpNew) {
        const shouldShow = (!isChild && top.kind === 'rates-presets');
        rpNew.style.display = shouldShow ? '' : 'none';
      }
    } catch {}

   if (top.kind === 'advanced-search') {
    btnEdit.style.display='none';
    btnSave.style.display='';
    btnSave.disabled=!!top._saving;
    if (relatedBtn) {
      relatedBtn.style.display = 'none';
      relatedBtn.disabled = true;
    }

  } else if (top.kind === 'rates-presets') {
    btnEdit.style.display='none';
    btnSave.style.display='none';
    btnSave.disabled=true;
    if (relatedBtn) {
      relatedBtn.style.display = 'none';
      relatedBtn.disabled = true;
    }

    // Always show â€œCloseâ€ for the Preset Rates manager (never â€œDiscardâ€)
    btnClose.textContent = 'Close';
    btnClose.setAttribute('aria-label', 'Close');
    btnClose.setAttribute('title', 'Close');

    L('_updateButtons snapshot (global)', {
      kind: top.kind, isChild, parentEditable, mode: top.mode,
      btnSave: { display: btnSave.style.display, disabled: btnSave.disabled },
      btnEdit: { display: btnEdit.style.display }
    });
    return;

  // NEW: candidate/client pickers â€“ explicit Apply, gated by row selection
  } else if (top.kind === 'candidate-picker' || top.kind === 'client-picker') {
    btnEdit.style.display = 'none';
    btnSave.style.display = '';
    btnSave.disabled = !!top._saving || !top._pickerHasSelection;

    if (relatedBtn) {
      relatedBtn.style.display = 'none';
      relatedBtn.disabled = true;
    }

    L('_updateButtons snapshot (picker)', {
      kind: top.kind,
      isChild,
      hasSelection: !!top._pickerHasSelection,
      btnSave: { display: btnSave.style.display, disabled: btnSave.disabled }
    });
    return;

  // NEW: utility modals (resolve/import) â€” hide Save/Edit, Close-only
  } else if (
    top.kind === 'timesheets-resolve' ||
    top.kind === 'resolve-candidate'  ||
    top.kind === 'resolve-client'     ||
    (typeof top.kind === 'string' && top.kind.startsWith('import-summary-'))
  ) {


  // No Save/Edit on these; everything happens via inline buttons in the modal body
  btnSave.style.display = 'none';
  btnSave.disabled      = true;
  btnEdit.style.display = 'none';

  if (relatedBtn) {
    relatedBtn.style.display = 'none';
    relatedBtn.disabled = true;
  }

  // Always simple "Close" label (never "Discard")
  btnClose.textContent = 'Close';
  btnClose.setAttribute('aria-label', 'Close');
  btnClose.setAttribute('title', 'Close');

  L('_updateButtons snapshot (utility)', {
    kind: top.kind,
    isChild,
    mode: top.mode,
    btnSave: { display: btnSave.style.display, disabled: btnSave.disabled },
    btnEdit: { display: btnEdit.style.display }
  });
  return;

} else if (isChild && !top.noParentGate) {

      if (top.mode === 'view') {
        btnSave.style.display = 'none';
        btnSave.disabled = true;
        btnEdit.style.display = 'none';
        if (relatedBtn) {
          relatedBtn.style.display = 'none';
          relatedBtn.disabled = true;
        }
      } else {
        btnSave.style.display = parentEditable ? '' : 'none';

        // Child apply gating:
        // - rate-presets-picker: gate by __canSave
        // - client-rate / candidate-override: gate by _applyDesired
        // - address-lookup (and other simple children): always allow Apply if parent is editable
        let wantApply;
        if (top.kind === 'rate-presets-picker') {
          wantApply = !!top.__canSave;
        } else if (top.kind === 'client-rate' || top.kind === 'candidate-override') {
          wantApply = (top._applyDesired === true);
        } else {
          // e.g. address-lookup and other simple child modals
          wantApply = true;
        }

        btnSave.disabled = (!parentEditable) || top._saving || !wantApply;
        btnEdit.style.display='none';
        if (relatedBtn) {
          relatedBtn.style.display = 'none';
          relatedBtn.disabled = true;
        }
        if (LOG) console.log('[MODAL] child _updateButtons()', {
          parentEditable, wantApply, disabled: btnSave.disabled, kind: top.kind
        });
      }
      } else {
      // â”€â”€ Edit button gating â”€â”€
      let canEdit = false;

      if (top.entity === 'timesheets') {
        // Use meta seeded by openTimesheet
        const meta = (window.modalCtx && window.modalCtx.timesheetMeta) || {};
        const sheetScope = String(meta.sheetScope || '').toUpperCase();
        const subMode    = String(meta.subMode    || '').toUpperCase();
        const isWeekly   = (sheetScope === 'WEEKLY');
        const isDaily    = (sheetScope === 'DAILY');
        const hasTsMeta  = !!meta.hasTs;
        const isPaid     = !!meta.isPaid;
        const isInvoiced = !!meta.isInvoiced;
        const cwMode     = String(meta.cw_submission_mode_snapshot || '').toUpperCase();
        const isPlanned  = !!meta.isPlannedWeek;

        // 1) Weekly MANUAL *real* timesheet, not paid/invoiced
        const isWeeklyManualTs =
          hasTsMeta &&
          isWeekly &&
          subMode === 'MANUAL' &&
          !isPaid &&
          !isInvoiced;

        // 2) Planned/open weekly week whose contract_week snapshot is MANUAL
        const isPlannedManualWeek =
          !hasTsMeta &&
          isPlanned &&
          isWeekly &&
          cwMode === 'MANUAL';

        // 3) Daily MANUAL *real* timesheet, not paid/invoiced
        const isDailyManualTs =
          hasTsMeta &&
          isDaily &&
          subMode === 'MANUAL' &&
          !isPaid &&
          !isInvoiced;

        canEdit = (top.mode === 'view') && (isWeeklyManualTs || isPlannedManualWeek || isDailyManualTs);
      } else {
        // Default for non-timesheet entities
        canEdit = (top.mode === 'view' && top.hasId);
      }

      btnEdit.style.display = canEdit ? '' : 'none';



     if (relatedBtn) {
  // Map modal entity â†’ backend /api/related entity key
  const relatedEntity =
    top.entity === 'candidates' ? 'candidate' :
    top.entity === 'clients'    ? 'client'    :
    top.entity === 'contracts'  ? 'contract'  :
    top.entity === 'timesheets' ? 'timesheet' :
    top.entity === 'invoices'   ? 'invoice'   :
    top.entity === 'umbrellas'  ? 'umbrella'  :
    null;

  const showRelated =
    !isChild &&
    top.hasId &&
    !!relatedEntity;

  relatedBtn.style.display = showRelated ? '' : 'none';

  const canClick = showRelated && top.mode === 'view';
  relatedBtn.disabled = !canClick;

  if (canClick) {
    relatedBtn.onclick = async (ev) => {
      try {
        ev.preventDefault();
        ev.stopPropagation();

        const ctxId = window.modalCtx?.data?.id || null;
        if (!ctxId) {
          console.warn('[RELATED] no id on modalCtx.data; cannot open related menu');
          return;
        }

        // Fetch counts per related type (timesheets, invoices, etc.)
        const counts = await fetchRelatedCounts(relatedEntity, ctxId);

        // Position menu just under the button click
        const x = ev.clientX;
        const y = ev.clientY + 8;

        showRelatedMenu(x, y, counts, relatedEntity, ctxId);
      } catch (e) {
        console.warn('[RELATED] failed to open related menu', e);
      }
    };
  } else {
    relatedBtn.onclick = null;
  }
}



      if (top.mode === 'create') {
        btnSave.style.display = '';
        btnSave.disabled = top._saving;
      } else if (top.mode==='view') {
        btnSave.style.display = 'none';
        btnSave.disabled = true;
      } else {

        btnSave.style.display='';

        let gateOK = true;
        let elig   = null;

        if (top.entity === 'contracts') {
          try {
            gateOK = (typeof computeContractSaveEligibility === 'function') ? !!computeContractSaveEligibility() : true;
            elig   = (typeof window !== 'undefined') ? (window.__contractEligibility || null) : null;

            // â€¦ TS boundary / missing candidate hints â€¦

          } catch { gateOK = true; }
        }

        btnSave.disabled = (top.entity === 'contracts')
          ? (top._saving || ((top.kind !== 'contract-clone-extend') && !top.isDirty) || !gateOK)
          : (top._saving);
      }

      // ðŸ”¹ Top-level Edit Contract â†’ wire global Delete button
      if (!isChild && top.entity === 'contracts') {
        const canDelete = !!(window.modalCtx?.data && window.modalCtx.data.can_delete);
        const showDelete = (top.mode === 'edit' && top.hasId && canDelete);

        if (showDelete) {
          btnDel.style.display = '';
          btnDel.disabled = !!top._saving;
          btnDel.onclick = async () => {
            const id = window.modalCtx?.data?.id;
            if (!id) return;

            const ok = window.confirm('Do you want to permanently delete this contract?');
            if (!ok) return;

            try {
              if (typeof deleteContract === 'function') {
                if (LOG) console.log('[MODAL][CONTRACTS] delete via btnDelete', { id });
                await deleteContract(id);
              } else {
                alert('Delete contract action is not available.');
                return;
              }
              try { discardAllModalsAndState(); } catch {}
              try { await renderAll(); } catch {}
            } catch (e) {
              alert(e?.message || 'Delete failed');
            }
          };
        } else {
          btnDel.style.display = 'none';
          btnDel.disabled = true;
          btnDel.onclick = null;
        }
      } else if (!isChild) {
        // Non-contract top-level: keep global Delete hidden
        btnDel.style.display = 'none';
        btnDel.disabled = true;
        btnDel.onclick = null;
      }

    }


    setCloseLabel();
    L('_updateButtons snapshot (global)', {
      kind: top.kind, isChild, parentEditable, mode: top.mode,
      btnSave: { display: btnSave.style.display, disabled: btnSave.disabled },
      btnEdit: { display: btnEdit.style.display }
    });
  };



  top._updateButtons();
  btnEdit.onclick = ()=> {
    const isChildNow    = (stack().length > 1);
    const isRatePreset  = (top.kind === 'rate-preset');

    // Block Edit for search & normal child-apply modals,
    // but allow Edit for rate-preset even when opened as a child.
    if (!isRatePreset && (isChildNow || top.kind === 'advanced-search')) return;

   if (top.mode === 'view') {
  top._snapshot = {
    data               : deep(window.modalCtx?.data || null),
    formState          : deep(window.modalCtx?.formState || null),
    rolesState         : deep(window.modalCtx?.rolesState || null),
    ratesState         : deep(window.modalCtx?.ratesState || null),
    hospitalsState     : deep(window.modalCtx?.hospitalsState || null),
    clientSettingsState: deep(window.modalCtx?.clientSettingsState || null),
    overrides          : deep(window.modalCtx?.overrides || { existing:[], stagedNew:[], stagedEdits:{}, stagedDeletes:[] }),
    candidateMainModel : deep(window.modalCtx?.candidateMainModel || null),

    // NEW: snapshot any timesheet-specific staging (lines, issues, etc.)
    timesheetState     : deep(window.modalCtx?.timesheetState || null)
  };
  top.isDirty = false;
  setFrameMode(top, 'edit');
  L('btnEdit (global) â†’ switch to edit (snapshot includes timesheetState)', {
    hasTimesheetState: !!top._snapshot.timesheetState,
    keys: Object.keys(top._snapshot || {})
  });
}


  };


  const handleSecondary = (ev)=>{
    if (currentFrame && currentFrame() !== top) return;
    if (top._confirmingDiscard || top._closing) return;

    if (top.kind==='advanced-search') {
      top._closing=true;
      document.onmousemove=null; document.onmouseup=null; byId('modal')?.classList.remove('dragging'); sanitizeModalGeometry();
      const closing=stack().pop(); if (closing?._detachDirty){ try{closing._detachDirty();}catch{} closing._detachDirty=null; }
      if (closing?._detachGlobal){ try{closing._detachGlobal();}catch{} closing._detachGlobal=null; } top._wired=false;
      if (stack().length>0) {
        const p = currentFrame();
        if (p && p._ctxRef) window.modalCtx = p._ctxRef;

        const resumeMode =
          (typeof closing !== 'undefined' && closing && closing._parentModeOnOpen)
            ? closing._parentModeOnOpen
            : p.mode;

        try { setFrameMode(p, resumeMode); } catch {}
        p._updateButtons?.();

        renderTop();
        try { p.onReturn && p.onReturn(); } catch {}
      } else {
        discardAllModalsAndState(); if (window.__pendingFocus) { try{ renderAll(); } catch(e){ console.error('refresh after modal close failed',e); } }
      }
      return;
    }


    const isChildNow = (stack().length > 1);

    // Child frames with noParentGate: if dirty in edit/create, confirm discard before closing.
    // NEW: never prompt for the Rate Presets Picker â€” it must behave read-only for discard purposes.
    if (isChildNow && top.noParentGate && (top.mode === 'edit' || top.mode === 'create') && top.isDirty && top.kind !== 'rate-presets-picker') {
      let ok = false;
      try {
        top._confirmingDiscard = true;
        btnClose.disabled = true;
        ok = window.confirm('Discard changes and close?');
      } finally {
        top._confirmingDiscard = false;
        btnClose.disabled = false;
      }
      if (!ok) return;
    }


    if (!isChildNow && !top.noParentGate && top.mode==='edit' && top.kind!=='rates-presets') {
    if (!top.isDirty) {
  if (top._snapshot && window.modalCtx) {
    window.modalCtx.data                = deep(top._snapshot.data);
    window.modalCtx.formState           = deep(top._snapshot.formState);
    window.modalCtx.rolesState          = deep(top._snapshot.rolesState);
    window.modalCtx.ratesState          = deep(top._snapshot.ratesState);
    window.modalCtx.hospitalsState      = deep(top._snapshot.hospitalsState);
    window.modalCtx.clientSettingsState = deep(top._snapshot.clientSettingsState);
    if (top._snapshot.overrides)         window.modalCtx.overrides          = deep(top._snapshot.overrides);
    window.modalCtx.candidateMainModel  = deep(top._snapshot.candidateMainModel || null);

    // NEW: restore timesheetState so staged Lines/Issues state is rolled back
    window.modalCtx.timesheetState      = deep(top._snapshot.timesheetState || null);

    if (LOG) {
      console.log('[MODAL][RESTORE][no-change]', {
        entity: top.entity,
        hasTimesheetState: !!top._snapshot.timesheetState
      });
    }

    try { renderCandidateRatesTable?.(); } catch {}
  }
  try {
    if (top.entity === 'contracts') {
      const cid = window.modalCtx?.data?.id;
      if (cid && typeof discardContractCalendarStage === 'function') discardContractCalendarStage(cid);
    }
  } catch {}
  top.isDirty=false; setFrameMode(top,'view'); top._snapshot=null;
  try{ window.__toast?.('No changes'); }catch{}; return;
}
 else {
        let ok=false; try{ top._confirmingDiscard=true; btnClose.disabled=true; ok=window.confirm('Discard changes and return to view?'); } finally { top._confirmingDiscard=false; btnClose.disabled=false; }
        if (!ok) return;
     if (top._snapshot && window.modalCtx) {
  window.modalCtx.data                = deep(top._snapshot.data);
  window.modalCtx.formState           = deep(top._snapshot.formState);
  window.modalCtx.rolesState          = deep(top._snapshot.rolesState);
  window.modalCtx.ratesState          = deep(top._snapshot.ratesState);
  window.modalCtx.hospitalsState      = deep(top._snapshot.hospitalsState);
  window.modalCtx.clientSettingsState = deep(top._snapshot.clientSettingsState);
  if (top._snapshot.overrides) window.modalCtx.overrides = deep(top._snapshot.overrides);
  // ðŸ”¹ restore candidateMainModel as well so job titles (and primary) roll back
  window.modalCtx.candidateMainModel  = deep(top._snapshot.candidateMainModel || null);

  // NEW: restore timesheetState so staged per-line changes are discarded
  window.modalCtx.timesheetState      = deep(top._snapshot.timesheetState || null);

  if (LOG) {
    console.log('[MODAL][RESTORE][discard]', {
      entity: top.entity,
      hasTimesheetState: !!top._snapshot.timesheetState
    });
  }

  try { renderCandidateRatesTable?.(); } catch {}
}

        try {
          if (top.entity === 'contracts') {
            const cid = window.modalCtx?.data?.id;
            if (cid && typeof discardContractCalendarStage === 'function') discardContractCalendarStage(cid);
          }
        } catch {}
        top.isDirty=false; top._snapshot=null; setFrameMode(top,'view'); return;
      }
    }


    if (top._closing) return;
    top._closing=true;
    document.onmousemove=null; document.onmouseup=null; byId('modal')?.classList.remove('dragging');

    if (!isChildNow && !top.noParentGate && top.mode==='create' && top.isDirty && top.kind!=='rates-presets') {
      let ok=false; try{ top._confirmingDiscard=true; btnClose.disabled=true; ok=window.confirm('You have unsaved changes. Discard them and close?'); } finally { top._confirmingDiscard=false; btnClose.disabled=false; }
      if (!ok) { top._closing=false; return; }
    }


    try {
      if (top.entity === 'contracts' && (top.mode==='edit' || top.mode==='create')) {
        const cid = window.modalCtx?.data?.id;
        if (cid && typeof discardContractCalendarStage === 'function') discardContractCalendarStage(cid);
      }
    } catch {}
    sanitizeModalGeometry();
    const closing=stack().pop(); if (closing?._detachDirty){ try{closing._detachDirty();}catch{} closing._detachDirty=null; }
    if (closing?._detachGlobal){ try{closing._detachGlobal();}catch{} closing._detachGlobal=null; } top._wired=false;
    if (stack().length>0) {
      const p=currentFrame();
      // restore parent context to ensure actions (Clone & Extend) render correctly
      if (p && p._ctxRef) window.modalCtx = p._ctxRef;
      // â–¶ for most children, resume the original parent mode; for the rate-presets picker,
      //    keep whatever mode the parent is currently in (typically 'edit' after Apply).
      const resumeMode =
        (typeof closing !== 'undefined' &&
         closing &&
         closing._parentModeOnOpen &&
         closing.kind !== 'rate-presets-picker')
          ? closing._parentModeOnOpen
          : p.mode;

      try { setFrameMode(p, resumeMode); } catch {}
      p._updateButtons && p._updateButtons();
      renderTop();

      try{ p.onReturn && p.onReturn(); }catch{}
    } else {
      discardAllModalsAndState();
      if (window.__pendingFocus) { try{ renderAll(); } catch(e) { console.error('refresh after modal close failed', e); } }
    }

  };
  // AFTER
  const onCloseClick = (ev) => {
    const btn = ev?.currentTarget || byId('btnCloseModal');
    const bound = btn?.dataset?.ownerToken;
    const topNow = currentFrame();
    if (!topNow || bound !== topNow._token) return;
    handleSecondary(ev);
  };

  const bindClose = (btn, fr) => {
    if (!btn || !fr) return;
    btn.dataset.ownerToken = fr._token;
    btn.onclick = onCloseClick;
  };

  bindClose(btnClose, top);

  const hasStagedClientDeletes = ()=> {
    try {
      const anyFlag = Array.isArray(window.modalCtx?.ratesState) && window.modalCtx.ratesState.some(w => w && w.__delete === true);
      const anySet  = (window.modalCtx?.ratesStagedDeletes instanceof Set) && window.modalCtx.ratesStagedDeletes.size > 0;
      const ovDel   = (window.modalCtx?.overrides?.stagedDeletes instanceof Set) && window.modalCtx.overrides.stagedDeletes.size > 0;
      return !!(anyFlag || anySet || ovDel);
    } catch { return false; }
  };

async function saveForFrame(fr) {
  if (!fr || fr._saving) return;
  const onlyDel    = hasStagedClientDeletes();
  const allowApply = (fr.kind === 'candidate-override' || fr.kind === 'client-rate') && fr._applyDesired === true;

  L('saveForFrame ENTER (global)', {
    kind: fr.kind,
    mode: fr.mode,
    noParentGate: fr.noParentGate,
    isDirty: fr.isDirty,
    onlyDel,
    allowApply
  });

  const isChildNow = (window.__modalStack?.length > 1);
  const shouldNoop =
    (fr.kind !== 'advanced-search') &&
    !fr.noParentGate &&
    fr.mode === 'edit' &&
    !fr.isDirty &&
    !onlyDel &&
    !allowApply;

  if (shouldNoop) {
    L('saveForFrame GUARD (global): no-op (no changes and apply not allowed)');
    if (isChildNow) {
      sanitizeModalGeometry();
      window.__modalStack.pop();
      if (window.__modalStack.length > 0) {
        const p = window.__modalStack[window.__modalStack.length - 1];
        renderTop();
        try { p.onReturn && p.onReturn(); } catch {}
      }
    } else {
      fr.isDirty = false;
      fr._snapshot = null;
      setFrameMode(fr, 'view');
      fr._updateButtons && fr._updateButtons();
    }
    try { window.__toast?.('No changes'); } catch {};
    return;
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // NEW: QR-aware tri-choice for timesheets
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (!isChildNow && fr.entity === 'timesheets' && fr.mode === 'edit' && fr.isDirty) {
    try {
      const mc   = window.modalCtx || {};
      const det  = mc.timesheetDetails || {};
      const ts   = det.timesheet || {};
      const fin  = det.tsfin || {};
      const qrStatus = String(det.qr_status || ts.qr_status || '').toUpperCase();
      const locked   = !!(fin.locked_by_invoice_id || fin.paid_at_utc);

      // Only prompt if this was already a QR timesheet and is still editable
      if (qrStatus && !locked) {
        const promptMsg =
          'This timesheet already has a QR version.\n\n' +
          'If you have changed the hours, you must decide what to do with the existing QR timesheet:\n\n' +
          '1 â€“ Save and REVOKE the existing QR timesheet only (do NOT send a new QR)\n' +
          '2 â€“ Save, REVOKE and REISSUE a NEW QR timesheet to the worker\n' +
          '3 â€“ Cancel (do not save changes)\n\n' +
          'Please type 1, 2 or 3:';

        const choice = window.prompt(promptMsg, '3');

        if (choice === null || choice === '3') {
          // Cancel â€“ abort the save
          L('saveForFrame QR prompt: user cancelled (3 or null)');
          fr._saving = false;
          fr._updateButtons && fr._updateButtons();
          return;
        }

        let revoke  = false;
        let reissue = false;

        if (choice === '1') {
          revoke  = true;
          reissue = false;
        } else if (choice === '2') {
          revoke  = true;
          reissue = true;
        } else {
          alert('Please enter 1, 2 or 3. Save has been cancelled.');
          fr._saving = false;
          fr._updateButtons && fr._updateButtons();
          return;
        }

        mc._revokeQrOnSave  = revoke;
        mc._reissueQrOnSave = reissue;

        L('saveForFrame QR prompt result', {
          choice,
          revoke_qr_on_save:  mc._revokeQrOnSave,
          reissue_qr_on_save: mc._reissueQrOnSave
        });
      }
    } catch (e) {
      L('saveForFrame QR prompt: failed (non-fatal)', e);
    }
  }

  fr.persistCurrentTabState();

  if (isChildNow && !fr.noParentGate && fr.kind !== 'advanced-search') {
    const p = window.__modalStack[window.__modalStack.length - 2];
    if (!p || !(p.mode === 'edit' || p.mode === 'create')) {
      L('saveForFrame GUARD (global): parent not editable');
      return;
    }
  }

  fr._saving = true;
  fr._updateButtons && fr._updateButtons();

  let ok = false, saved = null;
  if (typeof fr.onSave === 'function') {
    try {
      const res = await fr.onSave();
      ok = (res === true) || (res && res.ok === true);
      if (res && res.saved) saved = res.saved;
    } catch (e) {
      L('saveForFrame onSave threw (global)', e);
      ok = false;
    }
  }
  fr._saving = false;
  if (!ok) {
    L('saveForFrame RESULT not ok (global)');
    fr._updateButtons && fr._updateButtons();
    return;
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Existing post-save logic (unchanged)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  if (fr.kind === 'advanced-search') {
    sanitizeModalGeometry();
    const closing = window.__modalStack.pop();
    if (closing?._detachDirty) { try { closing._detachDirty(); } catch {} closing._detachDirty = null; }
    if (closing?._detachGlobal) { try { closing._detachGlobal(); } catch {} closing._detachGlobal = null; }
    fr._wired = false;

    if (window.__modalStack.length > 0) {
      const p = window.__modalStack[window.__modalStack.length - 1];
      renderTop();
      try { p.onReturn && p.onReturn(); } catch {}
    } else {
      discardAllModalsAndState();
    }

    L('saveForFrame EXIT (global advanced-search closed)');
    return;
  }

  if (isChildNow) {
    // If this child should remain open after save (successor contract),
    // flip it in-place to view mode and keep it on screen.
    if (fr.stayOpenOnSave) {
      try {
        if (saved && window.modalCtx) {
          window.modalCtx.data = { ...(window.modalCtx.data || {}), ...(saved.contract || saved) };
          fr.hasId = !!window.modalCtx.data?.id;
        }
        setFrameMode(fr, 'view');
        fr._updateButtons && fr._updateButtons();
        renderTop();
      } catch {}
      L('saveForFrame EXIT (child kept open)');
    } else {
      if (!fr.noParentGate) {
        try { window.dispatchEvent(new CustomEvent('modal-dirty')); } catch {}
      }

      sanitizeModalGeometry();
      window.__modalStack.pop();

      if (window.__modalStack.length > 0) {
        const p = window.__modalStack[window.__modalStack.length - 1];

        let resumeMode =
          (typeof fr !== 'undefined' &&
           fr &&
           fr._parentModeOnOpen &&
           fr.kind !== 'rate-presets-picker')
            ? fr._parentModeOnOpen
            : p.mode;

        // SPECIAL CASE: candidate pay-method change â†’ treat as successful parent save
        if (fr.kind === 'candidate-pay-method-change' && p.entity === 'candidates') {
          resumeMode   = 'view';
          p.isDirty    = false;
          p._snapshot  = null;

          try {
            if (saved && window.modalCtx && window.modalCtx.entity === 'candidates') {
              window.modalCtx.data = {
                ...(window.modalCtx.data || {}),
                ...(saved || {})
              };
            }
          } catch {}
        }

        try { setFrameMode(p, resumeMode); } catch {}
        p._updateButtons && p._updateButtons();
        renderTop();

        try { window.dispatchEvent(new Event('contracts-main-rendered')); } catch {}
        try { p.onReturn && p.onReturn(); } catch {}
      }

      L('saveForFrame EXIT (global child)');
    }
  } else {
    // parent branch...
    try {
      const savedContract = (saved && (saved.contract || saved)) || null;
      const id = savedContract?.id || window.modalCtx?.data?.id || null;
      if (id && savedContract) {
        const idx = Array.isArray(currentRows)
          ? currentRows.findIndex(x => String(x.id) === String(id))
          : -1;
        if (idx >= 0) currentRows[idx] = savedContract;
        (window.__lastSavedAtById ||= {})[String(id)] = Date.now();
      }
    } catch (e) {
      console.warn('[SAVE] list cache merge failed', e);
    }

    if (saved && window.modalCtx) {
      window.modalCtx.data = { ...(window.modalCtx.data || {}), ...(saved.contract || saved) };
      fr.hasId = !!window.modalCtx.data?.id;
    }
    fr.isDirty = false;
    fr._snapshot = null;
    setFrameMode(fr, 'view');
    L('saveForFrame EXIT (global parent, kept open)');
  }
}


  const onSaveClick = async (ev)=>{
    const btn=ev?.currentTarget || byId('btnSave');
    const topNow=currentFrame(); const bound=btn?.dataset?.ownerToken;
    if (LOG) console.log('[MODAL] click #btnSave (global)', {boundToken:bound, topToken:topNow?._token, topKind:topNow?.kind, topTitle:topNow?.title});
    if(!topNow) return; if(bound!==topNow._token){ if(LOG) console.warn('[MODAL] token mismatch (global); using top frame'); }
    await saveForFrame(topNow);
  };

  const bindSave = (btn,fr)=>{ if(!btn||!fr) return; btn.dataset.ownerToken = fr._token; btn.onclick = onSaveClick; if(LOG) console.log('[MODAL] bind #btnSave â†’ (global)',{ownerToken:fr._token,kind:fr.kind||'(parent)',title:fr.title,mode:fr.mode}); };
  bindSave(btnSave, top);
  // FIX: ignore programmatic "dirty" while suppression is active
  const onDirtyEvt = ()=>{
    const fr = currentFrame();
    if (fr && fr._suppressDirty) return;

    // Allow presets picker dirty â†’ parent (ignore only truly load-only frames)
    if (fr && fr._loadOnly === true) return;


    const isChildNow = (stack().length > 1);
    if (isChildNow) {
      if (fr && fr.noParentGate) {
        if (fr.mode === 'edit' || fr.mode === 'create') {
          fr.isDirty = true;
          fr._updateButtons && fr._updateButtons();
        }
      } else {
        const p = parentFrame();
        if (p && (p.mode === 'edit' || p.mode === 'create')) {
          p.isDirty = true;
          p._updateButtons && p._updateButtons();
        }
      }
    } else if (fr && (fr.mode === 'edit' || fr.mode === 'create')) {
      fr.isDirty = true;
      fr._updateButtons && fr._updateButtons();
    }
    try{ const t=currentFrame(); if(t && t.entity==='candidates' && t.currentTabKey==='rates'){ renderCandidateRatesTable?.(); } }catch{}
  };


  const onApplyEvt = ev=>{
    const isChildNow=(stack().length>1); if(!isChildNow) return;
    const t=currentFrame(); if(!(t && (t.kind==='client-rate'||t.kind==='candidate-override'))) return;
    const enabled=!!(ev && ev.detail && ev.detail.enabled);
    t._applyDesired=enabled;
    t._updateButtons&&t._updateButtons();
    bindSave(byId('btnSave'), t);
    if(LOG) console.log('[MODAL] onApplyEvt (global) â†’ _applyDesired =', enabled,'rebound save to top frame');
  };

  const onModeChanged = ev=>{
    const isChildNow=(stack().length>1); if(!isChildNow) return;
    const parentIdx=stack().length-2, changed=ev?.detail?.frameIndex ?? -1;
    if(changed===parentIdx){ if(LOG) console.log('[MODAL] parent mode changed (global) â†’ child _updateButtons()'); const t=currentFrame(); t._updateButtons&&t._updateButtons(); bindSave(byId('btnSave'), t); }
  };

  const onMarginsEvt = ()=>{ try { const t=currentFrame(); if (t && (t.mode==='edit'||t.mode==='create')) t._updateButtons(); } catch {} };

  if (!top._wired) {
    window.addEventListener('modal-dirty', onDirtyEvt);
    window.addEventListener('modal-apply-enabled', onApplyEvt);
    window.addEventListener('modal-frame-mode-changed', onModeChanged);
    window.addEventListener('contract-margins-updated', onMarginsEvt);
    const onEsc=e=>{ if(e.key==='Escape'){ if(top._confirmingDiscard||top._closing) return; e.preventDefault(); byId('btnCloseModal').click(); } };
    window.addEventListener('keydown', onEsc);
    const onOverlayClick=e=>{ if(top._confirmingDiscard||top._closing) return; if(e.target===byId('modalBack')) { e.preventDefault(); e.stopPropagation(); return; } };
    byId('modalBack').addEventListener('click', onOverlayClick, true);

    top._detachGlobal = ()=>{ try{window.removeEventListener('modal-dirty',onDirtyEvt);}catch{} try{window.removeEventListener('modal-apply-enabled',onApplyEvt);}catch{} try{window.removeEventListener('modal-frame-mode-changed',onModeChanged);}catch{} try{window.removeEventListener('contract-margins-updated',onMarginsEvt);}catch{} try{window.removeEventListener('keydown',onEsc);}catch{} try{byId('modalBack').removeEventListener('click', onOverlayClick, true);}catch{}; };
    top._wired = true;
    L('renderTop (global): listeners wired');
  }


  const parentEditable = parent && (parent.mode==='edit' || parent.mode==='create');
  const isChildNow = (stack().length > 1);
  if (isChildNow && !top.noParentGate) setFormReadOnly(byId('modalBody'), !parentEditable);
  else                                 setFrameMode(top, top.mode);

  top._updateButtons && top._updateButtons();
  bindSave(btnSave, top);

  try {
    const pc = document.getElementById('btnPickCandidate');
    const pl = document.getElementById('btnPickClient');
    L('renderTop final snapshot (global)', {
      entity: top.entity, mode: top.mode, currentTabKey: top.currentTabKey,
      pickButtons: {
        btnPickCandidate: { exists: !!pc, disabled: !!(pc && pc.disabled) },
        btnPickClient:    { exists: !!pl, disabled: !!(pl && pl.disabled) }
      }
    });
  } catch {}

  GE();
}



  byId('modalBack').style.display='flex';
  window.__getModalFrame = currentFrame;
  L('showModal ENTER', { title, tabs: (tabs||[]).map(t=>t.key||t.title), hasId, entity: window.modalCtx?.entity, kind: opts.kind, forceEdit: !!opts.forceEdit });
  renderTop();
}

// Selection state helpers â€” simplified to explicit IDs only

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// IDs-only selection helpers (single source of truth: Set of selected IDs)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


























async function openTimesheetsResolveModal(selectedRows) {
  const rowsIn = Array.isArray(selectedRows) ? selectedRows : [];
  const ids = rowsIn
    .map(r => String(r.timesheet_id || r.id || ''))
    .filter(Boolean);

  if (!ids.length) {
    console.warn('[TS][RESOLVE] openTimesheetsResolveModal called with no ids');
    return;
  }

  let rows = [];
  try {
    const res = await authFetch(API('/api/timesheets/resolve-preview'), {
      method: 'POST',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify({ timesheet_ids: ids })
    });
    const text = await res.text();
    if (!res.ok) {
      throw new Error(text || `Failed to load resolve preview (${res.status})`);
    }
    rows = text ? JSON.parse(text) : [];
    if (!Array.isArray(rows)) rows = [];
  } catch (err) {
    console.error('[TS][RESOLVE] failed to fetch resolve-preview', err);
    alert(err?.message || 'Failed to load resolve preview.');
    return;
  }

  // Keep state globally so child modals (candidate/client resolve) can refresh
  window.__resolveTimesheetsState = {
    rows,
    selectionIds: ids
  };

  // Show a simple modal with a single "Resolve" tab
  showModal(
    'Resolve timesheets',
    [{ key: 'main', label: 'Resolve' }],
    (key) => {
      if (key !== 'main') return '';
      return renderTimesheetsResolveModal(window.__resolveTimesheetsState || { rows: [] });
    },
    null,               // no onSave
    false,              // hasId
    null,               // onReturn
    {
      kind: 'timesheets-resolve',
      noParentGate: true,    // editing aliases shouldn't be gated by parent mode
      stayOpenOnSave: false  // there is no save, just close/child actions
    }
  );
}

function renderTimesheetsResolveModal(state) {
  const enc = (typeof escapeHtml === 'function')
    ? escapeHtml
    : (s) => String(s == null ? '' : s);

  const rows = state && Array.isArray(state.rows) ? state.rows : [];

  const rowsHtml = rows.length
    ? rows.map((r, idx) => {
        const tsId   = r.timesheet_id || r.id || '';
        const scope  = (r.sheet_scope || '').toUpperCase();
        const weYmd  = r.week_ending_date || r.worked_date || r.date_ymd || '';
        const occ    = r.occupant_key_norm || '';
        const hosp   = r.hospital_norm || '';
        const pRaw   = r.processing_status || '';
        const p      = String(pRaw || '').toUpperCase();

        let pillCls = 'pill-info';
        if (p === 'UNASSIGNED' || p === 'CLIENT_UNRESOLVED') pillCls = 'pill-bad';
        else if (p === 'READY_FOR_HR') pillCls = 'pill-warn';
        else if (p === 'READY_FOR_INVOICE') pillCls = 'pill-ok';

        const canAssignCand   = (p === 'UNASSIGNED');
        const canAssignClient = (p === 'CLIENT_UNRESOLVED');

        return `
          <tr>
            <td><span class="mini">${enc(tsId || 'â€”')}</span></td>
            <td><span class="mini">${enc(scope || 'â€”')}</span></td>
            <td><span class="mini">${weYmd ? enc(weYmd) : 'â€”'}</span></td>
            <td><span class="mini">${occ ? enc(occ) : 'â€”'}</span></td>
            <td><span class="mini">${hosp ? enc(hosp) : 'â€”'}</span></td>
            <td>
              <span class="pill ${pillCls}">${p ? enc(p) : 'UNKNOWN'}</span>
            </td>
            <td>
              ${
                canAssignCand
                  ? `<button type="button"
                             class="btn mini"
                             onclick="openResolveCandidateModal((window.__resolveTimesheetsState||{}).rows[${idx}])">
                       Assign candidateâ€¦
                     </button>`
                  : ''
              }
              ${
                canAssignClient
                  ? `<button type="button"
                             class="btn mini"
                             style="margin-left:4px;"
                             onclick="openResolveClientModal && openResolveClientModal((window.__resolveTimesheetsState||{}).rows[${idx}])">
                       Assign clientâ€¦
                     </button>`
                  : ''
              }
            </td>
          </tr>
        `;
      }).join('')
    : `
      <tr>
        <td colspan="7">
          <span class="mini">No timesheets in this selection require candidate/client resolution.</span>
        </td>
      </tr>
    `;

  return html(`
    <div class="form" id="ts-resolve-wrapper">
      <div class="card">
        <div class="row">
          <label>Resolve timesheets</label>
          <div class="controls">
            <span class="mini">
              Use this screen to fix unassigned candidates and unresolved clients
              by teaching the system how rota/HR names map to database records.
            </span>
          </div>
        </div>
      </div>

      <div class="card" style="margin-top:10px;">
        <div class="row">
          <label>Timesheets</label>
          <div class="controls">
            <table class="grid">
              <thead>
                <tr>
                  <th>Timesheet ID</th>
                  <th>Scope</th>
                  <th>Week ending / Date</th>
                  <th>Rota name</th>
                  <th>Rota hospital</th>
                  <th>Status</th>
                  <th>Resolve</th>
                </tr>
              </thead>
              <tbody>
                ${rowsHtml}
              </tbody>
            </table>
          </div>
        </div>
        <div class="row">
          <label></label>
          <div class="controls">
            <button type="button" class="btn" id="btnTsResolveClose">
              Close
            </button>
            <span class="mini" style="margin-left:8px;">
              Closing this dialog does not change any data; only the "Assignâ€¦" actions
              update aliases and trigger financial recompute.
            </span>
          </div>
        </div>
      </div>
    </div>
  `);
}

// Wire up the "Close" button once the modal is rendered
(function wireTsResolveCloseButtonOnce() {
  // This will be re-run on each tab render, so guard with a small timeout
  setTimeout(() => {
    try {
      const btn = document.getElementById('btnTsResolveClose');
      if (btn && !btn.__tsResolveWired) {
        btn.__tsResolveWired = true;
        btn.addEventListener('click', () => {
          const closeBtn = document.getElementById('btnCloseModal');
          if (closeBtn) closeBtn.click();
        });
      }
    } catch (e) {
      console.warn('[TS][RESOLVE] failed wiring Close button', e);
    }
  }, 0);
})();

async function openResolveCandidateModal(resolveRow) {
  if (!resolveRow || !resolveRow.timesheet_id) {
    alert('Timesheet context missing for resolve.');
    return;
  }

  const tsId    = resolveRow.timesheet_id;
  const occName = resolveRow.occupant_key_norm || resolveRow.candidate_name || '(unknown)';

  // Seed a small local state for this child modal
  window.__resolveCandidateState = {
    row: resolveRow,
    results: [],
    term: ''
  };

  const enc = (typeof escapeHtml === 'function')
    ? escapeHtml
    : (s) => String(s == null ? '' : s);

  const renderResolveCandidateTab = (key) => {
    if (key !== 'main') return '';
    const state = window.__resolveCandidateState || {};
    const results = Array.isArray(state.results) ? state.results : [];

    const resultsHtml = results.length
      ? `
        <ul class="mini">
          ${results.map(c => `
            <li>
              <strong>${enc(c.display_name || c.name || (c.first_name || '') + ' ' + (c.last_name || ''))}</strong>
              ${c.tms_ref ? ` &nbsp; <span class="mono">(${enc(c.tms_ref)})</span>` : ''}
              <button type="button"
                      class="btn mini"
                      data-act="resolve-cand-select"
                      data-candidate-id="${enc(c.id)}">
                Select
              </button>
            </li>
          `).join('')}
        </ul>
      `
      : '<span class="mini">No candidates loaded yet. Try a search.</span>';

    return html(`
      <div class="form" id="ts-resolve-cand">
        <div class="card">
          <div class="row">
            <label>Assign candidate</label>
            <div class="controls">
              <div class="mini">
                Assign candidate for <strong>${enc(occName)}</strong><br/>
                Timesheet: <span class="mono">${enc(tsId)}</span>
              </div>
            </div>
          </div>
        </div>

        <div class="card" style="margin-top:10px;">
          <div class="row">
            <label>Search</label>
            <div class="controls">
              <input id="candResolveSearch"
                     class="input"
                     type="text"
                     placeholder="Search by name, CCR, NI, etc."
                     value="${enc(state.term || '')}" />
              <button type="button"
                      class="btn mini"
                      data-act="resolve-cand-search">
                Search
              </button>
              <div class="hint mini" style="margin-top:4px;">
                This uses the same search as the Candidates summary (name, CCR, NI, etc.).
              </div>
            </div>
          </div>
          <div class="row">
            <label>Matches</label>
            <div class="controls" id="candResolveResults">
              ${resultsHtml}
            </div>
          </div>
        </div>
      </div>
    `);
  };

  // Open as child modal
  showModal(
    'Assign candidate',
    [{ key: 'main', label: 'Assign candidate' }],
    renderResolveCandidateTab,
    null,
    false,
    null,
    {
      kind: 'timesheet-resolve-candidate',
      noParentGate: true,
      stayOpenOnSave: false
    }
  );

  // Wire search + select after the modal is rendered
  setTimeout(() => {
    try {
      const root = document.getElementById('modalBody');
      if (!root) return;

      const searchBtn = root.querySelector('button[data-act="resolve-cand-search"]');
      const searchInput = root.querySelector('#candResolveSearch');

      if (searchBtn && !searchBtn.__tsCandResolveWired) {
        searchBtn.__tsCandResolveWired = true;
        searchBtn.addEventListener('click', async () => {
          const term = (searchInput && searchInput.value || '').trim();
          if (!term) {
            alert('Please enter something to search for.');
            return;
          }
          try {
            const results = await searchCandidatesForResolve(term);
            window.__resolveCandidateState = window.__resolveCandidateState || {};
            window.__resolveCandidateState.term = term;
            window.__resolveCandidateState.results = Array.isArray(results) ? results : [];
            // Re-render just the results area
            const frame = (typeof window.__getModalFrame === 'function') ? window.__getModalFrame() : null;
            if (frame && frame.kind === 'timesheet-resolve-candidate') {
              frame.setTab('main');
            }
          } catch (err) {
            console.error('[TS][RESOLVE] candidate search failed', err);
            alert(err?.message || 'Candidate search failed.');
          }
        });
      }

      // Delegate click handler for "Select" buttons
      const resultsHost = root.querySelector('#candResolveResults');
      if (resultsHost && !resultsHost.__tsCandResolveSelectWired) {
        resultsHost.__tsCandResolveSelectWired = true;
        resultsHost.addEventListener('click', async (ev) => {
          const btn = ev.target.closest('button[data-act="resolve-cand-select"]');
          if (!btn) return;
          const candId = btn.getAttribute('data-candidate-id') || '';
          if (!candId) return;
          try {
            await apiResolveTimesheetCandidate(tsId, candId);
            window.__toast && window.__toast('Candidate mapping updated for timesheet.');

            // Close this child modal
            const closeBtn = document.getElementById('btnCloseModal');
            if (closeBtn) closeBtn.click();

            // Refresh the parent "Resolve timesheets" modal using stored selectionIds
            const state = window.__resolveTimesheetsState || {};
            const ids = Array.isArray(state.selectionIds) ? state.selectionIds : (state.rows || []).map(r => String(r.timesheet_id || r.id || '')).filter(Boolean);
            if (ids.length) {
              try {
                const res = await authFetch(API('/api/timesheets/resolve-preview'), {
                  method: 'POST',
                  headers: { 'content-type': 'application/json' },
                  body: JSON.stringify({ timesheet_ids: ids })
                });
                const text = await res.text();
                if (res.ok) {
                  const newRows = text ? JSON.parse(text) : [];
                  window.__resolveTimesheetsState.rows = Array.isArray(newRows) ? newRows : [];
                  const frame = (typeof window.__getModalFrame === 'function') ? window.__getModalFrame() : null;
                  if (frame && frame.kind === 'timesheets-resolve') {
                    frame.setTab('main');
                  }
                }
              } catch (e2) {
                console.warn('[TS][RESOLVE] failed to refresh resolve-preview after candidate assignment', e2);
              }
            }
          } catch (err) {
            console.error('[TS][RESOLVE] apiResolveTimesheetCandidate failed', err);
            alert(err?.message || 'Failed to assign candidate.');
          }
        });
      }
    } catch (e) {
      console.warn('[TS][RESOLVE] wiring resolve-candidate modal failed', e);
    }
  }, 0);
}

async function searchCandidatesForResolve(term) {
  const q = String(term || '').trim();
  if (!q) return [];

  const url = `/api/candidates?search=${encodeURIComponent(q)}`;

  const res  = await authFetch(API(url));
  const text = await res.text();

  if (!res.ok) {
    throw new Error(text || `Candidate search failed (${res.status})`);
  }

  let json;
  try {
    json = text ? JSON.parse(text) : [];
  } catch {
    json = [];
  }

  return Array.isArray(json) ? json : [];
}

async function apiResolveTimesheetCandidate(timesheetId, candidateId) {
  const tsId = String(timesheetId || '').trim();
  const candId = String(candidateId || '').trim();
  if (!tsId || !candId) {
    throw new Error('Missing timesheet_id or candidate_id for resolve.');
  }

  const res  = await authFetch(API(`/api/timesheets/${encodeURIComponent(tsId)}/resolve-candidate`), {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify({ candidate_id: candId })
  });
  const text = await res.text();

  if (!res.ok) {
    throw new Error(text || `Failed to resolve candidate for timesheet (${res.status})`);
  }
}

async function openResolveClientModal(resolveRow) {
  if (!resolveRow || !resolveRow.timesheet_id) {
    alert('Timesheet context missing for client resolve.');
    return;
  }

  const tsId   = resolveRow.timesheet_id;
  const hosp   = resolveRow.hospital_norm || '(unknown hospital/site)';
  const enc    = (typeof escapeHtml === 'function')
    ? escapeHtml
    : (s) => String(s == null ? '' : s);

  // Seed local state for this child modal
  window.__resolveClientState = {
    row: resolveRow,
    results: [],
    term: ''
  };

  const renderResolveClientTab = (key) => {
    if (key !== 'main') return '';
    const state   = window.__resolveClientState || {};
    const results = Array.isArray(state.results) ? state.results : [];

    const resultsHtml = results.length
      ? `
        <ul class="mini">
          ${results.map(c => `
            <li>
              <strong>${enc(c.name || c.client_name || '')}</strong>
              ${c.cli_ref ? ` &nbsp; <span class="mono">(${enc(c.cli_ref)})</span>` : ''}
              <button type="button"
                      class="btn mini"
                      data-act="resolve-client-select"
                      data-client-id="${enc(c.id)}">
                Select
              </button>
            </li>
          `).join('')}
        </ul>
      `
      : '<span class="mini">No clients loaded yet. Try a search.</span>';

    return html(`
      <div class="form" id="ts-resolve-client">
        <div class="card">
          <div class="row">
            <label>Assign client</label>
            <div class="controls">
              <div class="mini">
                Assign client / site for <strong>${enc(hosp)}</strong><br/>
                Timesheet: <span class="mono">${enc(tsId)}</span>
              </div>
            </div>
          </div>
        </div>

        <div class="card" style="margin-top:10px;">
          <div class="row">
            <label>Search</label>
            <div class="controls">
              <input id="clientResolveSearch"
                     class="input"
                     type="text"
                     placeholder="Search by client name or reference"
                     value="${enc(state.term || '')}" />
              <button type="button"
                      class="btn mini"
                      data-act="resolve-client-search">
                Search
              </button>
              <div class="hint mini" style="margin-top:4px;">
                This uses the same search as the Clients summary (name, CLI ref, etc.).
              </div>
            </div>
          </div>
          <div class="row">
            <label>Matches</label>
            <div class="controls" id="clientResolveResults">
              ${resultsHtml}
            </div>
          </div>
        </div>
      </div>
    `);
  };

  // Open as child modal
  showModal(
    'Assign client / site',
    [{ key: 'main', label: 'Assign client' }],
    renderResolveClientTab,
    null,
    false,
    null,
    {
      kind: 'timesheet-resolve-client',
      noParentGate: true,
      stayOpenOnSave: false
    }
  );

  // Wire search + select after render
  setTimeout(() => {
    try {
      const root = document.getElementById('modalBody');
      if (!root) return;

      const searchBtn   = root.querySelector('button[data-act="resolve-client-search"]');
      const searchInput = root.querySelector('#clientResolveSearch');

      if (searchBtn && !searchBtn.__tsClientResolveWired) {
        searchBtn.__tsClientResolveWired = true;
        searchBtn.addEventListener('click', async () => {
          const term = (searchInput && searchInput.value || '').trim();
          if (!term) {
            alert('Please enter something to search for.');
            return;
          }
          try {
            const results = await searchClientsForResolve(term);
            window.__resolveClientState = window.__resolveClientState || {};
            window.__resolveClientState.term = term;
            window.__resolveClientState.results = Array.isArray(results) ? results : [];
            const frame = (typeof window.__getModalFrame === 'function') ? window.__getModalFrame() : null;
            if (frame && frame.kind === 'timesheet-resolve-client') {
              frame.setTab('main');
            }
          } catch (err) {
            console.error('[TS][RESOLVE] client search failed', err);
            alert(err?.message || 'Client search failed.');
          }
        });
      }

      const resultsHost = root.querySelector('#clientResolveResults');
      if (resultsHost && !resultsHost.__tsClientResolveSelectWired) {
        resultsHost.__tsClientResolveSelectWired = true;
        resultsHost.addEventListener('click', async (ev) => {
          const btn = ev.target.closest('button[data-act="resolve-client-select"]');
          if (!btn) return;
          const clientId = btn.getAttribute('data-client-id') || '';
          if (!clientId) return;

          try {
            await apiResolveTimesheetClient(tsId, clientId);
            window.__toast && window.__toast('Client mapping updated for timesheet.');

            // Close the child modal
            const closeBtn = document.getElementById('btnCloseModal');
            if (closeBtn) closeBtn.click();

            // Refresh parent Resolve modal
            const state = window.__resolveTimesheetsState || {};
            const ids = Array.isArray(state.selectionIds)
              ? state.selectionIds
              : (state.rows || [])
                  .map(r => String(r.timesheet_id || r.id || ''))
                  .filter(Boolean);

            if (ids.length) {
              try {
                const res = await authFetch(API('/api/timesheets/resolve-preview'), {
                  method: 'POST',
                  headers: { 'content-type': 'application/json' },
                  body: JSON.stringify({ timesheet_ids: ids })
                });
                const text = await res.text();
                if (res.ok) {
                  const newRows = text ? JSON.parse(text) : [];
                  window.__resolveTimesheetsState.rows = Array.isArray(newRows) ? newRows : [];
                  const frame = (typeof window.__getModalFrame === 'function') ? window.__getModalFrame() : null;
                  if (frame && frame.kind === 'timesheets-resolve') {
                    frame.setTab('main');
                  }
                }
              } catch (e2) {
                console.warn('[TS][RESOLVE] failed to refresh resolve-preview after client assignment', e2);
              }
            }
          } catch (err) {
            console.error('[TS][RESOLVE] apiResolveTimesheetClient failed', err);
            alert(err?.message || 'Failed to assign client.');
          }
        });
      }
    } catch (e) {
      console.warn('[TS][RESOLVE] wiring resolve-client modal failed', e);
    }
  }, 0);
}

async function searchClientsForResolve(term) {
  const q = String(term || '').trim();
  if (!q) return [];

  const url = `/api/clients?search=${encodeURIComponent(q)}`;

  const res  = await authFetch(API(url));
  const text = await res.text();

  if (!res.ok) {
    throw new Error(text || `Client search failed (${res.status})`);
  }

  let json;
  try {
    json = text ? JSON.parse(text) : [];
  } catch {
    json = [];
  }

  return Array.isArray(json) ? json : [];
}


async function apiResolveTimesheetClient(timesheetId, clientId) {
  const tsId = String(timesheetId || '').trim();
  const cliId = String(clientId || '').trim();
  if (!tsId || !cliId) {
    throw new Error('Missing timesheet_id or client_id for resolve.');
  }

  const res  = await authFetch(API(`/api/timesheets/${encodeURIComponent(tsId)}/resolve-client`), {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify({ client_id: cliId })
  });
  const text = await res.text();

  if (!res.ok) {
    throw new Error(text || `Failed to resolve client for timesheet (${res.status})`);
  }
}


async function openImportsModal() {
  // Seed a neutral modalCtx for this screen
  window.modalCtx = {
    entity: 'imports',
    data: {},
    importsState: {}
  };

const renderImportsTab = (key) => {
  if (key !== 'main') return '';
  const enc = (typeof escapeHtml === 'function')
    ? escapeHtml
    : (s) => String(s == null ? '' : s);

  return html(`
    <div class="form" id="importsMain">
      <div class="card">
        <div class="row">
          <label>Imports</label>
          <div class="controls">
            <span class="mini">
              Use this screen to upload and process NHSP and HealthRoster files.
              Each tile accepts an Excel export from the corresponding system.
            </span>
          </div>
        </div>
      </div>

      <div class="grid-3" style="margin-top:10px;gap:12px;">
        <!-- NHSP Weekly Import -->
        <div class="card dropzone"
             id="nhspImportDrop"
             data-import-kind="nhsp">
          <div class="row">
            <label>NHSP Weekly Import</label>
            <div class="controls">
              <span class="mini">
                Drop NHSP weekly export anywhere in this tile or<br/>
                <input id="nhspImportFile"
                       type="file"
                       accept=".xls,.xlsx,.csv"
                       style="
                         margin-top:4px;
                         background:#020617;
                         border:1px solid var(--line);
                         color:var(--text);
                         border-radius:8px;
                         padding:6px 8px;
                         font-size:12px;
                       " />
              </span>
              <div class="hint mini" style="margin-top:4px;">
                NHSP weekly export (self-bill style). The system will parse, classify,
                let you resolve unmapped staff/clients, and then create weeks & timesheets.
              </div>
              <div id="nhspImportSummary" class="mini" style="margin-top:4px;"></div>
            </div>
          </div>
        </div>

        <!-- HealthRoster Weekly Import -->
        <div class="card dropzone"
             id="hrWeeklyImportDrop"
             data-import-kind="hr-weekly">
          <div class="row">
            <label>HealthRoster Weekly Import</label>
            <div class="controls">
              <span class="mini">
                Drop HealthRoster weekly export anywhere in this tile or<br/>
                <input id="hrWeeklyImportFile"
                       type="file"
                       accept=".xls,.xlsx,.csv"
                       style="
                         margin-top:4px;
                         background:#020617;
                         border:1px solid var(--line);
                         color:var(--text);
                         border-radius:8px;
                         padding:6px 8px;
                         font-size:12px;
                       " />
              </span>
              <div class="hint mini" style="margin-top:4px;">
                Weekly HealthRoster template shifts. These are auto-processed into
                nhsp_shifts / contract weeks, with optional candidate/client resolve.
              </div>
              <div id="hrWeeklyImportSummary" class="mini" style="margin-top:4px;"></div>
            </div>
          </div>
        </div>

        <!-- HealthRoster Rota Validation (Daily) -->
        <div class="card dropzone"
             id="hrRotaImportDrop"
             data-import-kind="hr-rota">
          <div class="row">
            <label>HealthRoster Rota Validation (Daily)</label>
            <div class="controls">
              <span class="mini">
                Drop HR rota daily export anywhere in this tile or<br/>
                <input id="hrRotaImportFile"
                       type="file"
                       accept=".xls,.xlsx,.csv"
                       style="
                         margin-top:4px;
                         background:#020617;
                         border:1px solid var(--line);
                         color:var(--text);
                         border-radius:8px;
                         padding:6px 8px;
                         font-size:12px;
                       " />
              </span>
              <div class="hint mini" style="margin-top:4px;">
                Daily HealthRoster rota used to validate self-reported daily timesheets.
                Weâ€™ll compare start/end/break/â€œActual Hoursâ€, check gradeâ†’roleâ†’rates, and
                let you queue mismatch emails to Temp Staffing.
              </div>
              <div id="hrRotaImportSummary" class="mini" style="margin-top:4px;"></div>
            </div>
          </div>
        </div>
      </div>
    </div>
  `);
};


  showModal(
    'Imports',
    [{ key: 'main', label: 'Imports' }],
    renderImportsTab,
    null,         // no onSave
    false,        // hasId
    null,         // onReturn
    {
      kind: 'imports',
      noParentGate: true,
      stayOpenOnSave: false
    }
  );

  // Install global drag/drop guards once so dropping files never opens them in a new tab
  if (!window.__importsGlobalDragGuards) {
    window.__importsGlobalDragGuards = true;

    const preventGlobal = (ev) => {
      ev.preventDefault();
      ev.stopPropagation();
    };

    window.addEventListener('dragover', preventGlobal);
    window.addEventListener('drop', preventGlobal);
  }

  // Wire file inputs and dropzones after the modal is rendered
  setTimeout(() => {
    try {
      wireImportDropzones();
    } catch (e) {
      console.warn('[IMPORTS] wireImportDropzones failed', e);
    }
  }, 0);
}

function wireImportDropzones() {
  const LOG = (typeof window.__LOG_IMPORTS === 'boolean') ? window.__LOG_IMPORTS : true;
  const L   = (...a) => { if (LOG) console.log('[IMPORTS]', ...a); };

  const root = document.getElementById('importsMain');
  if (!root) {
    if (LOG) L('wireImportDropzones: no importsMain root, skipping');
    return;
  }

  // Small helper to prevent default drag behaviour
  const prevent = (ev) => {
    ev.preventDefault();
    ev.stopPropagation();
  };

  const wireOneZone = (dropId, fileId, handler) => {
    const dz   = document.getElementById(dropId);
    const file = document.getElementById(fileId);

    if (!dz && !file) {
      if (LOG) L(`wireImportDropzones: missing elements for ${dropId}/${fileId}`);
      return;
    }

    // File input select
    if (file && !file.__importsWired) {
      file.__importsWired = true;
      file.addEventListener('change', async (ev) => {
        try {
          const files = ev.target.files ? Array.from(ev.target.files) : [];
          const f = files[0] || null;
          if (!f) return;
          await handler(f);
          ev.target.value = ''; // reset
        } catch (err) {
          console.error('[IMPORTS] file handler failed', err);
          alert(err?.message || 'Import failed.');
        }
      });
    }

    // Drag & drop
    if (dz && !dz.__importsWired) {
      dz.__importsWired = true;

      dz.addEventListener('dragenter', prevent);
      dz.addEventListener('dragover', (ev) => {
        prevent(ev);
        dz.classList && dz.classList.add('drop-hover');
      });
      dz.addEventListener('dragleave', (ev) => {
        prevent(ev);
        dz.classList && dz.classList.remove('drop-hover');
      });
      dz.addEventListener('drop', async (ev) => {
        prevent(ev);
        dz.classList && dz.classList.remove('drop-hover');

        try {
          const files = (ev.dataTransfer && ev.dataTransfer.files)
            ? Array.from(ev.dataTransfer.files)
            : [];
          const f = files[0] || null;
          if (!f) return;
          await handler(f);
        } catch (err) {
          console.error('[IMPORTS] drop handler failed', err);
          alert(err?.message || 'Import failed.');
        }
      });
    }
  };

  // NHSP Weekly
  wireOneZone('nhspImportDrop', 'nhspImportFile', handleNhspFileDrop);

  // HR Weekly autoprocess
  wireOneZone('hrWeeklyImportDrop', 'hrWeeklyImportFile', handleHrWeeklyFileDrop);

  // HR Rota daily
  wireOneZone('hrRotaImportDrop', 'hrRotaImportFile', handleHrRotaFileDrop);
}

async function handleNhspFileDrop(file) {
  const summaryEl = document.getElementById('nhspImportSummary');
  if (summaryEl) {
    summaryEl.textContent = 'Uploading NHSP file to storageâ€¦';
  }

  try {
    // 1) Upload file to R2 and get file_key
    const { fileKey, filename } = await uploadImportFileToR2(file);

    if (summaryEl) {
      summaryEl.textContent = 'Registering NHSP import and parsing workbookâ€¦';
    }

    // 2) Tell backend about the file so it can parse + classify
    const resUpload = await authFetch(API('/api/nhsp/import'), {
      method: 'POST',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify({
        original_name: filename,
        file_key: fileKey,
        tz_assumption: 'Europe/London'
      })
    });
    const textUpload = await resUpload.text();
    if (!resUpload.ok) {
      throw new Error(textUpload || `NHSP import upload failed (${resUpload.status})`);
    }

    let parsed;
    try { parsed = textUpload ? JSON.parse(textUpload) : {}; } catch { parsed = {}; }
    const importId = parsed.import_id || parsed.id || null;
    if (!importId) {
      throw new Error('NHSP import did not return an import_id.');
    }

    if (summaryEl) {
      summaryEl.textContent = `File uploaded. Loading NHSP classification for import ${importId}â€¦`;
    }

    // 3) Fetch preview / classification
    const resPrev  = await authFetch(API(`/api/nhsp/${encodeURIComponent(importId)}/preview`));
    const textPrev = await resPrev.text();
    if (!resPrev.ok) {
      throw new Error(textPrev || `NHSP import preview failed (${resPrev.status})`);
    }

    let summaryState;
    try { summaryState = textPrev ? JSON.parse(textPrev) : {}; } catch { summaryState = {}; }

    // 4) Persist and render summary modal
    window.modalCtx = window.modalCtx || {};
    window.modalCtx.importsState = window.modalCtx.importsState || {};
    window.modalCtx.importsState.nhsp = {
      import_id: importId,
      summary: summaryState
    };

    const total =
      (summaryState.summary && typeof summaryState.summary.total_rows === 'number')
        ? summaryState.summary.total_rows
        : Array.isArray(summaryState.rows) ? summaryState.rows.length : 0;

    if (summaryEl) {
      summaryEl.textContent = `Import ${importId}: ${total} rows parsed.`;
    }

    if (typeof renderImportSummaryModal === 'function') {
      renderImportSummaryModal('NHSP', summaryState);
    } else {
      console.warn('[IMPORTS] renderImportSummaryModal is not defined; NHSP summary not shown.');
    }
  } catch (err) {
    console.error('[IMPORTS][NHSP] handleNhspFileDrop failed', err);
    if (summaryEl) {
      summaryEl.textContent = `NHSP import failed: ${err?.message || 'Unknown error'}`;
    }
    alert(err?.message || 'NHSP import failed.');
  }
}

// Install once so dropping a file anywhere in the app never opens it in a new tab.
function installGlobalFileDropGuards() {
  if (window.__globalFileDropGuardsInstalled) return;
  window.__globalFileDropGuardsInstalled = true;

  const prevent = (ev) => {
    ev.preventDefault();
    ev.stopPropagation();
  };

  window.addEventListener('dragover', prevent);
  window.addEventListener('drop', prevent);
}

// Attach weekly summary behaviour (Assign buttons + optional group selection)
// Attach weekly summary behaviour (Assign buttons + optional group selection)
function wireWeeklyImportSummaryActions(type, importId) {
  const t = String(type || '').toUpperCase();
  if (t !== 'NHSP' && t !== 'HR_WEEKLY') return;

  const root = document.getElementById('weeklyImportSummary');
  if (!root) return;
  if (root.__weeklyWired) return;
  root.__weeklyWired = true;

  window.__importSummaryState   = window.__importSummaryState   || {};
  window.__weeklyImportMappings = window.__weeklyImportMappings || {};
  window.__weeklySelectedGroups = window.__weeklySelectedGroups || {};

  // Ensure mapping container exists for this type+importId
  if (!window.__weeklyImportMappings[t]) {
    window.__weeklyImportMappings[t] = {};
  }
  if (!window.__weeklySelectedGroups[t]) {
    window.__weeklySelectedGroups[t] = {};
  }

  const ensureMappings = (id) => {
    const key = String(id || importId || '');
    let mRoot = window.__weeklyImportMappings[t];
    let m = mRoot[key];
    if (!m) {
      m = {
        candidate_mappings: [],
        client_aliases: []
      };
      mRoot[key] = m;
    }
    return m;
  };

  const ensureSelectedSet = (id) => {
    const key = String(id || importId || '');
    let sRoot = window.__weeklySelectedGroups[t];
    let s = sRoot[key];
    if (!(s instanceof Set)) {
      s = new Set();
      sRoot[key] = s;
    }
    return s;
  };

  // Always read the latest state/rows so refreshes & re-renders work
  const getState = () => {
    const state = window.__importSummaryState[t] || {};
    const rows  = Array.isArray(state.rows) ? state.rows : [];
    const id    = state.import_id || importId;
    return { state, rows, importId: id };
  };

  const norm = (s) => String(s || '').trim().toLowerCase();

  // Helper: best-effort fetch of candidate name for warning
  async function fetchCandidateName(candId) {
    try {
      if (typeof authFetch !== 'function' || typeof API !== 'function') return null;
      const res  = await authFetch(API(`/api/candidates/${encodeURIComponent(candId)}`));
      const text = await res.text();
      if (!res.ok || !text) return null;
      const json = JSON.parse(text);
      const c = json && json.candidate ? json.candidate : json;
      if (!c) return null;
      return (
        c.display_name ||
        c.name ||
        `${c.first_name || ''} ${c.last_name || ''}`.trim() ||
        null
      );
    } catch {
      return null;
    }
  }

  // Handle Assign candidate/client buttons and (optionally) checkbox selection
  root.addEventListener('click', async (ev) => {
    const btn = ev.target.closest('button[data-act]');
    if (!btn) return;

    const act = btn.getAttribute('data-act');
    if (act !== 'weekly-resolve-candidate' && act !== 'weekly-resolve-client') {
      return;
    }

    const { rows, importId: currentImportId } = getState();
    const idx = Number(btn.getAttribute('data-row-idx') || '-1');
    const row = (idx >= 0 && idx < rows.length) ? rows[idx] : null;
    if (!row) return;

    const mappings = ensureMappings(currentImportId);

    if (act === 'weekly-resolve-candidate') {
      const staffRaw = row.staff_name || row.staff_raw || '';
      const hospRaw  = row.hospital_or_trust || row.unit || row.hospital_norm || '';

      const candId = (prompt(
        `Enter candidate_id to map staff "${staffRaw}" (site: "${hospRaw}") to:`,
        row.candidate_id || ''
      ) || '').trim();

      if (!candId) return;

      // Try to fetch candidate name for a smarter warning
      let candName = await fetchCandidateName(candId);
      const staffNorm = norm(staffRaw);
      const candNorm  = norm(candName || '');
      const staffTokens = staffNorm ? staffNorm.split(/\s+/).filter(Boolean) : [];
      const candTokens  = candNorm  ? candNorm.split(/\s+/).filter(Boolean)  : [];

      let confirmMsg;
      if (candName && staffTokens.length && candTokens.length) {
        const hasSharedToken = staffTokens.some(t => candTokens.includes(t));
        const workDateYmd =
          row.work_date ||
          row.date_local ||
          row.date ||
          row.week_ending_date ||
          null;

        if (!hasSharedToken) {
          confirmMsg =
            `âš  WARNING:\n` +
            `Imported staff name: "${staffRaw}"\n` +
            `Chosen candidate:    "${candName}" (id: ${candId})\n\n` +
            `These names do not share any words.\n\n` +
            `Are you sure you want to link this candidate for ` +
            `${workDateYmd || 'this date'} at "${hospRaw || 'unknown site'}"?`;
        } else {
          confirmMsg =
            `Confirm linking:\n\n` +
            `  Staff (import): "${staffRaw}"\n` +
            `  Candidate:      "${candName}" (id: ${candId})\n` +
            `  Site:           "${hospRaw || 'unknown site'}"\n\n` +
            `Proceed?`;
        }
      } else {
        // Fallback confirm when we don't have a nice name
        confirmMsg =
          `Link imported staff "${staffRaw}" at "${hospRaw || 'unknown site'}"\n` +
          `to candidate_id "${candId}"?\n\n` +
          `This will create/update an alias used for future imports.`;
      }

      if (!window.confirm(confirmMsg)) {
        return;
      }

      mappings.candidate_mappings.push({
        staff_norm:       row.staff_norm || staffRaw || '',
        hospital_or_trust: hospRaw || null,
        candidate_id:     candId
      });

      if (window.__toast) {
        window.__toast('Candidate mapping queued for this import.');
      }
      return;
    }

    if (act === 'weekly-resolve-client') {
      const hospRaw = row.hospital_or_trust || row.unit || row.hospital_norm || '';

      const clientId = (prompt(
        `Enter client_id to map hospital/site "${hospRaw}" to:`,
        row.client_id || ''
      ) || '').trim();

      if (!clientId) return;

      const confirmMsg =
        `Link import site "${hospRaw || 'unknown site'}"\n` +
        `to client_id "${clientId}"?\n\n` +
        `This will create/update a client_hospitals alias for future imports.`;

      if (!window.confirm(confirmMsg)) {
        return;
      }

      mappings.client_aliases.push({
        hospital_norm: row.hospital_norm || hospRaw || '',
        client_id:     clientId
      });

      if (window.__toast) {
        window.__toast('Client mapping queued for this import.');
      }
    }
  });

  // Optional: handle group selection checkboxes if you add them later
  // (e.g. <input type="checkbox" data-act="weekly-select-group" data-group-id="...">)
  root.addEventListener('change', (ev) => {
    const cb = ev.target.closest('input[data-act="weekly-select-group"]');
    if (!cb) return;

    const { importId: currentImportId } = getState();
    const sel = ensureSelectedSet(currentImportId);

    const groupId = cb.getAttribute('data-group-id') || '';
    if (!groupId) return;

    if (cb.checked) {
      sel.add(groupId);
    } else {
      sel.delete(groupId);
    }
  });
}

// Normalise mappings object for a given type/importId into the payload shape
function getWeeklyImportMappings(type, importId) {
  const t = String(type || '').toUpperCase();
  const mRoot = (window.__weeklyImportMappings && window.__weeklyImportMappings[t]) || {};
  const m     = mRoot[importId] || {};

  const candidate_mappings = Array.isArray(m.candidate_mappings)
    ? m.candidate_mappings.slice()
    : [];

  const client_aliases = Array.isArray(m.client_aliases)
    ? m.client_aliases.slice()
    : [];

  return { candidate_mappings, client_aliases };
}

// Build an array of preview_group_ids selected in the weekly summary (if implemented)
function getWeeklySelectedGroupIds(type, importId) {
  const t = String(type || '').toUpperCase();

  // Preferred way: honour the selected set maintained by wireWeeklyImportSummaryActions
  if (window.__weeklySelectedGroups &&
      window.__weeklySelectedGroups[t] &&
      window.__weeklySelectedGroups[t][importId] instanceof Set) {
    return Array.from(window.__weeklySelectedGroups[t][importId]);
  }

  // Fallback: read from DOM checkboxes if present
  const root = document.getElementById('weeklyImportSummary');
  if (!root) return [];

  const selected = [];
  const cbs = root.querySelectorAll('input[data-act="weekly-select-group"]');
  cbs.forEach(cb => {
    if (!cb.checked) return;
    const gid = cb.getAttribute('data-group-id');
    if (gid) selected.push(gid);
  });

  return selected;
}


async function handleHrWeeklyFileDrop(file) {
  const summaryEl = document.getElementById('hrWeeklyImportSummary');
  if (summaryEl) {
    summaryEl.textContent = 'Preparing HealthRoster weekly importâ€¦';
  }

  try {
    // Ensure modalCtx/importsState exist
    window.modalCtx = window.modalCtx || {};
    window.modalCtx.importsState = window.modalCtx.importsState || {};
    const st = window.modalCtx.importsState;

    // 0) Ensure a client_id is selected (use picker if missing)
    let clientId =
      st.hrWeeklyClientId ? String(st.hrWeeklyClientId).trim() : '';
    let clientName = st.hrWeeklyClientName || '';

    if (!clientId) {
      const picked = await openHrWeeklyClientPicker();
      if (!picked) {
        throw new Error('Select a client for the HealthRoster weekly import before uploading.');
      }
      clientId   = String(picked.clientId || '').trim();
      clientName = picked.clientName || '';

      st.hrWeeklyClientId   = clientId;
      st.hrWeeklyClientName = clientName;
    }

    if (summaryEl) {
      summaryEl.textContent =
        `Client: ${clientName || clientId} â€” uploading HealthRoster weekly file to storageâ€¦`;
    }

    // 1) Upload file to R2
    const { fileKey, filename } = await uploadImportFileToR2(file);

    if (summaryEl) {
      summaryEl.textContent = 'Registering HealthRoster weekly import and parsing workbookâ€¦';
    }

    // 2) Register HR autoprocess import
    const resUpload = await authFetch(API('/api/healthroster/autoprocess/import'), {
      method: 'POST',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify({
        original_name: filename,
        file_key: fileKey,
        client_id: clientId,
        tz_assumption: 'Europe/London'
      })
    });
    const textUpload = await resUpload.text();
    if (!resUpload.ok) {
      throw new Error(textUpload || `HealthRoster weekly import upload failed (${resUpload.status})`);
    }

    let parsed;
    try { parsed = textUpload ? JSON.parse(textUpload) : {}; } catch { parsed = {}; }
    const importId = parsed.import_id || parsed.id || null;
    if (!importId) {
      throw new Error('HealthRoster weekly import did not return an import_id.');
    }

    if (summaryEl) {
      summaryEl.textContent =
        `File uploaded. Loading HealthRoster weekly classification for import ${importId}â€¦`;
    }

    // 3) Fetch preview / classification
    const resPrev  = await authFetch(API(`/api/healthroster/autoprocess/${encodeURIComponent(importId)}/preview`));
    const textPrev = await resPrev.text();
    if (!resPrev.ok) {
      throw new Error(textPrev || `HealthRoster weekly preview failed (${resPrev.status})`);
    }

    let summaryState;
    try { summaryState = textPrev ? JSON.parse(textPrev) : {}; } catch { summaryState = {}; }

    // 4) Persist and render summary modal
    window.modalCtx = window.modalCtx || {};
    window.modalCtx.importsState = window.modalCtx.importsState || {};
    window.modalCtx.importsState.hrWeekly = {
      import_id: importId,
      summary: summaryState
    };

    const total =
      (summaryState.summary && typeof summaryState.summary.total_rows === 'number')
        ? summaryState.summary.total_rows
        : Array.isArray(summaryState.rows) ? summaryState.rows.length : 0;

    if (summaryEl) {
      summaryEl.textContent =
        `Import ${importId} (${clientName || clientId}): ${total} rows parsed.`;
    }

    if (typeof renderImportSummaryModal === 'function') {
      renderImportSummaryModal('HR_WEEKLY', summaryState);
    } else {
      console.warn('[IMPORTS] renderImportSummaryModal is not defined; HR weekly summary not shown.');
    }
  } catch (err) {
    console.error('[IMPORTS][HR_WEEKLY] handleHrWeeklyFileDrop failed', err);
    if (summaryEl) {
      summaryEl.textContent =
        `HealthRoster weekly import failed: ${err?.message || 'Unknown error'}`;
    }
    alert(err?.message || 'HealthRoster weekly import failed.');
  }
}



async function handleHrRotaFileDrop(file) {
  const summaryEl = document.getElementById('hrRotaImportSummary');
  if (summaryEl) {
    summaryEl.textContent = 'Uploading HR rota daily file to storageâ€¦';
  }

  try {
    // 1) Upload file to R2
    const { fileKey, filename } = await uploadImportFileToR2(file);

    if (summaryEl) {
      summaryEl.textContent = 'Registering HR rota daily import and parsing workbookâ€¦';
    }

    // 2) Call parse endpoint with JSON and file_r2_key
    const res = await authFetch(API('/api/imports/hr-rota/parse'), {
      method: 'POST',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify({
        file_r2_key: fileKey,
        original_name: filename
      })
    });
    const text = await res.text();
    if (!res.ok) {
      throw new Error(text || `HR rota daily import upload failed (${res.status})`);
    }

    let parsed;
    try { parsed = text ? JSON.parse(text) : {}; } catch { parsed = {}; }
    const importId = parsed.import_id || parsed.id || null;
    if (!importId) {
      throw new Error('HR rota daily import did not return an import_id.');
    }

    if (summaryEl) {
      summaryEl.textContent =
        `File uploaded. Loading HR rota classification for import ${importId}â€¦`;
    }

    // 3) Fetch preview / classification
    const previewRes  = await authFetch(API(`/api/imports/hr-rota/${encodeURIComponent(importId)}/preview`));
    const previewText = await previewRes.text();
    if (!previewRes.ok) {
      throw new Error(previewText || `HR rota daily preview failed (${previewRes.status})`);
    }

    let summaryState;
    try { summaryState = previewText ? JSON.parse(previewText) : {}; } catch { summaryState = {}; }

    // 4) Persist into modalCtx and render summary modal
    window.modalCtx = window.modalCtx || {};
    window.modalCtx.importsState = window.modalCtx.importsState || {};
    window.modalCtx.importsState.hrRota = {
      import_id: importId,
      summary: summaryState
    };

    const total =
      (summaryState.summary && typeof summaryState.summary.total_rows === 'number')
        ? summaryState.summary.total_rows
        : Array.isArray(summaryState.rows) ? summaryState.rows.length : 0;

    if (summaryEl) {
      summaryEl.textContent = `Import ${importId}: ${total} rows parsed.`;
    }

    if (typeof renderImportSummaryModal === 'function') {
      renderImportSummaryModal('HR_ROTA_DAILY', summaryState);
    } else {
      console.warn('[IMPORTS] renderImportSummaryModal is not defined; HR rota summary not shown.');
    }
  } catch (err) {
    console.error('[IMPORTS][HR_ROTA] handleHrRotaFileDrop failed', err);
    if (summaryEl) {
      summaryEl.textContent =
        `HR rota daily import failed: ${err?.message || 'Unknown error'}`;
    }
    alert(err?.message || 'HR rota daily import failed.');
  }
}

async function searchClientsForResolve(term) {
  const q = String(term || '').trim();
  if (!q) return [];

  const url = `/api/clients?search=${encodeURIComponent(q)}`;

  const res  = await authFetch(API(url));
  const text = await res.text();

  if (!res.ok) {
    throw new Error(text || `Client search failed (${res.status})`);
  }

  let json;
  try {
    json = text ? JSON.parse(text) : [];
  } catch {
    json = [];
  }

  return Array.isArray(json) ? json : [];
}

async function resolveImportConflicts(importId, importType, mappings) {
  const type = String(importType || '').toUpperCase();
  const encId = encodeURIComponent(String(importId || ''));

  if (!encId) {
    throw new Error('Missing import_id for resolveImportConflicts.');
  }

  const body = mappings || {};
  const payload = {
    candidate_mappings: Array.isArray(body.candidate_mappings) ? body.candidate_mappings : [],
    client_aliases: Array.isArray(body.client_aliases) ? body.client_aliases : []
    // selected_group_ids can be added here later if/when you add per-group checkboxes
  };

  if (type === 'NHSP') {
    const url = `/api/nhsp/${encId}/apply`;
    const res = await authFetch(API(url), {
      method: 'POST',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify(payload)
    });
    const text = await res.text();
    if (!res.ok) {
      throw new Error(text || `NHSP import apply failed (${res.status})`);
    }
    window.__toast && window.__toast('NHSP import applied.');
    return;
  }

  if (type === 'HR_WEEKLY') {
    const url = `/api/healthroster/${encId}/autoprocess-apply`;
    const res = await authFetch(API(url), {
      method: 'POST',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify(payload)
    });
    const text = await res.text();
    if (!res.ok) {
      throw new Error(text || `HealthRoster weekly apply failed (${res.status})`);
    }
    window.__toast && window.__toast('HealthRoster weekly import applied.');
    return;
  }

  if (type === 'HR_ROTA_DAILY') {
    // HR rota uses applyHrRotaValidation, not this helper.
    console.warn('[IMPORTS] resolveImportConflicts called for HR_ROTA_DAILY; nothing to apply here.');
    return;
  }

  throw new Error(`Unsupported import type for resolveImportConflicts: ${type}`);
}


async function uploadImportFileToR2(file) {
  if (!file) {
    throw new Error('No file provided for upload.');
  }

  const filename    = file.name || 'import.xlsx';
  const contentType =
    file.type ||
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';

  // 1) Get presigned URL + key
  const presignRes = await authFetch(API('/api/files/presign-upload'), {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify({
      filename,
      content_type: contentType,
      use_case: 'IMPORT'
    })
  });
  const presignText = await presignRes.text();
  if (!presignRes.ok) {
    throw new Error(
      presignText || `Failed to presign upload (${presignRes.status})`
    );
  }

  let presign;
  try { presign = presignText ? JSON.parse(presignText) : {}; } catch { presign = {}; }

  const uploadUrl = presign.upload_url;
  const fileKey   = presign.key;

  if (!uploadUrl || !fileKey) {
    throw new Error('Presign response missing upload_url or key.');
  }

  // 2) PUT the file to R2
  const putRes  = await fetch(uploadUrl, {
    method: 'PUT',
    headers: { 'content-type': contentType },
    body: file
  });
  const putText = await putRes.text().catch(() => '');
  if (!putRes.ok) {
    throw new Error(putText || `File upload failed (${putRes.status})`);
  }

  return { fileKey, filename };
}




async function applyHrRotaValidation(importId, sendEmailRowIds) {
  const encId = encodeURIComponent(String(importId || ''));
  if (!encId) {
    throw new Error('Missing import_id for applyHrRotaValidation.');
  }

  const body = {
    send_email_row_ids: Array.isArray(sendEmailRowIds) ? sendEmailRowIds : []
  };

  const res  = await authFetch(API(`/api/imports/hr-rota/${encId}/apply`), {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify(body)
  });
  const text = await res.text();
  if (!res.ok) {
    throw new Error(text || `HR rota apply failed (${res.status})`);
  }

  let payload;
  try { payload = text ? JSON.parse(text) : {}; } catch { payload = {}; }

  const ok     = payload.validations_ok    ?? 0;
  const failed = payload.validations_failed ?? 0;
  const emailed= payload.emails_queued     ?? (body.send_email_row_ids.length || 0);

  const msg = `Applied HR rota validations (${ok} OK, ${failed} failed, ${emailed} emails queued).`;
  window.__toast && window.__toast(msg);

  // Optional: you could auto-close the summary modal here or re-render it.
  return payload;
}

async function apiQueueHrRotaTsoEmail(row) {
  if (!row || !row.timesheet_id) {
    throw new Error('Missing timesheet_id for TSO email.');
  }

  const body = {
    timesheet_id: row.timesheet_id,
    hr_request_id: row.request_id || row.hr_request_id || null,
    reason_code: row.failure_reason || row.reason_code || null,
    mismatch_details: row.detail || null
  };

  const res  = await authFetch(API('/api/hr/rota/tso-email'), {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify(body)
  });
  const text = await res.text();

  if (!res.ok) {
    throw new Error(text || `Failed to queue HR rota TSO email (${res.status})`);
  }

  window.__toast && window.__toast('Query email queued to Temporary Staffing.');
}


























































function ensureSelection(section) {
  window.__selection = window.__selection || {};
  if (!window.__selection[section]) {
    window.__selection[section] = {
      fingerprint: '',
      ids: new Set(),
    };
  }
  return window.__selection[section];
}

function getSelectionSnapshot(section) {
  const sel = ensureSelection(section);
  return {
    fingerprint: sel.fingerprint || '',
    ids: Array.from(sel.ids || []),
    section,
  };
}
function applySelectionSnapshot(section, snapshot) {
  if (!snapshot || (snapshot.section && snapshot.section !== section)) {
    return getSelectionSnapshot(section);
  }
  const sel = ensureSelection(section);
  sel.fingerprint = String(snapshot.fingerprint || sel.fingerprint || '');
  sel.ids = new Set((snapshot.ids || []).map(String));
  return getSelectionSnapshot(section);
}

function isRowSelected(section, id) {
  if (!id) return false;
  return ensureSelection(section).ids.has(String(id));
}

function setRowSelected(section, id, selected) {
  if (!id) return getSelectionSnapshot(section);
  const sel = ensureSelection(section);
  const key = String(id);
  if (selected) sel.ids.add(key);
  else sel.ids.delete(key);
  return getSelectionSnapshot(section);
}


async function applyShortlistFilter(section, { ids }) {
  const cleanIds = Array.isArray(ids) ? ids.map(String).filter(Boolean) : [];
  if (!cleanIds.length) {
    alert('No records selected to focus.');
    return;
  }

  // Reset paging & REPLACE existing filters with IDs-only
  window.__listState = window.__listState || {};
  const st = (window.__listState[section] ||= {
    page: 1, pageSize: 50, total: null, hasMore: false, filters: null,
  });
  st.page = 1;
  st.filters = { ids: cleanIds }; // â† replace, don't merge

  // Mirror into selection for checkbox sync
  const sel = ensureSelection(section);
  sel.fingerprint = JSON.stringify({ section, filters: st.filters || {} });
  sel.ids = new Set(cleanIds);

  // Reload with the focused shortlist
  const rows = await search(section, st.filters);
  renderSummary(rows);
}


// Convenience: focus current selection by applying its IDs as a filter
async function focusCurrentSelection(section) {
  const sel = ensureSelection(section);
  const ids = Array.from(sel.ids || []);
  if (!ids.length) {
    alert('No records selected to focus.');
    return;
  }
  await applyShortlistFilter(section, { ids });
}

// Apply IDs-only selection as a filter and reload
// Apply IDs-only selection as a filter and reload
async function applySelectionAsFilter(section, selectionSnapshot) {
  const ids = Array.isArray(selectionSnapshot?.ids)
    ? selectionSnapshot.ids.map(String).filter(Boolean)
    : [];

  if (!ids.length) {
    alert('No records selected to focus.');
    return;
  }

  // Reset paging & REPLACE existing filters with IDs-only
  window.__listState = window.__listState || {};
  const st = (window.__listState[section] ||= {
    page: 1, pageSize: 50, total: null, hasMore: false, filters: null,
  });
  st.page = 1;
  st.filters = { ids }; // â† replace, don't merge

  // Mirror into selection for checkbox sync
  const sel = ensureSelection(section);
  sel.fingerprint = JSON.stringify({ section, filters: st.filters || {} });
  sel.ids = new Set(ids);

  // Reload data and re-render
  const rows = await search(section, st.filters);
  renderSummary(rows);
}





function clearSelection(section) {
  const sel = ensureSelection(section);
  sel.ids.clear();
  return getSelectionSnapshot(section);
}

function serializeSelection(section) {
  return getSelectionSnapshot(section);
}



function mergeSelectionSnapshots(section, baseSnapshot, addSnapshot) {
  const base = baseSnapshot || getSelectionSnapshot(section);
  const add  = addSnapshot  || {};
  const result = {
    fingerprint: base.fingerprint || add.fingerprint || '',
    ids: Array.from(new Set([
      ...(base.ids || []).map(String),
      ...(add.ids  || []).map(String),
    ])),
    section
  };
  return applySelectionSnapshot(section, result);
}

function dedupeIds(arr) {
  return Array.from(new Set((arr || []).map(String)));
}

async function openHrWeeklyClientPicker() {
  // Ensure modalCtx + importsState exist
  window.modalCtx = window.modalCtx || {};
  window.modalCtx.importsState = window.modalCtx.importsState || {};
  const st = window.modalCtx.importsState;

  // If we already have a choice cached, just return it
  if (st.hrWeeklyClientId) {
    return {
      clientId: st.hrWeeklyClientId,
      clientName: st.hrWeeklyClientName || ''
    };
  }

  // 1) Load list of HR autoprocess clients from backend
  let items = [];
  try {
    const res  = await authFetch(API('/api/healthroster/autoprocess/clients'));
    const text = await res.text();
    if (!res.ok) {
      throw new Error(text || `Failed to load HealthRoster clients (${res.status})`);
    }
    const json = text ? JSON.parse(text) : {};
    items = Array.isArray(json.items) ? json.items : [];
  } catch (e) {
    console.error('[IMPORTS][HR_WEEKLY] failed to load clients', e);
    alert(e?.message || 'Failed to load HealthRoster clients for weekly import.');
    return null;
  }

  if (!items.length) {
    alert('No HealthRoster weekly import clients are configured.');
    return null;
  }

  // 2) Show a small modal to pick one client
  return new Promise((resolve) => {
    // Build options HTML (use escapeHtml if you have it; otherwise keep it simple)
    const optionsHtml = items.map((c) => {
      const name = (c.client_name || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
      return `<option value="${c.client_id}">${name}</option>`;
    }).join('');

    showModal(
      'Select HealthRoster client',
      [{ key: 'main', label: 'Select client' }],
      ($root) => {
        $root.innerHTML = `
          <div class="form">
            <div class="row">
              <label>Client</label>
              <div class="controls">
                <select id="hrWeeklyClientSelect">
                  <option value="">-- choose a client --</option>
                  ${optionsHtml}
                </select>
              </div>
            </div>
            <p class="hint">
              This client will be used for parsing and applying this HealthRoster
              weekly export. You can change it in future imports.
            </p>
          </div>
        `;
      },
      async () => {
        const sel = document.getElementById('hrWeeklyClientSelect');
        if (!sel || !sel.value) {
          alert('Please select a client to continue.');
          return false; // keep modal open
        }

        const clientId   = sel.value;
        const clientName = sel.options[sel.selectedIndex].textContent;

        // Cache in modalCtx so subsequent imports can reuse the same choice
        st.hrWeeklyClientId   = clientId;
        st.hrWeeklyClientName = clientName;

        resolve({ clientId, clientName });
        return true; // close modal
      },
      false,
      null,
      { kind: 'hr-weekly-client-picker', noParentGate: true }
    );
  });
}




// =================== ADD HOSPITAL MODAL (UPDATED: push into stagedNew) ===================
// ==== CHILD MODAL (ADD HOSPITAL) â€” throw on errors; return true on success ====

function openClientHospitalModal(client_id) {
  const parentFrame = _currentFrame();
  // âœ… Allow create OR edit to add hospitals pre-save
  const parentEditable = parentFrame && (parentFrame.mode === 'edit' || parentFrame.mode === 'create');
  const ctx = window.modalCtx; // ðŸ”§ use canonical context

  const formHtml = html(`
    <div class="form" id="hospitalForm">
      ${input('hospital_name_norm','Hospital / Trust (normalised)','', 'text', parentEditable ? {} : { disabled:true })}
      ${input('ward_hint','Ward hint (optional)','', 'text', parentEditable ? {} : { disabled:true })}
    </div>
  `);

  // â¬‡ï¸ Key change: pass noParentGate so the child save isn't blocked by the "not dirty" guard
  showModal(
    'Add Hospital / Ward',
    [{key:'form',label:'Form'}],
    () => formHtml,
    async ()=> {
      const pf = _parentFrame();
      // âœ… Allow create OR edit to apply
      if (!pf || (pf.mode !== 'edit' && pf.mode !== 'create')) return false;

      const raw  = collectForm('#hospitalForm');
      const name = String(raw.hospital_name_norm || '').trim();
      if (!name) { alert('Hospital / Trust is required'); return false; }

      const H = ctx.hospitalsState || (ctx.hospitalsState = { existing: [], stagedNew: [], stagedEdits:{}, stagedDeletes: new Set() });
      H.stagedNew.push({ hospital_name_norm: name, ward_hint: (raw.ward_hint || '').trim() || null });

      try { window.dispatchEvent(new CustomEvent('modal-dirty')); } catch {}
      try { renderClientHospitalsTable(); } catch {}
      return true; // Apply closes child
    },
    false,
    () => {
      const parent = _currentFrame();
      if (parent) { parent.currentTabKey = 'hospitals'; parent.setTab('hospitals'); }
    },
    // â¬‡ï¸ Options: bypass parent-gate guard for this child modal only
    { noParentGate: true, forceEdit: true, kind: 'client-hospital' }
  );
}

async function openWeeklyCandidateResolveModal(importType, importId, rowIdx) {
  const type = String(importType || '').toUpperCase();
  const enc  = (typeof escapeHtml === 'function')
    ? escapeHtml
    : (s) => String(s == null ? '' : s);

  const st   = window.__importSummaryState && window.__importSummaryState[type];
  const rows = st && Array.isArray(st.rows) ? st.rows : [];
  const row  = (rowIdx >= 0 && rowIdx < rows.length) ? rows[rowIdx] : null;
  if (!row) {
    alert('Row not found for candidate resolve.');
    return;
  }

  const staffRaw = row.staff_name || row.staff_raw || '';
  const unitRaw  = row.unit || row.hospital_or_trust || row.hospital_norm || '';

  // Local state for this modal
  window.__weeklyResolveCandidateState = {
    type,
    importId,
    rowIdx,
    term: staffRaw,
    results: [],
    selectedCandidateId: null
  };

  const state = () => window.__weeklyResolveCandidateState || {};

  const renderTab = (key) => {
    if (key !== 'main') return '';
    const s = state();
    const term    = s.term || '';

    // Results box will be filled dynamically
    return html(`
      <div class="form" id="weeklyResolveCandidate">
        <div class="card">
          <div class="row">
            <label>Assign candidate</label>
            <div class="controls">
              <div class="mini">
                Import: <span class="mono">${enc(importId || '')}</span><br/>
                Staff (from import): <strong>${enc(staffRaw || 'â€”')}</strong><br/>
                Unit / Site: <span class="mini">${enc(unitRaw || 'â€”')}</span>
              </div>
            </div>
          </div>
        </div>

        <div class="card" style="margin-top:10px;">
          <div class="row">
            <label>Candidate name</label>
            <div class="controls">
              <input id="weeklyCandSearch"
                     class="input"
                     type="text"
                     placeholder="Type to search by first or surname"
                     value="${enc(term)}" />
              <div class="hint mini" style="margin-top:4px;">
                Start typing the candidate's name. The list on the right will filter as you type.
              </div>
            </div>
          </div>
          <div class="row">
            <label>Matches</label>
            <div class="controls" id="weeklyCandResults">
              <!-- results injected dynamically -->
              <span class="mini">Type a name to search for candidates.</span>
            </div>
          </div>
          <div class="row" style="margin-top:8px;">
            <label></label>
            <div class="controls">
              <button type="button"
                      class="btn btn-primary"
                      data-act="weekly-cand-link">
                Link to this candidate
              </button>
              <button type="button"
                      class="btn"
                      style="margin-left:8px;"
                      data-act="weekly-cand-cancel">
                Cancel
              </button>
            </div>
          </div>
        </div>
      </div>
    `);
  };

  // Open child modal
  showModal(
    'Assign candidate (weekly import)',
    [{ key: 'main', label: 'Assign candidate' }],
    renderTab,
    null,
    false,
    null,
    {
      kind: 'weekly-resolve-candidate',
      noParentGate: true,
      stayOpenOnSave: false
    }
  );

  // Helper: render results into the existing results container
  function renderCandidateResults() {
    const s = state();
    const results    = Array.isArray(s.results) ? s.results : [];
    const selectedId = s.selectedCandidateId || '';

    const root = document.getElementById('modalBody');
    if (!root) return;
    const host = root.querySelector('#weeklyCandResults');
    if (!host) return;

    if (!results.length) {
      host.innerHTML = '<span class="mini">No candidates matched. Try typing a different name.</span>';
      return;
    }

    const listHtml = `
      <div class="card" style="max-height:250px;overflow:auto;border:1px solid #ddd;margin-top:4px;">
        <ul class="mini">
          ${results.map(c => {
            const id   = c.id;
            const name = c.display_name || c.name || ((c.first_name || '') + ' ' + (c.last_name || ''));
            const selected = String(id) === String(selectedId);
            const style = selected ? ' style="background:#007bff;color:#fff;cursor:pointer;"' : ' style="cursor:pointer;"';
            return `
              <li class="weekly-candidate-option"${style}
                  data-act="weekly-cand-select"
                  data-candidate-id="${enc(id)}">
                <strong>${enc(name || '')}</strong>
                ${c.tms_ref ? ` &nbsp; <span class="mono">(${enc(c.tms_ref)})</span>` : ''}
              </li>
            `;
          }).join('')}
        </ul>
      </div>
    `;

    host.innerHTML = listHtml;
  }

  // Helper: run search and update results
  async function searchAndRender(term) {
    const q = String(term || '').trim();
    window.__weeklyResolveCandidateState = state();
    window.__weeklyResolveCandidateState.term = q;
    if (!q) {
      window.__weeklyResolveCandidateState.results = [];
      window.__weeklyResolveCandidateState.selectedCandidateId = null;
      renderCandidateResults();
      return;
    }
    try {
      const results = await searchCandidatesForResolve(q);
      window.__weeklyResolveCandidateState.results = Array.isArray(results) ? results : [];
      // Auto-select if exactly one result
      if (results && results.length === 1) {
        window.__weeklyResolveCandidateState.selectedCandidateId = results[0].id;
      }
    } catch (err) {
      console.error('[WEEKLY][RESOLVE] candidate search failed', err);
      alert(err?.message || 'Candidate search failed.');
      window.__weeklyResolveCandidateState.results = [];
      window.__weeklyResolveCandidateState.selectedCandidateId = null;
    }
    renderCandidateResults();
  }

  // Wire input + click handlers after first render
  setTimeout(() => {
    const root = document.getElementById('modalBody');
    if (!root) return;

    const input = root.querySelector('#weeklyCandSearch');
    if (input && !input.__weeklyCandInputWired) {
      input.__weeklyCandInputWired = true;
      input.addEventListener('input', () => {
        const term = (input.value || '').trim();
        searchAndRender(term);
      });
      // Initial search with pre-filled name
      searchAndRender(input.value || '');
    }

    const resultsHost = root.querySelector('#weeklyCandResults');
    if (resultsHost && !resultsHost.__weeklyCandSelectWired) {
      resultsHost.__weeklyCandSelectWired = true;
      resultsHost.addEventListener('click', (ev) => {
        const li = ev.target.closest('li[data-act="weekly-cand-select"]');
        if (!li) return;
        const candId = li.getAttribute('data-candidate-id') || '';
        if (!candId) return;
        window.__weeklyResolveCandidateState = state();
        window.__weeklyResolveCandidateState.selectedCandidateId = candId;
        renderCandidateResults();
      });
    }

    root.addEventListener('click', (ev) => {
      const btn = ev.target.closest('button[data-act]');
      if (!btn) return;
      const act = btn.getAttribute('data-act');
      const s   = state();

      if (act === 'weekly-cand-cancel') {
        const closeBtn = document.getElementById('btnCloseModal');
        if (closeBtn) closeBtn.click();
        return;
      }

      if (act === 'weekly-cand-link') {
        const selectedId = s.selectedCandidateId;
        if (!selectedId) {
          alert('Select a candidate from the list on the right first.');
          return;
        }

        // Build mapping
        const mappings = ensureWeeklyImportMappings(type, importId);
        const staffNorm = row.staff_norm || String(staffRaw || '').trim().toLowerCase();
        const hospRaw   = row.hospital_or_trust || row.unit || row.hospital_norm || '';
        const hospNorm  = String(hospRaw || '').trim().toLowerCase();

        mappings.candidate_mappings.push({
          staff_norm: staffNorm,
          hospital_or_trust: hospNorm || null,
          candidate_id: selectedId
        });

        // Optimistically update summary row in-memory
        const all = window.__importSummaryState && window.__importSummaryState[type];
        if (all && Array.isArray(all.rows)) {
          const newRows = all.rows.slice();
          const cur = { ...(newRows[rowIdx] || {}) };
          cur.candidate_id = selectedId;

          // If client is still missing, flip to NO_CLIENT; otherwise mark OK
          if (!cur.client_id) {
            cur.resolution_status = 'NO_CLIENT';
          } else {
            cur.resolution_status = 'OK';
          }

          newRows[rowIdx] = cur;
          window.__importSummaryState[type] = {
            import_id: all.import_id,
            summary: all.summary,
            rows: newRows
          };
          renderImportSummaryModal(type, {
            import_id: all.import_id,
            summary: all.summary.summary || all.summary,
            rows: newRows
          });
        }

        window.__toast && window.__toast('Candidate mapping queued for this import.');

        const closeBtn = document.getElementById('btnCloseModal');
        if (closeBtn) closeBtn.click();
      }
    });
  }, 0);
}

async function weeklySearchClientsForResolve(importType, term) {
  const q = String(term || '').trim();
  if (!q) return [];

  let results = [];
  try {
    results = await searchClientsForResolve(q);
    if (!Array.isArray(results)) results = [];
  } catch (e) {
    console.error('[WEEKLY][RESOLVE] client search failed', e);
    throw e;
  }

  const t = String(importType || '').toUpperCase();

  // For NHSP, only show clients with is_nhsp === true
  if (t === 'NHSP') {
    results = results.filter(c => c && (c.is_nhsp === true || c.client_is_nhsp === true));
  }

  return results;
}

async function openWeeklyClientResolveModal(importType, importId, rowIdx) {
  const type = String(importType || '').toUpperCase();
  const enc  = (typeof escapeHtml === 'function')
    ? escapeHtml
    : (s) => String(s == null ? '' : s);

  const st   = window.__importSummaryState && window.__importSummaryState[type];
  const rows = st && Array.isArray(st.rows) ? st.rows : [];
  const row  = (rowIdx >= 0 && rowIdx < rows.length) ? rows[rowIdx] : null;
  if (!row) {
    alert('Row not found for client resolve.');
    return;
  }

  const staffRaw = row.staff_name || row.staff_raw || '';
  const unitRaw  = row.unit || row.hospital_or_trust || row.hospital_norm || '';

  window.__weeklyResolveClientState = {
    type,
    importId,
    rowIdx,
    term: unitRaw,
    results: [],
    selectedClientId: null
  };

  const state = () => window.__weeklyResolveClientState || {};

  const renderTab = (key) => {
    if (key !== 'main') return '';
    const s = state();
    const term    = s.term || '';

    return html(`
      <div class="form" id="weeklyResolveClient">
        <div class="card">
          <div class="row">
            <label>Assign client / site</label>
            <div class="controls">
              <div class="mini">
                Import: <span class="mono">${enc(importId || '')}</span><br/>
                Unit / Site (from import): <strong>${enc(unitRaw || 'â€”')}</strong><br/>
                Staff: <span class="mini">${enc(staffRaw || 'â€”')}</span>
              </div>
            </div>
          </div>
        </div>

        <div class="card" style="margin-top:10px;">
          <div class="row">
            <label>Client name</label>
            <div class="controls">
              <input id="weeklyClientSearch"
                     class="input"
                     type="text"
                     placeholder="Type to search by client name"
                     value="${enc(term)}" />
              <div class="hint mini" style="margin-top:4px;">
                For NHSP, only NHSP-enabled clients will be shown.
              </div>
            </div>
          </div>
          <div class="row">
            <label>Matches</label>
            <div class="controls" id="weeklyClientResults">
              <!-- results injected dynamically -->
              <span class="mini">Type a name to search for clients.</span>
            </div>
          </div>
          <div class="row" style="margin-top:8px;">
            <label></label>
            <div class="controls">
              <button type="button"
                      class="btn btn-primary"
                      data-act="weekly-client-link">
                Link to this client
              </button>
              <button type="button"
                      class="btn"
                      style="margin-left:8px;"
                      data-act="weekly-client-cancel">
                Cancel
              </button>
            </div>
          </div>
        </div>
      </div>
    `);
  };

  showModal(
    'Assign client (weekly import)',
    [{ key: 'main', label: 'Assign client' }],
    renderTab,
    null,
    false,
    null,
    {
      kind: 'weekly-resolve-client',
      noParentGate: true,
      stayOpenOnSave: false
    }
  );

  function renderClientResults() {
    const s = state();
    const results    = Array.isArray(s.results) ? s.results : [];
    const selectedId = s.selectedClientId || '';

    const root = document.getElementById('modalBody');
    if (!root) return;
    const host = root.querySelector('#weeklyClientResults');
    if (!host) return;

    if (!results.length) {
      host.innerHTML = '<span class="mini">No clients matched. Try typing a different name.</span>';
      return;
    }

    const listHtml = `
      <div class="card" style="max-height:250px;overflow:auto;border:1px solid #ddd;margin-top:4px;">
        <ul class="mini">
          ${results.map(c => {
            const id   = c.id;
            const name = c.name || c.client_name || '';
            const selected = String(id) === String(selectedId);
            const style = selected ? ' style="background:#007bff;color:#fff;cursor:pointer;"' : ' style="cursor:pointer;"';
            return `
              <li class="weekly-client-option"${style}
                  data-act="weekly-client-select"
                  data-client-id="${enc(id)}">
                <strong>${enc(name || '')}</strong>
                ${c.cli_ref ? ` &nbsp; <span class="mono">(${enc(c.cli_ref)})</span>` : ''}
              </li>
            `;
          }).join('')}
        </ul>
      </div>
    `;

    host.innerHTML = listHtml;
  }

  async function searchAndRender(term) {
    const q = String(term || '').trim();
    window.__weeklyResolveClientState = state();
    window.__weeklyResolveClientState.term = q;
    if (!q) {
      window.__weeklyResolveClientState.results = [];
      window.__weeklyResolveClientState.selectedClientId = null;
      renderClientResults();
      return;
    }
    try {
      const results = await weeklySearchClientsForResolve(type, q);
      window.__weeklyResolveClientState.results = Array.isArray(results) ? results : [];
      if (results && results.length === 1) {
        window.__weeklyResolveClientState.selectedClientId = results[0].id;
      }
    } catch (err) {
      console.error('[WEEKLY][RESOLVE] client search failed', err);
      alert(err?.message || 'Client search failed.');
      window.__weeklyResolveClientState.results = [];
      window.__weeklyResolveClientState.selectedClientId = null;
    }
    renderClientResults();
  }

  setTimeout(() => {
    const root = document.getElementById('modalBody');
    if (!root) return;

    const input = root.querySelector('#weeklyClientSearch');
    if (input && !input.__weeklyClientInputWired) {
      input.__weeklyClientInputWired = true;
      input.addEventListener('input', () => {
        const term = (input.value || '').trim();
        searchAndRender(term);
      });
      searchAndRender(input.value || '');
    }

    const resultsHost = root.querySelector('#weeklyClientResults');
    if (resultsHost && !resultsHost.__weeklyClientSelectWired) {
      resultsHost.__weeklyClientSelectWired = true;
      resultsHost.addEventListener('click', (ev) => {
        const li = ev.target.closest('li[data-act="weekly-client-select"]');
        if (!li) return;
        const clientId = li.getAttribute('data-client-id') || '';
        if (!clientId) return;
        window.__weeklyResolveClientState = state();
        window.__weeklyResolveClientState.selectedClientId = clientId;
        renderClientResults();
      });
    }

    root.addEventListener('click', (ev) => {
      const btn = ev.target.closest('button[data-act]');
      if (!btn) return;
      const act = btn.getAttribute('data-act');
      const s   = state();

      if (act === 'weekly-client-cancel') {
        const closeBtn = document.getElementById('btnCloseModal');
        if (closeBtn) closeBtn.click();
        return;
      }

      if (act === 'weekly-client-link') {
        const selectedId = s.selectedClientId;
        if (!selectedId) {
          alert('Select a client from the list on the right first.');
          return;
        }

        const mappings = ensureWeeklyImportMappings(type, importId);
        const hospRaw  = row.hospital_or_trust || row.unit || row.hospital_norm || '';
        const hospNorm = String(hospRaw || '').trim().toLowerCase();

        mappings.client_aliases.push({
          hospital_norm: hospNorm || '',
          client_id: selectedId
        });

        const all = window.__importSummaryState && window.__importSummaryState[type];
        if (all && Array.isArray(all.rows)) {
          const newRows = all.rows.slice();
          const cur = { ...(newRows[rowIdx] || {}) };
          cur.client_id = selectedId;

          if (!cur.candidate_id) {
            cur.resolution_status = 'NO_CANDIDATE';
          } else {
            cur.resolution_status = 'OK';
          }

          newRows[rowIdx] = cur;
          window.__importSummaryState[type] = {
            import_id: all.import_id,
            summary: all.summary,
            rows: newRows
          };
          renderImportSummaryModal(type, {
            import_id: all.import_id,
            summary: all.summary.summary || all.summary,
            rows: newRows
          });
        }

        window.__toast && window.__toast('Client mapping queued for this import.');

        const closeBtn = document.getElementById('btnCloseModal');
        if (closeBtn) closeBtn.click();
      }
    });
  }, 0);
}




function ensureWeeklyImportMappings(type, importId) {
  const t = String(type || '').toUpperCase();
  const id = String(importId || '');
  window.__weeklyImportMappings = window.__weeklyImportMappings || {};
  if (!window.__weeklyImportMappings[t]) {
    window.__weeklyImportMappings[t] = {};
  }
  let m = window.__weeklyImportMappings[t][id];
  if (!m) {
    m = {
      candidate_mappings: [],
      client_aliases: []
    };
    window.__weeklyImportMappings[t][id] = m;
  }
  return m;
}


function renderImportSummaryModal(importType, summaryState) {
  const enc = (typeof escapeHtml === 'function')
    ? escapeHtml
    : (s) => String(s == null ? '' : s);

  const type = String(importType || '').toUpperCase();
  const ss   = summaryState || {};
  const importId = ss.import_id || ss.id || (ss.summary && ss.summary.import_id) || null;
  const rows = Array.isArray(ss.rows) ? ss.rows : [];

  window.__importSummaryState = window.__importSummaryState || {};
  // Identify the summary kind and current top frame so we can avoid stacking
  const summaryKind = `import-summary-${type.toLowerCase()}`;
  const stack       = window.__modalStack || [];
  const topFrame    = stack[stack.length - 1] || null;
  const reusingExistingSummary =
    !!topFrame &&
    topFrame.kind === summaryKind;

  // Update the global import summary cache for this type
  window.__importSummaryState[type] = {
    import_id: importId,
    summary: ss,
    rows
  };

  // Global store for weekly mappings (per type + importId)
  window.__weeklyImportMappings = window.__weeklyImportMappings || {};

  const renderTab = (key) => {
    if (key !== 'main') return '';

    if (type === 'HR_ROTA_DAILY') {
      return renderHrRotaDailySummary(type, importId, rows, ss);
    }

    if (type === 'NHSP' || type === 'HR_WEEKLY') {
      return renderWeeklyImportSummary(type, importId, rows, ss);
    }

    return html(`
      <div class="form">
        <div class="card">
          <div class="row">
            <label>Summary</label>
            <div class="controls">
              <span class="mini">Unsupported import type: ${enc(importType)}</span>
            </div>
          </div>
        </div>
      </div>
    `);
  };

  const summaryTitle =
    (type === 'HR_ROTA_DAILY'
      ? 'HR Rota Daily Validation'
      : (type === 'NHSP'
          ? 'NHSP Weekly Import Summary'
          : 'HealthRoster Weekly Import Summary'));

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Import summary modal â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (!reusingExistingSummary) {
    showModal(
      summaryTitle,
      [{ key: 'main', label: 'Summary' }],
      renderTab,
      null,
      false,
      null,
      {
        kind: summaryKind,
        noParentGate: true,
        stayOpenOnSave: false
      }
    );
  } else if (topFrame) {
    try {
      topFrame.title = summaryTitle;
      topFrame.tabs  = [{ key: 'main', label: 'Summary' }];
      topFrame.renderTab = renderTab;
      topFrame.currentTabKey = 'main';
      if (typeof topFrame.setTab === 'function') {
        topFrame.setTab('main');
      }
    } catch (e) {
      console.warn('[IMPORTS] failed to re-render existing import summary frame', e);
    }
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  function renderHrRotaDailySummary(type, importId, rows, ss) {
    const summary = ss.summary || {};
    const total   = summary.total_rows || rows.length || 0;

    const counts = {
      OK: 0,
      FAILED: 0,
      UNMATCHED: 0
    };
    rows.forEach(r => {
      const st = String(r.status || '').toUpperCase();
      if (st === 'OK' || st === 'VALIDATION_OK') counts.OK++;
      else if (st === 'UNMATCHED') counts.UNMATCHED++;
      else counts.FAILED++;
    });

    window.__hrRotaEmailSelections = window.__hrRotaEmailSelections || {};
    window.__hrRotaEmailSelections[importId] = new Set();
    const emailSel = window.__hrRotaEmailSelections[importId];

    const rowsHtml = rows.length
      ? rows.map((r, idx) => {
          const staff = r.staff_name || r.staff_raw || '';
          const unit  = r.unit || r.hospital_or_trust || r.hospital_norm || '';
          const date  = r.date_local || r.date || r.shift_date || '';
          const stRaw = r.status || '';
          const st    = String(stRaw || '').toUpperCase();
          const reasonCode = String(r.reason_code || r.failure_reason || r.reason || '').toLowerCase();

          const canAssignCand   = (reasonCode === 'candidate_unresolved');
          const canAssignClient = (reasonCode === 'client_unresolved');

          const isTimeMismatch =
            reasonCode === 'actual_hours_mismatch' ||
            reasonCode === 'start_end_mismatch' ||
            reasonCode === 'break_minutes_mismatch';

          let stCls = 'pill-info';
          if (st === 'OK' || st === 'VALIDATION_OK') {
            stCls = 'pill-ok';
          } else if (reasonCode === 'candidate_unresolved' || reasonCode === 'client_unresolved') {
            stCls = 'pill-bad';
          } else if (isTimeMismatch) {
            stCls = 'pill-warn';
          }

          let labelHtml;
          if (st === 'OK' || st === 'VALIDATION_OK') {
            labelHtml = 'OK';
          } else if (reasonCode === 'candidate_unresolved') {
            labelHtml = 'CANDIDATE<br/>UNMATCHED';
          } else if (reasonCode === 'client_unresolved') {
            labelHtml = 'CLIENT<br/>UNMATCHED';
          } else if (reasonCode === 'actual_hours_mismatch') {
            labelHtml = 'HOURS<br/>MISMATCH';
          } else if (reasonCode === 'start_end_mismatch') {
            labelHtml = 'START/END<br/>MISMATCH';
          } else if (reasonCode === 'break_minutes_mismatch') {
            labelHtml = 'BREAK<br/>MISMATCH';
          } else {
            const raw = (reasonCode || 'UNKNOWN').replace(/_/g, ' ').toUpperCase();
            const firstSpace = raw.indexOf(' ');
            if (firstSpace > 0) {
              labelHtml = `${enc(raw.slice(0, firstSpace))}<br/>${enc(raw.slice(firstSpace + 1))}`;
            } else {
              labelHtml = enc(raw);
            }
          }

          const emailEligible    = r.email_eligible === true;
          const emailAlreadySent = r.email_already_sent === true;

          const rowId = r.hr_row_id || r.id || `${idx}`;

          let emailCellHtml;
          if (!emailEligible) {
            emailCellHtml = '<span class="mini">â€”</span>';
          } else {
            const checked = (emailSel instanceof Set && emailSel.has(rowId)) ? 'checked' : '';
            const iconHtml = emailAlreadySent
              ? `<span class="email-icon" title="Email previously sent" style="font-size:0.8rem;opacity:0.7;">&#x2709;&#x2713;</span>`
              : '';

            emailCellHtml = `
              <div class="hr-email-cell" style="display:flex;align-items:center;justify-content:center;gap:4px;">
                <input type="checkbox"
                       data-act="hr-rota-email"
                       data-row-id="${enc(rowId)}"
                       data-row-idx="${idx}"
                       ${checked} />
                ${iconHtml}
              </div>
            `;
          }

          return `
            <tr>
              <td><span class="mini">${enc(staff || 'â€”')}</span></td>
              <td><span class="mini">${enc(unit || 'â€”')}</span></td>
              <td><span class="mini">${enc(date || 'â€”')}</span></td>
              <td>
                <span class="pill ${stCls}">
                  ${labelHtml}
                </span>
              </td>
              <td>
                ${
                  canAssignCand
                    ? `<button type="button"
                               class="btn mini"
                               data-act="resolve-candidate"
                               data-row-idx="${idx}">
                         Assign candidateâ€¦
                       </button>`
                    : ''
                }
                ${
                  canAssignClient
                    ? `<button type="button"
                               class="btn mini"
                               style="margin-left:4px;"
                               data-act="resolve-client"
                               data-row-idx="${idx}">
                         Assign clientâ€¦
                       </button>`
                    : ''
                }
              </td>
              <td>${emailCellHtml}</td>
            </tr>
          `;
        }).join('')
      : `
        <tr>
          <td colspan="6">
            <span class="mini">No rows to show.</span>
          </td>
        </tr>
      `;

    const markup = html(`
      <div class="form" id="hrRotaSummary">
        <div class="card hr-rota-full">
          <div class="row">
            <label>Overview</label>
            <div class="controls">
              <div class="mini">
                Import ID: <span class="mono">${enc(importId || 'â€”')}</span><br/>
                Total rows: ${total}<br/>
                OK: ${counts.OK} &nbsp; Failed: ${counts.FAILED} &nbsp; Unmatched: ${counts.UNMATCHED}
              </div>
            </div>
          </div>

          <div class="row" style="margin-top:10px;">
            <label>Rows</label>
            <div class="controls">
              <div class="hr-rota-table-wrap" style="max-height:420px; overflow-y:auto;">
                <table class="grid">
                  <thead>
                    <tr>
                      <th>Staff</th>
                      <th>Unit / Site</th>
                      <th>Date</th>
                      <th>Status</th>
                      <th>Resolve</th>
                      <th>Send email</th>
                    </tr>
                  </thead>
                  <tbody>
                    ${rowsHtml}
                  </tbody>
                </table>
              </div>
            </div>
          </div>

          <div class="row hr-rota-footer" style="margin-top:8px;">
            <label></label>
            <div class="controls">
              <button type="button"
                      class="btn"
                      data-act="hr-rota-reclassify">
                Reclassify
              </button>
              <button type="button"
                      class="btn btn-primary"
                      style="margin-left:8px;"
                      data-act="hr-rota-apply">
                Finalise validations
              </button>
              <span class="mini" style="margin-left:8px;">
                "Reclassify" re-runs checks and refreshes this summary.
                "Finalise validations" updates validation status and, if boxes are ticked,
                queues emails to Temp Staffing.
              </span>
            </div>
          </div>
        </div>
      </div>
    `);

    // Wiring (unchanged in spirit)
    setTimeout(() => {
      try {
        const root = document.getElementById('hrRotaSummary');
        if (!root || type !== 'HR_ROTA_DAILY') return;

        root.addEventListener('click', (ev) => {
          const btn = ev.target.closest('button[data-act]');
          if (!btn) return;
          const act = btn.getAttribute('data-act');

          const st = window.__importSummaryState && window.__importSummaryState['HR_ROTA_DAILY'];
          if (!st) return;

          const rows = Array.isArray(st.rows) ? st.rows : [];
          const idx  = Number(btn.getAttribute('data-row-idx') || '-1');
          const row  = (idx >= 0 && idx < rows.length) ? rows[idx] : null;
          if (!row) return;

          const reasonCode   = String(row.reason_code || row.failure_reason || row.reason || '').toLowerCase();
          const hasTimesheet = !!row.timesheet_id;

          if (act === 'resolve-candidate') {
            if (reasonCode === 'candidate_unresolved' || !hasTimesheet) {
              openHrRotaAssignCandidateModal(importId, idx);
              return;
            }

            if (hasTimesheet) {
              openResolveCandidateModal({
                timesheet_id:      row.timesheet_id,
                occupant_key_norm: row.staff_name || row.staff_raw || '',
                hospital_norm:     row.unit || row.hospital_or_trust || row.hospital_norm || ''
              });
            } else {
              alert('No timesheet matched for this row; resolve candidate via imports/aliases instead.');
            }
          }

          if (act === 'resolve-client') {
            if (reasonCode === 'client_unresolved' || !hasTimesheet) {
              openHrRotaAssignClientModal(importId, idx);
              return;
            }

            if (hasTimesheet) {
              openResolveClientModal({
                timesheet_id:  row.timesheet_id,
                hospital_norm: row.unit || row.hospital_or_trust || row.hospital_norm || ''
              });
            } else {
              alert('No timesheet matched for this row; resolve client/site via imports/aliases instead.');
            }
          }
        });

        root.addEventListener('change', (ev) => {
          const cb = ev.target.closest('input[data-act="hr-rota-email"]');
          if (!cb) return;

          const rowId = cb.getAttribute('data-row-id') || '';
          if (!rowId) return;

          window.__hrRotaEmailSelections = window.__hrRotaEmailSelections || {};
          const sel = window.__hrRotaEmailSelections[importId] || new Set();
          if (!(sel instanceof Set)) {
            window.__hrRotaEmailSelections[importId] = new Set();
          }

          if (cb.checked) {
            window.__hrRotaEmailSelections[importId].add(rowId);
          } else {
            window.__hrRotaEmailSelections[importId].delete(rowId);
          }
        });

        const btnReclass = root.querySelector('button[data-act="hr-rota-reclassify"]');
        if (btnReclass && !btnReclass.__hrRotaReclassWired) {
          btnReclass.__hrRotaReclassWired = true;
          btnReclass.addEventListener('click', async () => {
            try {
              if (!importId) {
                alert('No import_id in summary; cannot reclassify.');
                return;
              }
              await refreshHrRotaSummary(importId);
            } catch (err) {
              console.error('[IMPORTS][HR_ROTA] reclassify failed', err);
              alert(err?.message || 'Reclassify failed.');
            }
          });
        }

        const btnApply = root.querySelector('button[data-act="hr-rota-apply"]');
        if (btnApply && !btnApply.__hrRotaApplyWired) {
          btnApply.__hrRotaApplyWired = true;
          btnApply.addEventListener('click', async () => {
            try {
              if (!importId) {
                alert('No import_id in summary; cannot finalise.');
                return;
              }

              const ok = window.confirm('Are you sure you are ready to finalise?');
              if (!ok) return;

              const sel = window.__hrRotaEmailSelections && window.__hrRotaEmailSelections[importId];
              const sendEmailRowIds = (sel instanceof Set) ? Array.from(sel) : [];

              const result = await applyHrRotaValidation(importId, sendEmailRowIds) || {};

              const lines = [];
              lines.push(`HR Rota validations for import ${result.import_id || importId} have been processed.`);

              if (typeof result.validations_ok === 'number') {
                lines.push(`Valid rows: ${result.validations_ok}`);
              }
              if (typeof result.validations_failed === 'number') {
                lines.push(`Rows still unresolved: ${result.validations_failed}`);
              }
              if (typeof result.emails_queued === 'number') {
                lines.push(`Emails queued: ${result.emails_queued}`);
              }

              if (Array.isArray(result.reasons) && result.reasons.length) {
                lines.push('');
                lines.push('Remaining issues:');
                for (const r of result.reasons) {
                  const rc    = String(r.reason_code || '').toLowerCase();
                  const count = r.count ?? 0;
                  let nice;
                  if      (rc === 'candidate_unresolved')         nice = 'Candidate unmatched';
                  else if (rc === 'client_unresolved')            nice = 'Client unmatched';
                  else if (rc === 'actual_hours_mismatch')       nice = 'Hours mismatch';
                  else if (rc === 'start_end_mismatch')          nice = 'Start/end mismatch';
                  else if (rc === 'break_minutes_mismatch')      nice = 'Break mismatch';
                  else                                           nice = (rc || 'other').replace(/_/g, ' ');
                  lines.push(`- ${nice}: ${count}`);
                }
              }

              alert(lines.join('\n'));
              await refreshHrRotaSummary(importId);
            } catch (err) {
              console.error('[IMPORTS][HR_ROTA] apply failed', err);
              alert(err?.message || 'Apply validations failed.');
            }
          });
        }
      } catch (e) {
        console.warn('[IMPORTS] HR_ROTA wiring failed', e);
      }
    }, 0);

    return markup;
  }

  function renderWeeklyImportSummary(type, importId, rows, ss) {
    const summary = ss.summary || {};
    const total   = summary.total_rows || rows.length || 0;

    const rowsHtml = rows.length
      ? rows.map((r, idx) => {
          const staff  = r.staff_name || r.staff_raw || '';
          const unit   = r.unit || r.hospital_or_trust || r.hospital_norm || '';

          const rawDateYmd =
            r.date_local ||
            r.work_date ||
            r.date ||
            r.week_ending_date ||
            '';

          const date   = formatYmdToNiceDate(rawDateYmd);
          const action = String(r.resolution_status || r.action || '').toUpperCase();

          let cls = 'pill-info';
          if (action === 'OK' || action === 'APPLY') cls = 'pill-ok';
          else if (action === 'NO_CANDIDATE' || action === 'NO_CLIENT') cls = 'pill-bad';

          const canAssignCand   = (action === 'NO_CANDIDATE');
          const canAssignClient = (action === 'NO_CLIENT');

          return `
            <tr>
              <td><span class="mini">${enc(staff || 'â€”')}</span></td>
              <td><span class="mini">${enc(unit || 'â€”')}</span></td>
              <td><span class="mini">${enc(date || 'â€”')}</span></td>
              <td><span class="pill ${cls}">${enc(action || 'UNKNOWN')}</span></td>
              <td>
                ${
                  canAssignCand
                    ? `<button type="button"
                               class="btn mini"
                               data-act="weekly-resolve-candidate"
                               data-row-idx="${idx}"
                               data-staff="${enc(staff)}"
                               data-unit="${enc(unit)}">
                         Assign candidateâ€¦
                       </button>`
                    : ''
                }
                ${
                  canAssignClient
                    ? `<button type="button"
                               class="btn mini"
                               style="margin-left:4px;"
                               data-act="weekly-resolve-client"
                               data-row-idx="${idx}"
                               data-unit="${enc(unit)}">
                         Assign clientâ€¦
                       </button>`
                    : ''
                }
              </td>
            </tr>
          `;
        }).join('')
      : `
        <tr>
          <td colspan="5">
            <span class="mini">No rows to show.</span>
          </td>
        </tr>
      `;

    const markup = html(`
      <div class="form" id="weeklyImportSummary">
        <div class="card">
          <div class="row">
            <label>Overview</label>
            <div class="controls">
              <div class="mini">
                Import ID: <span class="mono">${enc(importId || 'â€”')}</span><br/>
                Total rows: ${total}
              </div>
            </div>
          </div>
        </div>

        <div class="card" style="margin-top:10px;">
          <div class="row">
            <label>Rows</label>
            <div class="controls">
              <table class="grid">
                <thead>
                  <tr>
                    <th>Staff</th>
                    <th>Unit / Site</th>
                    <th>Date / Week ending</th>
                    <th>Resolution</th>
                    <th>Resolve</th>
                  </tr>
                </thead>
                <tbody>
                  ${rowsHtml}
                </tbody>
              </table>
            </div>
          </div>

          <div class="row" style="margin-top:8px;">
            <label></label>
            <div class="controls">
              <button type="button"
                      class="btn"
                      data-act="weekly-import-refresh">
                Refresh
              </button>
              <button type="button"
                      class="btn btn-primary"
                      style="margin-left:8px;"
                      data-act="weekly-import-apply">
                Finalise import
              </button>
              <span class="mini" style="margin-left:8px;">
                This will apply the classification and create/update weeks and timesheets.
              </span>
            </div>
          </div>
        </div>
      </div>
    `);

    // Wiring for NHSP / HR_WEEKLY "Apply import" + Assign buttons
    setTimeout(() => {
      try {
        const root = document.getElementById('weeklyImportSummary');
        if (!root || (type !== 'NHSP' && type !== 'HR_WEEKLY')) return;
        if (root.__weeklyWired) return;
        root.__weeklyWired = true;

        const st = window.__importSummaryState && window.__importSummaryState[type];
        const rows = st && Array.isArray(st.rows) ? st.rows : [];

        const ensureWeeklyImportMappings = () => {
          window.__weeklyImportMappings = window.__weeklyImportMappings || {};
          if (!window.__weeklyImportMappings[type]) {
            window.__weeklyImportMappings[type] = {};
          }
          let m = window.__weeklyImportMappings[type][importId];
          if (!m) {
            m = {
              candidate_mappings: [],
              client_aliases: []
            };
            window.__weeklyImportMappings[type][importId] = m;
          }
          return m;
        };

        root.addEventListener('click', (ev) => {
          const btn = ev.target.closest('button[data-act]');
          if (!btn) return;
          const act = btn.getAttribute('data-act');
          if (act !== 'weekly-resolve-candidate' && act !== 'weekly-resolve-client') return;

          const idx = Number(btn.getAttribute('data-row-idx') || '-1');
          if (idx < 0 || idx >= rows.length) return;

          const row         = rows[idx];
          const staffRaw    = row.staff_name || row.staff_raw || '';
          const hospRaw     = row.hospital_or_trust || row.unit || row.hospital_norm || '';
          const rawDateYmd  =
            row.date_local ||
            row.work_date ||
            row.date ||
            row.week_ending_date ||
            '';
          const niceDate    = formatYmdToNiceDate(rawDateYmd);

          const context = {
            importId,
            staffName: staffRaw,
            unit: hospRaw,
            dateYmd: rawDateYmd,
            dateNice: niceDate,
            source_system: type,
            rowIndex: idx
          };

          if (act === 'weekly-resolve-candidate') {
            openCandidatePicker(async ({ id, label }) => {
              const mappings        = ensureWeeklyImportMappings();
              const staffNorm       = row.staff_norm || staffRaw || '';
              const hospitalOrTrust = hospRaw || null;
              const clientId        = row.client_id || null;
              const workDateYmd =
                row.work_date ||
                row.date_local ||
                row.date ||
                row.week_ending_date ||
                null;

              const mapping = {
                staff_norm:       staffNorm,
                hospital_or_trust:hospitalOrTrust,
                candidate_id:     id,
                client_id:        clientId,
                work_date:        workDateYmd
              };

              const payload = {
                candidate_mappings: [mapping],
                client_aliases: []
              };

              try {
                await postWeeklyResolveMappings(importId, type, payload);
                mappings.candidate_mappings.push(mapping);

                window.__toast && window.__toast(`Candidate ${label} linked. Reclassifying importâ€¦`);
                await refreshWeeklyImportSummary(type, importId);
              } catch (err) {
                console.error('[IMPORTS][WEEKLY] resolve-candidate failed', err);
                alert(err?.message || 'Failed to resolve candidate for weekly import row.');
              }
            }, { context });

            return;
          }

          if (act === 'weekly-resolve-client') {
            const nhspOnly  = (type === 'NHSP');
            const hrAutoOnly= (type === 'HR_WEEKLY');

            openClientPicker(async ({ id, label }) => {
              const mappings     = ensureWeeklyImportMappings();
              const hospitalNorm = row.hospital_norm || hospRaw || '';

              const mapping = {
                hospital_norm: hospitalNorm,
                client_id:     id
              };

              const payload = {
                candidate_mappings: [],
                client_aliases: [mapping]
              };

              try {
                await postWeeklyResolveMappings(importId, type, payload);
                mappings.client_aliases.push(mapping);

                window.__toast && window.__toast(`Client ${label} linked. Reclassifying importâ€¦`);
                await refreshWeeklyImportSummary(type, importId);
              } catch (err) {
                console.error('[IMPORTS][WEEKLY] resolve-client failed', err);
                alert(err?.message || 'Failed to resolve client for weekly import row.');
              }
            }, { nhspOnly, hrAutoOnly, context });

            return;
          }
        });

        const btnRefresh = root.querySelector('button[data-act="weekly-import-refresh"]');
        if (btnRefresh && !btnRefresh.__weeklyRefreshWired) {
          btnRefresh.__weeklyRefreshWired = true;
          btnRefresh.addEventListener('click', async () => {
            try {
              await refreshWeeklyImportSummary(type, importId);
            } catch (err) {
              console.error('[IMPORTS][WEEKLY] manual refresh failed', err);
              alert(err?.message || 'Weekly import refresh failed.');
            }
          });
        }

        const btnApplyWeekly = root.querySelector('button[data-act="weekly-import-apply"]');
        if (btnApplyWeekly && !btnApplyWeekly.__weeklyApplyWired) {
          btnApplyWeekly.__weeklyApplyWired = true;
          btnApplyWeekly.addEventListener('click', async () => {
            try {
              if (!importId) {
                alert('No import_id in summary; cannot finalise.');
                return;
              }

              const ok = window.confirm('Are you sure you want to finalise now?');
              if (!ok) return;

              const mappings = ensureWeeklyImportMappings();

              const result = await resolveImportConflicts(importId, type, mappings) || {};

              const lines = [];
              lines.push(`Import ${result.import_id || importId} has been finalised.`);

              if (typeof result.shifts_created === 'number') {
                lines.push(`Shifts created: ${result.shifts_created}`);
              }
              if (typeof result.shifts_updated === 'number') {
                lines.push(`Shifts updated: ${result.shifts_updated}`);
              }
              if (typeof result.mapped_candidates === 'number') {
                lines.push(`Candidates mapped: ${result.mapped_candidates}`);
              }
              if (typeof result.mapped_clients === 'number') {
                lines.push(`Clients mapped: ${result.mapped_clients}`);
              }
              if (typeof result.groups_applied === 'number') {
                lines.push(`Groups applied: ${result.groups_applied}`);
              }

              alert(lines.join('\n'));
              await refreshWeeklyImportSummary(type, importId);
            } catch (err) {
              console.error('[IMPORTS][WEEKLY] apply failed', err);
              alert(err?.message || 'Weekly import apply failed.');
            }
          });
        }
      } catch (e) {
        console.warn('[IMPORTS] weekly import wiring failed', e);
      }
    }, 0);

    return markup;
  }
}


function renderClientHospitalsTable() {
  const el = byId('clientHospitals');
  if (!el) return;

  const frame = _currentFrame();
  // Allow create OR edit to add/edit hospitals
  const parentEditable = frame && (frame.mode === 'edit' || frame.mode === 'create');

  const ctx = window.modalCtx || {};
  const H = ctx.hospitalsState || (ctx.hospitalsState = {
    existing: [],
    stagedNew: [],
    stagedEdits: {},
    stagedDeletes: new Set()
  });

  // Normalise stagedDeletes back to a Set if it was JSON-cloned
  if (!(H.stagedDeletes instanceof Set)) {
    H.stagedDeletes = new Set(
      Array.isArray(H.stagedDeletes)
        ? H.stagedDeletes
        : Object.keys(H.stagedDeletes || {})
    );
  }
  H.stagedNew   = Array.isArray(H.stagedNew)   ? H.stagedNew   : [];
  H.existing    = Array.isArray(H.existing)    ? H.existing    : [];
  H.stagedEdits = H.stagedEdits || {};

  el.innerHTML = '';

  const tbl = document.createElement('table');
  tbl.className = 'grid';

  const thead = document.createElement('thead');
  const trh = document.createElement('tr');

  // Columns: Aliases, Ward hint, Status / Actions
  ['Aliases (HealthRoster / NHSP / Rota)','Ward / Unit hint','Status'].forEach(c => {
    const th = document.createElement('th');
    th.textContent = c;
    trh.appendChild(th);
  });
  thead.appendChild(trh);
  tbl.appendChild(thead);

  const tb = document.createElement('tbody');

  // Helper to render alias cell (chips + input) for an existing row
  function buildAliasCellForExisting(x) {
    const td = document.createElement('td');
    const wrap = document.createElement('div');
    wrap.className = 'chip-row';
    wrap.style.display = 'flex';
    wrap.style.flexWrap = 'wrap';
    wrap.style.gap = '4px';

    // Normalise aliases
    let aliases = Array.isArray(x.hospital_name_norm)
      ? x.hospital_name_norm.slice()
      : (x.hospital_name_norm ? [x.hospital_name_norm] : []);
    aliases = aliases.filter(a => !!a).map(a => String(a));

    const rowId = String(x.id);
    const setDirty = () => {
      H.stagedEdits[rowId] = {
        ...(H.stagedEdits[rowId] || {}),
        hospital_name_norm: aliases
      };
      try { window.dispatchEvent(new CustomEvent('modal-dirty')); } catch {}
    };

    const renderChips = () => {
      wrap.innerHTML = '';
      if (!aliases.length) {
        const span = document.createElement('span');
        span.className = 'mini';
        span.textContent = 'No aliases configured yet.';
        wrap.appendChild(span);
        return;
      }
      aliases.forEach(alias => {
        const chip = document.createElement('span');
        chip.className = 'chip';
        chip.dataset.alias = alias;

        const label = document.createElement('span');
        label.className = 'chip-label';
        label.textContent = alias;

        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'chip-remove';
        btn.textContent = 'Ã—';
        btn.title = 'Remove alias';
        btn.disabled = !parentEditable;
        btn.onclick = () => {
          if (!parentEditable) return;
          aliases = aliases.filter(a => a !== alias);
          renderChips();
          setDirty();
        };

        chip.appendChild(label);
        chip.appendChild(btn);
        wrap.appendChild(chip);
      });
    };

    renderChips();
    td.appendChild(wrap);

    const inp = document.createElement('input');
    inp.type = 'text';
    inp.className = 'input alias-input';
    inp.placeholder = 'Add alias (e.g. uhb qe)';
    inp.disabled = !parentEditable;
    inp.style.marginTop = '4px';
    inp.onkeydown = (ev) => {
      if (ev.key !== 'Enter') return;
      const raw = (inp.value || '').trim();
      if (!raw) return;
      const alias = raw.toLowerCase();
      if (!aliases.includes(alias)) {
        aliases.push(alias);
        renderChips();
        setDirty();
      }
      inp.value = '';
    };

    td.appendChild(inp);
    return td;
  }

  // Helper to render alias cell for a NEW (staged) row
  function buildAliasCellForNew(stagedRow) {
    const td = document.createElement('td');
    const wrap = document.createElement('div');
    wrap.className = 'chip-row';
    wrap.style.display = 'flex';
    wrap.style.flexWrap = 'wrap';
    wrap.style.gap = '4px';

    let aliases = Array.isArray(stagedRow.hospital_name_norm)
      ? stagedRow.hospital_name_norm.slice()
      : (stagedRow.hospital_name_norm ? [stagedRow.hospital_name_norm] : []);
    aliases = aliases.filter(a => !!a).map(a => String(a));

    const setDirty = () => {
      stagedRow.hospital_name_norm = aliases;
      try { window.dispatchEvent(new CustomEvent('modal-dirty')); } catch {}
    };

    const renderChips = () => {
      wrap.innerHTML = '';
      if (!aliases.length) {
        const span = document.createElement('span');
        span.className = 'mini';
        span.textContent = 'No aliases configured yet.';
        wrap.appendChild(span);
        return;
      }
      aliases.forEach(alias => {
        const chip = document.createElement('span');
        chip.className = 'chip';
        chip.dataset.alias = alias;

        const label = document.createElement('span');
        label.className = 'chip-label';
        label.textContent = alias;

        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'chip-remove';
        btn.textContent = 'Ã—';
        btn.title = 'Remove alias';
        btn.disabled = !parentEditable;
        btn.onclick = () => {
          if (!parentEditable) return;
          aliases = aliases.filter(a => a !== alias);
          renderChips();
          setDirty();
        };

        chip.appendChild(label);
        chip.appendChild(btn);
        wrap.appendChild(chip);
      });
    };

    renderChips();
    td.appendChild(wrap);

    const inp = document.createElement('input');
    inp.type = 'text';
    inp.className = 'input alias-input';
    inp.placeholder = 'Add alias (e.g. uhb qe)';
    inp.disabled = !parentEditable;
    inp.style.marginTop = '4px';
    inp.onkeydown = (ev) => {
      if (ev.key !== 'Enter') return;
      const raw = (inp.value || '').trim();
      if (!raw) return;
      const alias = raw.toLowerCase();
      if (!aliases.includes(alias)) {
        aliases.push(alias);
        renderChips();
        setDirty();
      }
      inp.value = '';
    };

    td.appendChild(inp);
    return td;
  }

  // Existing rows (DB)
  (H.existing || []).forEach((x) => {
    if (H.stagedDeletes.has(String(x.id))) return;

    const tr = document.createElement('tr');

    // Aliases cell
    const aliasTd = buildAliasCellForExisting(x);

    // Ward hint cell
    const hintTd = document.createElement('td');
    const hintInp = document.createElement('input');
    hintInp.type = 'text';
    hintInp.className = 'input';
    hintInp.value = x.ward_hint || '';
    hintInp.disabled = !parentEditable;
    hintInp.oninput = () => {
      const rowId = String(x.id);
      H.stagedEdits[rowId] = {
        ...(H.stagedEdits[rowId] || {}),
        ward_hint: hintInp.value || null
      };
      try { window.dispatchEvent(new CustomEvent('modal-dirty')); } catch {}
    };
    hintTd.appendChild(hintInp);

    // Status / actions cell
    const actTd = document.createElement('td');
    const rmBtn = document.createElement('button');
    rmBtn.textContent = 'Remove';
    rmBtn.disabled = !parentEditable;
    rmBtn.setAttribute('data-action', 'delete');
    rmBtn.setAttribute('data-hid', String(x.id));
    rmBtn.className = 'btnDelHospital';
    actTd.appendChild(rmBtn);

    tr.appendChild(aliasTd);
    tr.appendChild(hintTd);
    tr.appendChild(actTd);
    tb.appendChild(tr);
  });

  // New (unsaved) rows
  (H.stagedNew || []).forEach((x, idx) => {
    const tr = document.createElement('tr');

    // Aliases cell for staged row
    const aliasTd = buildAliasCellForNew(x);

    // Ward hint
    const hintTd = document.createElement('td');
    const hintInp = document.createElement('input');
    hintInp.type = 'text';
    hintInp.className = 'input';
    hintInp.value = x.ward_hint || '';
    hintInp.disabled = !parentEditable;
    hintInp.oninput = () => {
      x.ward_hint = hintInp.value || null;
      try { window.dispatchEvent(new CustomEvent('modal-dirty')); } catch {}
    };
    hintTd.appendChild(hintInp);

    const actTd = document.createElement('td');
    const rm = document.createElement('button');
    rm.textContent = 'Remove (staged)';
    rm.disabled = !parentEditable;
    rm.onclick = () => {
      if (!parentEditable) return;
      H.stagedNew.splice(idx, 1);
      renderClientHospitalsTable();
      try { window.dispatchEvent(new CustomEvent('modal-dirty')); } catch {}
    };
    actTd.appendChild(rm);

    tr.appendChild(aliasTd);
    tr.appendChild(hintTd);
    tr.appendChild(actTd);
    tb.appendChild(tr);
  });

  tbl.appendChild(tb);

  const actions = document.createElement('div');
  actions.className = 'actions';
  actions.innerHTML = `
    <button id="btnAddClientHospital"${parentEditable ? '' : ' disabled'}>
      Add Hospital / Ward
    </button>
    ${
      parentEditable
        ? ''
        : '<span class="hint">Read-only. Click â€œEditâ€ in the main dialog to add/modify hospitals.</span>'
    }
  `;

  el.appendChild(tbl);
  el.appendChild(actions);

  const addBtn = byId('btnAddClientHospital');
  if (addBtn && parentEditable) {
    addBtn.onclick = () => openClientHospitalModal(ctx.data?.id);
  }
}



// =================== HOSPITALS TABLE (UPDATED: staged delete & edit) ===================
async function renderClientSettingsUI(settingsObj){
  const div = byId('clientSettings'); if (!div) return;

  const ctx = window.modalCtx;

  const initial = (ctx.clientSettingsState && typeof ctx.clientSettingsState === 'object')
    ? ctx.clientSettingsState
    : (settingsObj && typeof settingsObj === 'object' ? settingsObj : {});

  const _toHHMM = (v) => {
    if (!v) return '';
    const s = String(v).trim();
    if (/^\d{2}:\d{2}(:\d{2})?$/.test(s)) return s.slice(0,5);
    return s;
  };

  // Normalised state with sensible defaults
  const s = {
    timezone_id : initial.timezone_id ?? 'Europe/London',
    day_start   : _toHHMM(initial.day_start)   || '06:00',
    day_end     : _toHHMM(initial.day_end)     || '20:00',
    night_start : _toHHMM(initial.night_start) || '20:00',
    night_end   : _toHHMM(initial.night_end)   || '06:00',
    sat_start   : _toHHMM(initial.sat_start)   || '00:00',
    sat_end     : _toHHMM(initial.sat_end)     || '00:00',
    sun_start   : _toHHMM(initial.sun_start)   || '00:00',
    sun_end     : _toHHMM(initial.sun_end)     || '00:00',
    bh_start    : _toHHMM(initial.bh_start)    || '',      // inherit global if blank
    bh_end      : _toHHMM(initial.bh_end)      || '',

    week_ending_weekday:
      Number.isInteger(Number(initial.week_ending_weekday))
        ? String(Math.min(6, Math.max(0, Number(initial.week_ending_weekday))))
        : '0',

    // Existing toggles
    pay_reference_required:      !!initial.pay_reference_required,
    invoice_reference_required:  !!initial.invoice_reference_required,
    default_submission_mode:     String(initial.default_submission_mode || 'ELECTRONIC').toUpperCase(),

    // Existing â€œextraâ€ flags â€“ default to false if absent
    is_nhsp:                     !!initial.is_nhsp,
    self_bill_no_invoices_sent:  !!initial.self_bill_no_invoices_sent,
    daily_calc_of_invoices:      !!initial.daily_calc_of_invoices,
    no_timesheet_required:       !!initial.no_timesheet_required,
    group_nightsat_sunbh:        !!initial.group_nightsat_sunbh,

    // HR flags
    requires_hr:                 !!initial.requires_hr,          // â€œRequires HealthRoster cross-checkâ€
    autoprocess_hr:              !!initial.autoprocess_hr,       // â€œAutoprocess timesheets with HealthRosterâ€
    // Attachments: default TRUE when unset (so old clients behave as â€œattach by defaultâ€)
    hr_attach_to_invoice:        (initial.hr_attach_to_invoice !== false),
    ts_attach_to_invoice:        (initial.ts_attach_to_invoice !== false),
  };

  // Persist back into modalCtx so openClient() sees the normalised values
  ctx.clientSettingsState = { ...initial, ...s };

  const input = (name,label,val,type='text') =>
    `<div class="row"><label>${label}</label><div class="controls"><input class="input" name="${name}" value="${String(val||'')}" ${type==='time'?'type="time" step="60"':''}/></div></div>`;

  const weekDaySelect = () => {
    const opts = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday']
      .map((lab,idx)=>`<option value="${idx}" ${String(idx)===String(s.week_ending_weekday)?'selected':''}>${lab}</option>`).join('');
    return `<div class="row"><label>Week Ending Day</label><div class="controls"><select name="week_ending_weekday">${opts}</select></div></div>`;
  };

  // Small helper to render a tight checkbox + label
  const yesNoToggle = (name, text, checked) => `
    <label class="inline chk-tight"
           style="display:inline-flex;align-items:center;gap:6px;margin-right:18px;white-space:nowrap;">
      <input type="checkbox" name="${name}" ${checked ? 'checked' : ''}/>
      <span>${text}</span>
    </label>
  `;

  const gatesAndSubmission = () => {
    return `
      <div class="row">
        <label>References & flags</label>
        <div class="controls" style="display:flex;flex-direction:column;gap:4px;">

          <!-- Row 1: existing ref flags + NHSP -->
          <div class="toggle-row" style="display:flex;flex-wrap:wrap;gap:10px;">
            ${yesNoToggle('pay_reference_required',     'Ref No. required to PAY',      s.pay_reference_required)}
            ${yesNoToggle('invoice_reference_required', 'Ref No. required to INVOICE',  s.invoice_reference_required)}
            ${yesNoToggle('is_nhsp',                    'NHSP client',                  s.is_nhsp)}
          </div>

          <!-- Row 2: core process flags -->
          <div class="toggle-row" style="display:flex;flex-wrap:wrap;gap:10px;">
            ${yesNoToggle('self_bill_no_invoices_sent', 'Self-bill (no invoices sent)', s.self_bill_no_invoices_sent)}
            ${yesNoToggle('daily_calc_of_invoices',     'Daily invoice calculation',    s.daily_calc_of_invoices)}
            ${yesNoToggle('no_timesheet_required',      'No timesheet required',        s.no_timesheet_required)}
            ${yesNoToggle('group_nightsat_sunbh',       'Group Night/Sat/Sun/BH',       s.group_nightsat_sunbh)}
          </div>

          <!-- Row 3: HR + attachments -->
          <div class="toggle-row" style="display:flex;flex-wrap:wrap;gap:10px;">
            ${yesNoToggle('requires_hr',       'Requires HealthRoster cross-check',       s.requires_hr)}
            ${yesNoToggle('autoprocess_hr',    'Autoprocess timesheets with HealthRoster',s.autoprocess_hr)}
            ${yesNoToggle('hr_attach_to_invoice', 'Attach HealthRoster to invoice',       s.hr_attach_to_invoice)}
            ${yesNoToggle('ts_attach_to_invoice', 'Attach timesheets to invoice',         s.ts_attach_to_invoice)}
          </div>
        </div>
      </div>

      <div class="row">
        <label>Default Submission</label>
        <div class="controls">
          <select name="default_submission_mode">
            <option value="ELECTRONIC" ${s.default_submission_mode==='ELECTRONIC'?'selected':''}>ELECTRONIC</option>
            <option value="MANUAL"     ${s.default_submission_mode==='MANUAL'    ?'selected':''}>MANUAL</option>
          </select>
        </div>
      </div>
    `;
  };

  div.innerHTML = `
    <div class="form" id="clientSettingsForm">
      ${input('timezone_id','Timezone', s.timezone_id)}
      ${input('day_start','Day shift starts (HH:MM)', s.day_start, 'time')}
      ${input('day_end','Day shift ends (HH:MM)', s.day_end, 'time')}
      ${input('night_start','Night shift starts (HH:MM)', s.night_start, 'time')}
      ${input('night_end','Night shift ends (HH:MM)', s.night_end, 'time')}

      ${input('sat_start','Saturday starts (HH:MM)', s.sat_start, 'time')}
      ${input('sat_end','Saturday ends (HH:MM)', s.sat_end, 'time')}
      ${input('sun_start','Sunday starts (HH:MM)', s.sun_start, 'time')}
      ${input('sun_end','Sunday ends (HH:MM)', s.sun_end, 'time')}

      ${input('bh_start','Bank Holiday starts (HH:MM)', s.bh_start, 'time')}
      ${input('bh_end','Bank Holiday ends (HH:MM)',   s.bh_end,   'time')}

      ${weekDaySelect()}

      ${gatesAndSubmission()}

      <div class="hint" style="grid-column:1/-1">
        Example: Day 06:00â€“20:00, Night 20:00â€“06:00. Saturday/Sunday windows can extend into the following day (e.g. Sunday ends 06:00 next day).
        Bank Holiday hours can also be restricted (e.g. BH 08:00â€“20:00) or left blank to inherit global defaults.
      </div>
    </div>
  `;

  const root = document.getElementById('clientSettingsForm');
  const hhmm = /^([01]\d|2[0-3]):[0-5]\d$/;
  const timeKeys = ['day_start','day_end','night_start','night_end','sat_start','sat_end','sun_start','sun_end','bh_start','bh_end'];

  const asBool = (v) => (v === 'on' || v === true || v === 'true');

  let lastValid = { ...s };

  if (root.__wired) {
    root.removeEventListener('input',  root.__syncSoft, true);
    root.removeEventListener('change', root.__syncValidate, true);
    timeKeys.forEach(k=>{
      const el = root.querySelector(`input[name="${k}"]`);
      if (el && el.__syncValidate) el.removeEventListener('blur', el.__syncValidate, true);
    });
  }

  const _currentFrame = window.__getModalFrame || (() => null);

  const syncSoft = ()=>{
    const frame = _currentFrame();
    if (!frame || frame.mode !== 'edit') return;

    const vals = collectForm('#clientSettingsForm', false);
    const next = { ...ctx.clientSettingsState, ...vals };

    // Soft normalise times
    timeKeys.forEach(k=>{
      const v = String(vals[k] ?? '').trim();
      if (v && !hhmm.test(v)) next[k] = lastValid[k];
    });

    // Soft normalise week ending
    const w = Number(vals.week_ending_weekday);
    next.week_ending_weekday = Number.isInteger(w) ? String(Math.min(6, Math.max(0, w))) : lastValid.week_ending_weekday;

    // Soft normalise toggles â†’ booleans
    next.pay_reference_required        = asBool(vals.pay_reference_required);
    next.invoice_reference_required    = asBool(vals.invoice_reference_required);
    next.is_nhsp                       = asBool(vals.is_nhsp);
    next.self_bill_no_invoices_sent    = asBool(vals.self_bill_no_invoices_sent);
    next.daily_calc_of_invoices        = asBool(vals.daily_calc_of_invoices);
    next.no_timesheet_required         = asBool(vals.no_timesheet_required);
    next.group_nightsat_sunbh          = asBool(vals.group_nightsat_sunbh);
    next.requires_hr                   = asBool(vals.requires_hr);
    next.autoprocess_hr                = asBool(vals.autoprocess_hr);
    next.hr_attach_to_invoice          = asBool(vals.hr_attach_to_invoice);
    next.ts_attach_to_invoice          = asBool(vals.ts_attach_to_invoice);

    // Default submission mode
    const mode = String(vals.default_submission_mode || next.default_submission_mode || 'ELECTRONIC').toUpperCase();
    next.default_submission_mode = (mode === 'ELECTRONIC' || mode === 'MANUAL') ? mode : 'ELECTRONIC';

    ctx.clientSettingsState = next;
  };

  let lastAlertAt = 0;
  const syncValidate = (ev)=>{
    const frame = _currentFrame();
    if (!frame || frame.mode !== 'edit') return;

    const vals = collectForm('#clientSettingsForm', false);
    let hadError = false;

    // Strict validate times
    timeKeys.forEach(k=>{
      const v = String(vals[k] ?? '').trim();
      if (v && !hhmm.test(v)) {
        hadError = true;
        const el = root.querySelector(`input[name="${k}"]`);
        if (el) el.value = lastValid[k] || '';
      }
    });

    // Strict validate week ending
    let w = Number(vals.week_ending_weekday);
    if (!Number.isInteger(w) || w<0 || w>6) {
      hadError = true;
      w = Number(lastValid.week_ending_weekday) || 0;
    }

    // Booleans
    const payReq   = asBool(vals.pay_reference_required);
    const invReq   = asBool(vals.invoice_reference_required);
    const isNhsp   = asBool(vals.is_nhsp);
    const sbNoInv  = asBool(vals.self_bill_no_invoices_sent);
    const dailyInv = asBool(vals.daily_calc_of_invoices);
    const noTsReq  = asBool(vals.no_timesheet_required);
    const groupNsb = asBool(vals.group_nightsat_sunbh);
    const reqHr    = asBool(vals.requires_hr);
    const autoHr   = asBool(vals.autoprocess_hr);
    const attHr    = asBool(vals.hr_attach_to_invoice);
    const attTs    = asBool(vals.ts_attach_to_invoice);

    // Default submission mode
    const modeRaw = String(vals.default_submission_mode || '').toUpperCase();
    const modeOk  = (modeRaw === 'ELECTRONIC' || modeRaw === 'MANUAL') ? modeRaw : 'ELECTRONIC';

    ctx.clientSettingsState = {
      ...ctx.clientSettingsState,
      ...vals,
      week_ending_weekday: String(w),
      pay_reference_required:        payReq,
      invoice_reference_required:    invReq,
      default_submission_mode:       modeOk,
      is_nhsp:                       isNhsp,
      self_bill_no_invoices_sent:    sbNoInv,
      daily_calc_of_invoices:        dailyInv,
      no_timesheet_required:         noTsReq,
      group_nightsat_sunbh:          groupNsb,
      requires_hr:                   reqHr,
      autoprocess_hr:                autoHr,
      hr_attach_to_invoice:          attHr,
      ts_attach_to_invoice:          attTs
    };
    lastValid = { ...ctx.clientSettingsState };

    if (hadError) {
      const now = Date.now();
      if (now - lastAlertAt > 400) {
        alert('Please fix invalid values (times must be HH:MM, week ending must be 0â€“6).');
        lastAlertAt = now;
      }
    }
  };

  root.__syncSoft = syncSoft;
  root.__syncValidate = syncValidate;
  root.addEventListener('input',  syncSoft, true);
  root.addEventListener('change', syncValidate, true);
  timeKeys.forEach(k=>{
    const el = root.querySelector(`input[name="${k}"]`);
    if (el) {
      el.__syncValidate = syncValidate;
      el.addEventListener('blur', syncValidate, true);
      el.setAttribute('step', '60');
    }
  });
  root.__wired = true;
}



// ---- Umbrella modal
// ========================= openUmbrella (FIXED) =========================
// ---- Umbrella modal
// ========================= openUmbrella (FIXED) =========================
// ================== FRONTEND: openUmbrella (UPDATED) ==================
// ================== FIXED: openUmbrella (hydrate before showModal) ==================
// ================== FIXED: openUmbrella (hydrate before showModal) ==================
async function openUmbrella(row){
  // ===== Logging helpers (toggle with window.__LOG_MODAL = true/false) =====
  const LOG = (typeof window.__LOG_MODAL === 'boolean') ? window.__LOG_MODAL : true;
  const L  = (...a)=> { if (LOG) console.log('[OPEN_UMBRELLA]', ...a); };
  const W  = (...a)=> { if (LOG) console.warn('[OPEN_UMBRELLA]', ...a); };
  const E  = (...a)=> { if (LOG) console.error('[OPEN_UMBRELLA]', ...a); };

  const deep = (o)=> JSON.parse(JSON.stringify(o || {}));
  const incoming = deep(row || {});
  const seedId   = incoming?.id || null;

  L('ENTRY', { incomingKeys: Object.keys(incoming||{}), seedId });

  const unwrapSingle = (data, key) => {
    if (Array.isArray(data)) return data[0] || null;
    if (data && key && data[key]) return unwrapSingle(data[key], null);
    if (data && Array.isArray(data.rows))  return data.rows[0]  || null;
    if (data && Array.isArray(data.items)) return data.items[0] || null;
    if (data && Array.isArray(data.data))  return data.data[0]  || null;
    return (data && typeof data === 'object') ? data : null;
  };

  // 1) Hydrate full umbrella if we have an id
  let full = incoming;
  if (seedId) {
    try {
      const url = API(`/api/umbrellas/${encodeURIComponent(seedId)}`);
      L('[HTTP] GET', url);
      const res = await authFetch(url);
      L('[HTTP] status', res?.status, res?.ok);

      try {
        const raw = await res.clone().text();
        if (LOG) console.debug('[HTTP] raw body (â‰¤2KB):', raw.slice(0, 2048));
      } catch (peekErr) { W('[HTTP] raw peek failed', peekErr?.message || peekErr); }

      if (res.ok) {
        const data = await res.json().catch(()=> ({}));
        const unwrapped = unwrapSingle(data, 'umbrella');
        L('hydrated JSON keys', Object.keys(data||{}), 'unwrapped keys', Object.keys(unwrapped||{}));
        full = unwrapped || incoming;
      } else {
        W('non-OK response, using incoming row');
      }
    } catch (e) {
      W('openUmbrella hydrate failed; using summary row', e);
    }
  } else {
    L('no seedId â€” create mode');
  }

  // 2) Seed window.modalCtx and SHOW IMMEDIATELY
  const fullKeys = Object.keys(full || {});
  L('seeding window.modalCtx', { entity: 'umbrellas', fullId: full?.id, fullKeys });

  window.modalCtx = {
    entity: 'umbrellas',
    data: deep(full),
    formState: { __forId: full?.id || null, main: {} },
    rolesState: null,
    ratesState: null,
    clientSettingsState: null,
    openToken: ((full?.id) || 'new') + ':' + Date.now()
  };

  L('window.modalCtx seeded', {
    entity: window.modalCtx.entity,
    dataId: window.modalCtx.data?.id,
    dataKeys: Object.keys(window.modalCtx.data||{}),
    formStateForId: window.modalCtx.formState?.__forId,
    openToken: window.modalCtx.openToken
  });

  // 3) Render modal NOW
  L('calling showModal with hasId=', !!full?.id, 'rawHasIdArg=', full?.id);
  showModal(
    'Umbrella',
    [{ key:'main', label:'Main' }],
    (key, r)=> {
      L('[renderUmbrellaTab] tab=', key, 'rowKeys=', Object.keys(r||{}), 'sample=', { name: r?.name, id: r?.id });
      const u = r || {};
      return html(`
        <div class="form" id="tab-main">
          ${input('name','Name', u.name)}
          ${input('remittance_email','Remittance email', u.remittance_email, 'email')}
          ${input('bank_name','Bank', u.bank_name)}
          ${input('sort_code','Sort code', u.sort_code)}
          ${input('account_number','Account number', u.account_number)}

          <div class="row">
            <label>Company registration number</label>
            <div class="controls">
              <input class="input"
                     name="company_number"
                     value="${escapeHtml(u.company_number || '')}">
            </div>
          </div>

          <div class="row">
            <label>Address</label>
            <div class="controls">
              <div class="grid-2">
                <input class="input"
                       name="address_line1"
                       placeholder="Address line 1"
                       value="${escapeHtml(u.address_line1 || '')}">
                <input class="input"
                       name="address_line2"
                       placeholder="Address line 2"
                       value="${escapeHtml(u.address_line2 || '')}">
                <input class="input"
                       name="address_line3"
                       placeholder="Address line 3"
                       value="${escapeHtml(u.address_line3 || '')}">
                <input class="input"
                       name="town_city"
                       placeholder="City / Town"
                       value="${escapeHtml(u.town_city || '')}">
                <input class="input"
                       name="county"
                       placeholder="County"
                       value="${escapeHtml(u.county || '')}">
                <div class="split">
                  <input class="input"
                         name="postcode"
                         placeholder="Postcode"
                         value="${escapeHtml(u.postcode || '')}">
                  <button type="button"
                          class="btn mini"
                          data-act="umbrella-postcode-lookup"
                          title="Lookup by postcode">
                    Lookup
                  </button>
                </div>
                <input class="input"
                       name="country"
                       placeholder="Country"
                       value="${escapeHtml(u.country || '')}">
              </div>
            </div>
          </div>

          ${select('vat_chargeable','VAT chargeable', (u.vat_chargeable ? 'Yes' : 'No'), ['Yes','No'])}
          ${select('enabled','Enabled', (u.enabled === false) ? 'No' : 'Yes', ['Yes','No'])}
        </div>
      `);
    },
    async ()=> {
      L('[onSave] begin', { dataId: window.modalCtx?.data?.id, forId: window.modalCtx?.formState?.__forId });

      const fs = window.modalCtx.formState || { __forId: null, main:{} };
      const sameRecord = (!!window.modalCtx.data?.id && fs.__forId === window.modalCtx.data.id) ||
                         (!window.modalCtx.data?.id && fs.__forId == null);

      const staged = sameRecord ? (fs.main || {}) : {};
      const live   = collectForm('#tab-main');
      const payload = { ...staged, ...live };

      L('[onSave] collected', { sameRecord, stagedKeys: Object.keys(staged||{}), liveKeys: Object.keys(live||{}) });

      if (typeof payload.vat_chargeable !== 'boolean') {
        payload.vat_chargeable = (payload.vat_chargeable === 'Yes' || payload.vat_chargeable === 'true');
      }
      if (typeof payload.enabled !== 'boolean') {
        payload.enabled = (payload.enabled === 'Yes' || payload.enabled === 'true');
      }

      for (const k of Object.keys(payload)) {
        if (payload[k] === '') delete payload[k];
      }

      const idForUpdate = window.modalCtx?.data?.id || full?.id || null;
      L('[onSave] upsertUmbrella', { idForUpdate, payloadKeys: Object.keys(payload||{}) });
      const saved = await upsertUmbrella(payload, idForUpdate).catch(err => { E('upsertUmbrella failed', err); return null; });
      const umbrellaId = idForUpdate || (saved && saved.id);
      L('[onSave] saved', { ok: !!saved, umbrellaId, savedKeys: Object.keys(saved||{}) });
      if (!umbrellaId) { alert('Failed to save umbrella'); return { ok:false }; }

      window.modalCtx.data      = { ...(window.modalCtx.data || {}), ...(saved || {}), id: umbrellaId };
      window.modalCtx.formState = { __forId: umbrellaId, main: {} };

      if (!seedId && umbrellaId) window.__pendingFocus = { section: 'umbrellas', id: umbrellaId };

      L('[onSave] final window.modalCtx', {
        dataId: window.modalCtx.data?.id,
        dataKeys: Object.keys(window.modalCtx.data||{})
      });

      return { ok: true, saved: window.modalCtx.data };
    },
    full?.id,
    // onReturn: (re)bind address + company number to model + postcode lookup
    () => {
      try {
        const container = document.getElementById('tab-main');
        if (!container) return;
        const model = buildUmbrellaDetailsModel(window.modalCtx?.data || {});
        window.modalCtx.umbrellaModel = model;
        bindUmbrellaAddressEvents(container, model);
      } catch (e) {
        W('bindUmbrellaAddressEvents failed', e);
      }
    }
  );

  // (Umbrella has no heavy post-paint preloads in your snippet; if you add any later,
  // keep them here, after showModal, and guard with token/id like in openClient.)
}


// ---- Audit (Outbox)
function openAuditItem(row){
  const body = html(`
    <div class="form">
      ${readonly('Type', row.type)}
      ${readonly('To', row.to)}
      ${readonly('Subject', row.subject)}
      ${readonly('Status', row.status)}
      <div class="row" style="grid-column:1/-1"><label>Last error</label><textarea readonly>${row.last_error || ''}</textarea></div>
    </div>
  `);
  showModal('Outbox', [{key:'v',label:'View'}], ()=>body, async ()=>{ closeModal(); }, row?.id);
  const act = byId('modalActions');
  const retry = document.createElement('button'); retry.textContent='Retry send';
  retry.onclick = async ()=>{ await retryOutbox(row.id); alert('Retry queued'); }
  act.insertBefore(retry, byId('btnSave'));
}

// ---- Settings (global defaults)

async function renderSettingsPanel(content){
  // Load settings with a visible error if the call fails
  let s;
  try {
    s = await getSettings(); // unwraps {settings:{...}} â†’ {...}
  } catch (e) {
    content.innerHTML = `
      <div class="tabc">
        <div class="error">Couldnâ€™t load settings: ${e?.message || 'Unknown error'}</div>
      </div>`;
    return;
  }

  // Establish mode + snapshot for Cancel/Discard semantics
  let mode = 'view';            // 'view' | 'edit' | 'saving'
  let dirty = false;            // enable Save only when true
  let snapshot = JSON.parse(JSON.stringify(s)); // original values to restore on Discard

  // Prefer the new key; fall back to legacy if needed (still GLOBAL-only)
  const erniValue = (s.employers_ni_pct ?? s.erni_pct ?? 0);

  const input = (name,label,val,type='text') =>
    `<div class="row"><label>${label}</label><div class="controls"><input class="input" name="${name}" value="${String(val||'')}" ${type==='time'?'type="time" step="60"':''}/></div></div>`;

  const select = (name,label,val,opts)=>{
    const o = opts.map(v=>`<option value="${v}" ${String(v)===String(val)?'selected':''}>${v}</option>`).join('');
    return `<div class="row"><label>${label}</label><div class="controls"><select name="${name}">${o}</select></div></div>`;
  };

  // Render panel shell with explicit Edit / Save / Cancel buttons
  content.innerHTML = `
    <div class="tabc">
      <div class="form" id="settingsForm">
        ${input('timezone_id','Timezone', s.timezone_id || 'Europe/London')}
        ${input('day_start','Day start', s.day_start || '06:00')}
        ${input('day_end','Day end', s.day_end || '20:00')}
        ${input('night_start','Night start', s.night_start || '20:00')}
        ${input('night_end','Night end', s.night_end || '06:00')}

        ${input('sat_start','Saturday starts (HH:MM)', s.sat_start || '00:00')}
        ${input('sat_end','Saturday ends (HH:MM)', s.sat_end || '00:00')}
        ${input('sun_start','Sunday starts (HH:MM)', s.sun_start || '00:00')}
        ${input('sun_end','Sunday ends (HH:MM)', s.sun_end || '00:00')}

        ${input('bh_start','Bank Holiday starts (HH:MM)', s.bh_start || '00:00')}
        ${input('bh_end','Bank Holiday ends (HH:MM)',   s.bh_end   || '00:00')}

        ${select('bh_source','Bank Holidays source', s.bh_source || 'MANUAL', ['MANUAL','FEED'])}
        <div class="row" style="grid-column:1/-1">
          <label>Bank Holidays list (JSON dates)</label>
          <textarea name="bh_list">${JSON.stringify(s.bh_list || [], null, 2)}</textarea>
        </div>
        ${input('bh_feed_url','BH feed URL', s.bh_feed_url || '')}
        ${input('vat_rate_pct','VAT %', s.vat_rate_pct ?? 20, 'number')}
        ${input('holiday_pay_pct','Holiday pay %', s.holiday_pay_pct ?? 0, 'number')}
        ${input('erni_pct','ERNI %', erniValue, 'number')}
        ${select('apply_holiday_to','Apply holiday to', s.apply_holiday_to || 'PAYE_ONLY', ['PAYE_ONLY','ALL','NONE'])}
        ${select('apply_erni_to','Apply ERNI to', s.apply_erni_to || 'PAYE_ONLY', ['PAYE_ONLY','ALL','NONE'])}
        <div class="row" style="grid-column:1/-1">
          <label>Margin includes (JSON)</label>
          <textarea name="margin_includes">${JSON.stringify(s.margin_includes || {}, null, 2)}</textarea>
        </div>

        <div class="row">
          <label>Effective from (DD/MM/YYYY)</label>
          <input type="text" name="effective_from" id="settings_effective_from" placeholder="DD/MM/YYYY"
                 value="${s.effective_from ? formatIsoToUk(s.effective_from) : ''}" />
        </div>
      </div>

      <div class="actions">
        <span class="hint" id="settingsHint"></span>
        <div class="spacer"></div>
        <button id="btnEditSettings">Edit</button>
        <button id="btnCancelSettings">Close</button>
        <button id="btnSaveSettings" class="primary" disabled>Save</button>
      </div>
    </div>
  `;

  // Elements
  const formEl   = byId('settingsForm');
  const effInput = byId('settings_effective_from');
  const btnEdit  = byId('btnEditSettings');
  const btnSave  = byId('btnSaveSettings');
  const btnCancel= byId('btnCancelSettings');
  const hintEl   = byId('settingsHint');

  // Attach date picker
  if (effInput) attachUkDatePicker(effInput);

  // Helpers for view/edit toggling
  function setReadOnly(ro) {
    formEl.querySelectorAll('input, select, textarea').forEach(el => {
      el.disabled = !!ro;
      el.readOnly = !!ro && el.tagName === 'INPUT';
    });
  }
  function repaintButtons() {
    if (mode === 'view') {
      btnCancel.textContent = 'Close';
      hintEl.textContent = '';
      btnEdit.style.display = '';
      btnSave.style.display = 'none';
    } else if (mode === 'edit') {
      btnCancel.textContent = dirty ? 'Discard' : 'Cancel';
      hintEl.textContent = dirty ? 'You have unsaved changes' : '';
      btnEdit.style.display = 'none';
      btnSave.style.display = '';
      btnSave.disabled = !dirty;
    } else if (mode === 'saving') {
      btnCancel.textContent = 'Savingâ€¦';
      btnEdit.style.display = 'none';
      btnSave.style.display = '';
      btnSave.disabled = true;
    }
  }
  function toView() { mode = 'view'; dirty = false; setReadOnly(true);  repaintButtons(); }
  function toEdit() { mode = 'edit'; dirty = false; setReadOnly(false); repaintButtons(); }

  function refillFrom(obj) {
    const map = new Map([...formEl.querySelectorAll('input,select,textarea')].map(el => [el.name, el]));
    if (map.has('timezone_id')) map.get('timezone_id').value = obj.timezone_id || 'Europe/London';
    if (map.has('day_start'))   map.get('day_start').value   = obj.day_start || '06:00';
    if (map.has('day_end'))     map.get('day_end').value     = obj.day_end || '20:00';
    if (map.has('night_start')) map.get('night_start').value = obj.night_start || '20:00';
    if (map.has('night_end'))   map.get('night_end').value   = obj.night_end || '06:00';
    if (map.has('sat_start'))   map.get('sat_start').value   = obj.sat_start || '00:00';
    if (map.has('sat_end'))     map.get('sat_end').value     = obj.sat_end   || '00:00';
    if (map.has('sun_start'))   map.get('sun_start').value   = obj.sun_start || '00:00';
    if (map.has('sun_end'))     map.get('sun_end').value     = obj.sun_end   || '00:00';
    if (map.has('bh_start'))    map.get('bh_start').value    = obj.bh_start  || '00:00';
    if (map.has('bh_end'))      map.get('bh_end').value      = obj.bh_end    || '00:00';
    if (map.has('bh_source'))   map.get('bh_source').value   = obj.bh_source || 'MANUAL';
    if (map.has('bh_list'))     map.get('bh_list').value     = JSON.stringify(obj.bh_list || [], null, 2);
    if (map.has('bh_feed_url')) map.get('bh_feed_url').value = obj.bh_feed_url || '';
    if (map.has('vat_rate_pct'))map.get('vat_rate_pct').value= obj.vat_rate_pct ?? 20;
    if (map.has('holiday_pay_pct')) map.get('holiday_pay_pct').value = obj.holiday_pay_pct ?? 0;
    if (map.has('erni_pct'))    map.get('erni_pct').value    = (obj.employers_ni_pct ?? obj.erni_pct ?? 0);
    if (map.has('apply_holiday_to')) map.get('apply_holiday_to').value = obj.apply_holiday_to || 'PAYE_ONLY';
    if (map.has('apply_erni_to'))    map.get('apply_erni_to').value    = obj.apply_erni_to || 'PAYE_ONLY';
    if (map.has('margin_includes'))  map.get('margin_includes').value  = JSON.stringify(obj.margin_includes || {}, null, 2);
    if (map.has('effective_from'))   map.get('effective_from').value   = obj.effective_from ? formatIsoToUk(obj.effective_from) : '';
  }

  // Initial view-only mode
  setReadOnly(true);
  repaintButtons();

  // Dirty tracking (only in edit mode)
  const onDirty = () => { if (mode !== 'edit') return; dirty = true; repaintButtons(); };
  formEl.addEventListener('input', onDirty, true);
  formEl.addEventListener('change', onDirty, true);

  // Edit
  btnEdit.onclick = () => {
    if (mode !== 'view') return;
    snapshot = JSON.parse(JSON.stringify(s)); // capture original
    toEdit();
  };

  // Cancel / Discard / Close
  btnCancel.onclick = () => {
    if (mode === 'edit') {
      if (!dirty) { toView(); return; }
      const ok = window.confirm('Discard changes and return to view?');
      if (!ok) return;
      s = JSON.parse(JSON.stringify(snapshot));
      refillFrom(s);
      toView();
      return;
    }
    // mode === 'view' â†’ Close the settings panel view
    currentSection = 'candidates';
    renderAll();
  };

  // Save
  btnSave.onclick = async () => {
    if (mode !== 'edit' || !dirty) return;
    mode = 'saving'; repaintButtons();

    const payload = collectForm('#settingsForm', true);
    if (payload.effective_from) {
      const iso = parseUkDateToIso(payload.effective_from);
      if (!iso) { alert('Invalid Effective from date'); mode='edit'; repaintButtons(); return; }
      payload.effective_from = iso;
    }

    try {
      await saveSettings(payload);
      s = { ...s, ...payload };
      snapshot = JSON.parse(JSON.stringify(s));
      toView();
      hintEl.textContent = 'Saved.';
      setTimeout(()=> { if (hintEl.textContent === 'Saved.') hintEl.textContent=''; }, 1500);
    } catch (e) {
      mode = 'edit'; repaintButtons();
      alert('Save failed: ' + (e?.message || 'Unknown error'));
    }
  };
}



function renderContractAdditionalRatesTab(ctx) {
  const LOGC = (typeof window.__LOG_CONTRACTS === 'boolean') ? window.__LOG_CONTRACTS : false;

  const merged = mergeContractStateIntoRow(ctx?.data || {});
  const payMethod = String(merged?.pay_method_snapshot || 'PAYE').toUpperCase();
  const payLabel  = (payMethod === 'UMBRELLA') ? 'Pay (Umbrella)' : 'Pay (PAYE)';

  const extras = Array.isArray(merged.additional_rates_json)
    ? merged.additional_rates_json
    : [];

  const findSlot = (code) => extras.find(e => e && String(e.code || '').toUpperCase() === String(code).toUpperCase()) || null;
  const num = (v) => (v == null || v === '') ? '' : String(v);

  const freqOptions = [
    ['ONE_PER_WEEK',         'One per week'],
    ['ONE_PER_DAY',          'One per day'],
    ['WEEKENDS_AND_BH_ONLY', 'Weekends & Bank Holidays only'],
    ['WEEKDAYS_EXCL_BH_ONLY','Weekdays (excl Bank Holidays) only']
  ];

  const esc = (x) => String(x == null ? '' : x)
    .replace(/&/g,'&amp;')
    .replace(/</g,'&lt;')
    .replace(/>/g,'&gt;')
    .replace(/"/g,'&quot;')
    .replace(/'/g,'&#39;');

  const rowsHtml = [];
  for (let i = 1; i <= 5; i++) {
    const code = `EX${i}`;
    const cfg  = findSlot(code) || {};
    const bucketName = cfg.bucket_name || '';
    const unitName   = cfg.unit_name || '';
    const freq       = (cfg.frequency || 'ONE_PER_WEEK').toUpperCase();
    const payRate    = (cfg.pay_rate != null && Number.isFinite(Number(cfg.pay_rate))) ? Number(cfg.pay_rate) : null;
    const chargeRate = (cfg.charge_rate != null && Number.isFinite(Number(cfg.charge_rate))) ? Number(cfg.charge_rate) : null;

    let marginStr = '';
    if (payRate != null && chargeRate != null) {
      let erniMult = 1;
      try {
        if (typeof window.__ERNI_MULT__ === 'number' && window.__ERNI_MULT__ > 0) {
          erniMult = window.__ERNI_MULT__;
        }
      } catch {}
      let mg = chargeRate - (payMethod === 'PAYE' ? payRate * erniMult : payRate);
      marginStr = mg.toFixed(2);
    }

    rowsHtml.push(`
      <div class="row extra-rate-row" data-slot="${esc(code)}">
        <label>Bucket ${i}</label>
        <div class="controls" style="display:flex;flex-direction:column;gap:4px">
          <div class="grid-6" style="min-width:0;gap:8px;align-items:flex-end;flex-wrap:wrap">
            <div class="split">
              <span class="mini">Bucket name</span>
              <input class="input" name="extra_bucket_name_${i}" value="${esc(bucketName)}" placeholder="e.g. Patient visits" />
            </div>
            <div class="split">
              <span class="mini">Unit name</span>
              <input class="input" name="extra_unit_name_${i}" value="${esc(unitName)}" placeholder="e.g. Number of visits" />
            </div>
            <div class="split">
              <span class="mini">Frequency</span>
              <select class="input" name="extra_frequency_${i}">
                ${freqOptions.map(([val,label]) => `
                  <option value="${val}" ${val === freq ? 'selected' : ''}>${esc(label)}</option>
                `).join('')}
              </select>
            </div>
            <div class="split">
              <span class="mini">${payLabel} (per unit)</span>
              <input class="input" type="number" step="0.01" min="0" name="extra_pay_${i}" value="${payRate != null ? esc(payRate.toFixed(2)) : ''}" placeholder="0.00" />
            </div>
            <div class="split">
              <span class="mini">Charge (per unit)</span>
              <input class="input" type="number" step="0.01" min="0" name="extra_charge_${i}" value="${chargeRate != null ? esc(chargeRate.toFixed(2)) : ''}" placeholder="0.00" />
            </div>
            <div class="split">
              <span class="mini">Margin / unit</span>
              <span class="mini" data-role="extra-margin" data-slot="${esc(code)}">${marginStr ? `Â£${esc(marginStr)}` : ''}</span>
            </div>
          </div>
          <div style="margin-top:4px">
            <button type="button"
                    class="btn mini"
                    data-extra-clear="${esc(code)}"
                    title="Clear bucket ${i}">
              Clear
            </button>
          </div>
        </div>
      </div>
    `);
  }

  const html = `
    <div class="tabc" id="contractAdditionalRatesTab">
      <div class="row">
        <label class="section">Additional Rates</label>
        <div class="controls">
          <div class="hint">
            Up to 5 optional additional pay buckets, billed by units (e.g. patient visits).<br/>
            Margins are per-unit and follow the PAYE/Umbrella logic used on the Rates tab.
          </div>
        </div>
      </div>
      <div class="group">
        ${rowsHtml.join('')}
      </div>
    </div>
  `;

  // Wire up margin recalculation + Clear buttons after DOM render
  setTimeout(() => {
    try {
      const root = document.getElementById('contractAdditionalRatesTab');
      if (!root) return;

      const getErniMult = () => {
        try {
          if (typeof window.__ERNI_MULT__ === 'number' && window.__ERNI_MULT__ > 0) {
            return window.__ERNI_MULT__;
          }
        } catch {}
        return 1;
      };

      const getPayMethod = () => {
        try {
          const fs = (window.modalCtx && window.modalCtx.formState) || { main:{}, pay:{} };
          const staged = (fs.main && fs.main.pay_method_snapshot) || '';
          const sel = document.querySelector('select[name="pay_method_snapshot"], select[name="default_pay_method_snapshot"]');
          const v = (sel && sel.value) || staged || 'PAYE';
          return String(v).toUpperCase();
        } catch {
          return 'PAYE';
        }
      };

      const recalcMargins = () => {
        const pm = getPayMethod();
        const erniMult = getErniMult();
        for (let i = 1; i <= 5; i++) {
          const code = `EX${i}`;
          const payEl    = root.querySelector(`input[name="extra_pay_${i}"]`);
          const chargeEl = root.querySelector(`input[name="extra_charge_${i}"]`);
          const span     = root.querySelector(`span[data-role="extra-margin"][data-slot="${code}"]`);
          if (!span) continue;

          const payVal    = payEl ? Number(payEl.value || 0) : 0;
          const chargeVal = chargeEl ? Number(chargeEl.value || 0) : 0;

          if (!Number.isFinite(payVal) || !Number.isFinite(chargeVal) || (!payEl?.value && !chargeEl?.value)) {
            span.textContent = '';
            continue;
          }

          let mg;
          if (pm === 'PAYE') {
            mg = chargeVal - (payVal * erniMult);
          } else {
            mg = chargeVal - payVal;
          }
          span.textContent = `Â£${mg.toFixed(2)}`;
        }
      };

      // Wire Clear buttons
      root.querySelectorAll('button[data-extra-clear]').forEach(btn => {
        if (btn.__wiredClear) return;
        btn.__wiredClear = true;
        btn.addEventListener('click', () => {
          const slot = btn.getAttribute('data-extra-clear');
          const idx  = slot && slot.replace(/^EX/, '');
          if (!idx) return;
          ['bucket_name','unit_name','pay','charge'].forEach(suffix => {
            const name = suffix === 'bucket_name'
              ? `extra_bucket_name_${idx}`
              : suffix === 'unit_name'
                ? `extra_unit_name_${idx}`
                : suffix === 'pay'
                  ? `extra_pay_${idx}`
                  : `extra_charge_${idx}`;
            const el = root.querySelector(`[name="${name}"]`);
            if (el) {
              el.value = '';
              try { el.dispatchEvent(new Event('input', { bubbles:true })); } catch {}
              try { el.dispatchEvent(new Event('change',{ bubbles:true })); } catch {}
            }
          });
          const span = root.querySelector(`span[data-role="extra-margin"][data-slot="${slot}"]`);
          if (span) span.textContent = '';
          try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
        });
      });

      // Recalc margins on input changes
      const onChange = (ev) => {
        const t = ev.target;
        if (!t || !t.name) return;
        if (/^extra_(pay|charge)_\d+$/.test(t.name)) {
          recalcMargins();
          try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
        }
      };
      root.addEventListener('input', onChange, true);
      root.addEventListener('change', onChange, true);

      recalcMargins();

      // Signal for any wiring that listens for this tab
      try {
        const ev = new CustomEvent('contracts-extras-rendered', { detail: {} });
        window.dispatchEvent(ev);
      } catch {
        window.dispatchEvent(new Event('contracts-extras-rendered'));
      }

      if (LOGC) console.log('[CONTRACTS] renderContractAdditionalRatesTab wired');
    } catch (e) {
      if (LOGC) console.warn('[CONTRACTS] extras tab wiring failed', e);
    }
  }, 0);

  return html;
}



// ===== Generic modal plumbing =====

// =============================== showModal (FIXED) ===============================
// ==== FIXED MODAL FRAMEWORK: close only on explicit success from onSave ====
// ==== CHILD MODAL (CANDIDATE RATE) â€” throw on errors; return true on success ====



// =============================== closeModal (kept) ===============================
// ================== FRONTEND: closeModal (UPDATED to refresh if pending focus) ==================
function closeModal(){
  if (!window.__modalStack || !window.__modalStack.length) {
    // nothing to close; ensure overlay hidden and geometry clean
    discardAllModalsAndState();
    return;
  }

  // Sanitize geometry before changing frames
  const m = byId('modal');
  if (m) {
    m.style.position = '';
    m.style.left = '';
    m.style.top = '';
    m.style.right = '';
    m.style.bottom = '';
    m.style.transform = '';
    m.classList.remove('dragging');
  }
  document.onmousemove = null;
  document.onmouseup   = null;

  const closing = window.__modalStack.pop();
  if (closing) {
    // Detach per-frame listeners
    if (closing._detachDirty)  { try { closing._detachDirty();  } catch(_) {} closing._detachDirty  = null; }
    if (closing._detachGlobal) { try { closing._detachGlobal(); } catch(_) {} closing._detachGlobal = null; }
  }

  if (window.__modalStack.length > 0) {
    const parent = window.__modalStack[window.__modalStack.length - 1];
    byId('modalBack').style.display = 'flex';

    // Rebuild tabs
    const tabsEl = byId('modalTabs'); tabsEl.innerHTML = '';
    (parent.tabs || []).forEach((t) => {
      const b = document.createElement('button');
      b.textContent = t.label;
      if (t.key === parent.currentTabKey) b.classList.add('active');
      b.onclick = () => {
        tabsEl.querySelectorAll('button').forEach(x => x.classList.remove('active'));
        b.classList.add('active');
        parent.setTab(t.key);
      };
      tabsEl.appendChild(b);
    });

    // Re-show parent current tab
    if (parent.currentTabKey) parent.setTab(parent.currentTabKey);
    else if (parent.tabs && parent.tabs[0]) parent.setTab(parent.tabs[0].key);
  } else {
    // last frame closed -> full teardown so nothing lingers
    discardAllModalsAndState();

    // If a pending focus token exists, refresh the summary now so it can jump & highlight
    if (window.__pendingFocus) {
      try { renderAll(); } catch (e) { console.error('refresh after modal close failed', e); }
    }
  }
}

// === Helpers for modal mode & interactivity ===
function _currentFrame() {
  const stk = window.__modalStack || [];
  return stk[stk.length - 1] || null;
}
function _parentFrame() {
  const stk = window.__modalStack || [];
  return stk.length >= 2 ? stk[stk.length - 2] : null;
}
function _setFormReadOnly(root, ro) {
  if (!root) return;
  root.querySelectorAll('input, select, textarea, button').forEach(el => {
    const isDisplayOnly = el.id === 'tms_ref_display' || el.id === 'cli_ref_display';
    if (el.type === 'button') {
      // Buttons are generally disabled only when parent is view/child not editable
      if (ro && !isDisplayOnly) el.disabled = true;
      else if (!isDisplayOnly) el.disabled = false;
      return;
    }
    if (isDisplayOnly) {
      el.setAttribute('disabled', 'true');
      el.setAttribute('readonly', 'true');
      return;
    }
    if (ro) { el.setAttribute('disabled','true'); el.setAttribute('readonly','true'); }
    else    { el.removeAttribute('disabled'); el.removeAttribute('readonly'); }
  });
}
function _setFrameMode(frame, mode) {
  // mode: 'create' | 'view' | 'edit' | 'saving'
  frame.mode = mode;
  // read-only if view or saving
  const readOnly = (mode === 'view' || mode === 'saving');
  _setFormReadOnly(byId('modalBody'), readOnly);
  // buttons update
  if (typeof frame._updateButtons === 'function') frame._updateButtons();
}


// ===== Small helpers (fixed attribute serialization + HTML escaping) =====
const html = (s)=> s;

const _esc = (v) => String(v)
  .replace(/&/g,'&amp;')
  .replace(/</g,'&lt;')
  .replace(/>/g,'&gt;')
  .replace(/"/g,'&quot;')
  .replace(/'/g,'&#39;');

const _attrStr = (extra) => {
  if (!extra) return '';
  if (typeof extra === 'string') {
    const t = extra.trim();
    return t ? (' ' + t) : '';
  }
  if (typeof extra !== 'object') return '';
  let out = '';
  for (const [k, v] of Object.entries(extra)) {
    if (v === false || v == null) continue;      // skip false/null/undefined
    if (v === true) { out += ` ${k}`; continue; } // boolean attribute
    out += ` ${k}="${_esc(v)}"`;                  // key="value"
  }
  return out;
};

const input = (name, label, val = '', type = 'text', extra = '') => {
  const attrs = _attrStr(extra);
  const value = (val == null ? '' : val);
  return `<div class="row"><label>${_esc(label)}</label><input name="${_esc(name)}" type="${_esc(type)}" value="${_esc(value)}"${attrs}/></div>`;
};

const select = (name, label, val, options = [], extra = {}) => {
  const attrs = _attrStr(extra);
  const opts = options.map(o => {
    const selected = String(o) === String(val) ? ' selected' : '';
    return `<option${selected}>${_esc(o)}</option>`;
  }).join('');
  return `<div class="row"><label>${_esc(label)}</label><select name="${_esc(name)}"${attrs}>${opts}</select></div>`;
};

const readonly = (label, value) =>
  `<div class="row"><label>${_esc(label)}</label><input value="${_esc(value ?? '')}" readonly/></div>`;


/**
 * Safer form collector:
 * - Skips elements with no name
 * - Skips disabled/readonly or data-no-collect
 * - Converts Yes/No selects to booleans
 */
function collectForm(sel, jsonTry=false){
  const root = document.querySelector(sel);
  if (!root) return {};

  const out = {};
  root.querySelectorAll('input,select,textarea').forEach(el=>{
    if (!el.name) return;
    if (el.disabled || el.readOnly || el.dataset.noCollect === 'true') return;

    const k = el.name;
    let v;

    if (el.type === 'checkbox') {
      v = el.checked ? 'on' : '';
    } else if (el.type === 'radio') {
      if (!el.checked) return;
      v = el.value;
    } else if (el.type === 'number') {
      v = (el.value === '' ? '' : Number(el.value));
    } else {
      v = el.value;
    }

    if (el.tagName === 'SELECT' && (v === 'Yes' || v === 'No')) v = (v === 'Yes');

    if (jsonTry && (k === 'bh_list' || k === 'margin_includes')) {
      try { v = JSON.parse(v || (k === 'bh_list' ? '[]' : '{}')); } catch {}
    }

    out[k] = v;
  });
  return out;
}


// ================= NEW: Job titles client-side cache ==================
window.__jobTitlesCache = window.__jobTitlesCache || {
  items: [],
  byId: {},
  roots: [],
  loadedAt: 0
};

function normaliseJobTitles(items) {
  const byId = {};
  const roots = [];
  (items || []).forEach((r) => {
    if (!r || !r.id) return;
    const copy = { ...r, children: [] };
    byId[r.id] = copy;
  });
  Object.values(byId).forEach((node) => {
    if (node.parent_id && byId[node.parent_id]) {
      byId[node.parent_id].children.push(node);
    } else {
      roots.push(node);
    }
  });
  return { items, byId, roots };
}

// =============== NEW: loadJobTitlesTree (backend â†’ cache) ===============
// =============== NEW: loadJobTitlesTree (backend â†’ cache) ===============
async function loadJobTitlesTree(force = false, activeOnly = true) {
  // Ensure cache shape
  window.__jobTitlesCache = window.__jobTitlesCache || {
    items: [],
    byId: {},
    roots: [],
    loadedAt: 0
  };
  const C = window.__jobTitlesCache;
  const now = Date.now();

  // Reuse cache only for activeOnly=true
  if (
    activeOnly &&
    !force &&
    C.items &&
    C.items.length &&
    now - C.loadedAt < 60_000
  ) {
    return C;
  }

  const url = API(`/api/job-titles?activeOnly=${activeOnly ? 'true' : 'false'}`);
  const res = await authFetch(url);
  if (!res.ok) {
    console.error('[JOB_TITLES] list failed', res.status);
    throw new Error('Failed to load job titles');
  }
  const data = (await res.json().catch(() => ({}))) || {};
  const items = data.items || [];
  const norm = normaliseJobTitles(items);

  // Only mutate global cache when weâ€™re in activeOnly mode
  if (activeOnly) {
    C.items = items;
    C.byId = norm.byId;
    C.roots = norm.roots;
    C.loadedAt = now;
    return C;
  }

  // For Settings (activeOnly=false) return a separate snapshot
  return {
    items,
    byId: norm.byId,
    roots: norm.roots,
    loadedAt: now
  };
}


// =============== NEW: buildJobTitlePathLabels ==========================
function buildJobTitlePathLabels(jobTitleId) {
  const C = window.__jobTitlesCache || {};
  const byId = C.byId || {};
  const chain = [];
  let cur = byId[jobTitleId];
  while (cur && chain.length < 16) {
    chain.push(cur.label || '');
    cur = cur.parent_id ? byId[cur.parent_id] : null;
  }
  return chain.reverse().filter(Boolean);
}

// =============== NEW: Job titles API helpers ===========================
async function apiCreateJobTitle(payload) {
  const url = API('/api/job-titles');
  const res = await authFetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload || {})
  });
  if (!res.ok) throw new Error('Failed to create job title');
  const data = (await res.json().catch(() => ({}))) || {};
  return data.item || null;
}

async function apiUpdateJobTitle(id, patch) {
  const url = API(`/api/job-titles/${encodeURIComponent(id)}`);
  const res = await authFetch(url, {
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(patch || {})
  });
  if (!res.ok) throw new Error('Failed to update job title');
  const data = (await res.json().catch(() => ({}))) || {};
  return data.item || null;
}

async function apiDeleteJobTitle(id) {
  const url = API(`/api/job-titles/${encodeURIComponent(id)}`);
  const res = await authFetch(url, { method: 'DELETE' });
  if (!res.ok) throw new Error('Failed to delete job title');
  const data = (await res.json().catch(() => ({}))) || {};
  return data;
}

function openJobTitleSettingsModal() {
  const S = {
    loading: false,
    error: '',
    items: [],
    byId: {},
    roots: [],
    selectedId: null,
    editing: null, // { id|null, parent_id|null, label, is_role, requires_prof_reg, prof_reg_type, active, isNew }
    collapsed: {}  // { [id]: true } for collapsed nodes
  };

  const profTypes = ['NMC', 'GMC', 'HCPC'];

  const makeEditingFromNode = (node) => {
    if (!node) return null;
    return {
      id: node.id,
      parent_id: node.parent_id || null,
      label: node.label || '',
      is_role: !!node.is_role,
      requires_prof_reg: !!node.requires_prof_reg,
      prof_reg_type: node.prof_reg_type || '',
      active: node.active !== false,
      isNew: false
    };
  };

  const makeEditingNew = (parentId) => ({
    id: null,
    parent_id: parentId || null,
    label: '',
    is_role: false, // default to Category
    requires_prof_reg: false,
    prof_reg_type: '',
    active: true,
    isNew: true
  });

  const renderTree = (nodes, level) => {
    if (!nodes || !nodes.length) return '';
    const pad = level * 16;
    return nodes
      .map((n) => {
        const isSelected =
          S.selectedId === n.id || (!S.selectedId && S.editing && S.editing.id === n.id);
        const kindLabel = n.is_role ? 'Role' : 'Category';
        const regBadge =
          n.is_role && n.requires_prof_reg
            ? `<span class="pill mini" style="margin-left:4px">${n.prof_reg_type || 'Reg'}</span>`
            : '';
        const inactiveTag =
          n.active === false
            ? `<span class="mini" style="margin-left:4px;opacity:.7">(inactive)</span>`
            : '';

        const hasChildren = Array.isArray(n.children) && n.children.length > 0;
        const isCollapsed = !!S.collapsed[n.id];

        const toggleHtml = hasChildren
          ? `<button type="button" class="btn mini" data-act="toggle" data-id="${n.id}" style="margin-right:4px;width:24px;text-align:center;padding:2px 0">${isCollapsed ? '+' : 'âˆ’'}</button>`
          : `<span style="display:inline-block;width:24px"></span>`;

        const childrenHtml = !isCollapsed ? renderTree(n.children || [], level + 1) : '';

        return `
          <div class="jt-node${isSelected ? ' jt-node-active' : ''}" data-id="${n.id}"
               style="padding:4px 6px 4px ${pad + 6}px;cursor:pointer;border-radius:6px;">
            <div style="display:flex;align-items:center;justify-content:space-between;gap:6px">
              <div style="display:flex;align-items:center;gap:4px">
                ${toggleHtml}
                <span class="jt-label" style="font-weight:600">${escapeHtml(n.label || '')}</span>
                <span class="mini" style="margin-left:6px;opacity:.75">${kindLabel}</span>
                ${regBadge}
                ${inactiveTag}
              </div>
              <div class="mini">
                <button type="button" class="btn mini" data-act="add-child" data-id="${n.id}">+ Child</button>
              </div>
            </div>
          </div>
          ${childrenHtml}
        `;
      })
      .join('');
  };

  const renderDetailsPanel = () => {
    const e = S.editing;
    if (!e) {
      return `
        <div class="hint" style="padding:8px">
          Select a node on the left, or click <strong>Add family</strong> to create a new top-level group.
        </div>
      `;
    }

    const node = e.id ? S.byId[e.id] : null;

    const hasRoleDescendants = (n) => {
      if (!n || !Array.isArray(n.children)) return false;
      const stack = [...n.children];
      let guard = 0;
      while (stack.length && guard++ < 1024) {
        const cur = stack.pop();
        if (!cur) continue;
        if (cur.is_role) return true;
        if (Array.isArray(cur.children) && cur.children.length) {
          stack.push(...cur.children);
        }
      }
      return false;
    };

    const depth = node ? (Number(node.depth) || 0) : (e.parent_id ? 1 : 0);
    const hasRoleDesc = node && hasRoleDescendants(node);

    // Determine title based on type + depth
    let title;
    if (e.isNew) {
      if (!e.parent_id) {
        title = 'New Family';
      } else if (!e.is_role) {
        title = 'New Sub Family';
      } else {
        title = 'New Role';
      }
    } else {
      if (e.is_role) {
        title = 'Edit Job Title';
      } else if (depth > 0 || e.parent_id) {
        title = 'Edit Sub Family Name';
      } else {
        title = 'Edit Family Name';
      }
    }

    // Category Type radios
    const nodeTypeGroupChecked = !e.is_role ? 'checked' : '';
    const nodeTypeRoleChecked = e.is_role ? 'checked' : '';

    // Show Role radio?
    let showRoleRadio = true;
    if (e.isNew && !e.parent_id) {
      // Add Family â†’ cannot create a Role at top level
      showRoleRadio = false;
    } else if (!e.isNew && !e.is_role && hasRoleDesc) {
      // Existing Family/Subfamily with descendant Roles â†’ cannot switch to Role
      showRoleRadio = false;
    }

    const requiresChecked = !!(e.is_role && e.requires_prof_reg);
    const regBlockStyle = e.is_role ? '' : 'display:none';

    // Parent path using local state (families > subfamilies)
    const parentPath = (() => {
      if (!e.parent_id) return '(top-level family)';
      const chain = [];
      let cur = S.byId[e.parent_id];
      let guard = 0;
      while (cur && guard++ < 16) {
        chain.push(cur.label || '');
        cur = cur.parent_id ? S.byId[cur.parent_id] : null;
      }
      return chain.length ? chain.reverse().join(' > ') : '(no parent)';
    })();

    const regOptions = profTypes
      .map((t) => `<option value="${t}" ${e.prof_reg_type === t ? 'selected' : ''}>${t}</option>`)
      .join('');

    const activeChecked = e.active ? 'checked' : '';

    return `
      <form id="jt_details_form" class="form" autocomplete="off">
        <div class="row" style="grid-column:1/-1">
          <div class="mini" style="opacity:.85">${title}</div>
        </div>

        <div class="row">
          <label>Label</label>
          <div class="controls">
            <input type="text" name="label" value="${escapeHtml(e.label || '')}" required />
            <div id="jt_cat_vis_row" style="margin-top:6px;display:flex;gap:12px;align-items:center;flex-wrap:wrap">
              <label class="inline">
                <input type="radio" name="node_type" value="group" ${nodeTypeGroupChecked} />
                <span>Category</span>
              </label>
              ${
                showRoleRadio
                  ? `
              <label class="inline">
                <input type="radio" name="node_type" value="role" ${nodeTypeRoleChecked} />
                <span>Role</span>
              </label>`
                  : ''
              }
              <label class="inline">
                <input type="checkbox" name="active" ${activeChecked} />
                <span>Visible to users</span>
              </label>
            </div>
          </div>
        </div>

        <div class="row">
          <label>Parent</label>
          <div class="mini" style="padding:6px 8px;border-radius:8px;background:#020617;border:1px solid var(--line)">
            ${escapeHtml(parentPath)}
          </div>
        </div>

        <div class="row" data-block="reg" style="${regBlockStyle}">
          <label class="inline">
            <input type="checkbox" name="requires_prof_reg" ${requiresChecked ? 'checked' : ''} />
            <span>Requires professional registration</span>
          </label>
          <select name="prof_reg_type" style="margin-top:6px;${requiresChecked ? '' : 'display:none'}">
            <option value="">-- Select type --</option>
            ${regOptions}
          </select>
        </div>

        <div class="row" style="grid-column:1/-1;margin-top:8px;display:flex;flex-direction:row;align-items:center;gap:6px;justify-content:flex-end">
          <button type="button" class="btn mini" style="padding:4px 8px" id="jt_btn_delete" ${(e.isNew || (node && Array.isArray(node.children) && node.children.length)) ? 'disabled' : ''}>Delete</button>
          <button type="button" class="btn mini primary" style="padding:4px 10px" id="jt_btn_save">Save</button>
        </div>
      </form>
    `;
  };

  const buildBody = () => {
    if (S.loading) {
      return html(`
        <div id="jobTitlesSettingsRoot" style="padding:10px">
          <div class="hint">Loading job titlesâ€¦</div>
        </div>
      `);
    }

    const treeHtml = renderTree(S.roots || [], 0);

    return html(`
      <div id="jobTitlesSettingsRoot" style="display:grid;grid-template-columns:minmax(0,1.4fr) minmax(0,1.8fr);gap:12px;min-height:260px">
        <div>
          <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:6px">
            <div class="mini">Families / subfamilies / roles</div>
            <button type="button" class="btn mini" id="jt_add_root">+ Add family</button>
          </div>
          <div id="jt_tree"
               style="border:1px solid var(--line);border-radius:10px;max-height:420px;overflow:auto;padding:4px">
            ${
              treeHtml ||
              '<div class="hint" style="padding:8px">No job titles defined yet. Click <strong>Add family</strong> to create your first group.</div>'
            }
          </div>
          ${S.error ? `<div class="error" style="margin-top:8px">${escapeHtml(S.error)}</div>` : ''}
        </div>

        <div style="border:1px solid var(--line);border-radius:10px;padding:8px;min-height:240px">
          ${renderDetailsPanel()}
        </div>
      </div>
    `);
  };

  const repaint = () => {
    const bodyEl = document.getElementById('modalBody');
    if (!bodyEl) return;
    bodyEl.innerHTML = buildBody();
    wireEvents();
  };

  const showRoleUsageInCandidates = async (candidateIds) => {
    if (!Array.isArray(candidateIds) || !candidateIds.length) {
      alert('This job title is in use, but no candidate IDs were returned.');
      return;
    }
    const ok = window.confirm(
      `This role is assigned to ${candidateIds.length} candidates. Show them in the Candidates list?`
    );
    if (!ok) return;

    try {
      // Switch to Candidates section and filter by ids
      window.currentSection = 'candidates';
      window.__listState = window.__listState || {};
      const st = (window.__listState.candidates ||= {
        page: 1,
        pageSize: 50,
        total: null,
        hasMore: false,
        filters: null,
        sort: { key: null, dir: 'asc' }
      });
      st.page = 1;
      st.filters = { ...(st.filters || {}), ids: candidateIds };

      const rows = await search('candidates', st.filters);
      renderSummary(rows);

      // Close the Job Titles modal if it's open
      const btnClose = document.getElementById('btnCloseModal');
      if (btnClose) btnClose.click();
    } catch (e) {
      console.error('Failed to show candidates for job title', e);
      alert('Failed to open Candidates list for this role.');
    }
  };

  const refreshFromCache = async () => {
    S.loading = true;
    S.error = '';
    repaint();
    try {
      // Load ALL titles (including inactive) for Settings
      const cache = await loadJobTitlesTree(true, false);
      S.items = cache.items;
      S.byId = cache.byId;
      S.roots = cache.roots;

      // Seed collapsed state: collapse all non-role nodes that have children
      S.collapsed = {};
      const seedCollapsed = (nodes) => {
        if (!Array.isArray(nodes)) return;
        for (const n of nodes) {
          if (!n) continue;
          if (!n.is_role && Array.isArray(n.children) && n.children.length > 0) {
            S.collapsed[n.id] = true;
            seedCollapsed(n.children);
          }
        }
      };
      seedCollapsed(S.roots);

      // If nothing is selected, pick the first root if any
      if (!S.selectedId && S.roots.length) {
        S.selectedId = S.roots[0].id;
      }
      if (S.selectedId && S.byId[S.selectedId]) {
        S.editing = makeEditingFromNode(S.byId[S.selectedId]);
      } else {
        S.editing = null;
      }
    } catch (e) {
      console.error('[JOB_TITLES] load failed', e);
      S.error = 'Failed to load job titles';
    } finally {
      S.loading = false;
      repaint();
    }
  };

  const wireEvents = () => {
    const root = document.getElementById('jobTitlesSettingsRoot');
    if (!root) return;

    const treeBox = root.querySelector('#jt_tree');
    const addRootBtn = root.querySelector('#jt_add_root');
    const form = root.querySelector('#jt_details_form');
    const saveBtn = root.querySelector('#jt_btn_save');
    const deleteBtn = root.querySelector('#jt_btn_delete');

    if (addRootBtn) {
      addRootBtn.onclick = () => {
        S.selectedId = null;
        S.editing = makeEditingNew(null);
        repaint();
      };
    }

    if (treeBox) {
      treeBox.onclick = (e) => {
        const btn = e.target.closest('button[data-act]');
        if (btn) {
          const act = btn.getAttribute('data-act');
          const id = btn.getAttribute('data-id');
          const node = S.byId[id];
          if (!node) return;

          if (act === 'add-child') {
            S.selectedId = null;
            S.editing = makeEditingNew(node.id);
            repaint();
          } else if (act === 'toggle') {
            S.collapsed[id] = !S.collapsed[id];
            repaint();
          }
          return;
        }

        const nodeEl = e.target.closest('.jt-node[data-id]');
        if (!nodeEl) return;
        const id = nodeEl.getAttribute('data-id');
        const n = S.byId[id];
        if (!n) return;
        S.selectedId = id;
        S.editing = makeEditingFromNode(n);
        repaint();
      };
    }

    if (form && saveBtn) {
      saveBtn.onclick = async () => {
        const v = collectForm('#jt_details_form', false) || {};
        const label = (v.label || '').trim();
        if (!label) {
          alert('Label is required');
          return;
        }

        const nodeType = v.node_type === 'role' ? 'role' : 'group';
        const isRole = nodeType === 'role';

        const requiresProfReg = isRole && v.requires_prof_reg === 'on';
        const profRegType = requiresProfReg ? (v.prof_reg_type || '').trim().toUpperCase() : null;
        const active = v.active === 'on';

        if (requiresProfReg && !profRegType) {
          alert('Please choose a professional registration type (NMC / GMC / HCPC)');
          return;
        }

        const isNew = !S.editing || !S.editing.id;
        const parentId = S.editing ? S.editing.parent_id || null : null;

        try {
          let node;
          if (isNew) {
            node = await apiCreateJobTitle({
              label,
              parent_id: parentId,
              is_role: isRole,
              requires_prof_reg: requiresProfReg,
              prof_reg_type: profRegType,
              active
            });
          } else {
            node = await apiUpdateJobTitle(S.editing.id, {
              label,
              is_role: isRole,
              requires_prof_reg: requiresProfReg,
              prof_reg_type: profRegType,
              active
            });
          }

          // If backend signals that the role is in use, offer to show candidates
          if (node && node.error === 'JOB_TITLE_IN_USE' && Array.isArray(node.candidate_ids)) {
            await showRoleUsageInCandidates(node.candidate_ids);
            return;
          }

          // Refresh cache & select this node
          await refreshFromCache();
          if (node && node.id) {
            S.selectedId = node.id;
            S.editing = makeEditingFromNode(node);
            repaint();
          }
        } catch (err) {
          console.error('job title save failed', err);
          alert('Failed to save job title');
        }
      };
    }

    if (form && deleteBtn && !deleteBtn.disabled) {
      deleteBtn.onclick = async () => {
        if (!S.editing || !S.editing.id) return;
        const node = S.byId[S.editing.id];
        if (!node) return;

        if (!window.confirm(`Delete "${node.label}"?`)) return;

        try {
          const res = await apiDeleteJobTitle(node.id);

          // If backend says job title is in use, offer to show candidates
          if (res && res.error === 'JOB_TITLE_IN_USE' && Array.isArray(res.candidate_ids)) {
            await showRoleUsageInCandidates(res.candidate_ids);
            return;
          }

          await refreshFromCache();
        } catch (err) {
          console.error('job title delete failed', err);
          alert('Failed to delete job title â€“ it may still be in use.');
        }
      };
    }

    // Category Type + registration block behaviour
    if (form) {
      const nodeTypeInputs = form.querySelectorAll('input[name="node_type"]');
      const regBlock = form.querySelector('[data-block="reg"]');
      const reqCb = form.querySelector('input[name="requires_prof_reg"]');
      const regSelect = form.querySelector('select[name="prof_reg_type"]');

      nodeTypeInputs.forEach((el) => {
        el.onchange = () => {
          const v = collectForm('#jt_details_form', false) || {};
          const isRole = v.node_type === 'role';
          if (regBlock) {
            regBlock.style.display = isRole ? '' : 'none';
          }
        };
      });

      if (reqCb && regSelect) {
        reqCb.onchange = () => {
          if (reqCb.checked) {
            regSelect.style.display = '';
          } else {
            regSelect.style.display = 'none';
            regSelect.value = '';
          }
        };
      }
    }
  };

  showModal(
    'Job Titles',
    [{ key: 'main', label: 'Job Titles' }],
    () => buildBody(),
    async () => ({ ok: true }), // All job title actions are immediate
    false,
    async () => {
      await refreshFromCache();
    },
    { kind: 'job-titles', noParentGate: false }
  );

  // Initial load after modal is mounted
  refreshFromCache().catch((e) => console.error('[JOB_TITLES] initial refresh failed', e));
}


// =============== NEW: Job Titles Settings modal (side panel) ===========
// =============== NEW: Job Titles Settings modal (side panel) ===========


function openJobTitlePickerModal(initialJobTitleId, onSelect) {
  const C = window.__jobTitlesCache || {};
  const roots = C.roots || [];
  const byId = C.byId || {};

  let selectedId = initialJobTitleId || null;
  const collapsedById = {};

  // Initial state: collapse all non-role nodes that have children
  const seedCollapsed = (nodes) => {
    if (!Array.isArray(nodes)) return;
    for (const n of nodes) {
      if (!n) continue;
      if (!n.is_role && Array.isArray(n.children) && n.children.length > 0) {
        collapsedById[n.id] = true;
        seedCollapsed(n.children);
      }
    }
  };
  seedCollapsed(roots);

  const renderOptions = (nodes, depth) => {
    if (!nodes || !nodes.length) return '';
    const pad = depth * 16;
    return nodes
      .map((n) => {
        const isRole = !!n.is_role;
        const isSelected = n.id === selectedId;
        const hasChildren = Array.isArray(n.children) && n.children.length > 0;
        const isCollapsed = !!collapsedById[n.id];

        const label = n.label || '';
        const regBadge =
          isRole && n.requires_prof_reg
            ? `<span class="pill mini" style="margin-left:4px">${n.prof_reg_type || 'Reg'}</span>`
            : '';
        const kind = isRole ? 'Role' : 'Group';

        const toggleHtml = hasChildren
          ? `<span class="mini" style="margin-right:4px">${isCollapsed ? '+' : 'âˆ’'}</span>`
          : `<span style="display:inline-block;width:10px"></span>`;

        const childrenHtml =
          hasChildren && !isCollapsed ? renderOptions(n.children || [], depth + 1) : '';

        return `
          <div data-id="${n.id}"
               class="jt-pick-row${isSelected ? ' active' : ''}"
               style="padding:4px 8px;margin-left:${pad}px;cursor:pointer;display:flex;justify-content:space-between;align-items:center;border-radius:6px;">
            <div>
              ${toggleHtml}
              <strong>${escapeHtml(label)}</strong>
              <span class="mini" style="margin-left:6px;opacity:.7">${kind}</span>
            </div>
            <div>${regBadge}</div>
          </div>
          ${childrenHtml}
        `;
      })
      .join('');
  };

  const buildBody = () => {
    const node = selectedId ? byId[selectedId] : null;
    const pathLabels = node ? buildJobTitlePathLabels(selectedId) : [];

    const selectionSummary = (() => {
      if (!node) {
        return '<div class="mini">Nothing selected. Choose a <strong>Role</strong> from the left.</div>';
      }
      const isRole = !!node.is_role;
      if (!isRole) {
        return `
          <div class="mini">
            <div><strong>${escapeHtml(pathLabels.join(' > '))}</strong></div>
            <div style="margin-top:4px;color:#f97316">
              This is a <strong>Group</strong>. Please expand it and select a <strong>Role</strong> underneath.
            </div>
          </div>
        `;
      }
      const regBit = node.requires_prof_reg
        ? `Professional registration: ${node.prof_reg_type || ''} (number captured on candidate)`
        : 'No professional registration required for this role.';
      return `
        <div class="mini">
          <div><strong>${escapeHtml(pathLabels.join(' > '))}</strong></div>
          <div style="margin-top:4px">${escapeHtml(regBit)}</div>
        </div>
      `;
    })();

    return html(`
      <div id="jobTitlePickerRoot">
        <div class="hint" style="margin-bottom:8px">
          Choose <strong>Family â†’ Subfamily â†’ Role</strong>. Only <strong>Roles</strong> can be assigned to candidates.
        </div>

        <div style="display:grid;grid-template-columns:minmax(0,2fr) minmax(0,1.2fr);gap:10px;align-items:stretch">
          <div id="jtPickerTree"
               style="border:1px solid var(--line);border-radius:10px;max-height:360px;overflow:auto">
            ${
              renderOptions(roots, 0) ||
              '<div class="hint" style="padding:8px">No job titles defined yet. Add families and roles in Settings â†’ Job Titles.</div>'
            }
          </div>
          <div style="border:1px solid var(--line);border-radius:10px;padding:8px;font-size:12px">
            <div style="font-weight:600;margin-bottom:4px">Selection</div>
            ${selectionSummary}
          </div>
        </div>
      </div>
    `);
  };

  const wireEvents = () => {
    const root = document.getElementById('jobTitlePickerRoot');
    if (!root) return;

    const tree = root.querySelector('#jtPickerTree');
    if (!tree || tree.__jtWired) return;
    tree.__jtWired = true;

    tree.onclick = (e) => {
      const row = e.target.closest('.jt-pick-row[data-id]');
      if (!row) return;
      const id = row.getAttribute('data-id');
      const node = byId[id];
      if (!node) return;

      if (!node.is_role) {
        // Group / Family / Subfamily â€“ treat click as toggle expand/collapse
        const hasChildren = Array.isArray(node.children) && node.children.length > 0;
        if (!hasChildren) return;
        collapsedById[id] = !collapsedById[id];

        const bodyEl = document.getElementById('modalBody');
        if (!bodyEl) return;
        bodyEl.innerHTML = buildBody();
        const newRoot = document.getElementById('jobTitlePickerRoot');
        const newTree = newRoot && newRoot.querySelector('#jtPickerTree');
        if (newTree) newTree.__jtWired = false;
        wireEvents();
        return;
      }

      // Role â€“ select
      selectedId = id;
      const bodyEl = document.getElementById('modalBody');
      if (!bodyEl) return;
      bodyEl.innerHTML = buildBody();
      const newRoot = document.getElementById('jobTitlePickerRoot');
      const newTree = newRoot && newRoot.querySelector('#jtPickerTree');
      if (newTree) newTree.__jtWired = false;
      wireEvents();
    };
  };

  showModal(
    'Select Job Title',
    [{ key: 'main', label: 'Job Title' }],
    () => buildBody(),
    async () => {
      const node = byId[selectedId];
      if (!node) {
        alert('Please select a job title first.');
        return { ok: false };
      }
      if (!node.is_role) {
        alert('Please select a Role (not just a Group/Category).');
        return { ok: false };
      }
      const pathLabels = buildJobTitlePathLabels(selectedId);
      if (typeof onSelect === 'function') {
        await onSelect({
          jobTitleId: selectedId,
          pathLabels,
          requiresProfReg: !!node.requires_prof_reg,
          profRegType: node.prof_reg_type || null
        });
      }
      return { ok: true };
    },
    false,
    () => {},
    { kind: 'job-title-picker', noParentGate: false }
  );

  // Wire events on initial open
  wireEvents();
}



// =============== NEW: Candidate Job Title picker =======================

// =============== NEW: applySelectedJobTitleToCandidate =================
function applySelectedJobTitleToCandidate(candidateModel, selection) {
  if (!candidateModel || !selection) return;
  candidateModel.job_title_id = selection.jobTitleId;
  candidateModel.job_title_path_display = (selection.pathLabels || []).join(' > ');
  candidateModel.prof_reg_type = selection.profRegType || null;

  if (!selection.requiresProfReg) {
    candidateModel.prof_reg_number = '';
  }
}

// =============== NEW: buildCandidateMainDetailsModel ===================
function buildCandidateMainDetailsModel(row) {
  const r = row || {};
  const model = {
    id: r.id || null,

    // Personal identifiers
    ni_number: r.ni_number || '',
    date_of_birth: r.date_of_birth || null, // ISO date string (YYYY-MM-DD)
    gender: r.gender || '',

    // Registration
    prof_reg_type: r.prof_reg_type || null,
    prof_reg_number: r.prof_reg_number || '',

    // Address
    address_line1: r.address_line1 || '',
    address_line2: r.address_line2 || '',
    address_line3: r.address_line3 || '',
    town_city: r.town_city || '',
    county: r.county || '',
    postcode: r.postcode || '',
    country: r.country || ''
  };

  // Multi job titles from backend (candidate_job_titles)
  // shape: [{ job_title_id, is_primary }, ...]
  let jobs = Array.isArray(r.job_titles)
    ? r.job_titles
        .map((jt) => ({
          job_title_id: jt.job_title_id,
          is_primary: !!jt.is_primary
        }))
        .filter((t) => t.job_title_id)
    : [];

  // Normalise:
  // - if none is primary, make the first primary
  // - if multiple are primary, keep the first as primary and clear the rest
  // - always move the primary to index 0
  if (jobs.length) {
    let primaryIdx = jobs.findIndex((t) => t.is_primary);
    if (primaryIdx === -1) {
      primaryIdx = 0;
    }

    jobs = jobs.map((t, idx) => ({
      ...t,
      is_primary: idx === primaryIdx
    }));

    if (primaryIdx !== 0) {
      const primary = jobs[primaryIdx];
      jobs.splice(primaryIdx, 1);
      jobs.unshift(primary);
    }
  }

  model.job_titles = jobs;
  return model;
}

// =============== NEW: bindCandidateMainFormEvents ======================
// =============== NEW: bindCandidateMainFormEvents ======================

function bindCandidateMainFormEvents(container, model) {
  if (!container || !model) return;

  const q = (sel) => container.querySelector(sel);

  const bind = (selector, key) => {
    const el = q(selector);
    if (!el) return;
    el.value = model[key] || '';
    el.addEventListener('input', () => {
      model[key] = el.value;
    });
  };

  // Small helper to mark current candidate frame dirty
  const markDirty = () => {
    try {
      const fr = window.__getModalFrame?.();
      if (fr && (fr.mode === 'edit' || fr.mode === 'create')) {
        fr.isDirty = true;
        fr._updateButtons?.();
      }
      window.dispatchEvent(new Event('modal-dirty'));
    } catch {}
  };

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ NHSP / HR aliases (hr_name_mappings) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  try {
    const aliasRow    = q('#cand-alias-select-row');
    const aliasSelect = q('#cand-alias-select');
    const aliasEmpty  = q('#cand-alias-empty');

    if (aliasRow && aliasSelect && aliasEmpty) {
      const state = (window.modalCtx && window.modalCtx.hrAliasState) || {
        existing: [],
        stagedDeletes: [],
        selectedId: null
      };

      // Normalise state structure in case it came through a snapshot
      if (!Array.isArray(state.existing))      state.existing      = [];
      if (!Array.isArray(state.stagedDeletes)) state.stagedDeletes = [];
      if (!window.modalCtx.hrAliasState) {
        window.modalCtx.hrAliasState = state;
      }

      const renderAliases = () => {
        const stagedSet = new Set(state.stagedDeletes.map(String));
        const visible   = state.existing.filter(a => a && !stagedSet.has(String(a.id)));

        aliasSelect.innerHTML = '';

        if (!visible.length) {
          aliasRow.style.display   = 'none';
          aliasEmpty.style.display = '';
          state.selectedId         = null;
          return;
        }

        visible.forEach((a) => {
          const opt = document.createElement('option');
          const pieces = [];
          if (a.hr_name_norm) pieces.push(String(a.hr_name_norm));
          if (a.hospital_or_trust) pieces.push(`@ ${a.hospital_or_trust}`);
          opt.value = String(a.id);
          opt.textContent = pieces.join(' ') || String(a.id);
          aliasSelect.appendChild(opt);
        });

        // Choose a sensible selectedId if current is gone
        let currentId = state.selectedId && !stagedSet.has(String(state.selectedId))
          ? String(state.selectedId)
          : (visible[0] && String(visible[0].id)) || '';

        aliasSelect.value = currentId;
        state.selectedId  = currentId || null;

        aliasRow.style.display   = '';
        aliasEmpty.style.display = 'none';
      };

      renderAliases();

      if (!aliasSelect.__wired) {
        aliasSelect.__wired = true;
        aliasSelect.addEventListener('change', () => {
          state.selectedId = aliasSelect.value || null;
          markDirty();
        });
      }

      const delBtn = q('[data-act="delete-cand-alias"]');
      if (delBtn) {
        // Visibility controller: only show the Remove mapping button in edit/create
        const updateAliasDeleteVisibility = () => {
          try {
            const stack = (window.__modalStack || []);
            const fr    = stack[stack.length - 1] || null;
            const mode  = fr ? fr.mode : 'view';
            delBtn.style.display = (mode === 'edit' || mode === 'create') ? '' : 'none';
          } catch {
            // If anything goes wrong, fall back to hiding in view mode conservatively
            delBtn.style.display = 'none';
          }
        };

        // Run once on init
        updateAliasDeleteVisibility();

        if (!delBtn.__visWired) {
          delBtn.__visWired = true;
          // Re-run whenever the frame mode changes
          window.addEventListener('modal-frame-mode-changed', updateAliasDeleteVisibility);
        }

        if (!delBtn.__wired) {
          delBtn.__wired = true;
          delBtn.addEventListener('click', () => {
            const id = state.selectedId && String(state.selectedId);
            if (!id) return;

            if (!state.stagedDeletes.map(String).includes(id)) {
              state.stagedDeletes.push(id);
            }

            renderAliases();
            markDirty();
          });
        }
      }
    }
  } catch (e) {
    console.warn('[CAND][MAIN] alias wiring failed', e);
  }

  // Normalise job_titles:
  // - drop any entries without job_title_id
  // - if none primary, first becomes primary
  // - if multiple primaries, only first stays primary
  // - primary always moved to index 0
  const normaliseJobTitles = () => {
    let items = Array.isArray(model.job_titles) ? model.job_titles.slice() : [];
    items = items.filter((t) => t && t.job_title_id);

    if (!items.length) {
      model.job_titles = [];
      return;
    }

    let primaryIdx = items.findIndex((t) => t.is_primary);
    if (primaryIdx === -1) {
      primaryIdx = 0;
    }

    items = items.map((t, idx) => ({
      ...t,
      is_primary: idx === primaryIdx
    }));

    if (primaryIdx !== 0) {
      const primary = items[primaryIdx];
      items.splice(primaryIdx, 1);
      items.unshift(primary);
    }

    model.job_titles = items;
  };

  // NI
  bind('input[name="ni_number"]', 'ni_number');

  // DOB (model holds ISO)
  const dobEl = q('input[name="date_of_birth"]');
  if (dobEl) {
    dobEl.value = model.date_of_birth
      ? (typeof formatIsoToUk === 'function' ? formatIsoToUk(model.date_of_birth) : model.date_of_birth)
      : '';
    dobEl.addEventListener('change', () => {
      const v = dobEl.value.trim();
      if (!v) {
        model.date_of_birth = null;
        markDirty();
        return;
      }
      if (typeof parseUkDateToIso === 'function') {
        const iso = parseUkDateToIso(v);
        model.date_of_birth = iso || null;
      } else {
        model.date_of_birth = v;
      }
      markDirty();
    });

    if (typeof attachUkDatePicker === 'function') {
      attachUkDatePicker(dobEl);
    }
  }

  // Gender
  const genderEl = q('select[name="gender"]');
  if (genderEl) {
    genderEl.value = model.gender || '';
    genderEl.addEventListener('change', () => {
      model.gender = genderEl.value || '';
      markDirty();
    });
  }

  // Professional registration number
  const profEl = q('input[name="prof_reg_number"]');
  if (profEl) {
    profEl.value = model.prof_reg_number || '';
    profEl.addEventListener('input', () => {
      model.prof_reg_number = profEl.value || '';
      markDirty();
    });
  }

  // ðŸ”¹ Pay method change handler â€” nuke bank details / umbrella_id in modal only
  const payEl = q('select[name="pay_method"]');
  if (payEl) {
    // Normalise initial previous method
    let lastMethod = (model.pay_method || payEl.value || 'UNKNOWN').toString().toUpperCase();
    if (lastMethod === '' || lastMethod === 'UNKNOWN') lastMethod = null;

    payEl.addEventListener('change', () => {
      const raw = payEl.value || '';
      let nextMethod = raw.toUpperCase();
      if (nextMethod === '' || nextMethod === 'UNKNOWN') nextMethod = null;

      const prev = lastMethod;
      const next = nextMethod;

      if (prev === next) return;

      const wasPAYE     = prev === 'PAYE';
      const wasUMBRELLA = prev === 'UMBRELLA';
      const nowPAYE     = next === 'PAYE';
      const nowUMBRELLA = next === 'UMBRELLA';

      // Helper to clear bank fields in the Pay tab + model
      const clearBankFields = () => {
        const acc = document.querySelector('#tab-pay input[name="account_holder"]');
        const bn  = document.querySelector('#tab-pay input[name="bank_name"]');
        const sc  = document.querySelector('#tab-pay input[name="sort_code"]');
        const an  = document.querySelector('#tab-pay input[name="account_number"]');
        if (acc) acc.value = '';
        if (bn)  bn.value  = '';
        if (sc)  sc.value  = '';
        if (an)  an.value  = '';
        model.account_holder = '';
        model.bank_name      = '';
        model.sort_code      = '';
        model.account_number = '';
      };

      // Helper to clear umbrella id + text field in Pay tab + model
      const clearUmbrella = () => {
        const umbId   = document.getElementById('umbrella_id');
        const umbName = document.getElementById('umbrella_name');
        if (umbId)   umbId.value   = '';
        if (umbName) umbName.value = '';
        model.umbrella_id = null;
      };

      // If we are switching channel (PAYE â†” UMBRELLA), wipe bank details in the modal
      if ((wasPAYE && nowUMBRELLA) || (wasUMBRELLA && nowPAYE)) {
        clearBankFields();
      }
      // Specifically for UMBRELLA â†’ PAYE, also clear umbrella_id
      if (wasUMBRELLA && nowPAYE) {
        clearUmbrella();
      }

      // Update model + modalCtx in-memory only (server-side nuking is handled by what we send)
      model.pay_method = next;
      try {
        window.modalCtx = window.modalCtx || {};
        window.modalCtx.data = window.modalCtx.data || {};
        window.modalCtx.data.pay_method = next;
        window.modalCtx.payMethodState = next; // âœ… NEW: track the current (unsaved) pay method

        if (next === 'PAYE') {
          // Keep umbrella_id null in the in-memory candidate once PAYE is chosen
          window.modalCtx.data.umbrella_id = null;
        }
      } catch {}

      // Broadcast so Pay tab can react if it wants to
      try {
        window.dispatchEvent(new CustomEvent('pay-method-changed', {
          detail: { from: prev, to: next }
        }));
      } catch {}

      lastMethod = next;
      markDirty();
    });
  }

  // Address fields
  const addrKeys = [
    'address_line1',
    'address_line2',
    'address_line3',
    'town_city',
    'county',
    'postcode',
    'country'
  ];
  addrKeys.forEach((k) => bind(`input[name="${k}"]`, k));

  // Helper to render current job_titles list
  const jobTitlesHost = q('#jobTitlesList');

  const renderJobTitlesList = () => {
    if (!jobTitlesHost) return;

    // Normalise before rendering
    normaliseJobTitles();

    const C = window.__jobTitlesCache || {};
    const byId = C.byId || {};
    const items = Array.isArray(model.job_titles) ? model.job_titles : [];

    // Check if we are in edit/create mode (for bins + context menu)
    const fr = window.__getModalFrame?.();
    const canEdit =
      !!fr &&
      fr.entity === 'candidates' &&
      fr.currentTabKey === 'main' &&
      (fr.mode === 'edit' || fr.mode === 'create');

    if (!items.length) {
      jobTitlesHost.innerHTML = `<div class="hint">No job titles selected yet.</div>`;
    } else {
      jobTitlesHost.innerHTML = items
        .map((t) => {
          const node = byId[t.job_title_id];
          const isPrimary = !!t.is_primary;
          // Just the leaf label (no full tree)
          const label = node ? (node.label || '') : String(t.job_title_id || '');
          const regBadge =
            node && node.requires_prof_reg
              ? `<span class="pill mini" style="margin-left:4px">${node.prof_reg_type || 'Reg'}</span>`
              : '';

          const pillBase =
            'display:inline-flex;align-items:center;gap:6px;margin:2px 4px 0 0;padding:2px 6px;border-radius:999px;';
          const pillStyle = isPrimary
            ? `${pillBase}border:1px solid var(--ok,#22c55e);background:rgba(34,197,94,0.08);`
            : `${pillBase}border:1px solid var(--line);`;

          const labelHtml = isPrimary
            ? `<span style="color:var(--ok,#22c55e);font-weight:600">${escapeHtml(label)}</span>`
            : `<span>${escapeHtml(label)}</span>`;

          const primaryTag = isPrimary
            ? `<span class="mini" style="margin-left:4px;opacity:.85;color:var(--ok,#22c55e)">Primary</span>`
            : '';

          const binHtml = canEdit
            ? `
              <button type="button"
                      class="btn mini"
                      data-act="remove-job-title"
                      data-id="${t.job_title_id}"
                      title="Remove">
                ðŸ—‘
              </button>`
            : '';

          return `
            <div class="pill"
                 data-role-id="${t.job_title_id}"
                 style="${pillStyle}">
              ${labelHtml}
              ${primaryTag}
              ${regBadge}
              ${binHtml}
            </div>
          `;
        })
        .join('');
    }

    // Recompute whether any role requires registration
    const regWrapper = q('[data-block="prof_reg"]');
    const regLabel = q('[data-field="prof_reg_label"]');
    const anyRequires = items.some((t) => {
      const node = byId[t.job_title_id];
      return node && node.requires_prof_reg;
    });

    if (regWrapper) {
      if (anyRequires) {
        regWrapper.style.display = '';
        if (regLabel) {
          const type = model.prof_reg_type || '';
          regLabel.textContent = type ? `${type} Number` : 'Registration Number';
        }
      } else {
        regWrapper.style.display = 'none';
      }
    }
  };

  // Initial cache + list render
  (async () => {
    try {
      await loadJobTitlesTree(false);
    } catch {}
    renderJobTitlesList();
  })();

  // Wire bins (remove job title)
  if (jobTitlesHost && !jobTitlesHost.__wiredClick) {
    jobTitlesHost.__wiredClick = true;
    jobTitlesHost.addEventListener('click', (e) => {
      const btn = e.target.closest('button[data-act="remove-job-title"]');
      if (!btn) return;
      const id = btn.getAttribute('data-id');
      if (!id) return;

      model.job_titles = (model.job_titles || []).filter(
        (t) => String(t.job_title_id) !== String(id)
      );
      renderJobTitlesList();
      markDirty();
    });
  }

  // Right-click context menu for "Set Primary Job Title"
  if (jobTitlesHost && !jobTitlesHost.__wiredCtx) {
    jobTitlesHost.__wiredCtx = true;

    jobTitlesHost.addEventListener('contextmenu', (e) => {
      const pill = e.target.closest('.pill[data-role-id]');
      if (!pill) return;

      const fr = window.__getModalFrame?.();
      const canEdit =
        !!fr &&
        fr.entity === 'candidates' &&
        fr.currentTabKey === 'main' &&
        (fr.mode === 'edit' || fr.mode === 'create');

      if (!canEdit) return; // no menu in view mode

      e.preventDefault();

      const id = pill.getAttribute('data-role-id');
      if (!id) return;

      // Remove any existing job title context menu
      if (window.__jtContextMenu) {
        try { document.body.removeChild(window.__jtContextMenu); } catch {}
        window.__jtContextMenu = null;
      }

      const menu = document.createElement('div');
      menu.style.cssText =
        'position:fixed;z-index:10000;background:#0b1528;border:1px solid var(--line);' +
        'padding:6px;border-radius:8px;min-width:180px;font-size:12px;';
      menu.innerHTML = `
        <div data-act="set-primary"
             style="padding:6px 10px;cursor:pointer;">
          Set as primary job title
        </div>
      `;

      const closeMenu = () => {
        if (window.__jtContextMenu) {
          try { document.body.removeChild(window.__jtContextMenu); } catch {}
          window.__jtContextMenu = null;
          document.removeEventListener('click', onDocClick, true);
        }
      };

      const onDocClick = (ev) => {
        if (ev.target && ev.target.closest && ev.target.closest('#__jtContextMenu')) return;
        closeMenu();
      };

      menu.id = '__jtContextMenu';
      window.__jtContextMenu = menu;
      document.body.appendChild(menu);

      const x = e.clientX;
      const y = e.clientY;
      menu.style.left = `${x}px`;
      menu.style.top = `${y}px`;

      menu.addEventListener('click', (ev) => {
        const item = ev.target.closest('[data-act="set-primary"]');
        if (!item) return;

        // Set this job title as primary
        let items = Array.isArray(model.job_titles) ? model.job_titles.slice() : [];
        items = items.map((t) => ({
          ...t,
          is_primary: String(t.job_title_id) === String(id)
        }));
        model.job_titles = items;
        renderJobTitlesList();
        markDirty();
        closeMenu();
      });

      document.addEventListener('click', onDocClick, true);
    });
  }

  // Job Title picker button (add another role)
  const jobBtn = q('[data-act="pick-job-title"]');
  if (jobBtn && !jobBtn.__wired) {
    jobBtn.__wired = true;
    jobBtn.addEventListener('click', async () => {
      await loadJobTitlesTree(false).catch(() => {});
      openJobTitlePickerModal(null, (sel) => {
        const id = sel.jobTitleId;
        if (!id) return;

        const existing = Array.isArray(model.job_titles) ? model.job_titles.slice() : [];
        if (existing.some((t) => String(t.job_title_id) === String(id))) {
          alert('This role is already added for this candidate.');
          return;
        }

        const requires = !!sel.requiresProfReg;
        const type = sel.profRegType || null;

        if (requires) {
          if (model.prof_reg_type && model.prof_reg_type !== type) {
            alert('All roles must share the same registration type (NMC / GMC / HCPC).');
            return;
          }
          if (!model.prof_reg_type && type) {
            model.prof_reg_type = type;
          }
        }

        const hasPrimary = existing.some((t) => t.is_primary);
        const newItem = {
          job_title_id: id,
          // First job title ever becomes primary; otherwise only if there was no primary for some reason
          is_primary: !existing.length && !hasPrimary
        };

        model.job_titles = [...existing, newItem];
        renderJobTitlesList();
        markDirty();
      });
    });
  }

  // Postcode lookup icon
  const addrBtn = q('[data-act="postcode-lookup"]');
  if (addrBtn && !addrBtn.__wired) {
    addrBtn.__wired = true;
    addrBtn.addEventListener('click', () => {
      const current = {
        line1: model.address_line1,
        line2: model.address_line2,
        line3: model.address_line3,
        city: model.town_city,
        postcode: model.postcode
      };
      openAddressLookupModal(current, (chosen) => {
        applyAddressToCandidateModel(model, chosen);
        // reflect in inputs
        ['address_line1', 'address_line2', 'address_line3', 'town_city', 'postcode'].forEach((k) => {
          const el = q(`input[name="${k}"]`);
          if (el) el.value = model[k] || '';
        });
        markDirty();
      });
    });
  }
}


// =============== NEW: apiPostcodeLookup (frontend â†’ backend) ===========
async function apiPostcodeLookup(postcode, house) {
  const params = new URLSearchParams();
  if (postcode) params.set('postcode', postcode);
  if (house) params.set('house', house);

  const url = API(`/api/tools/postcode-lookup?${params.toString()}`);
  const res = await authFetch(url);
  if (!res.ok) {
    throw new Error('Postcode lookup failed');
  }
  const data = (await res.json().catch(() => ({}))) || {};
  return data.addresses || [];
}

// =============== NEW: Address lookup modal (candidate/umbrella) ========
function openAddressLookupModal(initialAddress, onSave) {
  const S = {
    line1: initialAddress?.line1 || '',
    line2: initialAddress?.line2 || '',
    line3: initialAddress?.line3 || '',
    city: initialAddress?.city || '',
    postcode: initialAddress?.postcode || '',
    house: '',
    lookupInFlight: false,
    results: [],
    error: ''
  };

  const body = html(`
    <div id="addrLookupRoot" class="form">
      <div class="row">
        <label>Postcode</label>
        <input type="text" name="lookup_postcode" />
      </div>
      <div class="row">
        <label>House number / name (optional)</label>
        <input type="text" name="lookup_house" />
      </div>
      <div class="row">
        <button type="button" id="btnAddrLookup">Lookup</button>
      </div>

      <div class="row" style="grid-column:1/-1">
        <label>Results</label>
        <div id="addrLookupResults"
             style="border:1px solid var(--line);border-radius:8px;max-height:200px;overflow:auto">
          <div class="hint" style="padding:8px">No lookup results yet.</div>
        </div>
      </div>

      <div class="row" style="grid-column:1/-1;margin-top:10px">
        <label>Manual address (you can edit after choosing a result, or ignore lookup entirely)</label>
      </div>
      <div class="row">
        <label>Address line 1</label>
        <input type="text" name="addr_line1" />
      </div>
      <div class="row">
        <label>Address line 2</label>
        <input type="text" name="addr_line2" />
      </div>
      <div class="row">
        <label>Address line 3</label>
        <input type="text" name="addr_line3" />
      </div>
      <div class="row">
        <label>City / Town</label>
        <input type="text" name="addr_city" />
      </div>
      <div class="row">
        <label>Postcode</label>
        <input type="text" name="addr_postcode" />
      </div>
    </div>
  `);

  const renderResults = () => {
    const root = document.getElementById('addrLookupRoot');
    if (!root) return;
    const box = root.querySelector('#addrLookupResults');
    if (!box) return;

    if (S.error) {
      box.innerHTML = `<div class="error" style="padding:8px">${escapeHtml(S.error)}</div>`;
      return;
    }

    if (!S.results.length) {
      box.innerHTML = `<div class="hint" style="padding:8px">No lookup results yet.</div>`;
      return;
    }

    box.innerHTML = S.results
      .map(
        (a, idx) => `
        <div class="addr-row" data-i="${idx}"
             style="padding:6px 8px;border-bottom:1px solid var(--line);cursor:pointer">
          <div>${escapeHtml(a.line1 || '')}</div>
          <div class="mini">${escapeHtml(
            [a.line2, a.line3, a.city, a.postcode].filter(Boolean).join(', ')
          )}</div>
        </div>
      `
      )
      .join('');
  };

  const syncStateToForm = () => {
    const root = document.getElementById('addrLookupRoot');
    if (!root) return;
    const setVal = (name, v) => {
      const el = root.querySelector(`input[name="${name}"]`);
      if (el) el.value = v || '';
    };

    setVal('lookup_postcode', S.postcode);
    setVal('lookup_house', S.house);
    setVal('addr_line1', S.line1);
    setVal('addr_line2', S.line2);
    setVal('addr_line3', S.line3);
    setVal('addr_city', S.city);
    setVal('addr_postcode', S.postcode);
  };

  const syncFormToState = () => {
    const root = document.getElementById('addrLookupRoot');
    if (!root) return;
    const getVal = (name) => {
      const el = root.querySelector(`input[name="${name}"]`);
      return el ? el.value.trim() : '';
    };

    // For lookup purposes, postcode comes only from the lookup_postcode field
    S.postcode = getVal('lookup_postcode') || S.postcode;
    S.house = getVal('lookup_house') || S.house;
    S.line1 = getVal('addr_line1') || S.line1;
    S.line2 = getVal('addr_line2') || S.line2;
    S.line3 = getVal('addr_line3') || S.line3;
    S.city = getVal('addr_city') || S.city;
    // Do NOT overwrite S.postcode from addr_postcode here (Option A)
  };

  const onOpen = () => {
    const root = document.getElementById('addrLookupRoot');
    if (!root) return;

    syncStateToForm();
    renderResults();

    const btn = root.querySelector('#btnAddrLookup');
    if (btn && !btn.__wired) {
      btn.__wired = true;
      btn.addEventListener('click', async () => {
        syncFormToState();
        if (!S.postcode) {
          alert('Please enter a postcode first');
          return;
        }
        S.lookupInFlight = true;
        S.error = '';
        btn.disabled = true;
        btn.textContent = 'Looking upâ€¦';

        const wireResultClicks = () => {
          const box = root.querySelector('#addrLookupResults');
          if (!box || box.__wired) return;
          box.__wired = true;
          box.addEventListener('click', (e) => {
            const row = e.target.closest('.addr-row[data-i]');
            if (!row) return;
            const idx = +row.getAttribute('data-i');
            const a = S.results[idx];
            if (!a) return;
            S.line1 = a.line1 || '';
            S.line2 = a.line2 || '';
            S.line3 = a.line3 || '';
            S.city = a.city || '';
            S.postcode = a.postcode || '';
            syncStateToForm();
          });
        };

        try {
          const results = await apiPostcodeLookup(S.postcode, S.house);
          S.results = results || [];
          if (S.results.length === 1) {
            const a = S.results[0];
            S.line1 = a.line1 || S.line1;
            S.line2 = a.line2 || S.line2;
            S.line3 = a.line3 || S.line3;
            S.city = a.city || S.city;
            S.postcode = a.postcode || S.postcode;
            syncStateToForm();
          }
        } catch (e) {
          console.error('postcode lookup failed', e);
          S.error = 'Lookup failed. Please check the postcode or try again.';
        } finally {
          S.lookupInFlight = false;
          btn.disabled = false;
          btn.textContent = 'Lookup';
          renderResults();
          // ensure row clicks wired after rendering
          const box = root.querySelector('#addrLookupResults');
          if (box && !box.__wired) {
            wireResultClicks();
          }
        }
      });
    }

    // Initial result click wiring (in case results are present already)
    const box = root.querySelector('#addrLookupResults');
    if (box && !box.__wired) {
      box.__wired = true;
      box.addEventListener('click', (e) => {
        const row = e.target.closest('.addr-row[data-i]');
        if (!row) return;
        const idx = +row.getAttribute('data-i');
        const a = S.results[idx];
        if (!a) return;
        S.line1 = a.line1 || '';
        S.line2 = a.line2 || '';
        S.line3 = a.line3 || '';
        S.city = a.city || '';
        S.postcode = a.postcode || '';
        syncStateToForm();
      });
    }
  };

  showModal(
    'Address',
    [{ key: 'main', label: 'Address' }],
    () => body,
    async () => {
      const root = document.getElementById('addrLookupRoot');
      if (!root) return { ok: false };
      syncFormToState();
      const addr = {
        line1: S.line1 || '',
        line2: S.line2 || '',
        line3: S.line3 || '',
        city: S.city || '',
        postcode: S.postcode || ''
      };
      if (typeof onSave === 'function') {
        onSave(addr);
      }
      return { ok: true };
    },
    false,
    onOpen,
    { kind: 'address-lookup', noParentGate: false }
  );

  // Wire up button + results on first open
  onOpen();
}

// =============== NEW: applyAddress* helpers ============================
function applyAddressToCandidateModel(model, addr) {
  if (!model || !addr) return;
  model.address_line1 = addr.line1 || '';
  model.address_line2 = addr.line2 || '';
  model.address_line3 = addr.line3 || '';
  model.town_city = addr.city || '';
  model.postcode = addr.postcode || '';
}

function applyAddressToUmbrellaModel(model, addr) {
  if (!model || !addr) return;
  model.address_line1 = addr.line1 || '';
  model.address_line2 = addr.line2 || '';
  model.address_line3 = addr.line3 || '';
  model.town_city = addr.city || '';
  model.postcode = addr.postcode || '';
}

// =============== NEW: buildUmbrellaDetailsModel ========================
function buildUmbrellaDetailsModel(row) {
  const r = row || {};
  return {
    id: r.id || null,
    name: r.name || '',
    remittance_email: r.remittance_email || '',
    bank_name: r.bank_name || '',
    sort_code: r.sort_code || '',
    account_number: r.account_number || '',
    vat_chargeable: !!r.vat_chargeable,
    enabled: r.enabled === false ? false : true,

    address_line1: r.address_line1 || '',
    address_line2: r.address_line2 || '',
    address_line3: r.address_line3 || '',
    town_city: r.town_city || '',
    county: r.county || '',
    postcode: r.postcode || '',
    country: r.country || '',
    company_number: r.company_number || ''
  };
}

// =============== NEW: bindUmbrellaAddressEvents ========================
function bindUmbrellaAddressEvents(container, model) {
  if (!container || !model) return;
  const q = (sel) => container.querySelector(sel);

  const bind = (selector, key) => {
    const el = q(selector);
    if (!el) return;
    el.value = model[key] || '';
    el.addEventListener('input', () => {
      model[key] = el.value;
    });
  };

  // Address fields
  bind('input[name="address_line1"]', 'address_line1');
  bind('input[name="address_line2"]', 'address_line2');
  bind('input[name="address_line3"]', 'address_line3');
  bind('input[name="town_city"]', 'town_city');
  bind('input[name="county"]', 'county');
  bind('input[name="postcode"]', 'postcode');
  bind('input[name="country"]', 'country');

  // Company registration number
  bind('input[name="company_number"]', 'company_number');

  // Optional postcode lookup
  const btn = q('[data-act="umbrella-postcode-lookup"]');
  if (btn && !btn.__wired) {
    btn.__wired = true;
    btn.addEventListener('click', () => {
      const curr = {
        line1: model.address_line1,
        line2: model.address_line2,
        line3: model.address_line3,
        city: model.town_city,
        postcode: model.postcode
      };
      openAddressLookupModal(curr, (addr) => {
        applyAddressToUmbrellaModel(model, addr);
        ['address_line1', 'address_line2', 'address_line3', 'town_city', 'postcode'].forEach((k) => {
          const el = q(`input[name="${k}"]`);
          if (el) el.value = model[k] || '';
        });
      });
    });
  }
}


















// ==== FIXED MODAL FRAMEWORK: close only on explicit success from onSave ====
// ==== FIXED MODAL FRAMEWORK: close only on explicit success from onSave ====

// FRONTEND â€” UPDATED
// showModal: ignore non-trusted events for dirty; ensure drag handlers cleared early on close
// ================== FRONTEND: renderSummary (UPDATED to jump & highlight pending focus) ==================

// ===== UPDATED: renderSummary â€” if pending focus row isn't visible, try one auto-relax/reload pass, then highlight when found

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// FIX 4: Bucket labels preview derived for contracts listing
// (cosmetic only; other sections unchanged)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UPDATED: renderSummary(rows)
// - Writes/refreshes summary membership cache fingerprint for current section
// - Prepares candidate role projection as before
// - Hooks page-size change as before
// - Triggers background membership priming (ALL IDs for current filters)
// - (Sorting of summary grid can be added here if/when you enable header clicks)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


// Close any existing floating menu
function closeRelatedMenu(){
  const m = document.getElementById('relatedMenu');
  if (m) m.remove();
  document.removeEventListener('click', closeRelatedMenu, { capture: true });
  document.removeEventListener('keydown', escCloseRelatedMenu, true);
}
function escCloseRelatedMenu(ev){
  if (ev.key === 'Escape') closeRelatedMenu();
}

// Create & show a context menu near (x,y)
// ========================= showRelatedMenu (FIXED) =========================
// Create & show a context menu near (x,y)
function showRelatedMenu(x, y, counts, entity, id){
  closeRelatedMenu();

  const entries = counts && typeof counts === 'object'
    ? Object.entries(counts).filter(([k]) => k && k.trim().length > 0)
    : [];

  const menu = document.createElement('div');
  menu.id = 'relatedMenu';
  menu.style.position = 'fixed';
  menu.style.left = x + 'px';
  menu.style.top  = y + 'px';
  menu.style.zIndex = 1000;
  menu.style.minWidth = '220px';
  menu.style.maxWidth = '280px';
  menu.style.background = '#0b1221';
  menu.style.border = '1px solid #334155';
  menu.style.borderRadius = '10px';
  menu.style.boxShadow = '0 10px 24px rgba(0,0,0,.35)';
  menu.style.padding = '6px';
  menu.style.color = '#f8fafc';
  menu.style.font = '14px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial';

  function item(label, disabled, onClick){
    const it = document.createElement('div');
    it.textContent = label;
    it.style.padding = '8px 10px';
    it.style.borderRadius = '8px';
    it.style.cursor = disabled ? 'default' : 'pointer';
    it.style.opacity = disabled ? '.6' : '1';
    it.onmouseenter = ()=>{ if (!disabled) it.style.background = 'rgba(255,255,255,.06)'; };
    it.onmouseleave = ()=>{ it.style.background = 'transparent'; };
    if (!disabled) {
      it.onclick = async (ev)=>{
        ev.stopPropagation();
        const rows = await fetchRelated(entity, id, onClick.type);

        if (rows && Array.isArray(rows)) {
          // Tear down any open modal before switching section
          if ((window.__modalStack?.length || 0) > 0 || window.modalCtx?.entity) {
            discardAllModalsAndState();
          }

          // Decide which summary section to show
          let targetSection = currentSection;
          const t = String(onClick.type || '').toLowerCase();

          switch (t) {
            case 'timesheet':
            case 'timesheets':
            case 'series':         // Adjustments series for a timesheet
              targetSection = 'timesheets';
              break;

            case 'invoice':
            case 'invoices':
              targetSection = 'invoices';
              break;

            case 'client':
            case 'clients':
              targetSection = 'clients';
              break;

            case 'candidate':
            case 'candidates':
              targetSection = 'candidates';
              break;

            case 'umbrella':
            case 'umbrellas':
              targetSection = 'umbrellas';
              break;

            case 'contract':
            case 'contracts':
              targetSection = 'contracts';
              break;

            default:
              // leave currentSection as-is
              break;
          }

          if (targetSection) {
            currentSection = targetSection;
          }

          renderSummary(rows);
        }

        closeRelatedMenu();
      };
    }
    menu.appendChild(it);
  }

  if (!entries.length) {
    item('No related records', true, {});
  } else {
    entries.sort((a,b)=> (b[1]||0)-(a[1]||0));
    entries.forEach(([rawType, rawCount])=>{
      const type = rawType;
      let count = typeof rawCount === 'number' ? rawCount : 0;

      let niceType = type;
      let displayCount = count;

      // Rename "series" â†’ "Adjustments" and show "other timesheets" only
      if (type === 'series') {
        niceType = 'Adjustments';
        displayCount = Math.max(count - 1, 0);
      } else if (type === 'umbrella') {
        niceType = 'Umbrella';
      } else if (type === 'umbrellas') {
        niceType = 'Umbrellas';
      } else if (type === 'timesheets') {
        niceType = 'timesheets';
      }

      const label = `${displayCount} related ${niceType}`;
      const disabled = displayCount === 0;
      item(label, disabled, { type });
    });
  }

  document.body.appendChild(menu);
  setTimeout(()=>{
    document.addEventListener('click', closeRelatedMenu, { capture: true, once: true });
    document.addEventListener('keydown', escCloseRelatedMenu, true);
  }, 0);

  menu.addEventListener('click', ev => ev.stopPropagation());
}


// ===== Quick search =====
// âœ… Quick search: build minimal per-section filters (with timesheet heuristic)
// âœ… Quick search: build minimal per-section filters (with timesheet heuristic)
// Helper to build minimal quick-search filters per section
function buildQuickFilters(section, text) {
  const q = String(text || '').trim();
  if (!q) return {};

  switch (section) {
    case 'clients':
    case 'umbrellas':
    case 'invoices':
      // backend supports ?q=... (ilike on name / invoice_no depending on endpoint)
      return { q: q };

    case 'timesheets': {
      // Pick ONE field to avoid AND-ing and missing matches
      const looksLikeUUID   = /^[0-9a-f-]{10,}$/i.test(q);
      const looksLikeBkId   = /^[A-Za-z0-9-]{6,}$/.test(q);
      const looksLikeOccKey = /^[A-Za-z0-9_.-]{4,}$/.test(q);

      if (looksLikeBkId || looksLikeUUID) return { booking_id: q };
      if (looksLikeOccKey)                return { occupant_key_norm: q };
      return { hospital_norm: q };
    }

    case 'candidates':
      return { first_name: q, last_name: q, email: q, phone: q };

    default:
      return {};
  }
}

// âœ… Quick search: use heuristic builder (includes timesheets fix)

async function openSearch() {
  const q = prompt('Search text:');
  if (!q) return;

  // reflect in the quick box for consistency
  const box = byId('quickSearch');
  if (box) box.value = q;

  const filters = buildQuickFilters(currentSection, q);
  const rows = await search(currentSection, filters);
  if (rows) renderSummary(rows);
}

// OPTIONAL: open ALT+F for fast search
document.addEventListener('keydown', (e) => {
  if (e.altKey && (e.key === 'f' || e.key === 'F')) {
    e.preventDefault();
    openSearchModal();
  }
});

// ================== NEW: openSettings (parent modal; opens in View) ==================
async function openSettings() {
  const deep = (o)=> JSON.parse(JSON.stringify(o || {}));

  // Hydrate settings first
  let settings;
  try {
    settings = await getSettings(); // unwraps {settings:{...}} â†’ {...}
  } catch (e) {
    alert('Could not load settings.');
    return;
  }

  // Seed modal context
  modalCtx = {
    entity: 'settings',
    data: deep(settings),                    // single source of truth for showModal
    formState: { __forId: 'global', main:{} },
    openToken: 'settings:' + Date.now()
  };

  // Open in VIEW mode (hasId=true) and let showModal manage Edit/Cancel/Discard/Save
  showModal(
    'Settings',
    [{ key:'main', label:'Defaults' }],
    renderSettingsTab,
    handleSaveSettings,
    true // hasId â†’ opens in View mode
  );
}
function renderSummary(rows){
  currentRows = rows;
  currentSelection = null;

  // â”€â”€ paging state (per section)
  window.__listState = window.__listState || {};
  const st = (window.__listState[currentSection] ||= {
    page: 1,
    pageSize: 50,
    total: null,
    hasMore: false,
    filters: null,
    sort: { key: null, dir: 'asc' }
  });

  // Ensure we always have a sort object
  if (!st.sort || typeof st.sort !== 'object') {
    st.sort = { key: null, dir: 'asc' };
  }
  const sortState = st.sort;

  const page     = Number(st.page || 1);
  const pageSize = st.pageSize; // 50 | 100 | 200 | 'ALL'

  // â”€â”€ selection state (per section) â€” explicit IDs only
  window.__selection = window.__selection || {};
  const ensureSel = (section)=>{ const init = { fingerprint:'', ids:new Set() }; return (window.__selection[section] ||= init); };
  const sel = ensureSel(currentSection);

  const isRowSelected = (id)=> sel.ids.has(String(id||''));    
  const setRowSelected = (id, selected)=>{
    id = String(id||''); if (!id) return;
    if (selected) sel.ids.add(id); else sel.ids.delete(id);
  };
  const clearSelection = ()=>{ sel.ids.clear(); };

  // Small helper: render red issue badges or green OK for the Issues column
  const renderIssueBadges = (codes) => {
    const wrap = document.createElement('div');
    wrap.className = 'issue-badges';

    const arr = Array.isArray(codes) ? codes.filter(Boolean) : [];

    if (!arr.length) {
      // No issues â†’ green OK badge
      const ok = document.createElement('span');
      ok.className = 'pill pill-ok';
      ok.textContent = 'OK';
      wrap.appendChild(ok);
      return wrap;
    }

    arr.forEach(code => {
      const span = document.createElement('span');
      const label = String(code || '').trim() || 'Issue';

      // Default: red (issue)
      let cls = 'pill pill-bad';

      // Slightly softer amber for "On hold" / "Validation" / "Authorisation"
      const up = label.toUpperCase();
      if (up === 'ON HOLD' || up === 'VALIDATION' || up === 'AUTHORISATION') {
        cls = 'pill pill-warn';
      }

      span.className = cls;
      span.textContent = label;
      wrap.appendChild(span);
    });

    return wrap;
  };

  // Tie selection to dataset via fingerprint (filters + section)
  const computeFp = ()=> getSummaryFingerprint(currentSection);
  const fp = computeFp();
  if (sel.fingerprint !== fp) { sel.fingerprint = fp; clearSelection(); }

  // Section-specific pre-formatting / normalisation
  if (currentSection === 'candidates') {
    rows.forEach(r => {
      // Rota roles only â€“ do NOT use this for Job Titles
      r.role = (r && Array.isArray(r.roles)) ? formatRolesSummary(r.roles) : '';

      // Ensure job_titles_display exists as a string so the grid
      // can show it via prefs as its own column
      if (r.job_titles_display == null) {
        r.job_titles_display = '';
      } else {
        r.job_titles_display = String(r.job_titles_display);
      }
    });
  } else if (currentSection === 'contracts') {
    rows.forEach(r => {
      const j = r && r.bucket_labels_json;
      if (j && typeof j === 'object') {
        const day   = (j.day   || '').trim();
        const night = (j.night || '').trim();
        const sat   = (j.sat   || '').trim();
        const sun   = (j.sun   || '').trim();
        const bh    = (j.bh    || '').trim();
        const parts = [day,night,sat,sun,bh].filter(Boolean);
        r.bucket_labels_preview = parts.length === 5 ? parts.join('/') : '';
      } else {
        r.bucket_labels_preview = '';
      }
    });
  } else if (currentSection === 'timesheets') {
    // Normalise timesheet rows so they always have a stable id:
    // - real TS â†’ id = timesheet_id
    // - planned/contract_week only â†’ id = contract_week_id
    rows.forEach(r => {
      if (!r || typeof r !== 'object') return;
      const tsId = r.timesheet_id || null;
      const cwId = r.contract_week_id || null;
      const stableId = tsId || cwId || r.id || null;
      if (stableId) {
        r.id = stableId;
      }
    });
  }

  const content = byId('content');
  byId('title').textContent = sections.find(s=>s.key===currentSection)?.label || '';

  // Preserve scroll position per section â€” for .summary-body, not #content
  window.__scrollMemory = window.__scrollMemory || {};
  const memKey = `summary:${currentSection}`;
  const prevScrollY = window.__scrollMemory[memKey] ?? 0;

  content.innerHTML = '';
  if (currentSection === 'settings') return renderSettingsPanel(content);
  if (currentSection === 'audit')    return renderAuditTable(content, rows);

  // â”€â”€ top controls â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const topControls = document.createElement('div');
  topControls.style.cssText = 'display:flex;align-items:center;gap:10px;padding:8px 10px;border-bottom:1px solid var(--line)';

  // Page size
  const sizeLabel = document.createElement('span'); sizeLabel.className = 'mini'; sizeLabel.textContent = 'Page size:';
  const sizeSel = document.createElement('select'); sizeSel.id = 'summaryPageSize';
  ['50','100','200','ALL'].forEach(optVal => {
    const opt = document.createElement('option');
    opt.value = optVal; opt.textContent = (optVal === 'ALL') ? 'All' : `First ${optVal}`;
    if (String(pageSize) === optVal) opt.selected = true;
    sizeSel.appendChild(opt);
  });
  sizeSel.addEventListener('change', async () => {
    const val = sizeSel.value;
    window.__listState[currentSection].pageSize = (val === 'ALL') ? 'ALL' : Number(val);
    window.__listState[currentSection].page = 1;
    const data = await loadSection();
    renderSummary(data);
  });

  topControls.appendChild(sizeLabel);
  topControls.appendChild(sizeSel);

  // â”€â”€ NEW: Contracts quick Status menu â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let statusSel = null;
  if (currentSection === 'contracts') {
    const stFilters = window.__listState[currentSection].filters || {};

    // Default to "active" if no status has been chosen yet
    if (!('status' in stFilters)) stFilters.status = 'active';
    window.__listState[currentSection].filters = stFilters;

    const statusLabel = document.createElement('span');
    statusLabel.className = 'mini';
    statusLabel.textContent = 'Status:';

    statusSel = document.createElement('select');

    [['all','All'], ['active','Active'], ['unassigned','Unassigned'], ['completed','Completed']]
      .forEach(([v, l]) => {
        const o = document.createElement('option');
        o.value = v;
        o.textContent = l;
        if ((stFilters.status || '').toLowerCase() === v) o.selected = true;
        statusSel.appendChild(o);
      });

    statusSel.addEventListener('change', async () => {
      const val = statusSel.value;
      const curFilters = { ...(window.__listState[currentSection].filters || {}) };
      curFilters.status = val;
      window.__listState[currentSection].filters = curFilters;
      window.__listState[currentSection].page = 1;
      const data = await loadSection();
      renderSummary(data);
    });

    topControls.appendChild(statusLabel);
    topControls.appendChild(statusSel);
  }

  // â”€â”€ Timesheets quick filters: Status / Route / Scope / Flags â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (currentSection === 'timesheets') {
    const stFilters = window.__listState[currentSection].filters || {};
    window.__listState[currentSection].filters = stFilters;

    // Status dropdown
    const statusLabel2 = document.createElement('span');
    statusLabel2.className = 'mini';
    statusLabel2.textContent = 'Status:';
    const statusSel2 = document.createElement('select');

    const statusOpts = [
      ['ALL',               'All'],
      ['NO_MATCH_ID',       'No match to Candidate/Client'],
      ['RATE_MISSING',      'Rate missing'],
      ['PAY_CHAN_MISS',     'Pay channel missing'],
      ['READY_FOR_HR',      'Ready for Healthroster validation'],
      ['READY_FOR_INV',     'Ready for invoice'],
      ['HR_HOURS_MISMATCH', 'Timesheet hours mismatch with Healthroster']
    ];
    const statusCur2 = (stFilters.status_code || 'ALL').toUpperCase();
    statusOpts.forEach(([v, label]) => {
      const o = document.createElement('option');
      o.value = v;
      o.textContent = label;
      if (statusCur2 === v) o.selected = true;
      statusSel2.appendChild(o);
    });
    statusSel2.addEventListener('change', async () => {
      const val = statusSel2.value;
      const curFilters = { ...(window.__listState[currentSection].filters || {}) };

      // Remember UI choice
      curFilters.status_code = val;

      // Reset hr_issue by default
      if ('hr_issue' in curFilters) {
        delete curFilters.hr_issue;
      }

      // Map to backend processing_status / hr_issue only when it helps
      switch (val) {
        case 'NO_MATCH_ID':
          curFilters.processing_status = 'UNASSIGNED,CLIENT_UNRESOLVED';
          break;
        case 'READY_FOR_HR':
          curFilters.processing_status = 'READY_FOR_HR';
          break;
        case 'READY_FOR_INV':
          curFilters.processing_status = 'READY_FOR_INVOICE';
          break;
        case 'HR_HOURS_MISMATCH':
          curFilters.processing_status = 'ALL';
          curFilters.hr_issue = 'HOURS_MISMATCH_HR';
          break;
        default:
          curFilters.processing_status = 'ALL';
          break;
      }

      window.__listState[currentSection].filters = curFilters;
      window.__listState[currentSection].page = 1;
      const data = await loadSection();
      renderSummary(data);
    });
    topControls.appendChild(statusLabel2);
    topControls.appendChild(statusSel2);

    // Route dropdown
    const routeLabel = document.createElement('span');
    routeLabel.className = 'mini';
    routeLabel.textContent = 'Route:';
    const routeSel = document.createElement('select');
    const routeOpts = [
      ['ALL',         'All'],
      ['ELECTRONIC',  'Electronic'],
      ['MANUAL',      'Manual'],
      ['NHSP',        'NHSP'],
      ['HEALTHROSTER','Healthroster'],
      ['QR',          'QR timesheets']
    ];
    const routeCur = (stFilters.route_type || 'ALL').toUpperCase();
    routeOpts.forEach(([v, label]) => {
      const o = document.createElement('option');
      o.value = v;
      o.textContent = label;
      if (routeCur === v) o.selected = true;
      routeSel.appendChild(o);
    });
    routeSel.addEventListener('change', async () => {
      const val = routeSel.value;
      const curFilters = { ...(window.__listState[currentSection].filters || {}) };
      curFilters.route_type = val;
      window.__listState[currentSection].filters = curFilters;
      window.__listState[currentSection].page = 1;
      const data = await loadSection();
      renderSummary(data);
    });
    topControls.appendChild(routeLabel);
    topControls.appendChild(routeSel);

    // Scope dropdown
    const scopeLabel = document.createElement('span');
    scopeLabel.className = 'mini';
    scopeLabel.textContent = 'Type:';
    const scopeSel = document.createElement('select');
    const scopeOpts = [
      ['ALL',    'Both'],
      ['WEEKLY', 'Weekly only'],
      ['DAILY',  'Daily only']
    ];
    const scopeCur = (stFilters.sheet_scope || 'ALL').toUpperCase();
    scopeOpts.forEach(([v, label]) => {
      const o = document.createElement('option');
      o.value = v;
      o.textContent = label;
      if (scopeCur === v) o.selected = true;
      scopeSel.appendChild(o);
    });
    scopeSel.addEventListener('change', async () => {
      const val = scopeSel.value;
      const curFilters = { ...(window.__listState[currentSection].filters || {}) };
      curFilters.sheet_scope = val;
      window.__listState[currentSection].filters = curFilters;
      window.__listState[currentSection].page = 1;
      const data = await loadSection();
      renderSummary(data);
    });
    topControls.appendChild(scopeLabel);
    topControls.appendChild(scopeSel);

    // Flags: Adjusted only (Needs attention lives in Tools)
    const mkFlag = (name, label) => {
      const wrap = document.createElement('label');
      wrap.className = 'mini';
      wrap.style.display = 'flex';
      wrap.style.alignItems = 'center';
      wrap.style.gap = '4px';
      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.checked = !!stFilters[name];
      cb.addEventListener('change', async () => {
        const curFilters = { ...(window.__listState[currentSection].filters || {}) };
        curFilters[name] = cb.checked ? true : false;
        window.__listState[currentSection].filters = curFilters;
        window.__listState[currentSection].page = 1;
        const data = await loadSection();
        renderSummary(data);
      });
      wrap.appendChild(cb);
      wrap.appendChild(document.createTextNode(label));
      return wrap;
    };

    topControls.appendChild(mkFlag('is_adjusted', 'Adjusted only'));
  }

  // Columns button
  const btnCols = document.createElement('button');
  btnCols.textContent = 'Columns';
  btnCols.style.cssText = 'border:1px solid var(--line);background:#0b152a;color:var(--text);padding:4px 8px;border-radius:8px;cursor:pointer';
  btnCols.addEventListener('click', () => openColumnsDialog(currentSection));
  topControls.appendChild(btnCols);

  const spacerTop = document.createElement('div'); spacerTop.style.flex = '1';
  topControls.appendChild(spacerTop);

  // Selected info / clear
  const selInfo = document.createElement('div'); selInfo.className = 'mini';
  const renderSelInfo = ()=>{ selInfo.textContent = (sel.ids.size > 0) ? `${sel.ids.size} selected.` : ''; };
  renderSelInfo();

  const clearBtn = document.createElement('button');
  clearBtn.textContent = 'Clear selection';
  clearBtn.style.cssText = 'border:1px solid var(--line);background:#0b152a;color:var(--text);padding:4px 8px;border-radius:8px;cursor:pointer;display:none';
  clearBtn.onclick = ()=>{
    clearSelection(); renderSelInfo();
    Array.from(document.querySelectorAll('input.row-select')).forEach(cb=>{ cb.checked = false; });
    const hdr = byId('summarySelectAll'); if (hdr) { hdr.checked=false; hdr.indeterminate=false; }
    updateButtons();
  };

  topControls.appendChild(selInfo);
  topControls.appendChild(clearBtn);
  content.appendChild(topControls);

  // â”€â”€ apply extra Status filtering client-side for timesheets â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let effectiveRows = rows;
  if (currentSection === 'timesheets') {
    const stFilters = window.__listState[currentSection].filters || {};
    const statusCode = (stFilters.status_code || 'ALL').toUpperCase();

    if (statusCode === 'NO_MATCH_ID') {
      effectiveRows = effectiveRows.filter(r => !r.candidate_id || !r.client_id);
    } else if (statusCode === 'RATE_MISSING') {
      effectiveRows = effectiveRows.filter(r => r.has_rate_issue === true);
    } else if (statusCode === 'PAY_CHAN_MISS') {
      effectiveRows = effectiveRows.filter(r => r.has_pay_channel_issue === true);
    } else if (statusCode === 'READY_FOR_HR') {
      effectiveRows = effectiveRows.filter(r =>
        String(r.processing_status || '').toUpperCase() === 'READY_FOR_HR'
      );
    } else if (statusCode === 'READY_FOR_INV') {
      effectiveRows = effectiveRows.filter(r =>
        String(r.processing_status || '').toUpperCase() === 'READY_FOR_INVOICE'
      );
    }
    // HR_HOURS_MISMATCH relies on backend hr_issue filter only
  }
  currentRows = effectiveRows;

  // â”€â”€ single table (header + body) inside scroll host â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const bodyWrap = document.createElement('div');
  bodyWrap.className = 'summary-body';
  content.appendChild(bodyWrap);

  const tbl = document.createElement('table');
  tbl.className = 'grid';

  const thead = document.createElement('thead');
  thead.style.borderBottom = '1px solid var(--line)';
  const trh = document.createElement('tr');
  thead.appendChild(trh);
  tbl.appendChild(thead);

  const tb = document.createElement('tbody');
  tbl.appendChild(tb);
  bodyWrap.appendChild(tbl);

  let btnFocus, btnSave, btnResolve;

  const computeHeaderState = ()=>{
    const idsVisible = effectiveRows.map(r => String(r.id || ''));
    const selectedOfVisible = idsVisible.filter(id => sel.ids.has(id)).length;
    const hdrCbEl = byId('summarySelectAll');
    if (hdrCbEl) {
      hdrCbEl.checked = (idsVisible.length > 0 && selectedOfVisible === idsVisible.length);
      hdrCbEl.indeterminate = (selectedOfVisible > 0 && selectedOfVisible < idsVisible.length);
    }
  };

  const updateButtons = ()=>{
    const any = sel.ids.size > 0;
    if (btnFocus)   btnFocus.disabled   = !any;
    if (btnSave)    btnSave.disabled    = !any;
    if (btnResolve) btnResolve.disabled = !any;
    clearBtn.style.display = any ? '' : 'none';
    renderSelInfo();
  };

  // Determine columns (using server prefs)
  const cols = getVisibleColumnsForSection(currentSection, effectiveRows);

  // â”€â”€ Force Issues column into timesheets view â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (currentSection === 'timesheets') {
    if (!cols.includes('issue_codes')) {
      // Put Issues near the left so itâ€™s visible by default
      cols.unshift('issue_codes');
    }
  }

  // Header checkbox (first column)
  const thSel = document.createElement('th');
  thSel.style.width = '40px';
  thSel.style.minWidth = '40px';
  thSel.style.maxWidth = '40px';

  const hdrCb = document.createElement('input'); hdrCb.type='checkbox'; hdrCb.id='summarySelectAll';
  hdrCb.addEventListener('click', (e)=>{
    e.stopPropagation();
    const idsVisible = effectiveRows.map(r => String(r.id || ''));
    const wantOn = !!hdrCb.checked;
    idsVisible.forEach(id => { if (wantOn) sel.ids.add(id); else sel.ids.delete(id); });
    Array.from(document.querySelectorAll('input.row-select')).forEach(cb=>{ cb.checked = wantOn; });
    computeHeaderState();
    updateButtons();
  });
  thSel.appendChild(hdrCb);
  trh.appendChild(thSel);

  // Build header cells with friendly labels, resizer handles, and click-to-sort
  cols.forEach(c=>{
    const th = document.createElement('th');
    th.dataset.colKey = String(c);
    th.style.cursor = 'pointer';

    let label = getFriendlyHeaderLabel(currentSection, c);
    if (currentSection === 'timesheets' && c === 'issue_codes') {
      label = 'Issues';
    }

    const isActive = sortState && sortState.key === c;
    const arrow = isActive ? (sortState.dir === 'asc' ? ' â–²' : ' â–¼') : '';
    th.textContent = label + arrow;

    const res = document.createElement('div');
    res.className = 'col-resizer';
    res.title = 'Drag to resize. Double-click to reset.';
    res.style.cssText = 'position:absolute;right:0;top:0;width:6px;height:100%;cursor:col-resize;user-select:none;';
    th.appendChild(res);

    th.draggable = true;

    th.addEventListener('click', async (ev) => {
      if (ev.target && ev.target.closest && ev.target.closest('.col-resizer')) return;

      const colKey = th.dataset.colKey;
      if (!colKey) return;

      window.__listState = window.__listState || {};
      const st2 = (window.__listState[currentSection] ||= {
        page: 1,
        pageSize: 50,
        total: null,
        hasMore: false,
        filters: null,
        sort: { key: null, dir: 'asc' }
      });

      if (!st2.sort || typeof st2.sort !== 'object') {
        st2.sort = { key: null, dir: 'asc' };
      }

      const prevDir = (st2.sort && st2.sort.key === colKey) ? st2.sort.dir : null;
      const nextDir = (prevDir === 'asc') ? 'desc' : 'asc';

      st2.sort = { key: colKey, dir: nextDir };
      st2.page = 1;

      try {
        const data = await loadSection();
        renderSummary(data);
      } catch (e) {
        console.error('Failed to apply sort', e);
      }
    });

    trh.appendChild(th);
  });

  // Body rows
  if (currentSection === 'candidates') {
    tbl.style.width = 'auto';
  }

  effectiveRows.forEach(r=>{
    const tr = document.createElement('tr');
    tr.dataset.id = (r && r.id) ? String(r.id) : '';
    tr.dataset.section = currentSection;

    const tdSel = document.createElement('td');
    tdSel.style.width = '40px';
    tdSel.style.minWidth = '40px';
    tdSel.style.maxWidth = '40px';

    const cb = document.createElement('input'); cb.type='checkbox'; cb.className='row-select';
    cb.checked = isRowSelected(tr.dataset.id);
    cb.addEventListener('click', (e)=>{
      e.stopPropagation();
      const id = tr.dataset.id; setRowSelected(id, cb.checked);
      computeHeaderState();
      updateButtons();
    });
    tdSel.appendChild(cb); tr.appendChild(tdSel);

    cols.forEach(c=>{
      const td = document.createElement('td');
      td.dataset.colKey = String(c);
      const v = r[c];

      if (currentSection === 'candidates' && c === 'job_titles_display') {
        const raw = typeof r.job_titles_display === 'string' ? r.job_titles_display : (v || '');
        if (!raw.trim()) {
          td.textContent = '';
        } else {
          const parts = raw.split(';').map(s => s.trim()).filter(Boolean);
          const rest  = parts.slice(1); // drop primary
          td.textContent = rest.join('; ');
        }
      } else if (currentSection === 'timesheets' && c === 'issue_codes') {
        // â”€â”€ Issues column: badges â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        td.classList.add('mini');

        const hasTs = !!r.timesheet_id;
        const codes = Array.isArray(v) ? v.filter(Boolean) : [];

        if (!hasTs) {
          // No timesheet yet (planned week only) â€“ show nothing
          td.textContent = '';
        } else {
          // Timesheet exists â€“ use shared helper (green OK or red/amber badges)
          td.appendChild(renderIssueBadges(codes));
        }
      } else {
        td.textContent = formatDisplayValue(c, v);
      }

      tr.appendChild(td);
    });

    tb.appendChild(tr);
  });

  // â”€â”€ Apply pending focus (from operations like pay-method change, change rates) â”€â”€
  try {
    if (window.__pendingFocus && window.__pendingFocus.section === currentSection) {
      const pf   = window.__pendingFocus;
      const ids  = Array.isArray(pf.ids) ? pf.ids.map(String) : [];
      const pids = Array.isArray(pf.primaryIds) ? pf.primaryIds.map(String) : [];
      const idSet   = new Set(ids);
      const priSet  = new Set(pids);
      let firstPrimaryRow = null;

      tb.querySelectorAll('tr').forEach(tr => {
        const id = String(tr.dataset.id || '');
        if (idSet.has(id)) {
          tr.classList.add('pending-focus');
          if (priSet.has(id)) tr.classList.add('pending-focus-primary');
          if (!firstPrimaryRow && priSet.has(id)) {
            firstPrimaryRow = tr;
          }
        }
      });

      if (firstPrimaryRow) {
        try {
          firstPrimaryRow.scrollIntoView({ block: 'center', behavior: 'smooth' });
        } catch {}
      }

      window.__pendingFocus = null;
    }
  } catch (e) {
    console.warn('pendingFocus application failed (non-fatal)', e);
  }

  // â”€â”€ NEW: Candidates row context menu (Open / Advances & loans) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (currentSection === 'candidates') {
    if (!window.__ensureCandidateRowMenu) {
      window.__candRowMenuEl = null;
      window.__candRowMenuRow = null;

      window.__hideCandidateRowMenu = function() {
        const el = window.__candRowMenuEl;
        if (el) el.style.display = 'none';
        window.__candRowMenuRow = null;
      };

      window.__ensureCandidateRowMenu = function() {
        if (!window.__candRowMenuEl) {
          const menu = document.createElement('div');
          menu.id = 'candidateRowContextMenu';
          menu.style.position = 'fixed';
          menu.style.zIndex = '9999';
          menu.style.background = '#0b152a';
          menu.style.border = '1px solid var(--line)';
          menu.style.borderRadius = '6px';
          menu.style.minWidth = '180px';
          menu.style.boxShadow = '0 4px 12px rgba(0,0,0,0.5)';
          menu.style.display = 'none';
          menu.innerHTML = `
            <div class="ctx-item" data-action="open" style="padding:6px 10px;cursor:pointer;">Open candidateâ€¦</div>
            <div class="ctx-item" data-action="advances" style="padding:6px 10px;cursor:pointer;border-top:1px solid var(--line);">
              Advances / loansâ€¦
            </div>
          `;
          menu.addEventListener('click', (e) => {
            const item = e.target.closest('.ctx-item');
            if (!item) return;
            const action = item.getAttribute('data-action') || '';
            const row = window.__candRowMenuRow;
            window.__hideCandidateRowMenu();
            if (!row) return;
            if (action === 'open') {
              if (typeof openCandidate === 'function') openCandidate(row);
            } else if (action === 'advances') {
              if (typeof openCandidateAdvancesModal === 'function') openCandidateAdvancesModal(row);
            }
          });
          document.body.appendChild(menu);
          window.__candRowMenuEl = menu;

          document.addEventListener('click', (ev) => {
            const el = window.__candRowMenuEl;
            if (!el || el.style.display === 'none') return;
            if (ev.target && el.contains(ev.target)) return;
            window.__hideCandidateRowMenu();
          }, true);

          document.addEventListener('contextmenu', (ev) => {
            const el = window.__candRowMenuEl;
            if (!el || el.style.display === 'none') return;
            if (ev.target && el.contains(ev.target)) return;
            window.__hideCandidateRowMenu();
          }, true);

          window.addEventListener('scroll', () => window.__hideCandidateRowMenu(), true);
        }
        return window.__candRowMenuEl;
      };
    }

    tb.addEventListener('contextmenu', (ev) => {
      const tr = ev.target && ev.target.closest('tr[data-id]');
      if (!tr) return;
      ev.preventDefault();

      const id = String(tr.dataset.id || '');
      const row = currentRows.find(x => String(x.id || '') === id) || rows.find(x => String(x.id || '') === id);
      if (!row) return;

      window.__candRowMenuRow = row;
      const menu = window.__ensureCandidateRowMenu();
      if (!menu) return;

      const x = ev.clientX;
      const y = ev.clientY;

      menu.style.left = `${x}px`;
      menu.style.top  = `${y}px`;
      menu.style.display = 'block';
    });
  }

  tb.addEventListener('click', (ev) => {
    const tr = ev.target && ev.target.closest('tr'); if (!tr) return;
    if (ev.target && ev.target.classList && ev.target.classList.contains('row-select')) return;
    tb.querySelectorAll('tr.selected').forEach(n => n.classList.remove('selected'));
    tr.classList.add('selected');
    const id = tr.dataset.id;
    currentSelection = currentRows.find(x => String(x.id) === id) || null;
  });

  tb.addEventListener('dblclick', (ev) => {
    const tr = ev.target && ev.target.closest('tr'); if (!tr) return;
    if (!confirmDiscardChangesIfDirty()) return;
    tb.querySelectorAll('tr.selected').forEach(n => n.classList.remove('selected'));
    tr.classList.add('selected');
    const id = tr.dataset.id;
    const row = currentRows.find(x => String(x.id) === id) || null;
    if (!row) return;
    const beforeDepth = (window.__modalStack && window.__modalStack.length) || 0;
    openDetails(row);
    setTimeout(() => {
      const afterDepth = (window.__modalStack && window.__modalStack.length) || 0;
      if (afterDepth > beforeDepth) tb.querySelectorAll('tr.selected').forEach(n => n.classList.remove('selected'));
    }, 0);
  });

  // â”€â”€ Apply widths + wire resize/reorder + header context menu â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  applyUserGridPrefs(currentSection, tbl, cols);
  wireGridColumnResizing(currentSection, tbl);
  wireGridColumnReorder(currentSection, tbl);
  attachHeaderContextMenu(currentSection, tbl);

  // Footer/pager
  const pager = document.createElement('div');
  pager.style.cssText = 'display:flex;align-items:center;gap:6px;padding:8px 10px;border-top:1px solid var(--line);';
  const info = document.createElement('span'); info.className = 'mini';

  const mkBtn = (label, disabled, onClick) => {
    const b = document.createElement('button');
    b.textContent = label; b.disabled = !!disabled;
    b.style.cssText = 'border:1px solid var(--line);background:#0b152a;color:var(--text);padding:4px 8px;border-radius:8px;cursor:pointer';
    if (!disabled) b.addEventListener('click', onClick);
    return b;
  };

  const hasMore = !!st.hasMore;
  const totalKnown = (typeof st.total === 'number');
  const current = page;
  let maxPageToShow;
  if (totalKnown && pageSize !== 'ALL') maxPageToShow = Math.max(1, Math.ceil(st.total / Number(pageSize)));
  else if (pageSize === 'ALL') maxPageToShow = 1;
  else maxPageToShow = hasMore ? (current + 1) : current;

  const prevBtn = mkBtn('Prev', current <= 1, async () => {
    window.__listState[currentSection].page = Math.max(1, current - 1);
    const data = await loadSection();
    renderSummary(data);
  });
  pager.appendChild(prevBtn);

  const makePageLink = (n) => mkBtn(String(n), n === current, async () => {
    window.__listState[currentSection].page = n;
    const data = await loadSection();
    renderSummary(data);
  });

  const pages = [];
  if (maxPageToShow <= 7) { for (let n=1; n<=maxPageToShow; n++) pages.push(n); }
  else {
    pages.push(1);
    if (current > 3) pages.push('â€¦');
    for (let n=Math.max(2, current-1); n<=Math.min(maxPageToShow-1, current+1); n++) pages.push(n);
    if (hasMore || current+1 < maxPageToShow) pages.push('â€¦');
    pages.push(maxPageToShow);
  }
  pages.forEach(pn => {
    if (pn === 'â€¦') { const span = document.createElement('span'); span.textContent = 'â€¦'; span.className = 'mini'; pager.appendChild(span); }
    else pager.appendChild(makePageLink(pn));
  });

  const nextBtn = mkBtn('Next', (pageSize === 'ALL') || (!hasMore && (!totalKnown || current >= maxPageToShow)), async () => {
    window.__listState[currentSection].page = current + 1;
    const data = await loadSection();
    renderSummary(data);
  });
  pager.appendChild(nextBtn);

  if (pageSize === 'ALL') info.textContent = `Showing all ${effectiveRows.length} ${currentSection}.`;
  else if (totalKnown) {
    const ps = Number(pageSize);
    const start = (current-1)*ps + 1;
    const end = Math.min(start + effectiveRows.length - 1, st.total || start - 1);
    info.textContent = `Showing ${start}â€“${end}${st.total!=null ? ` of ${st.total}` : ''}`;
  } else {
    const ps = Number(pageSize);
    const start = (current-1)*ps + 1;
    const end = start + effectiveRows.length - 1;
    info.textContent = `Showing ${start}â€“${end}${hasMore ? '+' : ''}`;
  }
  const spacer = document.createElement('div'); spacer.style.flex = '1';
  pager.appendChild(spacer); pager.appendChild(info);
  content.appendChild(pager);

  // Selection toolbar
  const selBar = document.createElement('div');
  selBar.style.cssText = 'display:flex;justify-content:flex-end;gap:8px;padding:6px 10px;border-top:1px dashed var(--line)';
  btnFocus = document.createElement('button');
  btnFocus.title = 'Focus on records';
  btnFocus.textContent = 'ðŸ” Focus';
  btnFocus.style.cssText = 'border:1px solid var(--line);background:#0b152a;color:var(--text);padding:4px 8px;border-radius:8px;cursor:pointer';

  btnSave = document.createElement('button');
  btnSave.title = 'Save selection';
  btnSave.textContent = 'ðŸ” Save';
  btnSave.style.cssText = btnFocus.style.cssText;

  const btnLoad = document.createElement('button');
  btnLoad.title = 'Load selection';
  btnLoad.textContent = 'ðŸ” Load';
  btnLoad.style.cssText = btnFocus.style.cssText;

  btnFocus.addEventListener('click', async () => {
    if (sel.ids.size === 0) return;
    const ids = Array.from(sel.ids);
    try {
      if (typeof applySelectionAsFilter === 'function') {
        await applySelectionAsFilter(currentSection, { ids });
      } else {
        window.__listState = window.__listState || {};
        const st2 = (window.__listState[currentSection] ||= { page:1, pageSize:50, total:null, hasMore:false, filters:null, sort:{ key:null, dir:'asc' } });
        st2.page = 1; st2.filters = { ...(st2.filters||{}), ids };
        const rows2 = await search(currentSection, st2.filters);
        renderSummary(rows2);
      }
    } catch (e) { console.error('Focus failed', e); }
  });

  btnSave.addEventListener('click', async () => {
    if (sel.ids.size === 0) return;
    try { await openSaveSelectionModal ? openSaveSelectionModal(currentSection) : null; } catch {}
  });

  btnLoad.addEventListener('click', async () => {
    try {
      if (typeof openLoadSelectionModal === 'function') await openLoadSelectionModal(currentSection);
    } catch {}
  });

  selBar.appendChild(btnFocus);
  selBar.appendChild(btnSave);
  selBar.appendChild(btnLoad);

  // NEW: Timesheets Resolveâ€¦ button (uses current selection)
  if (currentSection === 'timesheets' && typeof openTimesheetsResolveModal === 'function') {
    btnResolve = document.createElement('button');
    btnResolve.title = 'Resolve candidate/client for selected timesheets';
    btnResolve.textContent = 'Resolveâ€¦';
    btnResolve.style.cssText = btnFocus.style.cssText;
    btnResolve.disabled = sel.ids.size === 0;

    btnResolve.addEventListener('click', () => {
      if (sel.ids.size === 0) return;
      const selectedRows = currentRows.filter(r => sel.ids.has(String(r.id || '')));
      if (!selectedRows.length) return;
      openTimesheetsResolveModal(selectedRows);
    });

    selBar.appendChild(btnResolve);
  }

  content.appendChild(selBar);

  // Restore scroll memory on inner summary-body (data rows only)
  try {
    const scrollHost = content.querySelector('.summary-body');
    if (scrollHost) {
      scrollHost.__activeMemKey = memKey;
      scrollHost.scrollTop = prevScrollY;
      if (!scrollHost.__scrollMemHooked) {
        scrollHost.addEventListener('scroll', () => {
          const k = scrollHost.__activeMemKey || memKey;
          window.__scrollMemory[k] = scrollHost.scrollTop || 0;
        });
        scrollHost.__scrollMemHooked = true;
      }
    }
  } catch {}

  // Initial states
  computeHeaderState();
  updateButtons();

  try { primeSummaryMembership(currentSection, fp); } catch (e) { /* non-blocking */ }
}



// ================== NEW: renderSettingsTab (tab renderer; showModal controls read-only) ==================
function renderSettingsTab(key, s = {}) {
  if (key !== 'main') return '';

  const erniValue = (s.employers_ni_pct ?? s.erni_pct ?? 0);

  return html(`
    <div class="form" id="settingsForm">
      ${input('timezone_id','Timezone', s.timezone_id || 'Europe/London')}

      ${input('day_start','Day shift starts',  s.day_start  || '06:00')}
      ${input('day_end','Day shift ends',      s.day_end    || '20:00')}
      ${input('night_start','Night shift starts', s.night_start || '20:00')}
      ${input('night_end','Night shift ends',     s.night_end   || '06:00')}

      ${input('sat_start','Saturday starts',  s.sat_start || '00:00')}
      ${input('sat_end','Saturday ends',      s.sat_end   || '00:00')}
      ${input('sun_start','Sunday starts',    s.sun_start || '00:00')}
      ${input('sun_end','Sunday ends',        s.sun_end   || '00:00')}

      ${select('bh_source','Bank Holidays source', s.bh_source || 'MANUAL', ['MANUAL','FEED'])}
      <div class="row" style="grid-column:1/-1">
        <label>Bank Holidays list (JSON dates)</label>
        <textarea name="bh_list">${JSON.stringify(s.bh_list || [], null, 2)}</textarea>
      </div>
      ${input('bh_feed_url','BH feed URL', s.bh_feed_url || '')}
      ${input('vat_rate_pct','VAT %', s.vat_rate_pct ?? 20, 'number')}
      ${input('holiday_pay_pct','Holiday pay %', s.holiday_pay_pct ?? 0, 'number')}
      ${input('erni_pct','ERNI %', erniValue, 'number')}
      ${select('apply_holiday_to','Apply holiday to', s.apply_holiday_to || 'PAYE_ONLY', ['PAYE_ONLY','ALL','NONE'])}
      ${select('apply_erni_to','Apply ERNI to', s.apply_erni_to || 'PAYE_ONLY', ['PAYE_ONLY','ALL','NONE'])}
      <div class="row" style="grid-column:1/-1">
        <label>Margin includes (JSON)</label>
        <textarea name="margin_includes">${JSON.stringify(s.margin_includes || {}, null, 2)}</textarea>
      </div>

      <div class="row">
        <label>Effective from (DD/MM/YYYY)</label>
        <input type="text" name="effective_from" id="settings_effective_from" placeholder="DD/MM/YYYY"
               value="${s.effective_from ? formatIsoToUk(s.effective_from) : ''}" />
      </div>
    </div>
  `);
}


// ================== NEW: handleSaveSettings (parent onSave; persist then stay open in View) ==================
async function handleSaveSettings() {
  // Collect with JSON parsing for bh_list / margin_includes
  const payload = collectForm('#settingsForm', true) || {};

  // Normalise date
  if (payload.effective_from) {
    const iso = parseUkDateToIso(payload.effective_from);
    if (!iso) {
      alert('Invalid â€œEffective fromâ€ date');
      return { ok:false };
    }
    payload.effective_from = iso;
  }

  try {
    await saveSettings(payload);
  } catch (e) {
    alert('Save failed: ' + (e?.message || 'Unknown error'));
    return { ok:false };
  }

  // Return the merged saved state so showModal flips to View and repaints with new values
  const saved = { ...(modalCtx.data || {}), ...payload };
  return { ok:true, saved };
}

async function commitContractCalendarStage(contractId) {
  const LOG_CAL = (typeof window.__LOG_CAL === 'boolean') ? window.__LOG_CAL : true;
  const L = (...a)=> { if (LOG_CAL) console.log('[CAL][commit]', ...a); };
  const W = (...a)=> { if (LOG_CAL) console.warn('[CAL][commit]', ...a); };
  const E = (...a)=> { if (LOG_CAL) console.error('[CAL][commit]', ...a); };

  const { addRanges, removeRanges, additionals, removeAll } = buildPlanRangesFromStage(contractId);
  L('BEGIN', { contractId, addRanges, removeRanges, additionals, removeAll });

  // If "remove all" is staged, we only perform the single bulk unplan and exit.
  if (removeAll) {
    if (removeRanges.length) {
      const payload = {
        when_timesheet_exists: 'skip',
        empty_week_action: 'delete',
        ranges: removeRanges
      };
      L('DELETE /plan-ranges (removeAll)', payload);
      try {
        const resp = await contractsUnplanRanges(contractId, payload);
        L('DELETE /plan-ranges â†', resp);
      } catch (err) {
        E('unplan-ranges (removeAll) failed', err);
        throw err;
      }
    } else {
      L('removeAll=true but no removeRanges built');
    }
    clearContractCalendarStageState(contractId);
    L('DONE: stage cleared for', contractId);
    return { ok: true, detail: 'calendar saved', removedAll: true };
  }

  // Otherwise, proceed with normal sequence: adds â†’ removes â†’ additionals.
  if (addRanges.length) {
    const payload = {
      extend_contract_window: true,
      ranges: addRanges
    };
    L('POST /plan-ranges', payload);
    try {
      const resp = await contractsPlanRanges(contractId, payload);
      L('POST /plan-ranges â†', resp);
      if (!resp || typeof resp !== 'object') W('plan-ranges returned unexpected response', resp);
    } catch (err) {
      E('plan-ranges failed', err);
      throw err;
    }
  } else {
    L('No addRanges to commit');
  }

  if (removeRanges.length) {
    const payload = {
      when_timesheet_exists: 'skip',
      empty_week_action: 'cancel',
      ranges: removeRanges
    };
    L('DELETE /plan-ranges', payload);
    try {
      const resp = await contractsUnplanRanges(contractId, payload);
      L('DELETE /plan-ranges â†', resp);
    } catch (err) {
      E('unplan-ranges failed', err);
      throw err;
    }
  } else {
    L('No removeRanges to commit');
  }

  if (additionals.length) {
    L('Committing additional weeksâ€¦', { count: additionals.length });
    for (const g of additionals) {
      try {
        L('Create additional for baseWeekId', g.baseWeekId, 'dates=', g.dates);
        const addRow = await contractWeekCreateAdditional(g.baseWeekId);
        L('additional created â†', addRow);
        const payload = { add: g.dates.map(d => ({ date: d })), merge: 'append' };
        L('PATCH /contract-weeks/:id/plan', { week_id: addRow.id, payload });
        const resp = await contractWeekPlanPatch(addRow.id, payload);
        L('PATCH /contract-weeks/:id/plan â†', resp);
      } catch (err) {
        E('additional week flow failed', err);
        throw err;
      }
    }
  } else {
    L('No additional week patches to commit');
  }

  clearContractCalendarStageState(contractId);
  L('DONE: stage cleared for', contractId);
  return { ok: true, detail: 'calendar saved', removedAll: false };
}


async function duplicateContract(contractId, { count } = {}) {
  const n = Number(count || 1);
  if (!Number.isInteger(n) || n < 1 || n > 10) {
    return { ok: false, message: 'count must be an integer between 1 and 10' };
  }

  try {
    const url = API(`/api/contracts/${encodeURIComponent(contractId)}/duplicate`);
    const res = await authFetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ count: n })
    });

    // Non-2xx â†’ try to surface a useful error
    if (!res.ok) {
      let msg = `Duplicate failed (${res.status})`;
      try {
        const txt = await res.text();
        if (txt) msg = txt;
      } catch {}
      return { ok: false, message: msg };
    }

    let data = null;
    try {
      data = await res.json();
    } catch {
      data = null;
    }

    // Backend returns: { source_contract_id, count, duplicates: [...] }
    return {
      ok: true,
      ...(data || {}),
    };
  } catch (e) {
    return {
      ok: false,
      message: e?.message || 'Duplicate failed'
    };
  }
}














































































// ================== Timesheet helpers ==================

async function fetchTimesheetDetails(timesheetId) {
  const LOGM = (typeof window.__LOG_MODAL === 'boolean') ? window.__LOG_MODAL : false;
  const L    = (...a) => { if (LOGM) console.log('[TS][DETAILS]', ...a); };
  const GC   = (label) => { if (LOGM) console.groupCollapsed('[TS][DETAILS]', label); };
  const GE   = () => { if (LOGM) console.groupEnd(); };

  if (!timesheetId) {
    throw new Error('fetchTimesheetDetails: timesheetId is required');
  }

  const encId = encodeURIComponent(timesheetId);
  const url   = API(`/api/timesheets/${encId}/details`);
  GC('request');
  L('â†’ GET', { url, timesheetId });

  let res;
  try {
    res = await authFetch(url);
  } catch (err) {
    L('network error', { url, error: err });
    GE();
    throw err;
  }

  let json;
  try {
    const text = await res.text();
    if (!res.ok) {
      L('server error', { status: res.status, bodyPreview: text.slice(0, 400) });
      GE();
      throw new Error(text || `Timesheet details failed (${res.status})`);
    }
    json = text ? JSON.parse(text) : {};
  } catch (err) {
    L('parse error', { status: res.status, error: err });
    GE();
    throw err;
  }

  const timesheet   = json.timesheet  || null;
  const tsfin       = json.tsfin      || null;
  const validations = Array.isArray(json.validations) ? json.validations : [];
  const shifts      = Array.isArray(json.shifts)      ? json.shifts      : [];

  // Derive invoice breakdown + segments
  const ib   = tsfin && tsfin.invoice_breakdown_json && typeof tsfin.invoice_breakdown_json === 'object'
    ? tsfin.invoice_breakdown_json
    : null;
  const mode = ib && typeof ib.mode === 'string' ? ib.mode : null;
  const rawSegments = (ib && Array.isArray(ib.segments)) ? ib.segments : [];

  // Normalise segments: ensure exclude_from_pay is boolean and segment_id is string
  const segments = rawSegments.map((seg, idx) => {
    const s = seg && typeof seg === 'object' ? { ...seg } : { };
    s.segment_id = String(s.segment_id || `seg:${timesheetId}:${idx}`);
    s.exclude_from_pay = !!s.exclude_from_pay;
    return s;
  });

  const isSegments = mode === 'SEGMENTS';

  const detail = {
    timesheet,
    tsfin,
    validations,
    shifts,
    segments,
    invoiceBreakdown: ib,
    isSegmentsMode: isSegments,

    // Convenience: surface key fields that backend already returned
    sheet_scope: json.sheet_scope || (timesheet ? timesheet.sheet_scope || null : null),
    qr_status: json.qr_status || (timesheet ? timesheet.qr_status || null : null),
    qr_generated_at: json.qr_generated_at || null,
    qr_scanned_at: json.qr_scanned_at || null,
    manual_pdf_r2_key: json.manual_pdf_r2_key || (timesheet ? timesheet.manual_pdf_r2_key || null : null)
  };

  L('parsed payload snapshot', {
    hasTimesheet: !!timesheet,
    hasTsfin: !!tsfin,
    validationsCount: validations.length,
    shiftsCount: shifts.length,
    segmentsCount: segments.length,
    mode,
    sheet_scope: detail.sheet_scope,
    qr_status: detail.qr_status
  });
  GE();
  return detail;
}

async function fetchTimesheetRelated(timesheetId) {
  const LOGM = (typeof window.__LOG_MODAL === 'boolean') ? window.__LOG_MODAL : false;
  const L    = (...a) => { if (LOGM) console.log('[TS][RELATED]', ...a); };
  const GC   = (label) => { if (LOGM) console.groupCollapsed('[TS][RELATED]', label); };
  const GE   = () => { if (LOGM) console.groupEnd(); };

  if (!timesheetId) {
    throw new Error('fetchTimesheetRelated: timesheetId is required');
  }

  GC('fetchTimesheetRelated');
  L('START', { timesheetId });

  // 1) Get counts so we know what to request
  let counts = {};
  try {
    counts = await fetchRelatedCounts('timesheet', timesheetId) || {};
    L('counts', counts);
  } catch (err) {
    L('fetchRelatedCounts failed, proceeding with empty counts', err);
    counts = {};
  }

  const out = {
    counts,
    candidate: null,
    client:    null,
    invoice:   null,
    umbrella:  null,
    contract:  null,
    series:    []
  };

  // Helper to safely fetch related items
  const safeFetch = async (typeKey, label) => {
    try {
      const items = await fetchRelated('timesheet', timesheetId, typeKey);
      L(`related[${label}]`, { count: Array.isArray(items) ? items.length : -1, items });
      return items || [];
    } catch (err) {
      L(`related[${label}] failed`, err);
      return [];
    }
  };

  // Candidate (0/1)
  if ((counts.candidate ?? 0) > 0) {
    const items = await safeFetch('candidate', 'candidate');
    out.candidate = items[0] || null;
  }

  // Client (0/1)
  if ((counts.client ?? 0) > 0) {
    const items = await safeFetch('client', 'client');
    out.client = items[0] || null;
  }

  // Invoice (0/1)
  if ((counts.invoice ?? 0) > 0) {
    const items = await safeFetch('invoice', 'invoice');
    out.invoice = items[0] || null;
  }

  // Umbrella (0/1)
  if ((counts.umbrella ?? 0) > 0) {
    const items = await safeFetch('umbrella', 'umbrella');
    out.umbrella = items[0] || null;
  }

  // Contract (0/1)
  if ((counts.contract ?? 0) > 0) {
    const items = await safeFetch('contract', 'contract');
    out.contract = items[0] || null;
  }

  // Series (base + adjustments for same contract/week)
  if ((counts.series ?? 0) > 0) {
    const items = await safeFetch('series', 'series');
    out.series = Array.isArray(items) ? items : [];
  }

  L('RESULT', {
    hasCandidate: !!out.candidate,
    hasClient: !!out.client,
    hasInvoice: !!out.invoice,
    hasUmbrella: !!out.umbrella,
    hasContract: !!out.contract,
    seriesCount: out.series.length
  });
  GE();
  return out;
}

async function fetchTimesheetSourceRows(timesheetId, opts = {}) {
  const LOGM = (typeof window.__LOG_MODAL === 'boolean') ? window.__LOG_MODAL : false;
  const L    = (...a) => { if (LOGM) console.log('[TS][SOURCE]', ...a); };
  const GC   = (label) => { if (LOGM) console.groupCollapsed('[TS][SOURCE]', label); };
  const GE   = () => { if (LOGM) console.groupEnd(); };

  if (!timesheetId) {
    throw new Error('fetchTimesheetSourceRows: timesheetId is required');
  }

  const scopeRaw = (opts.scope || 'all').toLowerCase();
  const scope    = scopeRaw === 'shift' ? 'shift' : 'all';
  const shiftId  = scope === 'shift' ? (opts.shiftId || opts.shift_id || '') : '';
  const includeExcluded = !!opts.includeExcluded || !!opts.include_excluded;

  const qp = new URLSearchParams();
  qp.set('scope', scope);
  if (scope === 'shift' && shiftId) qp.set('shift_id', String(shiftId));
  if (includeExcluded) qp.set('include_excluded', 'true');

  const encId = encodeURIComponent(timesheetId);
  const url   = API(`/api/timesheets/${encId}/source-print?${qp.toString()}`);

  GC('request');
  L('â†’ GET', { url, timesheetId, scope, shiftId: shiftId || null, includeExcluded });

  let res;
  try {
    res = await authFetch(url);
  } catch (err) {
    L('network error', { url, error: err });
    GE();
    throw err;
  }

  let json;
  try {
    const text = await res.text();
    if (!res.ok) {
      L('server error', { status: res.status, bodyPreview: text.slice(0, 400) });
      GE();
      throw new Error(text || `Source rows failed (${res.status})`);
    }
    json = text ? JSON.parse(text) : {};
  } catch (err) {
    L('parse error', { status: res.status, error: err });
    GE();
    throw err;
  }

  const imports = Array.isArray(json.imports) ? json.imports : [];
  const summary = imports.map(i => ({
    source_system: i.source_system,
    import_id: i.import_id,
    header_columns: Array.isArray(i.header_columns) ? i.header_columns.length : 0,
    rows: Array.isArray(i.rows) ? i.rows.length : 0
  }));

  L('RESULT', {
    timesheet_id: json.timesheet_id || timesheetId,
    scope: json.scope || scope,
    includes_excluded: json.includes_excluded ?? includeExcluded,
    importsCount: imports.length,
    importsSummary: summary
  });
  GE();
  return json;
}
// ======== Timesheet tab helpers ========

function getTsLoggers(ns) {
  const LOGM = (typeof window.__LOG_MODAL === 'boolean') ? window.__LOG_MODAL : false;
  return {
    LOGM,
    L:  (...a) => { if (LOGM) console.log(ns, ...a); },
    GC: (label) => { if (LOGM) console.groupCollapsed(ns, label); },
    GE: () => { if (LOGM) console.groupEnd(); }
  };
}

function normaliseTimesheetCtx(ctx) {
  const baseCtx = ctx || {};
  const mc = window.modalCtx || {};

  // Summary row from v_timesheets_summary
  const row =
    baseCtx.row ||
    baseCtx.data ||
    mc.data ||
    {};

  // Details from fetchTimesheetDetails
  const details =
    baseCtx.details ||
    mc.timesheetDetails ||
    {
      timesheet: null,
      tsfin: null,
      validations: [],
      shifts: [],
      segments: [],
      isSegmentsMode: false,
      invoiceBreakdown: null,
      sheet_scope: row.sheet_scope || null,
      qr_status: row.qr_status || null
    };

  // Related entities from fetchTimesheetRelated
  const related =
    baseCtx.related ||
    mc.timesheetRelated ||
    {
      counts: {},
      candidate: null,
      client: null,
      invoice: null,
      umbrella: null,
      contract: null,
      series: []
    };

  // Timesheet-ui state (staging for future Save)
  if (!mc.timesheetState || typeof mc.timesheetState !== 'object') {
    mc.timesheetState = {
      reference: null,
      payHoldDesired: null,   // null = unchanged, true/false = desired state
      payHoldReason: '',
      markPaid: false,
      segmentOverrides: {},   // { segment_id: { exclude_from_pay: bool } }
      nhspDeferrals: {},      // { shift_id: { defer_until_run_after: string|null } }
      additionalRates: {}     // { CODE: { bucket_name, unit_name, units_week, ... } }
    };
  } else if (!mc.timesheetState.additionalRates || typeof mc.timesheetState.additionalRates !== 'object') {
    // Preserve existing staging fields but ensure additionalRates exists
    mc.timesheetState.additionalRates = {};
  }

  const state = mc.timesheetState;

  // Ensure modalCtx has these attached for other code to use
  window.modalCtx = mc;
  if (!mc.timesheetDetails) mc.timesheetDetails = details;
  if (!mc.timesheetRelated) mc.timesheetRelated = related;

  return { row, details, related, state };
}

function renderTimesheetLinesTab(ctx) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][LINES]');
  const { row, details, state } = normaliseTimesheetCtx(ctx);

  GC('render');
  const ts    = details.timesheet || {};
  const tsId  = row.timesheet_id || ts.timesheet_id || null;
  const segs  = Array.isArray(details.segments) ? details.segments : [];
  const ib    = details.invoiceBreakdown || null;
  const mode  = ib && typeof ib.mode === 'string' ? ib.mode : null;
  const shifts = Array.isArray(details.shifts) ? details.shifts : [];
  const isSegments = !!details.isSegmentsMode;

  const sheetScope = (details.sheet_scope ||
                      row.sheet_scope ||
                      ts.sheet_scope ||
                      '').toUpperCase();
  const subMode    = (row.submission_mode ||
                      ts.submission_mode ||
                      '').toUpperCase();

  const tsfin  = details.tsfin || {};
  const locked = !!(tsfin.locked_by_invoice_id || tsfin.paid_at_utc);
  const basis  = String(tsfin.basis || row.basis || '').toUpperCase();

  const isWeeklyManual = (sheetScope === 'WEEKLY' && subMode === 'MANUAL');

  const isNhspOrHrSelfBillBasis = [
    'NHSP',
    'NHSP_ADJUSTMENT',
    'HEALTHROSTER_SELF_BILL',
    'HEALTHROSTER_ADJUSTMENT'
  ].includes(basis);

  // â”€â”€ NEW: initialise per-day references state for weekly Timesheet Lines tab â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // state.dayReferences will be used to render and capture per-day "Ref #" values.
  if (!state.dayReferences || typeof state.dayReferences !== 'object') {
    state.dayReferences = {};
  }
  const dayReferences = state.dayReferences;

  // Seed from timesheet.day_references_json if present
  try {
    const tsDayRefs = ts && ts.day_references_json && typeof ts.day_references_json === 'object'
      ? ts.day_references_json
      : null;
    if (tsDayRefs) {
      Object.keys(tsDayRefs).forEach(ymd => {
        if (!dayReferences[ymd]) {
          dayReferences[ymd] = tsDayRefs[ymd];
        }
      });
    }
  } catch {
    // ignore seed failure, we'll still use state.dayReferences as-is
  }

  // If still empty, seed from TSFIN external_source_rows_json.HR_WEEKLY / NHSP_WEEKLY
  try {
    if (!Object.keys(dayReferences).length && tsfin && tsfin.external_source_rows_json) {
      const ext = tsfin.external_source_rows_json || {};
      const hrRows   = Array.isArray(ext.HR_WEEKLY)   ? ext.HR_WEEKLY   : [];
      const nhspRows = Array.isArray(ext.NHSP_WEEKLY) ? ext.NHSP_WEEKLY : [];
      [...hrRows, ...nhspRows].forEach(row => {
        const date = row && row.date;
        const ref  = row && row.reference;
        if (date && ref && !dayReferences[date]) {
          dayReferences[date] = ref;
        }
      });
    }
  } catch {
    // non-fatal; dayReferences may remain empty
  }

  const segTargets = state.segmentInvoiceTargets || {};
  state.segmentInvoiceTargets = segTargets;

  const hasTsfin = !!(
    tsfin &&
    (
      tsfin.timesheet_id ||
      tsfin.total_hours != null ||
      tsfin.total_pay_ex_vat != null ||
      tsfin.processing_status
    )
  );
  const hasContractWeek = !!(details.contract_week_id || row.contract_week_id);
  const isPlannedOnly   = !hasTsfin && hasContractWeek && !tsId;

  L('snapshot', {
    tsId,
    mode,
    segmentsCount: segs.length,
    shiftsCount: shifts.length,
    hasOverrides: !!(state && state.segmentOverrides && Object.keys(state.segmentOverrides).length),
    hasSegmentTargets: !!(state && state.segmentInvoiceTargets && Object.keys(state.segmentInvoiceTargets).length),
    sheetScope,
    subMode,
    basis,
    isWeeklyManual,
    hasTsfin,
    hasContractWeek,
    isPlannedOnly,
    locked
  });
  GE();

  // UI helper: YYYY-MM-DD â†’ DD-MM-YYYY
  const fmtYmdDmy = (ymd) => {
    if (!ymd || typeof ymd !== 'string') return ymd || '';
    const m = ymd.match(/^(\d{4})-(\d{2})-(\d{2})$/);
    if (!m) return ymd;
    const [, y, mo, d] = m;
    return `${d}-${mo}-${y}`;
  };

  const computeWeekStartFromWeekEnding = (weYmd) => {
    if (!weYmd) return null;
    const d = new Date(`${weYmd}T00:00:00Z`);
    if (Number.isNaN(d.getTime())) return weYmd;
    d.setUTCDate(d.getUTCDate() - 6);
    const yyyy = d.getUTCFullYear();
    const mm   = String(d.getUTCMonth() + 1).padStart(2, '0');
    const dd   = String(d.getUTCDate()).toString().padStart(2, '0');
    return `${yyyy}-${mm}-${dd}`; // internal YMD
  };

  const toYmd = (d) => {
    const yyyy = d.getUTCFullYear();
    const mm   = String(d.getUTCMonth() + 1).padStart(2, '0');
    const dd   = String(d.getUTCDate()).toString().padStart(2, '0');
    return `${yyyy}-${mm}-${dd}`; // internal YMD
  };

  // Current invoice week = Monday of "today"
  const computeCurrentWeekStart = () => {
    const now = new Date();
    const base = new Date(Date.UTC(
      now.getUTCFullYear(),
      now.getUTCMonth(),
      now.getUTCDate()
    ));
    const day = base.getUTCDay();           // 0 = Sun .. 6 = Sat
    const offset = (day + 6) % 7;           // days since Monday
    base.setUTCDate(base.getUTCDate() - offset);
    return toYmd(base);
  };

  // ðŸ”¹ internal WE used by weekly + daily display
  const tsWeekEnding     = ts.week_ending_date || row.week_ending_date || null;
  const naturalWeekStart = tsWeekEnding ? computeWeekStartFromWeekEnding(tsWeekEnding) : null;
  const currentWeekStart = computeCurrentWeekStart();
  const pauseWeekStart   = '2099-01-05'; // arbitrary far-future Monday used as "Pause"

  const disabledAttr = locked ? 'disabled' : '';

  const buildInvoiceWeekSelectHtml = (seg) => {
    if (!isNhspOrHrSelfBillBasis) {
      return '<span class="mini">â€”</span>';
    }
    const segId = String(seg.segment_id || '');
    if (!segId) return '<span class="mini">â€”</span>';

    // Prefer any staged target, then stored target, then THIS week
    const currentTarget = segTargets[segId] ||
      seg.invoice_target_week_start ||
      currentWeekStart ||
      '';

    const opts = [];
    const seen = new Set();

    // This week
    if (currentWeekStart) {
      opts.push({
        value: currentWeekStart,
        label: 'This week'
      });
      seen.add(currentWeekStart);
    }

    // Next week
    if (currentWeekStart) {
      const nextDate = new Date(`${currentWeekStart}T00:00:00Z`);
      nextDate.setUTCDate(nextDate.getUTCDate() + 7);
      const nextWeekStart = toYmd(nextDate);
      opts.push({
        value: nextWeekStart,
        label: `Week starting ${fmtYmdDmy(nextWeekStart)}`
      });
      seen.add(nextWeekStart);

      // Further future weeks (3rd, 4th, ... up to +8 weeks)
      for (let i = 2; i <= 8; i++) {
        const d = new Date(`${currentWeekStart}T00:00:00Z`);
        d.setUTCDate(d.getUTCDate() + i * 7);
        const ws = toYmd(d);
        if (!seen.has(ws)) {
          opts.push({
            value: ws,
            label: `Week starting ${fmtYmdDmy(ws)}`
          });
          seen.add(ws);
        }
      }
    }

    // Optional: natural week (worked week) as an extra reference option if different
    if (naturalWeekStart && !seen.has(naturalWeekStart)) {
      opts.push({
        value: naturalWeekStart,
        label: `Natural week (${fmtYmdDmy(naturalWeekStart)})`
      });
      seen.add(naturalWeekStart);
    }

    // Pause / indefinite defer
    if (!seen.has(pauseWeekStart)) {
      opts.push({
        value: pauseWeekStart,
        label: 'Pause (defer)'
      });
      seen.add(pauseWeekStart);
    }

    let selectedVal = currentTarget || currentWeekStart || '';
    const optionValues = opts.map(o => o.value);
    if (!optionValues.includes(selectedVal)) {
      // If stored target is outside our range, default to "This week" if possible, else Pause
      selectedVal = optionValues.includes(currentWeekStart)
        ? currentWeekStart
        : pauseWeekStart;
    }

    segTargets[segId] = selectedVal;

    const optionsHtml = opts.map(o => {
      const sel = (o.value === selectedVal) ? 'selected' : '';
      return `<option value="${o.value}" ${sel}>${o.label}</option>`;
    }).join('');

    return `
      <select
        name="seg_invoice_week"
        data-segment-id="${segId}"
        ${disabledAttr}
      >
        ${optionsHtml}
      </select>
      <span class="mini">Staged invoice week</span>
    `;
  };

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // A) SEGMENTS mode â†’ existing imported breakdown
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (isSegments && segs.length) {
    const headHtml = `
      <thead>
        <tr>
          <th>Date</th>
          <th>Ref / Request</th>
          <th>Source</th>
          <th>Hours</th>
          <th>Pay</th>
          <th>Charge</th>
          <th>Exclude from pay</th>
          <th>Invoice week / Pause</th>
        </tr>
      </thead>
   `;

    const bodyRows = segs.map((seg) => {
      const effOverride = state.segmentOverrides && state.segmentOverrides[seg.segment_id];
      const effExclude  = effOverride && Object.prototype.hasOwnProperty.call(effOverride, 'exclude_from_pay')
        ? !!effOverride.exclude_from_pay
        : !!seg.exclude_from_pay;

      const srcRaw = seg.source_system || (seg.segment_id || '').split(':')[0] || '';
      const src  = srcRaw || '';
      const rawDate = seg.date || seg.work_date || '';
      const displayDate = rawDate ? fmtYmdDmy(rawDate) : '';
      const dateCellHtml = displayDate || '<span class="mini">â€”</span>';

      const hours = seg.total_hours ?? seg.hours_day ?? seg.hours_night ?? seg.hours ?? '';
      const pay   = seg.pay_amount   ?? seg.pay_ex_vat ?? '';
      const charge= seg.charge_amount?? seg.charge_ex_vat ?? '';

      const ref   = seg.ref_num || '';
      const reqId = seg.request_id || '';

      const invoiceWeekCellHtml = buildInvoiceWeekSelectHtml(seg);

      return `
        <tr data-segment-id="${seg.segment_id}">
          <td>${dateCellHtml}</td>
          <td>
            ${ref ? `<span class="mini">Ref: ${ref}</span>` : ''}
            ${reqId ? `<br><span class="mini">Req: ${reqId}</span>` : ''}
            ${(!ref && !reqId) ? '<span class="mini">â€”</span>' : ''}
          </td>
          <td>${src || '<span class="mini">â€”</span>'}</td>
          <td>${hours !== '' ? hours : '<span class="mini">â€”</span>'}</td>
          <td>${pay   !== '' ? pay   : '<span class="mini">â€”</span>'}</td>
          <td>${charge!== '' ? charge: '<span class="mini">â€”</span>'}</td>
          <td>
            <input
              type="checkbox"
              name="seg_exclude_from_pay"
              data-segment-id="${seg.segment_id}"
              ${effExclude ? 'checked' : ''}
              ${disabledAttr}
            />
            <span class="mini">Tick = exclude from pay (staged)</span>
          </td>
          <td>
            ${invoiceWeekCellHtml}
          </td>
        </tr>
      `;
    }).join('');

    return `
      <div class="tabc">
        <div class="card">
          <div class="row">
            <label>Timesheet ID</label>
            <div class="controls">${tsId || '<span class="mini">Unknown</span>'}</div>
          </div>
          <div class="row">
            <label>Mode</label>
            <div class="controls">
              <span class="mini">Invoice breakdown mode: ${mode || 'UNKNOWN'} (basis: ${basis || 'UNKNOWN'})</span>
            </div>
          </div>
        </div>

        <div class="card" style="margin-top:10px;">
          <div class="row">
            <label>Lines</label>
            <div class="controls">
              <div style="max-height:320px;overflow:auto;">
                <table class="grid mini">
                  ${headHtml}
                  <tbody>
                    ${bodyRows}
                  </tbody>
                </table>
              </div>
            </div>
          </div>
          <div class="row">
            <label></label>
            <div class="controls">
              <span class="mini">
                Changes to "Exclude from pay" and "Invoice week / Pause" are staged only. They are applied when you click Save on the Timesheet modal.
              </span>
            </div>
          </div>
        </div>
      </div>
    `;
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // B) WEEKLY context â†’ per-day schedule grid
  //     - MANUAL: editable (if not locked)
  //     - ELECTRONIC: read-only, but shown in the same grid
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (sheetScope === 'WEEKLY') {
    const scheduleArr = Array.isArray(state.schedule) ? state.schedule.slice() : [];
    const hasSchedule = scheduleArr.length > 0;
    const hasTs       = !!tsId;
    const isPlannedSchedule = !hasTs; // once TS exists, we never show â€œplannedâ€ again

    const canEditSchedule = !locked && subMode === 'MANUAL';

    const badgeHtml = isPlannedSchedule
      ? (subMode === 'MANUAL'
          ? '<span class="pill pill-bad">PLANNED (manual)</span>'
          : '<span class="pill pill-info">PLANNED (electronic, read-only)</span>')
      : (subMode === 'MANUAL'
          ? '<span class="pill pill-ok">CONFIRMED HOURS (manual)</span>'
          : '<span class="pill pill-elec">CONFIRMED HOURS (electronic, read-only)</span>');

    const weekEnding = tsWeekEnding || row.week_ending_date || null;

    const uiRows = [];
    const dowShort = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];

    // How many *extra* break lines per day (beyond the primary)?
    let extraBreakCount = 0;
    if (Number.isFinite(Number(state.extraBreakCount))) {
      extraBreakCount = Math.max(0, Number(state.extraBreakCount));
    }
    state.extraBreakCount = extraBreakCount;

    const pushRowFromSeg = (seg) => {
      if (!seg || !seg.date) return;
      const d = new Date(`${seg.date}T00:00:00Z`);
      const dow = Number.isNaN(d.getTime()) ? '' : dowShort[d.getUTCDay()];

      const start       = seg.start        || '';
      const end         = seg.end          || '';
      const breakStart  = seg.break_start  || '';
      const breakEnd    = seg.break_end    || '';
      const breakMins   = (seg.break_mins != null && seg.break_mins !== '') ? String(seg.break_mins) : '';

      // Any extra break windows persisted in schedule.breaks (beyond the primary)
      const breaksArr = Array.isArray(seg.breaks) ? seg.breaks.filter(b => b && (b.start || b.end)) : [];
      const extra_breaks = breaksArr.length > 1 ? breaksArr.slice(1) : [];

      // Simple paid-hours preview: shift minus total break (minutes)
      const toMins = (hhmm) => {
        if (!hhmm || typeof hhmm !== 'string') return null;
        const m = hhmm.trim();
        const parts = m.split(':');
        if (parts.length !== 2) return null;
        const h = Number(parts[0]);
        const mm = Number(parts[1]);
        if (!Number.isFinite(h) || !Number.isFinite(mm)) return null;
        return h * 60 + mm;
      };

      const sMin = toMins(start);
      const eMin = toMins(end);

      let paid = '';
      if (sMin != null && eMin != null) {
        let shiftMinutes = eMin - sMin;
        if (shiftMinutes < 0) {
          // Overnight shift: assume wraps to next day
          shiftMinutes += 24 * 60;
        }
        const b = Number(breakMins || 0);
        const paidMin = Math.max(0, shiftMinutes - (Number.isFinite(b) ? b : 0));
        paid = paidMin > 0 ? (Math.round((paidMin / 60) * 100) / 100).toFixed(2) : '0.00';
      }

      // NEW: Pre-fill per-day reference from state.dayReferences
      const dayRef = seg.date && dayReferences[seg.date] ? String(dayReferences[seg.date]) : '';

      uiRows.push({
        date: seg.date,
        dow,
        start,
        end,
        break_start: breakStart,
        break_end:   breakEnd,
        break_mins:  breakMins,
        extra_breaks,
        paid_hours:  paid,
        day_ref:     dayRef
      });
    };

    if (hasSchedule) {
      scheduleArr.forEach(seg => pushRowFromSeg(seg));
    } else if (weekEnding) {
      // If no schedule yet but we know the week ending, build 7 blank rows (Monâ€“Sun)
      try {
        const base = new Date(`${weekEnding}T00:00:00Z`);
        for (let offset = 6; offset >= 0; offset--) {
          const d = new Date(base);
          d.setUTCDate(base.getUTCDate() - offset);
          const yyyy = d.getUTCFullYear();
          const mm   = String(d.getUTCMonth() + 1).padStart(2, '0');
          const dd   = String(d.getUTCDate()).toString().padStart(2, '0');
          const ymd  = `${yyyy}-${mm}-${dd}`;
          const dow  = dowShort[d.getUTCDay()];
          const dayRef = dayReferences[ymd] ? String(dayReferences[ymd]) : '';
          uiRows.push({
            date: ymd,
            dow,
            start: '',
            end: '',
            break_start: '',
            break_end: '',
            break_mins: '',
            extra_breaks: [],
            paid_hours: '',
            day_ref: dayRef
          });
        }
      } catch {
        // fallback: single row with no date
        uiRows.push({
          date: '',
          dow:  '',
          start: '',
          end: '',
          break_start: '',
          break_end: '',
          break_mins: '',
          extra_breaks: [],
          paid_hours: '',
          day_ref: ''
        });
      }
    } else {
      // fallback: single â€œunknown dateâ€ row
      uiRows.push({
        date: '',
        dow:  '',
        start: '',
        end: '',
        break_start: '',
        break_end: '',
        break_mins: '',
        extra_breaks: [],
        paid_hours: '',
        day_ref: ''
      });
    }

    const disabledAttrManual = (!canEditSchedule) ? 'disabled' : '';

    const rowsHtml = uiRows.map((r, idx) => {
      const dateAttr = r.date ? ` data-date="${r.date}"` : '';
      const displayDate = r.date ? fmtYmdDmy(r.date) : '';
      const dateCellHtml = displayDate || '<span class="mini">â€”</span>';
      const paidText = r.paid_hours || '';
      const extraBreaks = Array.isArray(r.extra_breaks) ? r.extra_breaks : [];

      const extraStartInputs = [];
      const extraEndInputs   = [];

      for (let i = 0; i < extraBreakCount; i++) {
        const b = extraBreaks[i] || {};
        const extraStart = b.start || '';
        const extraEnd   = b.end   || '';

        extraStartInputs.push(`
          <input type="text"
                 class="input mini"
                 name="sched_break_start_extra_${i}"
                 data-extra-break="start"
                 data-extra-index="${i}"
                 ${r.date ? `data-date="${r.date}"` : ''}
                 value="${escapeHtml(extraStart || '')}"
                 ${disabledAttrManual} />
        `);

        extraEndInputs.push(`
          <input type="text"
                 class="input mini"
                 name="sched_break_end_extra_${i}"
                 data-extra-break="end"
                 data-extra-index="${i}"
                 ${r.date ? `data-date="${r.date}"` : ''}
                 value="${escapeHtml(extraEnd || '')}"
                 ${disabledAttrManual} />
        `);
      }

      const extraStartBlock = extraStartInputs.length
        ? `<div class="extra-breaks">${extraStartInputs.join('<br/>')}</div>`
        : '';

      const extraEndBlock = extraEndInputs.length
        ? `<div class="extra-breaks">${extraEndInputs.join('<br/>')}</div>`
        : '';

      const refVal = r.day_ref || '';

      return `
        <tr data-row-idx="${idx}"${dateAttr}>
          <td>${r.dow || '<span class="mini">â€”</span>'}</td>
          <td>${dateCellHtml}</td>
          <td>
            <input type="text"
                   class="input mini"
                   name="day_ref_${escapeHtml(r.date || '')}"
                   data-day-ref="${escapeHtml(r.date || '')}"
                   value="${escapeHtml(refVal)}"
                   ${disabledAttrManual} />
          </td>
          <td>
            <input type="text"
                   class="input"
                   name="sched_start"
                   data-sched-field="start"
                   ${r.date ? `data-date="${r.date}"` : ''}
                   value="${escapeHtml(r.start || '')}"
                   ${disabledAttrManual} />
          </td>
          <td>
            <input type="text"
                   class="input"
                   name="sched_end"
                   data-sched-field="end"
                   ${r.date ? `data-date="${r.date}"` : ''}
                   value="${escapeHtml(r.end || '')}"
                   ${disabledAttrManual} />
          </td>
          <td>
            <input type="text"
                   class="input"
                   name="sched_break_start"
                   data-sched-field="break_start"
                   ${r.date ? `data-date="${r.date}"` : ''}
                   value="${escapeHtml(r.break_start || '')}"
                   ${disabledAttrManual} />
            ${extraStartBlock}
          </td>
          <td>
            <input type="text"
                   class="input"
                   name="sched_break_end"
                   data-sched-field="break_end"
                   ${r.date ? `data-date="${r.date}"` : ''}
                   value="${escapeHtml(r.break_end || '')}"
                   ${disabledAttrManual} />
            ${extraEndBlock}
          </td>
          <td>
            <input type="number"
                   step="1"
                   min="0"
                   class="input"
                   name="sched_break_mins"
                   data-sched-field="break_mins"
                   ${r.date ? `data-date="${r.date}"` : ''}
                   value="${escapeHtml(r.break_mins || '')}"
                   ${disabledAttrManual} />
          </td>
          <td>
            <span class="mini sched-paid-hours" ${r.date ? `data-date="${r.date}"` : ''}>
              ${paidText || ''}
            </span>
          </td>
        </tr>
      `;
    }).join('');

    const resetButtonHtml = (!canEditSchedule)
      ? ''
      : `
        <button type="button"
                class="btn mini"
                data-ts-action="reset-schedule">
          Reset timesheet schedule
        </button>
      `;

    // Extra Breaks + / âˆ’ buttons (wired in modal JS)
    const extraBreakButtonsHtml = (!canEditSchedule)
      ? ''
      : `
        <button type="button"
                class="btn mini"
                data-ts-action="extra-break-add">
          Extra breaks +
        </button>
        <button type="button"
                class="btn mini"
                data-ts-action="extra-break-remove">
          Extra breaks -
        </button>
      `;

    const scheduleHelpText = canEditSchedule
      ? 'Enter Start/End and either a specific Break window or a Break length in minutes. Paid hours are calculated as shift length minus break. Changes are staged only and applied when you click Save.'
      : 'Electronic schedule is shown read-only. To override the hours, convert this timesheet to manual first.';

    return `
      <div class="tabc">
        <div class="card">
          <div class="row">
            <label>Status</label>
            <div class="controls">
              ${badgeHtml}
              <span class="mini" style="margin-left:8px;">
                ${isPlannedSchedule
                  ? 'Planned schedule is shown here. Editing is only allowed when this week is in MANUAL mode.'
                  : 'Confirmed hours reflect the actual times stored for this timesheet.'}
              </span>
            </div>
          </div>
          <div class="row">
            <label>Timesheet ID</label>
            <div class="controls">
              ${tsId || '<span class="mini">Not yet created (planned week)</span>'}
            </div>
          </div>
        </div>

        <div class="card" style="margin-top:10px;">
          <div class="row">
            <label>Weekly schedule</label>
            <div class="controls">
              <div style="max-height:340px;overflow:auto;">
                <table class="grid mini" id="tsWeeklySchedule">
                  <thead>
                    <tr>
                      <th>Day</th>
                      <th>Date</th>
                      <th>Ref #</th>
                      <th>Start</th>
                      <th>End</th>
                      <th>Break start</th>
                      <th>Break end</th>
                      <th>Break (mins)</th>
                      <th>Paid hours</th>
                    </tr>
                  </thead>
                  <tbody>
                    ${rowsHtml}
                  </tbody>
                </table>
              </div>
              <span class="mini" style="display:block;margin-top:4px;">
                ${scheduleHelpText}
              </span>
              ${locked ? '<span class="mini"> This timesheet is locked (paid/invoiced); schedule is read-only.</span>' : ''}
              <div style="margin-top:8px;">
                ${resetButtonHtml}
                ${extraBreakButtonsHtml}
              </div>
            </div>
          </div>
        </div>
      </div>
    `;
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // C) DAILY / SELF-REPORTED context â†’ single shift row (read-only)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (sheetScope === 'DAILY') {
    const enc = escapeHtml;

    // Derive date from worked_start_iso or fallback to week_ending_date/row
    const startIso = ts.worked_start_iso || null;
    const endIso   = ts.worked_end_iso   || null;
    const brStartIso = ts.break_start_iso || null;
    const brEndIso   = ts.break_end_iso   || null;
    const brMinsRaw  = ts.break_minutes   != null ? Number(ts.break_minutes) : null;

    const toLocalHHMM = (iso) => {
      if (!iso) return '';
      const d = new Date(iso);
      if (Number.isNaN(d.getTime())) return '';
      try {
        const s = d.toLocaleTimeString('en-GB', {
          hour: '2-digit',
          minute: '2-digit',
          hour12: false,
          timeZone: 'Europe/London'
        });
        return s;
      } catch {
        const hh = String(d.getHours()).padStart(2, '0');
        const mm = String(d.getMinutes()).padStart(2, '0');
        return `${hh}:${mm}`;
      }
    };

    const toLocalDateYmd = (iso) => {
      if (!iso) return tsWeekEnding || row.week_ending_date || '';
      const d = new Date(iso);
      if (Number.isNaN(d.getTime())) return tsWeekEnding || row.week_ending_date || '';
      const yyyy = d.getFullYear();
      const mm   = String(d.getMonth() + 1).padStart(2, '0');
      const dd   = String(d.getDate()).toString().padStart(2, '0');
      return `${yyyy}-${mm}-${dd}`; // YMD, will be formatted for UI
    };

    const toLocalDowShort = (isoOrYmd) => {
      if (!isoOrYmd) return '';
      let d;
      if (/^\d{4}-\d{2}-\d{2}$/.test(isoOrYmd)) {
        d = new Date(`${isoOrYmd}T00:00:00Z`);
      } else {
        d = new Date(isoOrYmd);
      }
      if (Number.isNaN(d.getTime())) return '';
      return d.toLocaleDateString('en-GB', {
        weekday: 'short',
        timeZone: 'Europe/London'
      });
    };

    const dateYmd = toLocalDateYmd(startIso);
    const dateDmy = dateYmd ? fmtYmdDmy(dateYmd) : '';
    const dowShort = toLocalDowShort(dateYmd);

    const startHHMM = toLocalHHMM(startIso);
    const endHHMM   = toLocalHHMM(endIso);
    const brStartHHMM = toLocalHHMM(brStartIso);
    const brEndHHMM   = toLocalHHMM(brEndIso);

    // Paid hours preview (for display only)
    let paidHoursText = '';
    try {
      if (startIso && endIso) {
        const dStart = new Date(startIso);
        const dEnd   = new Date(endIso);
        if (!Number.isNaN(dStart.getTime()) && !Number.isNaN(dEnd.getTime())) {
          let diffMin = (dEnd.getTime() - dStart.getTime()) / 60000;
          if (diffMin < 0) diffMin = 0;
          const brMin = Number.isFinite(brMinsRaw) && brMinsRaw > 0 ? brMinsRaw : 0;
          const paidMin = Math.max(0, diffMin - brMin);
          paidHoursText = paidMin > 0
            ? (Math.round((paidMin / 60) * 100) / 100).toFixed(2)
            : '0.00';
        }
      }
    } catch {
      paidHoursText = '';
    }

    const badgeHtml = `
      <span class="pill pill-elec">Electronic daily shift</span>
      <span class="mini" style="margin-left:8px;">
        Start/End and break times are shown read-only. To override the hours, convert this timesheet to manual.
      </span>
    `;

    return `
      <div class="tabc">
        <div class="card">
          <div class="row">
            <label>Status</label>
            <div class="controls">
              ${badgeHtml}
            </div>
          </div>
          <div class="row">
            <label>Timesheet ID</label>
            <div class="controls">
              ${tsId || '<span class="mini">Unknown</span>'}
            </div>
          </div>
        </div>

        <div class="card" style="margin-top:10px;">
          <div class="row">
            <label>Shift details</label>
            <div class="controls">
              <div style="max-height:240px;overflow:auto;">
                <table class="grid mini">
                  <thead>
                    <tr>
                      <th>Day</th>
                      <th>Date</th>
                      <th>Start</th>
                      <th>End</th>
                      <th>Break start</th>
                      <th>Break end</th>
                      <th>Break (mins)</th>
                      <th>Paid hours</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>${dowShort || '<span class="mini">â€”</span>'}</td>
                      <td>${dateDmy || '<span class="mini">â€”</span>'}</td>
                      <td>${startHHMM || '<span class="mini">â€”</span>'}</td>
                      <td>${endHHMM   || '<span class="mini">â€”</span>'}</td>
                      <td>${brStartHHMM || '<span class="mini">â€”</span>'}</td>
                      <td>${brEndHHMM   || '<span class="mini">â€”</span>'}</td>
                      <td>${Number.isFinite(brMinsRaw) && brMinsRaw > 0 ? brMinsRaw : 0}</td>
                      <td>${paidHoursText || '<span class="mini">â€”</span>'}</td>
                    </tr>
                  </tbody>
                </table>
              </div>
              <span class="mini" style="display:block;margin-top:4px;">
                Bucketed hours and pay/charge for this shift are shown in the Finance tab.
              </span>
            </div>
          </div>
        </div>
      </div>
    `;
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // D) Fallback â€“ no detailed lines
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const fallbackMsg = isPlannedOnly
    ? `
      <span class="mini">
        This is a planned/open week without a financial snapshot yet.
        Once the week is processed, a detailed line breakdown will appear here.
      </span>
    `
    : `
      <span class="mini">
        This timesheet does not have a detailed line breakdown for editing in this view.
      </span>
    `;

  return `
    <div class="tabc">
      <div class="card">
        <div class="row">
          <label>Lines</label>
          <div class="controls">
            ${fallbackMsg}
          </div>
        </div>
      </div>
    </div>
  `;
}

// Utility: map route_type / status to pill CSS classes
function classifyTimesheetPill(kind, value) {
  const v = String(value || '').toUpperCase();
  switch (kind) {
    case 'stage':
      if (v === 'PAID') return 'pill pill-ok';
      if (v === 'INVOICED') return 'pill pill-info';
      if (v === 'READY_FOR_INVOICE') return 'pill pill-info';
      if (v === 'READY_FOR_HR') return 'pill pill-info';
      if (v === 'PENDING_AUTH') return 'pill pill-warn';
      if (v === 'NEEDS_ATTENTION') return 'pill pill-bad';
      return 'pill pill-muted';

    case 'route':
      if (v.startsWith('WEEKLY_NHSP')) return 'pill pill-nhsp';
      if (v === 'WEEKLY_HEALTHROSTER') return 'pill pill-hr';
      if (v.startsWith('WEEKLY')) return 'pill pill-weekly';
      if (v.startsWith('DAILY')) return 'pill pill-daily';
      return 'pill pill-muted';

    case 'scope':
      return (v === 'WEEKLY')
        ? 'pill pill-weekly'
        : (v === 'DAILY' ? 'pill pill-daily' : 'pill pill-muted');

    case 'mode':
      return (v === 'ELECTRONIC')
        ? 'pill pill-elec'
        : (v === 'MANUAL' ? 'pill pill-manual' : 'pill pill-muted');

    default:
      return 'pill pill-muted';
  }
}
function renderTimesheetOverviewTab(ctx) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][OVERVIEW]');
  const { row, details, related, state } = normaliseTimesheetCtx(ctx);

  GC('render');
  const ts    = details.timesheet || {};
  const tsfin = details.tsfin     || {};
  const cw    = details.contract_week || {};
  const rCand = related.candidate || {};
  const rCli  = related.client    || {};
  const rCtr  = related.contract  || {};
  const rInv  = related.invoice   || null;

  const sheetScope = (details.sheet_scope ||
                      row.sheet_scope ||
                      ts.sheet_scope ||
                      '').toUpperCase();
  const subMode    = (ts.submission_mode ||
                      row.submission_mode ||
                      '').toUpperCase();
  const basis      = (tsfin.basis || row.basis || '').toUpperCase();

  const tsId = ts.timesheet_id || row.timesheet_id || null;

  const enc = escapeHtml;

  const candidateName =
    (rCand.display_name && enc(rCand.display_name)) ||
    (row.candidate_name && enc(row.candidate_name)) ||
    (row.occupant_key_norm && enc(row.occupant_key_norm)) ||
    (rCand.first_name || rCand.last_name
      ? enc([rCand.first_name, rCand.last_name].filter(Boolean).join(' '))
      : 'Unknown candidate');

  const clientName =
    (rCli.name && enc(rCli.name)) ||
    (rCtr.display_site && enc(rCtr.display_site)) ||
    (row.client_name && enc(row.client_name)) ||
    (row.client_id ? enc(row.client_id) : 'Unknown client');

  const jobTitle =
    (rCtr.role && enc(rCtr.role)) ||
    (row.job_title_norm && enc(row.job_title_norm)) ||
    null;
  const band =
    (rCtr.band && String(rCtr.band).trim()) ||
    (row.band && String(row.band).trim()) ||
    null;

  const weYmd = ts.week_ending_date || row.week_ending_date || null;

  const fmtYmdToDmy = (ymd) => {
    if (!ymd || typeof ymd !== 'string' || !/^\d{4}-\d{2}-\d{2}$/.test(ymd)) return enc(ymd || '');
    const [y, m, d] = ymd.split('-');
    return `${d}-${m}-${y}`;
  };

  const fmtDow = (ymd) => {
    if (!ymd) return '';
    const d = new Date(`${ymd}T00:00:00Z`);
    if (Number.isNaN(d.getTime())) return '';
    return d.toLocaleDateString('en-GB', { weekday: 'short', timeZone: 'Europe/London' });
  };

  const fmtUkDateTime = (iso) => {
    if (!iso) return '';
    const d = new Date(iso);
    if (Number.isNaN(d.getTime())) return enc(iso);
    const s = d.toLocaleString('en-GB', {
      timeZone: 'Europe/London',
      weekday: 'short',
      day: '2-digit',
      month: 'short',
      year: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
      hour12: false
    });
    const parts = s.replace(',', '').split(' ');
    if (parts.length < 4) return enc(s);
    const [dow, day, mon, year, time] = parts;
    const hhmm = (time || '').replace(':', '');
    return `${enc(dow)} ${enc(day)} ${enc(mon)} ${enc(year)} at ${enc(hhmm)}hrs`;
  };

  const hasTsfin = !!(
    tsfin &&
    (
      tsfin.timesheet_id ||
      tsfin.total_hours != null ||
      tsfin.total_pay_ex_vat != null ||
      tsfin.processing_status
    )
  );
  const hasContractWeek = !!(details.contract_week_id || cw.id || row.contract_week_id);
  const isPlannedOnly   = !hasTsfin && hasContractWeek && !tsId;

  const stageRaw        = (tsfin.processing_status || '').toUpperCase() || null;
  const procStatus      = stageRaw || (row.processing_status || '').toUpperCase() || null;
  const isPaid          = !!tsfin.paid_at_utc;
  const isInvoiced      = !!tsfin.locked_by_invoice_id;
  const payOnHold       = !!tsfin.pay_on_hold;
  const authorised      = !!ts.authorised_at_server;
  const qrStatus        = (details.qr_status || ts.qr_status || '').toUpperCase();

  const amountPayEx   = Number(tsfin.total_pay_ex_vat || 0) || 0;
  const amountChgEx   = Number(tsfin.total_charge_ex_vat || 0) || 0;
  const amountMargin  = amountChgEx - amountPayEx;

  const fmtMoney = (v) => isNaN(Number(v)) ? 'â€”' : `Â£${(Math.round(Number(v) * 100) / 100).toFixed(2)}`;

  const cwId         = details.contract_week_id || cw.id || row.contract_week_id || null;
  const cwSubSnapRaw = cw.submission_mode_snapshot || row.submission_mode || '';
  const cwSubSnap    = String(cwSubSnapRaw || '').toUpperCase();

  const policy          = details.policy || {};
  const requiresHr      = !!policy.requires_hr;
  const autoprocessHr   = !!policy.autoprocess_hr;
  const noTimesheetReq  = !!policy.no_timesheet_required;
  const validations     = Array.isArray(details.validations) ? details.validations : [];
  const latestValidation  = validations.length ? validations[0] : null;
  const validationStatus  = latestValidation ? String(latestValidation.status || '').toUpperCase() : null;
  const validationIsOk    = validationStatus === 'VALIDATION_OK' || validationStatus === 'OVERRIDDEN';

  const r2NurseKey   = ts.r2_nurse_key || null;
  const r2AuthKey    = ts.r2_auth_key || null;
  const manualPdfKey = ts.manual_pdf_r2_key || details.manual_pdf_r2_key || null;

  L('snapshot', {
    tsId,
    sheetScope,
    subMode,
    basis,
    stageRaw,
    procStatus,
    authorised,
    isPaid,
    isInvoiced,
    payOnHold,
    qrStatus,
    weYmd,
    hasTsfin,
    hasContractWeek,
    isPlannedOnly,
    cwId,
    cwSubSnap,
    requiresHr,
    autoprocessHr,
    noTimesheetReq
  });
  GE();

  const headerHtml = `
    <div class="card">
      <div class="row">
        <label>Timesheet</label>
        <div class="controls">
          <div style="font-size:15px;font-weight:600;margin-bottom:2px;">
            ${candidateName}
          </div>
          <div class="mini">
            Client: ${clientName}
          </div>
          <div class="mini">
            ${
              weYmd
                ? `Week ending: ${fmtDow(weYmd)} ${fmtYmdToDmy(weYmd)}`
                : '<span class="mini">Week ending: Unknown</span>'
            }
          </div>
          <div class="mini">
            ${
              jobTitle
                ? (band ? `${jobTitle} (Band ${enc(band)})` : jobTitle)
                : (band ? `Band ${enc(band)}` : '<span class="mini">No job title</span>')
            }
          </div>
        </div>
      </div>
    </div>
  `;

  const stageLabel = (() => {
    if (!hasTsfin) {
      if (isPlannedOnly) return 'UNPROCESSED (planned week)';
      return 'UNPROCESSED';
    }
    if (isPaid) return 'Paid';
    if (isInvoiced) return 'Invoiced';
    if (stageRaw === 'READY_FOR_INVOICE') return 'Ready for invoice';
    if (stageRaw === 'PENDING_AUTH') return 'Pending authorisation';
    if (stageRaw === 'RATE_MISSING') return 'Rate missing';
    if (stageRaw === 'PAY_CHANNEL_MISSING') return 'Pay channel missing';
    return stageRaw || 'Unknown';
  })();

  const stageClass = (() => {
    if (!hasTsfin) return 'pill-bad';
    if (isPaid) return 'pill-ok';
    if (isInvoiced) return 'pill-warn';
    if (stageRaw === 'RATE_MISSING' || stageRaw === 'PAY_CHANNEL_MISSING') return 'pill-bad';
    if (stageRaw === 'READY_FOR_INVOICE') return 'pill-ok';
    return 'pill-info';
  })();

  const procStatusPillHtml = (() => {
    if (!procStatus) return '';
    let cls = 'pill-info';
    if (procStatus === 'UNASSIGNED' ||
        procStatus === 'CLIENT_UNRESOLVED' ||
        procStatus === 'RATE_MISSING' ||
        procStatus === 'PAY_CHANNEL_MISSING') {
      cls = 'pill-bad';
    } else if (procStatus === 'READY_FOR_HR') {
      cls = 'pill-warn';
    } else if (procStatus === 'READY_FOR_INVOICE') {
      cls = 'pill-ok';
    }
    return `<span class="pill ${cls}" style="margin-left:4px;">Status: ${enc(procStatus)}</span>`;
  })();

  const hrHintsHtml = (() => {
    if (!requiresHr) return '';
    const lines = [];

    if (!validationIsOk) {
      lines.push('HR validation required');
    }

    if (autoprocessHr) {
      lines.push('HR auto-process: no team authorisation required after HR checks.');
    } else {
      lines.push('Manual team authorisation required after HR checks.');
    }

    if (!lines.length) return '';
    return `
      <div class="mini" style="margin-top:4px;">
        ${lines.map(enc).join('<br/>')}
      </div>
    `;
  })();

  const scopePill = sheetScope === 'DAILY'
    ? '<span class="pill pill-daily">Daily</span>'
    : '<span class="pill pill-weekly">Weekly</span>';

  const modePill = (() => {
    if (basis === 'NHSP' || basis === 'NHSP_ADJUSTMENT') {
      return '<span class="pill pill-nhsp">NHSP</span>';
    }
    if (basis.startsWith('HEALTHROSTER')) {
      return '<span class="pill pill-hr">HealthRoster</span>';
    }
    if (subMode === 'ELECTRONIC') {
      return '<span class="pill pill-elec">Electronic</span>';
    }
    if (subMode === 'MANUAL' && qrStatus) {
      return `<span class="pill pill-manual">Manual (QR: ${enc(qrStatus)})</span>`;
    }
    if (subMode === 'MANUAL') {
      return '<span class="pill pill-manual">Manual</span>';
    }
    return '<span class="pill">Unknown mode</span>';
  })();

  const paidLabel = isPaid
    ? fmtUkDateTime(tsfin.paid_at_utc)
    : 'Not paid';

  const invLabel = isInvoiced
    ? (rInv && rInv.invoice_number
        ? `On invoice ${enc(rInv.invoice_number)}`
        : 'Invoiced')
    : 'Not invoiced';

  const flagsHtml = `
    <div class="mini" style="margin-top:4px;">
      <span class="pill ${isPaid ? 'pill-ok' : 'pill-warn'}">
        Paid: ${isPaid ? 'Yes' : 'No'}
      </span>
      <span class="pill ${isInvoiced ? 'pill-warn' : 'pill-info'}" style="margin-left:4px;">
        Invoiced: ${isInvoiced ? 'Yes' : 'No'}
      </span>
      ${
        payOnHold
          ? '<span class="pill pill-hold" style="margin-left:4px;">Pay on hold</span>'
          : ''
      }
    </div>
    <div class="mini" style="margin-top:4px;">
      ${isPaid ? `Paid at ${paidLabel}` : ''}
      ${isInvoiced ? `<br/>${invLabel}` : ''}
    </div>
  `;

  const totalsHtml = hasTsfin
    ? `
      <div class="mini">
        Candidate pay (ex VAT): <strong>${fmtMoney(amountPayEx)}</strong><br/>
        Client charge (ex VAT): <strong>${fmtMoney(amountChgEx)}</strong><br/>
        Margin (ex VAT): <strong>${fmtMoney(amountMargin)}</strong>
      </div>
    `
    : `
      <div class="mini">
        <strong>No financial snapshot yet.</strong><br/>
        This timesheet has not been processed. Once processed, pay and charge totals will appear here.
      </div>
    `;

  const refValue = state && typeof state.reference === 'string'
    ? state.reference
    : (ts.reference_number || row.reference_number || '');

  const hasTs   = !!tsId;
  const locked  = isPaid || isInvoiced;
  const isDaily = sheetScope === 'DAILY';
  const isWeekly = sheetScope === 'WEEKLY';

  const canSendDailyQr =
    isDaily && hasTs && !locked;

  const canSendWeeklyQr =
    isWeekly &&
    hasTs &&
    subMode === 'MANUAL' &&
    !!cwId &&
    !locked;

  const canSwitchToManualWeekly =
    hasTs &&
    sheetScope === 'WEEKLY' &&
    subMode === 'ELECTRONIC' &&
    !locked;

  const isPlannedWeekly = !hasTs && sheetScope === 'WEEKLY' && !!cwId;
  const canSwitchWeekToManualPlanned =
    isPlannedWeekly &&
    cwSubSnap === 'ELECTRONIC' &&
    !locked;

  const canRevertElectronic =
    hasTs &&
    sheetScope === 'WEEKLY' &&
    subMode === 'MANUAL' &&
    !locked;

  const canDeleteManualReopen =
    hasTs &&
    sheetScope === 'WEEKLY' &&
    subMode === 'MANUAL' &&
    !!cwId &&
    !locked;

  const canDeletePermanently =
    hasTs &&
    !locked;

  const missingTsEvidence =
    requiresHr &&
    !noTimesheetReq &&
    !isPaid &&
    !isInvoiced &&
    !(
      subMode === 'ELECTRONIC' &&
      r2NurseKey &&
      r2AuthKey
    ) &&
    !manualPdfKey;

  const timesheetRequiredPillHtml = missingTsEvidence
    ? '<span class="pill pill-bad" style="margin-left:4px;">Timesheet required</span>'
    : '';

  const hasQr = !!qrStatus;
  const showQrAmendWarning = hasQr && !locked;
  const qrAmendWarningHtml = showQrAmendWarning
    ? `
      <div class="mini" style="margin-top:8px;color:var(--warn);max-width:520px;">
        Warning: this timesheet already has a QR version. If you amend the hours and save,
        you will be asked whether to:
        <br/>â€¢ save and revoke the existing QR only, or
        <br/>â€¢ save, revoke and reissue a new QR timesheet to the worker.
        <br/><br/>Please make sure the hours are correct before saving to avoid sending
        multiple revised timesheets.
      </div>
    `
    : '';

  let actionsHtml = '';

  if (isDaily && hasTs) {
    const buttons = [];

    if (canSendDailyQr) {
      buttons.push(`
        <button type="button"
                class="btn"
                data-ts-action="send-daily-qr">
          Send daily QR timesheet
        </button>
      `);
    }

    if (!buttons.length) {
      actionsHtml = `
        <span class="mini">
          No structural actions are available for this daily timesheet (it may be paid, invoiced, or otherwise locked).
        </span>
      `;
    } else {
      actionsHtml = buttons.join('');
    }
  } else if (hasTs || isPlannedWeekly) {
    const buttons = [];

    if (canSendWeeklyQr) {
      buttons.push(`
        <button type="button"
                class="btn"
                data-ts-action="send-weekly-qr">
          Send weekly QR timesheet
        </button>
      `);
    }

    if (canSwitchToManualWeekly || canSwitchWeekToManualPlanned) {
      const label = hasTs
        ? 'Convert to manual timesheet'
        : 'Convert planned week to manual timesheet';

      buttons.push(`
        <button type="button"
                class="btn"
                data-ts-action="switch-manual">
          ${label}
        </button>
      `);
    }

    if (canRevertElectronic) {
      buttons.push(`
        <button type="button"
                class="btn"
                style="margin-left:8px;"
                data-ts-action="revert-electronic">
          Restore original electronic timesheet
        </button>
      `);
    }

    if (canDeleteManualReopen) {
      buttons.push(`
        <button type="button"
                class="btn"
                style="margin-left:8px;"
                data-ts-action="delete-manual-reopen">
          Delete manual & reopen week for electronic
        </button>
      `);
    }

    if (canDeletePermanently) {
      buttons.push(`
        <button type="button"
                class="btn btn-warn"
                style="margin-left:8px;"
                data-ts-action="delete-permanent">
          Delete permanently
        </button>
      `);
    }

    if (buttons.length) {
      actionsHtml = buttons.join('');
    } else {
      actionsHtml = `
        <span class="mini">
          No structural actions are available for this timesheet (it may be paid or invoiced).
        </span>
      `;
    }
  } else {
    actionsHtml = `
      <span class="mini">
        This is a planned/open week without a timesheet yet. Once a manual or electronic
        timesheet exists, actions will appear here.
      </span>
    `;
  }

  const routeHtml = `
    <div class="card" style="margin-top:10px;">
      <div class="row">
        <label>Stage</label>
        <div class="controls">
          <span class="pill ${stageClass}" style="font-weight:600;">
            ${enc(stageLabel)}
          </span>
          ${procStatusPillHtml}
          <div class="mini" style="margin-top:4px;">
            ${authorised ? 'Authorised' : 'Not authorised'}
          </div>
          ${hrHintsHtml}
        </div>
      </div>
      <div class="row">
        <label>Route</label>
        <div class="controls">
          ${scopePill}
          ${modePill}
          ${
            basis
              ? `<span class="pill pill-info" style="margin-left:4px;">Basis: ${enc(basis)}</span>`
              : ''
          }
          ${timesheetRequiredPillHtml}
          ${flagsHtml}
        </div>
      </div>
      <div class="row">
        <label>Totals</label>
        <div class="controls">
          ${totalsHtml}
        </div>
      </div>
      <div class="row">
        <label>Reference / PO</label>
        <div class="controls">
          <input
            class="input"
            name="ts_reference"
            value="${enc(refValue || '')}"
            placeholder="Reference or PO (optional)"
          />
          <span class="mini">
            This is staged only and will be saved when you click <strong>Save</strong>.
            You can update this even for electronic timesheets.
          </span>
        </div>
      </div>
      <div class="row" data-view-only="true">
        <label>Actions</label>
        <div class="controls">
          ${actionsHtml}
          ${qrAmendWarningHtml}
        </div>
      </div>
    </div>
  `;

  let linesCardHtml = '';

  return `
    <div class="tabc">
      ${headerHtml}
      ${routeHtml}
      ${linesCardHtml}
    </div>
  `;
}

async function switchContractWeekToManual(weekId) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][CW-SWITCH-MANUAL]');
  GC('switchContractWeekToManual');

  if (!weekId) {
    GE();
    throw new Error('switchContractWeekToManual: weekId is required');
  }

  const encId = encodeURIComponent(weekId);
  const url   = API(`/api/contract-weeks/${encId}/switch-mode`);

  L('REQUEST', { url, weekId });

  let res, text;
  try {
    res  = await authFetch(url, { method: 'POST' });
    text = await res.text();
  } catch (err) {
    L('network error', err);
    GE();
    throw err;
  }

  if (!res.ok) {
    L('server error', { status: res.status, bodyPreview: text.slice(0, 400) });
    GE();
    throw new Error(text || `Failed to switch contract week ${weekId} to manual`);
  }

  let json = {};
  try {
    json = text ? JSON.parse(text) : {};
  } catch (err) {
    L('parse error', err);
  }

  L('RESULT', json);
  GE();
  return json;
}

function renderTimesheetIssuesTab(ctx) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][ISSUES]');
  const { row, details } = normaliseTimesheetCtx(ctx);

  GC('render');

  const tsfin       = details.tsfin || {};
  const validations = Array.isArray(details.validations) ? details.validations : [];
  const stage       = row.summary_stage || null;
  const procStatus  = tsfin.processing_status || row.processing_status || null;
  const payOnHold   = !!row.pay_on_hold;
  const basis       = tsfin.basis || row.basis || null;

  const ts          = details.timesheet || {};
  const policy      = details.policy || {};
  const requiresHr        = !!policy.requires_hr;
  const autoprocessHr     = !!policy.autoprocess_hr;
  const noTimesheetReq    = !!policy.no_timesheet_required;

  const authoriseTs       = ts.authorised_at_server || row.authorised_at_server || null;
  const authorised        = !!authoriseTs;

  const validationRows    = validations.slice(); // assume already most-recent-first
  const latestValidation  = validationRows.length ? validationRows[0] : null;
  const latestValStatus   = latestValidation ? String(latestValidation.status || '').toUpperCase() : null;
  const latestValReason   = latestValidation ? (latestValidation.reason_code || latestValidation.reason || '') : '';
  const validationIsOk    = latestValStatus === 'VALIDATION_OK' || latestValStatus === 'OVERRIDDEN';
  const validationFailed  = !!latestValidation && !validationIsOk;

  // NEW: HR cross-check fields from TSFIN
  const hrStatusRaw  = tsfin.hr_crosscheck_status || null;
  const hrStatus     = hrStatusRaw ? String(hrStatusRaw).toUpperCase() : null;
  const hrIssuesArr  = Array.isArray(tsfin.hr_crosscheck_issues) ? tsfin.hr_crosscheck_issues : [];
  const hrIssues     = hrIssuesArr.map(c => String(c || '').toUpperCase()).filter(Boolean);

  L('snapshot', {
    stage,
    procStatus,
    payOnHold,
    basis,
    validationsCount: validations.length,
    requiresHr,
    autoprocessHr,
    noTimesheetReq,
    authorised,
    latestValStatus,
    latestValReason,
    hrStatus,
    hrIssuesCount: hrIssues.length
  });

  const issues = [];

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Processing status-based issues â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const p = String(procStatus || '').toUpperCase();
  if (p === 'RATE_MISSING') {
    issues.push('Rate missing: no pay/charge rates found for this client/role/band on this date.');
  }
  if (p === 'PAY_CHANNEL_MISSING') {
    issues.push('Pay channel missing: candidate bank/umbrella details incomplete for this timesheet.');
  }
  if (p === 'CLIENT_UNRESOLVED') {
    issues.push('Client unresolved: timesheet could not be linked to a client correctly.');
  }
  if (p === 'UNASSIGNED') {
    issues.push('Unassigned: this timesheet has not been fully matched or processed yet.');
  }

  // Stage-based generic attention
  if (String(stage || '').toUpperCase() === 'NEEDS_ATTENTION') {
    if (!issues.length) {
      issues.push('This timesheet is flagged as "Needs attention". Check rates, pay channel, and validation results.');
    }
  }

  // Pay hold
  if (payOnHold) {
    issues.push('Pay is currently on hold for this timesheet. It will be excluded from pay runs until released.');
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ HR / HealthRoster gating â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // We only treat HR as a hard gate when requires_hr is true.
  if (requiresHr) {
    // HR cross-check required but not OK
    if (!validationIsOk) {
      if (!latestValidation) {
        issues.push('Awaiting HealthRoster cross-check: this client requires HR validation before pay/invoice.');
      } else if (validationFailed) {
        const friendly = latestValReason || 'validation failed â€“ see validation log for details.';
        issues.push(`HealthRoster validation failed: ${friendly}`);
      } else {
        issues.push('Awaiting HealthRoster cross-check: this client requires HR validation before pay/invoice.');
      }
    }

    // Awaiting team authorisation when autoprocess_hr = false
    // We consider this blocking when:
    // - HR is required
    // - autoprocess is disabled
    // - the TS is not yet authorised
    // - TSFIN is in a pre-invoice state (PENDING_AUTH or READY_FOR_HR)
    const p2 = p;
    if (!autoprocessHr && !authorised && (p2 === 'PENDING_AUTH' || p2 === 'READY_FOR_HR')) {
      issues.push('Awaiting authorisation by team: this client requires manual sign-off after HealthRoster checks.');
    }

    // Missing timesheet evidence when no_timesheet_required = false
    // Only enforce for HR-driven flows and when not yet paid/invoiced.
    const subMode    = String(ts.submission_mode || row.submission_mode || '').toUpperCase();
    const r2NurseKey = ts.r2_nurse_key || null;
    const r2AuthKey  = ts.r2_auth_key || null;
    const manualKey  = ts.manual_pdf_r2_key || details.manual_pdf_r2_key || null;
    const isPaid     = !!tsfin.paid_at_utc;
    const isInvoiced = !!tsfin.locked_by_invoice_id;

    const basisStr   = String(basis || '').toUpperCase();
    const isHrBasis  =
      basisStr.startsWith('HEALTHROSTER') ||
      basisStr.startsWith('NHSP') ||
      basisStr === 'SELF_REPORTED'; // self-reported but HR cross-check required

    const hasElectronicEvidence =
      subMode === 'ELECTRONIC' && !!(r2NurseKey && r2AuthKey);
    const hasManualEvidence = !!manualKey;

    if (!noTimesheetReq && isHrBasis && !isPaid && !isInvoiced) {
      if (!hasElectronicEvidence && !hasManualEvidence) {
        issues.push('Missing timesheet: this client requires a signed timesheet (electronic, QR or manual) even after HealthRoster validation.');
      }
    }
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ HR cross-check issues (from TSFIN) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  try {
    const seenHrCodes = new Set();

    for (const codeRaw of hrIssues) {
      const code = String(codeRaw || '').toUpperCase();
      if (!code || seenHrCodes.has(code)) continue;
      seenHrCodes.add(code);

      if (code === 'HOURS_MISMATCH_HR') {
        issues.push('Timesheet hours mismatch with Healthroster â€“ amend/resubmit timesheet or reupload HealthRoster with matching hours.');
      } else if (code === 'HR_HOURS_MISSING') {
        issues.push('Timesheet has hours which are not yet on HealthRoster â€“ confirm the worker worked these hours and request them to be added on HealthRoster.');
      } else if (code === 'DUPLICATE_CONTRACTS') {
        issues.push('Multiple contracts cover the same period for this client â€“ resolve duplicate contracts before proceeding.');
      }
      // If new HR codes are added in future, they can be mapped here.
    }
  } catch (e) {
    if (LOGM) L('[ISSUES] HR cross-check issues mapping failed (non-fatal)', e);
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ HR daily mismatch reasons (HealthRoster daily) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  try {
    const seenReasons = new Set();
    (validationRows || []).forEach(v => {
      const src = String(v.source_system || v.kind || '').toUpperCase();
      const st  = String(v.status || '').toUpperCase();
      const rc  = String(v.reason_code || '').toLowerCase();

      if (src !== 'HEALTHROSTER_DAILY') return;
      if (!st || st === 'VALIDATION_OK' || st === 'OVERRIDDEN') return;

      if (rc === 'start_end_mismatch' && !seenReasons.has(rc)) {
        issues.push('HealthRoster start/end times differ from the timesheet.');
        seenReasons.add(rc);
      }
      if (rc === 'break_minutes_mismatch' && !seenReasons.has(rc)) {
        issues.push('HealthRoster break length differs from the timesheet.');
        seenReasons.add(rc);
      }
      if (rc === 'actual_hours_mismatch' && !seenReasons.has(rc)) {
        issues.push('HealthRoster â€œActual Hoursâ€ differ from calculated timesheet hours.');
        seenReasons.add(rc);
      }
      if (rc === 'rate_missing_for_grade' && !seenReasons.has(rc)) {
        issues.push('No matching rate found for the requested grade â€“ check grade â†’ role â†’ rates mapping.');
        seenReasons.add(rc);
      }
    });
  } catch (e) {
    if (LOGM) L('[ISSUES] HR-daily mismatch detection failed (non-fatal)', e);
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Schedule-based issues (shift + breaks) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  try {
    const mc = window.modalCtx || {};
    const st = mc.timesheetState || {};
    const schedule = Array.isArray(st.schedule) ? st.schedule : null;

    if (schedule && schedule.length) {
      schedule.forEach(seg => {
        if (!seg || !seg.date) return;
        const date    = seg.date;
        const start   = seg.start || '';
        const end     = seg.end   || '';
        const bs      = seg.break_start || '';
        const be      = seg.break_end   || '';
        const hasStart = !!start;
        const hasEnd   = !!end;
        const hasBs    = !!bs;
        const hasBe    = !!be;

        // Shift incomplete: start without end or end without start
        if (hasStart && !hasEnd) {
          issues.push(`Shift end time missing for ${date} â€“ this row will be ignored in calculations.`);
        } else if (!hasStart && hasEnd) {
          issues.push(`Shift start time missing for ${date} â€“ this row will be ignored in calculations.`);
        }

        // Incomplete primary break times (only one of break_start/break_end)
        if (hasStart && hasEnd && (hasBs !== hasBe)) {
          issues.push(`Break start/end incomplete for ${date} â€“ no primary break window applied to that shift.`);
        }

        // Extra break windows in breaks[]
        if (Array.isArray(seg.breaks) && seg.breaks.length) {
          seg.breaks.forEach((br, idx) => {
            if (!br || (br.start == null && br.end == null)) return;
            const extraStart = br.start || '';
            const extraEnd   = br.end   || '';
            const hasExtraStart = !!extraStart;
            const hasExtraEnd   = !!extraEnd;

            if (hasExtraStart !== hasExtraEnd) {
              const n = idx + 1;
              issues.push(`Extra break window #${n} incomplete for ${date} â€“ that break window will be ignored.`);
            }
          });
        }
      });
    }
  } catch (e) {
    if (LOGM) L('[ISSUES] schedule-based issue detection failed (non-fatal)', e);
  }

  // Validation rows â†’ log (read-only)
  const valItems = validations.map(v => {
    return `
      <li>
        <span class="mini">
          [${v.source_system || v.kind || 'VALIDATION'}] ${v.status || 'UNKNOWN'} â€“ ${v.reason || v.reason_code || '(no reason given)'}
        </span>
      </li>
    `;
  }).join('');

  // If there are truly no blocking issues, say so explicitly
  if (!issues.length) {
    issues.push('No blocking issues detected. This timesheet should be ready once normal processing steps complete.');
  }

  GE();

  return `
    <div class="tabc">
      <div class="card">
        <div class="row">
          <label>Processing status</label>
          <div class="controls">
            <span class="mini">${procStatus || 'UNKNOWN'}</span>
          </div>
        </div>
        <div class="row">
          <label>Stage</label>
          <div class="controls">
            <span class="mini">${stage || 'UNKNOWN'}</span>
          </div>
        </div>
        <div class="row">
          <label>Basis</label>
          <div class="controls">
            <span class="mini">${basis || 'â€”'}</span>
          </div>
        </div>
      </div>

      <div class="card" style="margin-top:10px;">
        <div class="row">
          <label>Issues</label>
          <div class="controls">
            <ul class="mini">
              ${issues.map(i => `<li>${i}</li>`).join('')}
            </ul>
          </div>
        </div>
      </div>

      <div class="card" style="margin-top:10px;">
        <div class="row">
          <label>Validation log</label>
          <div class="controls">
            ${valItems ? `<ul>${valItems}</ul>` : '<span class="mini">No validation rows recorded.</span>'}
          </div>
        </div>
        <div class="row">
          <label></label>
          <div class="controls">
            <button type="button" data-ts-action="load-source-rows">
              View source rows (HealthRoster / NHSP)
            </button>
            <span class="mini" style="margin-left:8px;">
              This will call /api/timesheets/&lt;id&gt;/source-print and show the original HR / NHSP rows used to create this timesheet.
            </span>
          </div>
        </div>
      </div>
    </div>
  `;
}

function renderTimesheetFinanceTab(ctx) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][FINANCE]');
  const { row, details, related, state } = normaliseTimesheetCtx(ctx);

  GC('render');
  const ts    = details.timesheet || {};
  const tsfin = details.tsfin     || {};
  const enc   = escapeHtml;

  const fmtMoney = (v) =>
    isNaN(Number(v)) ? 'â€”' : `Â£${(Math.round(Number(v) * 100) / 100).toFixed(2)}`;

  // Core TSFIN-derived buckets
  const hours = {
    day:   Number(tsfin.hours_day   || 0),
    night: Number(tsfin.hours_night || 0),
    sat:   Number(tsfin.hours_sat   || 0),
    sun:   Number(tsfin.hours_sun   || 0),
    bh:    Number(tsfin.hours_bh    || 0)
  };

  const pay = {
    day:   tsfin.pay_day,
    night: tsfin.pay_night,
    sat:   tsfin.pay_sat,
    sun:   tsfin.pay_sun,
    bh:    tsfin.pay_bh
  };

  const chg = {
    day:   tsfin.charge_day,
    night: tsfin.charge_night,
    sat:   tsfin.charge_sat,
    sun:   tsfin.charge_sun,
    bh:    tsfin.charge_bh
  };

  const buckets = ['day','night','sat','sun','bh'];
  const bucketLabel = {
    day:  'Day',
    night:'Night',
    sat:  'Saturday',
    sun:  'Sunday',
    bh:   'Bank Holiday'
  };

  const tsfinBucketRows = buckets.map(b => {
    const hrs   = hours[b] || 0;
    const payR  = pay[b] != null ? Number(pay[b]) : null;
    const chgR  = chg[b] != null ? Number(chg[b]) : null;
    const payEx = payR != null ? hrs * payR : null;
    const chgEx = chgR != null ? hrs * chgR : null;
    const marEx = (payEx != null && chgEx != null) ? (chgEx - payEx) : null;

    return `
      <tr>
        <td>${bucketLabel[b]}</td>
        <td>${hrs || 0}</td>
        <td>${payR != null ? fmtMoney(payR) : 'â€”'}</td>
        <td>${chgR != null ? fmtMoney(chgR) : 'â€”'}</td>
        <td>${payEx != null ? fmtMoney(payEx) : 'â€”'}</td>
        <td>${chgEx != null ? fmtMoney(chgEx) : 'â€”'}</td>
        <td>${marEx != null ? fmtMoney(marEx) : 'â€”'}</td>
      </tr>
    `;
  }).join('');

  // Additional rates (from TSFIN snapshot)
  let addUnits = tsfin.additional_units_json || {};
  if (typeof addUnits === 'string') {
    try { addUnits = JSON.parse(addUnits); } catch { addUnits = {}; }
  }
  if (!addUnits || typeof addUnits !== 'object') addUnits = {};

  const additionalRows = Object.entries(addUnits).map(([code, ex]) => {
    if (!ex || typeof ex !== 'object') return '';
    const bucketName = (ex.bucket_name || code || '').trim();
    const unitName   = (ex.unit_name || 'units').trim();
    const unitCount  = Number(ex.unit_count || 0) || 0;
    const payEx      = Number(ex.pay_ex_vat    || 0);
    const chgEx      = Number(ex.charge_ex_vat || 0);
    const marEx      = chgEx - payEx;

    if (!unitCount && !payEx && !chgEx) return '';

    return `
      <tr>
        <td>${enc(bucketName || code)}</td>
        <td>${unitCount}</td>
        <td>${enc(unitName)}</td>
        <td>${fmtMoney(ex.pay_rate    ?? null)}</td>
        <td>${fmtMoney(ex.charge_rate ?? null)}</td>
        <td>${fmtMoney(payEx)}</td>
        <td>${fmtMoney(chgEx)}</td>
        <td>${fmtMoney(marEx)}</td>
      </tr>
    `;
  }).filter(Boolean).join('');

  const hasAdditional = !!additionalRows;

  const expensesPay   = Number(tsfin.expenses_pay_ex_vat  || 0) || 0;
  const mileagePay    = Number(tsfin.mileage_pay_ex_vat   || 0) || 0;
  const addPay        = Number(tsfin.additional_pay_ex_vat    || 0) || 0;
  const addCharge     = Number(tsfin.additional_charge_ex_vat || 0) || 0;

  const totalPayEx    = Number(tsfin.total_pay_ex_vat    || 0) || 0;
  const totalChgEx    = Number(tsfin.total_charge_ex_vat || 0) || 0;
  const totalMarginEx = totalChgEx - totalPayEx;

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Determine mode & schedule state â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let frameMode = 'view';
  try {
    if (typeof window.__getModalFrame === 'function') {
      const fr = window.__getModalFrame();
      if (fr && typeof fr.mode === 'string') frameMode = fr.mode;
    }
  } catch {}

  const mc = window.modalCtx || {};
  const st = mc.timesheetState || state || {};
  const schedule = Array.isArray(st.schedule) ? st.schedule : null;
  const hasSchedule = !!(schedule && schedule.length);
  const isEditing = (frameMode === 'edit' || frameMode === 'create');

  // Look at timesheetMeta to know if this is a planned/open week
  const meta           = mc.timesheetMeta || {};
  const isPlannedWeek  = !!meta.isPlannedWeek;

  // In EDIT/CREATE + schedule present â†’ Proposed Buckets
  // Also: in VIEW + schedule present for planned weeks â†’ Proposed Buckets
  const useProposedBuckets = hasSchedule && (isEditing || isPlannedWeek);

  // Helper for building proposed-buckets table from preview payload
  const buildProposedBucketTable = (preview) => {
    if (!preview || typeof preview !== 'object') {
      return `<span class="mini">Bucket preview unavailable.</span>`;
    }
    const h = preview.hours  || {};
    const p = preview.pay    || {};
    const c = preview.charge || {};

    const rows = buckets.map(b => {
      const hrs   = Number(h[b] || 0);
      const payR  = p[b] != null ? Number(p[b]) : null;
      const chgR  = c[b] != null ? Number(c[b]) : null;
      const payEx = payR != null ? hrs * payR : null;
      const chgEx = chgR != null ? hrs * chgR : null;
      const marEx = (payEx != null && chgEx != null) ? (chgEx - payEx) : null;

      return `
        <tr>
          <td>${bucketLabel[b]}</td>
          <td>${hrs || 0}</td>
          <td>${payR  != null ? fmtMoney(payR)  : 'â€”'}</td>
          <td>${chgR  != null ? fmtMoney(chgR)  : 'â€”'}</td>
          <td>${payEx != null ? fmtMoney(payEx) : 'â€”'}</td>
          <td>${chgEx != null ? fmtMoney(chgEx) : 'â€”'}</td>
          <td>${marEx != null ? fmtMoney(marEx) : 'â€”'}</td>
        </tr>
      `;
    }).join('');

    return `
      <table class="grid mini">
        <thead>
          <tr>
            <th>Bucket</th>
            <th>Hours</th>
            <th>Pay rate</th>
            <th>Charge rate</th>
            <th>Pay (ex VAT)</th>
            <th>Charge (ex VAT)</th>
            <th>Margin (ex VAT)</th>
          </tr>
        </thead>
        <tbody>${rows}</tbody>
      </table>
      <span class="mini" style="display:block;margin-top:4px;">
        Based on the current Lines schedule (unsaved). For planned weeks this is a live preview;
        for existing timesheets it reflects any staged schedule changes once saved.
      </span>
    `;
  };

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Preview from current Lines schedule (total hours) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let previewHoursHtml = '';
  let bucketCardHtml = '';

  try {
    // Real timesheet id only
    const tsId   = mc.data?.timesheet_id || row.timesheet_id || null;
    // Contract-week id for planned/open weeks
    const weekId = mc.data?.contract_week_id || row.contract_week_id || null;

    if (schedule && schedule.length) {
      const hhmmToMinutes = (hhmm) => {
        if (!hhmm || typeof hhmm !== 'string') return null;
        const m = hhmm.trim();
        const parts = m.split(':');
        if (parts.length !== 2) return null;
        const h = Number(parts[0]);
        const mm = Number(parts[1]);
        if (!Number.isFinite(h) || !Number.isFinite(mm)) return null;
        return h * 60 + mm;
      };

      let totalPaidMinutes = 0;
      schedule.forEach(seg => {
        const startStr = seg.start || null;
        const endStr   = seg.end   || null;
        const sMin = hhmmToMinutes(startStr);
        const eMin = hhmmToMinutes(endStr);
        if (sMin == null || eMin == null) return;

        let shiftMinutes = eMin - sMin;
        if (shiftMinutes < 0) shiftMinutes += 24 * 60; // overnight wrap

        const breakMinutes = Number(seg.break_mins || seg.break_minutes || 0) || 0;
        const paidMin = Math.max(0, shiftMinutes - breakMinutes);
        totalPaidMinutes += paidMin;
      });

      const totalPaidHours = totalPaidMinutes > 0
        ? (Math.round((totalPaidMinutes / 60) * 100) / 100).toFixed(2)
        : '0.00';

      previewHoursHtml = `
        <div class="card" style="margin-top:10px;">
          <div class="row">
            <label>Preview from Lines</label>
            <div class="controls">
              <div class="mini">
                Total paid hours from current Lines schedule (unsaved): <strong>${totalPaidHours}</strong><br/>
                The bucketed pay/charge ${useProposedBuckets ? 'below' : 'above'} will reflect this
                schedule once the timesheet is saved and TSFIN is recomputed.
              </div>
            </div>
          </div>
        </div>
      `;

      // Proposed buckets via backend (now for edit/create AND planned weeks in view)
      if (useProposedBuckets && (tsId || weekId)) {
        const containerId = 'tsBucketPreview';
        const innerId = 'tsBucketPreviewInner';

        bucketCardHtml = `
          <div class="card">
            <div class="row">
              <label>Core hours & rates</label>
              <div class="controls">
                <span class="pill pill-bad">Proposed Buckets</span>
                <div id="${containerId}">
                  <div id="${innerId}">
                    <span class="mini" id="tsBucketPreviewStatus">Loading bucket preview from Linesâ€¦</span>
                  </div>
                </div>
              </div>
            </div>
          </div>
        `;

        try {
          // Build additional_units_week from staged additionalRates
          const additionalUnitsWeek = {};
          if (st.additionalRates && typeof st.additionalRates === 'object') {
            Object.entries(st.additionalRates).forEach(([code, r]) => {
              if (!r) return;
              const units = Number(r.units_week || 0);
              if (!Number.isFinite(units) || units === 0) return;
              additionalUnitsWeek[code] = units;
            });
          }

          const payload = {
            timesheet_id:         tsId || null,
            contract_week_id:     tsId ? null : (weekId || null),
            actual_schedule_json: schedule,
            additional_units_week: additionalUnitsWeek
          };

          const url = API('/api/timesheets/bucket-preview');
          authFetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          })
            .then(res => {
              if (!res.ok) {
                return res.text().then(msg => {
                  throw new Error(msg || 'Bucket preview failed');
                });
              }
              return res.json();
            })
            .then(data => {
              try {
                const cacheKey = tsId || `cw:${weekId || 'unknown'}`;
                window.__tsBucketPreviewCache = window.__tsBucketPreviewCache || {};
                window.__tsBucketPreviewCache[String(cacheKey)] = { ok: true, data };
              } catch {}
              const container = document.getElementById(innerId);
              if (container) {
                container.innerHTML = buildProposedBucketTable(data);
              }
            })
            .catch(err => {
              const msg = err?.message || 'Bucket preview failed';
              try {
                const cacheKey = tsId || `cw:${weekId || 'unknown'}`;
                window.__tsBucketPreviewCache = window.__tsBucketPreviewCache || {};
                window.__tsBucketPreviewCache[String(cacheKey)] = { error: msg };
              } catch {}
              const statusEl = document.getElementById('tsBucketPreviewStatus');
              if (statusEl) {
                const safeMsg = enc(msg);
                statusEl.innerHTML = `
                  <span class="warn-icon" title="${safeMsg}">&#9888;</span>
                `;
              }
            });
        } catch (e) {
          if (LOGM) L('[FINANCE] bucket-preview wiring failed', e);
        }
      }
    }
  } catch (e) {
    if (LOGM) L('[FINANCE] preview wiring failed', e);
  }

  // If not using proposed buckets, show TSFIN snapshot as Actual Buckets
  if (!useProposedBuckets) {
    bucketCardHtml = `
      <div class="card">
        <div class="row">
          <label>Core hours & rates</label>
          <div class="controls">
            <span class="pill pill-ok">Actual Buckets</span>
            <table class="grid mini">
              <thead>
                <tr>
                  <th>Bucket</th>
                  <th>Hours</th>
                  <th>Pay rate</th>
                  <th>Charge rate</th>
                  <th>Pay (ex VAT)</th>
                  <th>Charge (ex VAT)</th>
                  <th>Margin (ex VAT)</th>
                </tr>
              </thead>
              <tbody>
                ${tsfinBucketRows}
              </tbody>
            </table>
            <span class="mini" style="display:block;margin-top:4px;">
              These values come from the current financial snapshot (TSFIN).
              If you change the Lines schedule and then click <strong>Save</strong>, a new snapshot will be generated.
            </span>
          </div>
        </div>
      </div>
    `;
  }

  GE();

  return `
    <div class="tabc">
      ${bucketCardHtml}

      <div class="card" style="margin-top:10px;">
        <div class="row">
          <label>Additional rates</label>
          <div class="controls">
            ${
              hasAdditional
                ? `
                  <table class="grid mini">
                    <thead>
                      <tr>
                        <th>Bucket</th>
                        <th>Units</th>
                        <th>Unit name</th>
                        <th>Pay rate</th>
                        <th>Charge rate</th>
                        <th>Pay (ex VAT)</th>
                        <th>Charge (ex VAT)</th>
                        <th>Margin (ex VAT)</th>
                      </tr>
                    </thead>
                    <tbody>${additionalRows}</tbody>
                  </table>
                `
                : '<span class="mini">No additional rate units recorded on this snapshot.</span>'
            }
          </div>
        </div>
      </div>

      <div class="card" style="margin-top:10px;">
        <div class="row">
          <label>Summary</label>
          <div class="controls">
            <div class="mini">
              Core pay (ex VAT): <strong>${fmtMoney(totalPayEx)}</strong><br/>
              Core charge (ex VAT): <strong>${fmtMoney(totalChgEx)}</strong><br/>
              Margin (ex VAT): <strong>${fmtMoney(totalMarginEx)}</strong><br/><br/>
              Additional pay (ex VAT): <strong>${fmtMoney(addPay)}</strong><br/>
              Additional charge (ex VAT): <strong>${fmtMoney(addCharge)}</strong><br/>
              Expenses pay (ex VAT): <strong>${fmtMoney(expensesPay)}</strong><br/>
              Mileage pay (ex VAT): <strong>${fmtMoney(mileagePay)}</strong>
            </div>
          </div>
        </div>
      </div>

      ${previewHoursHtml}
    </div>
  `;
}


function renderTimesheetOverviewTab(ctx) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][OVERVIEW]');
  const { row, details, related, state } = normaliseTimesheetCtx(ctx);

  GC('render');
  const ts    = details.timesheet || {};
  const tsfin = details.tsfin     || {};
  const cw    = details.contract_week || {};
  const rCand = related.candidate || {};
  const rCli  = related.client    || {};
  const rCtr  = related.contract  || {};
  const rInv  = related.invoice   || null;

  const sheetScope = (details.sheet_scope ||
                      row.sheet_scope ||
                      ts.sheet_scope ||
                      '').toUpperCase();
  const subMode    = (ts.submission_mode ||
                      row.submission_mode ||
                      '').toUpperCase();
  const basis      = (tsfin.basis || row.basis || '').toUpperCase();

  const tsId = ts.timesheet_id || row.timesheet_id || null;

  const enc = escapeHtml;

  const candidateName =
    (rCand.display_name && enc(rCand.display_name)) ||
    (row.candidate_name && enc(row.candidate_name)) ||
    (row.occupant_key_norm && enc(row.occupant_key_norm)) ||
    (rCand.first_name || rCand.last_name
      ? enc([rCand.first_name, rCand.last_name].filter(Boolean).join(' '))
      : 'Unknown candidate');

  const clientName =
    (rCli.name && enc(rCli.name)) ||
    (rCtr.display_site && enc(rCtr.display_site)) ||
    (row.client_name && enc(row.client_name)) ||
    (row.client_id ? enc(row.client_id) : 'Unknown client');

  const jobTitle =
    (rCtr.role && enc(rCtr.role)) ||
    (row.job_title_norm && enc(row.job_title_norm)) ||
    null;
  const band =
    (rCtr.band && String(rCtr.band).trim()) ||
    (row.band && String(row.band).trim()) ||
    null;

  const weYmd = ts.week_ending_date || row.week_ending_date || null;

  // YYYY-MM-DD â†’ DD-MM-YYYY for UI
  const fmtYmdToDmy = (ymd) => {
    if (!ymd || typeof ymd !== 'string' || !/^\d{4}-\d{2}-\d{2}$/.test(ymd)) return enc(ymd || '');
    const [y, m, d] = ymd.split('-');
    return `${d}-${m}-${y}`;
  };

  const fmtDow = (ymd) => {
    if (!ymd) return '';
    const d = new Date(`${ymd}T00:00:00Z`);
    if (Number.isNaN(d.getTime())) return '';
    return d.toLocaleDateString('en-GB', { weekday: 'short', timeZone: 'Europe/London' });
  };

  const fmtUkDateTime = (iso) => {
    if (!iso) return '';
    const d = new Date(iso);
    if (Number.isNaN(d.getTime())) return enc(iso);
    const s = d.toLocaleString('en-GB', {
      timeZone: 'Europe/London',
      weekday: 'short',
      day: '2-digit',
      month: 'short',
      year: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
      hour12: false
    });
    const parts = s.replace(',', '').split(' ');
    if (parts.length < 4) return enc(s);
    const [dow, day, mon, year, time] = parts;
    const hhmm = (time || '').replace(':', '');
    return `${enc(dow)} ${enc(day)} ${enc(mon)} ${enc(year)} at ${enc(hhmm)}hrs`;
  };

  const hasTsfin = !!(
    tsfin &&
    (
      tsfin.timesheet_id ||
      tsfin.total_hours != null ||
      tsfin.total_pay_ex_vat != null ||
      tsfin.processing_status
    )
  );
  const hasContractWeek = !!(details.contract_week_id || cw.id || row.contract_week_id);
  const isPlannedOnly   = !hasTsfin && hasContractWeek && !tsId;

  const stageRaw      = (tsfin.processing_status || '').toUpperCase() || null;
  const isPaid        = !!tsfin.paid_at_utc;
  const isInvoiced    = !!tsfin.locked_by_invoice_id;
  const payOnHold     = !!tsfin.pay_on_hold;
  const authorised    = !!ts.authorised_at_server;
  const qrStatus      = (details.qr_status || ts.qr_status || '').toUpperCase();

  const amountPayEx   = Number(tsfin.total_pay_ex_vat || 0) || 0;
  const amountChgEx   = Number(tsfin.total_charge_ex_vat || 0) || 0;
  const amountMargin  = amountChgEx - amountPayEx;

  const fmtMoney = (v) => isNaN(Number(v)) ? 'â€”' : `Â£${(Math.round(Number(v) * 100) / 100).toFixed(2)}`;

  L('snapshot', {
    tsId,
    sheetScope,
    subMode,
    basis,
    stageRaw,
    authorised,
    isPaid,
    isInvoiced,
    payOnHold,
    qrStatus,
    weYmd,
    hasTsfin,
    hasContractWeek,
    isPlannedOnly
  });
  GE();

  const headerHtml = `
    <div class="card">
      <div class="row">
        <label>Timesheet</label>
        <div class="controls">
          <div style="font-size:15px;font-weight:600;margin-bottom:2px;">
            ${candidateName}
          </div>
          <div class="mini">
            Client: ${clientName}
          </div>
          <div class="mini">
            ${
              weYmd
                ? `Week ending: ${fmtDow(weYmd)} ${fmtYmdToDmy(weYmd)}`
                : '<span class="mini">Week ending: Unknown</span>'
            }
          </div>
          <div class="mini">
            ${
              jobTitle
                ? (band ? `${jobTitle} (Band ${enc(band)})` : jobTitle)
                : (band ? `Band ${enc(band)}` : '<span class="mini">No job title</span>')
            }
          </div>
        </div>
      </div>
    </div>
  `;

  const stageLabel = (() => {
    if (!hasTsfin) {
      if (isPlannedOnly) return 'UNPROCESSED (planned week)';
      return 'UNPROCESSED';
    }
    if (isPaid) return 'Paid';
    if (isInvoiced) return 'Invoiced';
    if (stageRaw === 'READY_FOR_INVOICE') return 'Ready for invoice';
    if (stageRaw === 'PENDING_AUTH') return 'Pending authorisation';
    if (stageRaw === 'RATE_MISSING') return 'Rate missing';
    if (stageRaw === 'PAY_CHANNEL_MISSING') return 'Pay channel missing';
    return stageRaw || 'Unknown';
  })();

  const stageClass = (() => {
    if (!hasTsfin) return 'pill-bad';
    if (isPaid) return 'pill-ok';
    if (isInvoiced) return 'pill-warn';
    if (stageRaw === 'RATE_MISSING' || stageRaw === 'PAY_CHANNEL_MISSING') return 'pill-bad';
    if (stageRaw === 'READY_FOR_INVOICE') return 'pill-ok';
    return 'pill-info';
  })();

  const scopePill = sheetScope === 'DAILY'
    ? '<span class="pill pill-daily">Daily</span>'
    : '<span class="pill pill-weekly">Weekly</span>';

  const modePill = (() => {
    if (basis === 'NHSP' || basis === 'NHSP_ADJUSTMENT') {
      return '<span class="pill pill-nhsp">NHSP</span>';
    }
    if (basis.startsWith('HEALTHROSTER')) {
      return '<span class="pill pill-hr">HealthRoster</span>';
    }
    if (subMode === 'ELECTRONIC') {
      return '<span class="pill pill-elec">Electronic</span>';
    }
    if (subMode === 'MANUAL' && qrStatus) {
      return `<span class="pill pill-manual">Manual (QR: ${enc(qrStatus)})</span>`;
    }
    if (subMode === 'MANUAL') {
      return '<span class="pill pill-manual">Manual</span>';
    }
    return '<span class="pill">Unknown mode</span>';
  })();

  const paidLabel = isPaid
    ? fmtUkDateTime(tsfin.paid_at_utc)
    : 'Not paid';

  const invLabel = isInvoiced
    ? (rInv && rInv.invoice_number
        ? `On invoice ${enc(rInv.invoice_number)}`
        : 'Invoiced')
    : 'Not invoiced';

  const flagsHtml = `
    <div class="mini" style="margin-top:4px;">
      <span class="pill ${isPaid ? 'pill-ok' : 'pill-warn'}">
        Paid: ${isPaid ? 'Yes' : 'No'}
      </span>
      <span class="pill ${isInvoiced ? 'pill-warn' : 'pill-info'}" style="margin-left:4px;">
        Invoiced: ${isInvoiced ? 'Yes' : 'No'}
      </span>
      ${
        payOnHold
          ? '<span class="pill pill-hold" style="margin-left:4px;">Pay on hold</span>'
          : ''
      }
    </div>
    <div class="mini" style="margin-top:4px;">
      ${isPaid ? `Paid at ${paidLabel}` : ''}
      ${isInvoiced ? `<br/>${invLabel}` : ''}
    </div>
  `;

  const totalsHtml = hasTsfin
    ? `
      <div class="mini">
        Candidate pay (ex VAT): <strong>${fmtMoney(amountPayEx)}</strong><br/>
        Client charge (ex VAT): <strong>${fmtMoney(amountChgEx)}</strong><br/>
        Margin (ex VAT): <strong>${fmtMoney(amountMargin)}</strong>
      </div>
    `
    : `
      <div class="mini">
        <strong>No financial snapshot yet.</strong><br/>
        This timesheet has not been processed. Once processed, pay and charge totals will appear here.
      </div>
    `;

  // Timesheet-level reference (safe to edit even for electronic â€“ this is NOT the hours)
  const refValue = state && typeof state.reference === 'string'
    ? state.reference
    : (ts.reference_number || row.reference_number || '');

  const routeHtml = `
    <div class="card" style="margin-top:10px;">
      <div class="row">
        <label>Stage</label>
        <div class="controls">
          <span class="pill ${stageClass}" style="font-weight:600;">
            ${enc(stageLabel)}
          </span>
          <div class="mini" style="margin-top:4px;">
            ${authorised ? 'Authorised' : 'Not authorised'}
          </div>
        </div>
      </div>
      <div class="row">
        <label>Route</label>
        <div class="controls">
          ${scopePill}
          ${modePill}
          ${
            basis
              ? `<span class="pill pill-info" style="margin-left:4px;">Basis: ${enc(basis)}</span>`
              : ''
          }
          ${flagsHtml}
        </div>
      </div>
      <div class="row">
        <label>Totals</label>
        <div class="controls">
          ${totalsHtml}
        </div>
      </div>
      <div class="row">
        <label>Reference / PO</label>
        <div class="controls">
          <input
            class="input"
            name="ts_reference"
            value="${enc(refValue || '')}"
            placeholder="Reference or PO (optional)"
          />
          <span class="mini">
            This is staged only and will be saved when you click <strong>Save</strong>.
          </span>
        </div>
      </div>
      <div class="row" data-view-only="true">
        <label>Actions</label>
        <div class="controls">
          <button type="button"
                  class="btn"
                  data-ts-action="switch-manual">
            Convert to manual timesheet
          </button>
        </div>
      </div>
    </div>
  `;

  // No shift breakdown here â€” all detailed lines (weekly & daily) are on the Lines tab.
  const linesCardHtml = '';

  return `
    <div class="tabc">
      ${headerHtml}
      ${routeHtml}
      ${linesCardHtml}
    </div>
  `;
}



async function getTimesheetPdfUrl(timesheetId) {
  const LOGM = (typeof window.__LOG_MODAL === 'boolean') ? window.__LOG_MODAL : false;
  const L    = (...a) => { if (LOGM) console.log('[TS][PDF][GET]', ...a); };
  const GC   = (label) => { if (LOGM) console.groupCollapsed('[TS][PDF][GET]', label); };
  const GE   = () => { if (LOGM) console.groupEnd(); };

  if (!timesheetId) {
    throw new Error('getTimesheetPdfUrl: timesheetId is required');
  }

  GC('getTimesheetPdfUrl');
  L('START', { timesheetId });

  const encId = encodeURIComponent(timesheetId);
  const metaUrl = API(`/api/timesheets/${encId}/pdf`);

  let pdfMeta;
  try {
    const res  = await authFetch(metaUrl);
    const text = await res.text();

    if (!res.ok) {
      // Treat any non-OK as "no CURRENT pdf" for the purposes of the Evidence dialog
      L('timesheet pdf meta failed', { status: res.status, bodyPreview: text.slice(0, 400) });
      GE();
      return null;
    }

    pdfMeta = text ? JSON.parse(text) : {};
  } catch (err) {
    // Network / parse errors â†’ treat as "no pdf" for the dialog
    L('meta fetch error', err);
    GE();
    return null;
  }

  const r2Key =
    pdfMeta.r2_key ||
    pdfMeta.key ||
    pdfMeta.manual_pdf_r2_key ||
    null;

  if (!r2Key) {
    L('no r2_key in pdfMeta', pdfMeta);
    GE();
    return null;
  }

  L('meta resolved', { r2Key, rotation_degrees: pdfMeta.rotation_degrees });

  // Ask files API for a presigned download URL
  const presignUrl = API('/api/files/presign-download');
  let signed;
  try {
    const res  = await authFetch(presignUrl, {
      method: 'POST',
      headers: { 'Content-Type':'application/json' },
      body: JSON.stringify({ key: r2Key })
    });
    const text = await res.text();

    if (!res.ok) {
      L('presign-download failed', { status: res.status, bodyPreview: text.slice(0, 400) });
      GE();
      return null;
    }

    signed = text ? JSON.parse(text) : {};
  } catch (err) {
    L('presign error', err);
    GE();
    return null;
  }

  const url = signed.url || signed.signed_url || null;
  if (!url) {
    L('no URL in presign response', signed);
    GE();
    return null;
  }

  L('RESOLVE OK', { url });
  GE();

  return {
    url,
    r2_key: r2Key,
    rotation_degrees: pdfMeta.rotation_degrees ?? 0,
    meta: pdfMeta
  };
}

async function openTimesheet(row) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][OPEN]');
  GC('openTimesheet');

  try {
    // 1) Normalise the incoming row & timesheet / week ids
    if (!row || typeof row !== 'object') {
      alert('No timesheet row provided.');
      GE();
      return;
    }

    const baseRow = { ...row };

    const realTsId = baseRow.timesheet_id || null;
    const weekId   = baseRow.contract_week_id || null;
    const hasTs    = !!realTsId;
    const isPlannedWeek = !hasTs && !!weekId; // PLANNED / OPEN weekly (no TS yet)

    if (!hasTs && !isPlannedWeek) {
      L('ERROR: missing timesheet_id / contract_week_id on row', { row });
      GE();
      alert('Timesheet or week id missing.');
      return;
    }

    // For existing TS, the stable grid id should be the timesheet_id.
    // For planned/open weeks (no TS yet), grid id will be contract_week_id.
    const tsId = hasTs ? realTsId : null;
    baseRow.id = hasTs ? realTsId : (weekId || baseRow.id);

    // Rough classification for logging & future UI tweaks
    const sheetScopeRaw = (baseRow.sheet_scope || '').toUpperCase();
    const subModeRaw    = (baseRow.submission_mode || '').toUpperCase();
    const basisRaw      = (baseRow.basis || '').toUpperCase();
    const routeTypeRaw  = (baseRow.route_type || '').toUpperCase();

    L('ENTRY', {
      tsId,
      weekId,
      isPlannedWeek,
      sheetScopeRaw,
      subModeRaw,
      basisRaw,
      routeTypeRaw,
      rowKeys: Object.keys(baseRow || {})
    });

    // 2) Fetch details + related entities from backend
    let details;
    let evidence = []; // NEW: evidence list for this timesheet

    if (hasTs) {
      try {
        details = await fetchTimesheetDetails(tsId);
        L('details fetched', {
          hasTimesheet: !!details.timesheet,
          hasTsfin: !!details.tsfin,
          segments: (details.segments || []).length,
          shifts: (details.shifts || []).length,
          isSegmentsMode: !!details.isSegmentsMode,
          contract_week_id: details.contract_week_id || null
        });
      } catch (err) {
        L('fetchTimesheetDetails FAILED', err);
        GE();
        alert(err?.message || 'Failed to load timesheet details.');
        return;
      }

      // NEW: fetch evidence list for this timesheet so Evidence tab can render it
      try {
        const encTsId = encodeURIComponent(tsId);
        const res  = await authFetch(API(`/api/timesheets/${encTsId}/evidence`));
        const json = await res.json().catch(() => []);
        evidence   = Array.isArray(json) ? json : [];
        L('evidence fetched', { timesheet_id: tsId, count: evidence.length });
      } catch (err) {
        L('fetch evidence FAILED (non-fatal)', err);
        evidence = [];
      }
    } else {
      // Planned / OPEN weekly week with no TS yet â€“ load contract_week via broker so we can seed schedule
      let contractWeek = null;
      try {
        const qs = new URLSearchParams();

        // We know the week id; also use contract_id + WE if we have them to minimise rows
        if (baseRow.contract_id) {
          qs.set('contract_id', baseRow.contract_id);
        }
        const we =
          baseRow.contract_week_ending_date ||
          baseRow.week_ending_date ||
          null;
        if (we) {
          qs.set('week_ending_from', we);
          qs.set('week_ending_to', we);
        }

        // Ask backend to include planned_schedule_json
        qs.set('include_plan', 'true');

        const url = API(`/api/contract-weeks?${qs.toString()}`);
        const res = await authFetch(url);
        const rows = await toList(res);

        contractWeek =
          (rows || []).find(w => String(w.id) === String(weekId)) ||
          (rows || [])[0] ||
          null;
      } catch (e) {
        if (LOGM) L('failed to load contract_week for planned week (non-fatal)', e);
      }

      details = {
        timesheet: null,
        tsfin: null,
        validations: [],
        shifts: [],
        segments: [],
        isSegmentsMode: false,
        invoiceBreakdown: null,
        sheet_scope: sheetScopeRaw || 'WEEKLY',
        qr_status: null,
        qr_generated_at: null,
        qr_scanned_at: null,
        manual_pdf_r2_key: null,
        contract_week_id: weekId,
        contract_week: contractWeek
      };

      // No evidence for planned week without a TS
      evidence = [];

      L('details stubbed for planned week', {
        weekId,
        details_scope: details.sheet_scope,
        hasContractWeek: !!contractWeek
      });
    }

    let related;
    if (hasTs) {
      try {
        related = await fetchTimesheetRelated(tsId);
        L('related fetched', {
          candidate: !!related.candidate,
          client: !!related.client,
          contract: !!related.contract,
          invoice: !!related.invoice,
          umbrella: !!related.umbrella,
          series: (related.series || []).length
        });
      } catch (err) {
        L('fetchTimesheetRelated FAILED (non-fatal)', err);
        related = {
          counts: {},
          candidate: null,
          client: null,
          invoice: null,
          umbrella: null,
          contract: null,
          series: []
        };
      }
    } else {
      // Planned week: surface candidate/client from the summary row so header isn't "Unknown"
      related = {
        counts: {},
        candidate: (baseRow.candidate_id || baseRow.candidate_name || baseRow.occupant_key_norm)
          ? {
              id: baseRow.candidate_id || null,
              display_name: baseRow.candidate_name || baseRow.occupant_key_norm || null,
              first_name: null,
              last_name: null
            }
          : null,
        client: (baseRow.client_id || baseRow.client_name)
          ? {
              id: baseRow.client_id || null,
              name: baseRow.client_name || null
            }
          : null,
        invoice: null,
        umbrella: null,
        contract: null,
        series: []
      };
    }

    // 3) Seed modalCtx for the timesheet frame
    const ts    = details.timesheet || {};
    const tsfin = details.tsfin     || {};

    const sheetScope = (details.sheet_scope ||
                        baseRow.sheet_scope ||
                        ts.sheet_scope ||
                        sheetScopeRaw ||
                        '').toUpperCase();

    const subMode    = ((ts.submission_mode ||
                         baseRow.submission_mode ||
                         subModeRaw ||
                         '')).toUpperCase();

    const isWeeklyManualContext =
      sheetScope === 'WEEKLY' &&
      (subMode === 'MANUAL' || (isPlannedWeek && !hasTs));

    const initialReference = ts.reference_number || baseRow.reference_number || '';

    let manualHours = {};
    if (isWeeklyManualContext && tsfin && (tsfin.hours_day != null ||
                                           tsfin.hours_night != null ||
                                           tsfin.hours_sat != null ||
                                           tsfin.hours_sun != null ||
                                           tsfin.hours_bh != null)) {
      manualHours = {
        day:   Number(tsfin.hours_day   ?? 0),
        night: Number(tsfin.hours_night ?? 0),
        sat:   Number(tsfin.hours_sat   ?? 0),
        sun:   Number(tsfin.hours_sun   ?? 0),
        bh:    Number(tsfin.hours_bh    ?? 0)
      };
    }

    // â”€â”€ Seed additionalRates (unchanged) â”€â”€
    let additionalRates = {};
    try {
      let units = tsfin.additional_units_json;
      if (!units && tsfin.invoice_breakdown_json && typeof tsfin.invoice_breakdown_json === 'object') {
        units = tsfin.invoice_breakdown_json.additional &&
                tsfin.invoice_breakdown_json.additional.units;
      }
      if (typeof units === 'string') {
        try { units = JSON.parse(units); } catch { units = {}; }
      }
      if (!units || typeof units !== 'object') units = {};

      let cfgArr = related && related.contract && related.contract.additional_rates_json;
      if (typeof cfgArr === 'string') {
        try { cfgArr = JSON.parse(cfgArr); } catch { cfgArr = []; }
      }
      if (!Array.isArray(cfgArr)) cfgArr = [];

      const codes = new Set();
      Object.keys(units || {}).forEach(k => {
        if (!k) return;
        codes.add(String(k).toUpperCase());
      });
      cfgArr.forEach(cfg => {
        if (!cfg || !cfg.code) return;
        codes.add(String(cfg.code).toUpperCase());
      });

      codes.forEach(code => {
        const cfg = cfgArr.find(c => c && String(c.code).toUpperCase() === code) || {};
        let existing = units[code];
        if (!existing) {
          const matchKey = Object.keys(units || {}).find(k => String(k).toUpperCase() === code);
          if (matchKey) existing = units[matchKey];
        }
        existing = existing || {};

        additionalRates[code] = {
          code,
          bucket_name: existing.bucket_name ?? cfg.bucket_name ?? null,
          unit_name:   existing.unit_name   ?? cfg.unit_name   ?? null,
          frequency:   existing.frequency   ?? cfg.frequency   ?? null,
          units_week:  existing.unit_count  ?? 0,
          pay_rate:    existing.pay_rate    ?? cfg.pay_rate    ?? null,
          charge_rate: existing.charge_rate ?? cfg.charge_rate ?? null
        };
      });

      if (LOGM) {
        L('additionalRates seeded', {
          codes: Object.keys(additionalRates),
          fromTsfin: !!tsfin.additional_units_json,
          fromContractCfg: Array.isArray(related?.contract?.additional_rates_json)
        });
      }
    } catch (e) {
      if (LOGM) L('additionalRates seed FAILED (non-fatal)', e);
      additionalRates = {};
    }

    // â”€â”€ Seed schedule from actual_schedule_json (existing TS) or planned std schedule (contract_week) â”€â”€
    let schedule = null;
    try {
      // Existing timesheet: prefer actual_schedule_json if present
      if (hasTs && ts.actual_schedule_json) {
        if (Array.isArray(ts.actual_schedule_json) || typeof ts.actual_schedule_json === 'object') {
          schedule = JSON.parse(JSON.stringify(ts.actual_schedule_json));
        } else if (typeof ts.actual_schedule_json === 'string') {
          try {
            const parsed = JSON.parse(ts.actual_schedule_json);
            if (Array.isArray(parsed) || typeof parsed === 'object') {
              schedule = parsed;
            }
          } catch {
            // ignore parse error
          }
        }
      }
      // Planned week (no TS yet): fall back to contract_week.planned_schedule_json or std_schedule_json
      if (!hasTs && !schedule && details && details.contract_week) {
        const cw = details.contract_week;
        const src =
          cw.planned_schedule_json != null
            ? cw.planned_schedule_json
            : cw.std_schedule_json != null
            ? cw.std_schedule_json
            : null;

        if (src) {
          if (Array.isArray(src) || typeof src === 'object') {
            schedule = JSON.parse(JSON.stringify(src));
          } else if (typeof src === 'string') {
            try {
              const parsedStd = JSON.parse(src);
              if (Array.isArray(parsedStd) || typeof parsedStd === 'object') {
                schedule = parsedStd;
              }
            } catch {
              // ignore parse error
            }
          }
        }
      }
    } catch (e) {
      if (LOGM) L('schedule seed FAILED (non-fatal)', e);
      schedule = null;
    }

    // â”€â”€ NEW: Seed per-day references (dayReferences) for weekly Lines tab â”€â”€
    let dayReferences = {};
    try {
      const tsDayRefs = ts && ts.day_references_json && typeof ts.day_references_json === 'object'
        ? ts.day_references_json
        : null;
      if (tsDayRefs) {
        dayReferences = { ...tsDayRefs };
      }
    } catch {
      dayReferences = {};
    }

    // If still empty, seed from TSFIN external_source_rows_json.HR_WEEKLY / NHSP_WEEKLY
    try {
      if (!Object.keys(dayReferences).length && tsfin && tsfin.external_source_rows_json) {
        const ext      = tsfin.external_source_rows_json || {};
        const hrRows   = Array.isArray(ext.HR_WEEKLY)   ? ext.HR_WEEKLY   : [];
        const nhspRows = Array.isArray(ext.NHSP_WEEKLY) ? ext.NHSP_WEEKLY : [];
        [...hrRows, ...nhspRows].forEach(row => {
          const date = row && row.date;
          const ref  = row && row.reference;
          if (date && ref && !dayReferences[date]) {
            dayReferences[date] = ref;
          }
        });
      }
    } catch (e) {
      if (LOGM) L('dayReferences seed FAILED (non-fatal)', e);
      dayReferences = dayReferences || {};
    }

    // Simple meta flags for downstream gating (delete, revert, etc.)
    const isPaid     = !!tsfin.paid_at_utc;
    const isInvoiced = !!tsfin.locked_by_invoice_id;
    const canDeletePerm = !!(hasTs && !isPaid && !isInvoiced);

    // Contract-week meta for actions on planned/open weeks
    const cwId =
      details.contract_week_id ||
      (details.contract_week && details.contract_week.id) ||
      baseRow.contract_week_id ||
      null;

    const cwSubSnapRaw =
      (details.contract_week && details.contract_week.submission_mode_snapshot) ||
      baseRow.submission_mode ||
      '';
    const cwSubSnap = String(cwSubSnapRaw || '').toUpperCase();

    window.modalCtx = {
      ...(window.modalCtx || {}),
      entity: 'timesheets',
      // Existing TS â†’ view, planned week â†’ edit (actual modal frame mode is decided in showModal)
      mode: hasTs ? 'view' : 'edit',
      data: {
        ...baseRow,
        timesheet_id: tsId || null,
        contract_week_id: weekId || baseRow.contract_week_id || null
      },
      timesheetDetails: details,
      timesheetRelated: related,
      timesheetState: {
        reference:        initialReference,
        payHoldDesired:   null,
        payHoldReason:    '',
        markPaid:         false,
        segmentOverrides: {},
        segmentInvoiceTargets: {},
        manualHours,
        additionalRates,
        schedule,          // schedule state seeded from TS or planned std schedule
        dayReferences,     // NEW: per-day references for weekly Lines tab
        evidence           // NEW: evidence list for Evidence tab
      },
      timesheetMeta: {
        hasTs,
        isPlannedWeek,
        sheetScope,
        subMode,
        isPaid,
        isInvoiced,
        canDeletePermanently: canDeletePerm,
        contract_week_id: cwId,
        cw_submission_mode_snapshot: cwSubSnap
      }
    };

    L('modalCtx seeded', {
      entity: window.modalCtx.entity,
      mode: window.modalCtx.mode,
      dataId: window.modalCtx.data?.id,
      hasDetails: !!window.modalCtx.timesheetDetails,
      hasRelated: !!window.modalCtx.timesheetRelated,
      additionalRateCodes: Object.keys(window.modalCtx.timesheetState.additionalRates || {}),
      manualHours: window.modalCtx.timesheetState.manualHours,
      hasSchedule: !!window.modalCtx.timesheetState.schedule,
      dayReferencesKeys: Object.keys(window.modalCtx.timesheetState.dayReferences || {}),
      evidenceCount: (window.modalCtx.timesheetState.evidence || []).length,
      timesheetMeta: window.modalCtx.timesheetMeta || null
    });

    const tabDefs = [
      { key: 'overview', title: 'Overview' },
      { key: 'lines',    title: 'Lines' },
      { key: 'evidence', title: 'Evidence' },
      { key: 'issues',   title: 'Issues' },
      { key: 'related',  title: 'Related' },
      { key: 'finance',  title: 'Finance' }
    ];

    const renderTab = (key, mergedRow) => {
      const ctxForTab = {
        row: mergedRow || window.modalCtx.data || baseRow,
        details: window.modalCtx.timesheetDetails || details,
        related: window.modalCtx.timesheetRelated || related,
        state: window.modalCtx.timesheetState
      };

      if (LOGM) {
        L('renderTab', {
          key,
          rowId: ctxForTab.row && ctxForTab.row.timesheet_id,
          hasDetails: !!ctxForTab.details,
          hasRelated: !!ctxForTab.related
        });
      }

      switch (key) {
        case 'overview':
          return renderTimesheetOverviewTab(ctxForTab);
        case 'lines':
          return renderTimesheetLinesTab(ctxForTab);
        case 'evidence':
          return renderTimesheetEvidenceTab(ctxForTab);
        case 'issues':
          return renderTimesheetIssuesTab(ctxForTab);
        case 'related':
          return renderTimesheetRelatedTab(ctxForTab);
        case 'finance':
          return renderTimesheetFinanceTab(ctxForTab);
        default:
          return `<div class="tabc"><div class="card"><div class="row"><label>Timesheet</label><div class="controls"><span class="mini">Unknown tab: ${key}</span></div></div></div></div>`;
      }
    };

    const onSaveTimesheet = async () => {
      const { LOGM, L, GC, GE } = getTsLoggers('[TS][SAVE]');
      GC('onSaveTimesheet');

      const mc     = window.modalCtx || {};
      const rowNow = mc.data || baseRow;
      const det    = mc.timesheetDetails || details;
      const st     = mc.timesheetState || {};

      // NEW: QR-on-save flags (set by saveForFrame tri-choice)
      const revokeQr  = !!mc._revokeQrOnSave;
      const reissueQr = !!mc._reissueQrOnSave;

      const segOverrides    = st.segmentOverrides || {};
      const hasSegOverrides = !!Object.keys(segOverrides).length;

      const tsLocal    = det.timesheet || {};
      const tsfinLocal = det.tsfin     || {};

      const currentRef = tsLocal.reference_number || rowNow.reference_number || '';
      const stagedRef  = (st.reference != null) ? st.reference : currentRef;
      const refChanged = stagedRef !== currentRef;

      const sheetScopeSave = (det.sheet_scope ||
                          rowNow.sheet_scope ||
                          tsLocal.sheet_scope ||
                          '').toUpperCase();
      const subModeSave    = (tsLocal.submission_mode ||
                          rowNow.submission_mode ||
                          '').toUpperCase();

      const weekIdSave     = rowNow.contract_week_id || det.contract_week_id || null;

      // Treat BOTH true manual weeks and planned weekly weeks (no TS yet) as "weekly manual context"
      const isPlannedWeeklyWithoutTs =
        sheetScopeSave === 'WEEKLY' &&
        !!weekIdSave &&
        !tsLocal.timesheet_id;

      const isWeeklyManualContext =
        sheetScopeSave === 'WEEKLY' &&
        !!weekIdSave &&
        (subModeSave === 'MANUAL' || isPlannedWeeklyWithoutTs);

      // DAILY MANUAL context â€“ editable daily TS in MANUAL mode
      const isDailyManualContext =
        sheetScopeSave === 'DAILY' &&
        subModeSave === 'MANUAL' &&
        !!tsLocal.timesheet_id;

      const manualHours = st.manualHours || {};
      const hasManualHours =
        manualHours &&
        ['day', 'night', 'sat', 'sun', 'bh'].some(
          k => manualHours[k] != null && manualHours[k] !== ''
        );

      const extrasMap        = st.additionalRates || {};
      const hasExtrasStaged  = extrasMap &&
        Object.values(extrasMap).some(r => r && Number(r.units_week || 0) !== 0);

      const segTargets = st.segmentInvoiceTargets || {};
      const hasSegTargets = !!Object.keys(segTargets).length;

      // Staged pay-hold + mark-paid
      const currentOnHold    = !!tsfinLocal.pay_on_hold;
      const payHoldDesired   =
        (st.payHoldDesired === true || st.payHoldDesired === false)
          ? st.payHoldDesired
          : null;
      const payHoldReason    = st.payHoldReason || '';
      const shouldChangeHold =
        (payHoldDesired === true  && !currentOnHold) ||
        (payHoldDesired === false &&  currentOnHold);

      const alreadyPaid      = !!tsfinLocal.paid_at_utc;
      const wantsMarkPaid    = !!st.markPaid;
      const shouldMarkPaid   = wantsMarkPaid && !alreadyPaid;

      L('staged state', {
        tsId,
        weekIdSave,
        sheetScopeSave,
        subModeSave,
        isWeeklyManualContext,
        hasManualHours,
        hasExtrasStaged,
        hasSegOverrides,
        segOverridesKeys: Object.keys(segOverrides),
        hasSegTargets,
        segTargetKeys: Object.keys(segTargets),
        currentRef,
        stagedRef,
        refChanged,
        currentOnHold,
        payHoldDesired,
        payHoldReason,
        shouldChangeHold,
        alreadyPaid,
        wantsMarkPaid,
        shouldMarkPaid
      });

      const tasks = [];

     // 5a) Weekly MANUAL hours + additional units â†’ contract-week manual upsert
if (isWeeklyManualContext && (hasManualHours || hasExtrasStaged)) {
  tasks.push(async () => {
    const payload = {
      hours: {
        day:   Number(manualHours.day   || 0) || 0,
        night: Number(manualHours.night || 0) || 0,
        sat:   Number(manualHours.sat   || 0) || 0,
        sun:   Number(manualHours.sun   || 0) || 0,
        bh:    Number(manualHours.bh    || 0) || 0
      },
      additional_units_week: {},

      // NEW: per-day NHSP/HR references for this week
      day_references_json: st.dayReferences || {},

      // QR revoke/reissue hints to backend (weekly)
      revoke_qr:  revokeQr,
      reissue_qr: reissueQr
    };

    Object.entries(extrasMap || {}).forEach(([code, r]) => {
      if (!r) return;
      const u = Number(r.units_week || 0);
      if (!Number.isFinite(u)) return;
      payload.additional_units_week[code] = u;
    });

    L('manual weekly upsert payload', { weekIdSave, payload });
    const result = await manualUpsertContractWeek(weekIdSave, payload);

          const newTsId = result.timesheet_id || tsId;
          if (!tsId && newTsId) {
            // Planned week â†’ newly created TS
            window.modalCtx.data = {
              ...(window.modalCtx.data || rowNow),
              timesheet_id: newTsId,
              id: newTsId
            };
          }

          const finalTsId = newTsId || tsId;
          if (finalTsId) {
            try {
              const freshDetails = await fetchTimesheetDetails(finalTsId);
              window.modalCtx.timesheetDetails = freshDetails;
            } catch (err) {
              L('refresh details after manual upsert failed (non-fatal)', err);
            }
          }
        });
      }

      // 5a-daily) DAILY MANUAL â€“ update worked/break + QR hints
      if (isDailyManualContext && tsId) {
        tasks.push(async () => {
          // We send the schedule blob; backend daily-manual-upsert will
          // resolve it into worked_start/end + breaks and rebuild TSFIN.
          const schedule = st.schedule || tsLocal.actual_schedule_json || null;

          if (!schedule) {
            L('daily-manual-upsert skipped: no schedule staged');
            return;
          }

          const payload = {
            schedule_json: schedule,
            revoke_qr:  revokeQr,
            reissue_qr: reissueQr
          };

          L('daily manual upsert payload', { tsId, payload });

          await apiPostJson(
            `/api/timesheets/${encodeURIComponent(tsId)}/daily-manual-upsert`,
            payload
          );

          // Reload details so TSFIN + QR fields reflect the new hours
          try {
            const freshDetails = await fetchTimesheetDetails(tsId);
            window.modalCtx.timesheetDetails = freshDetails;
          } catch (err) {
            L('refresh details after daily-manual-upsert failed (non-fatal)', err);
          }
        });
      }

      // 5b) Apply segment exclude_from_pay + invoice_target_week_start (SEGMENTS mode only)
      if (det.isSegmentsMode && (hasSegOverrides || hasSegTargets) && (tsId || rowNow.timesheet_id)) {
        tasks.push(async () => {
          const currentDetails = window.modalCtx.timesheetDetails || det;
          const segments = Array.isArray(currentDetails.segments) ? currentDetails.segments : [];
          if (!segments.length) return;

          const updates = [];
          const overrides = window.modalCtx.timesheetState.segmentOverrides || {};
          const targets   = window.modalCtx.timesheetState.segmentInvoiceTargets || {};

          for (const seg of segments) {
            if (!seg || typeof seg !== 'object') continue;
            const sid = String(seg.segment_id || '').trim();
            if (!sid) continue;

            const o = overrides[sid] || {};
            const hasOverride = Object.prototype.hasOwnProperty.call(o, 'exclude_from_pay');
            const exclude = hasOverride ? !!o.exclude_from_pay : !!seg.exclude_from_pay;

            const originalTarget = seg.invoice_target_week_start || null;
            const stagedTarget   = targets[sid] || originalTarget || null;

            const update = { segment_id: sid };
            let changed = false;

            if (exclude !== !!seg.exclude_from_pay) {
              update.exclude_from_pay = exclude;
              changed = true;
            } else {
              // still send explicit exclude flag so backend recomputes totals coherently
              update.exclude_from_pay = exclude;
            }

            if (stagedTarget && stagedTarget !== originalTarget) {
              update.invoice_target_week_start = stagedTarget;
              changed = true;
            }

            if (changed) {
              updates.push(update);
            }
          }

          if (!updates.length) return;

          L('segment updates', { count: updates.length });

          await apiPatchJson(
            `/api/tsfin/${encodeURIComponent(tsId || rowNow.timesheet_id)}/segments`,
            { segments: updates }
          );
        });
      }

      // 5c) Apply reference/PO update if changed
      if (refChanged && tsId) {
        tasks.push(async () => {
          await updateTimesheetReference(tsId, stagedRef);
        });
      }

      // 5e) Apply pay hold change (staged)
      if (shouldChangeHold && tsId) {
        tasks.push(async () => {
          const onHold = !!payHoldDesired;
          const reason = onHold ? payHoldReason : '';
          await toggleTimesheetPayHold(tsId, onHold, reason);
        });
      }

      // 5f) Apply mark paid (staged)
      if (shouldMarkPaid && tsId) {
        tasks.push(async () => {
          await markTimesheetPaid(tsId);
        });
      }

      if (!tasks.length) {
        L('no staged changes to apply; no-op');
        GE();
        return { ok: true, saved: rowNow };
      }

      for (let i = 0; i < tasks.length; i++) {
        try {
          await tasks[i]();
        } catch (err) {
          L('task failed', { index: i, error: err });
          GE();
          alert(err?.message || 'Failed to save timesheet changes. No changes were fully applied.');
          return { ok: false };
        }
      }

      // After helpers, details & timesheetState should already be updated
      const newDetails = window.modalCtx.timesheetDetails || det;
      const newTsfin   = newDetails.tsfin || {};
      const newTs      = newDetails.timesheet || {};
      const finalTsId  = newTs.timesheet_id || tsId || rowNow.timesheet_id;

      const updatedRow = {
        ...(window.modalCtx.data || rowNow),
        timesheet_id:         finalTsId || null,
        total_pay_ex_vat:     newTsfin.total_pay_ex_vat     ?? rowNow.total_pay_ex_vat,
        total_charge_ex_vat:  newTsfin.total_charge_ex_vat  ?? rowNow.total_charge_ex_vat,
        margin_ex_vat:        newTsfin.margin_ex_vat        ?? rowNow.margin_ex_vat,
        pay_on_hold:          newTsfin.pay_on_hold          ?? rowNow.pay_on_hold,
        paid_at_utc:          newTsfin.paid_at_utc          ?? rowNow.paid_at_utc,
        locked_by_invoice_id: newTsfin.locked_by_invoice_id ?? rowNow.locked_by_invoice_id,
        reference_number:     newTs.reference_number        ?? rowNow.reference_number,
        id:                   finalTsId || rowNow.id
      };

      // NEW: clear QR-on-save flags after a successful save
      if (window.modalCtx) {
        window.modalCtx._revokeQrOnSave  = false;
        window.modalCtx._reissueQrOnSave = false;
      }

      window.modalCtx.data = updatedRow;

      // Clear staged segment state after successful save
      if (window.modalCtx.timesheetState) {
        window.modalCtx.timesheetState.segmentOverrides      = {};
        window.modalCtx.timesheetState.segmentInvoiceTargets = {};
        window.modalCtx.timesheetState.reference             = updatedRow.reference_number;
        window.modalCtx.timesheetState.payHoldDesired        = null;
        window.modalCtx.timesheetState.payHoldReason         = '';
        window.modalCtx.timesheetState.markPaid              = false;
        // manualHours / additionalRates / schedule / dayReferences / evidence remain staged for the next edit session
      }

      // Focus this TS in summary grid on next refresh
      try {
        if (finalTsId) {
          window.__pendingFocus = {
            section: 'timesheets',
            ids: [String(finalTsId)],
            primaryIds: [String(finalTsId)]
          };
        }
      } catch {}

      L('SAVE OK, updatedRow', { id: updatedRow.id });
      GE();
      return { ok: true, saved: updatedRow };
    };

    const title = hasTs
      ? `Timesheet ${String(tsId).slice(0, 8)}â€¦`
      : `Weekly timesheet (planned) ${String(weekId).slice(0, 8)}â€¦`;

    // hasId should also be true for planned weeks (contract_week exists)
    const hasRecordId = !!(hasTs || isPlannedWeek);

    showModal(
      title,
      tabDefs,
      renderTab,
      onSaveTimesheet,
      hasRecordId,        // â¬…ï¸ now true for planned weeks as well
      undefined,
      { kind: 'timesheets' }
    );

    GE();
  } catch (err) {
    if ((typeof window.__LOG_MODAL === 'boolean') ? window.__LOG_MODAL : false) {
      console.error('[TS][OPEN] EXCEPTION', err);
    }
    alert(err?.message || 'Failed to open timesheet.');
    GE();
  }
}


function renderTimesheetRelatedTab(ctx) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][RELATED-TAB]');
  const { row, related } = normaliseTimesheetCtx(ctx);

  GC('render');
  L('snapshot', {
    tsId: row.timesheet_id,
    counts: related.counts
  });
  GE();

  const candidate = related.candidate;
  const client    = related.client;
  const invoice   = related.invoice;
  const umbrella  = related.umbrella;
  const contract  = related.contract;
  const series    = Array.isArray(related.series) ? related.series : [];

  const renderBlock = (title, bodyHtml) => `
    <div class="card" style="margin-top:10px;">
      <div class="row">
        <label>${title}</label>
        <div class="controls">
          ${bodyHtml}
        </div>
      </div>
    </div>
  `;

  const candidateHtml = candidate
    ? `
      <div>
        <div>${candidate.display_name || '(no name)'}</div>
        <div class="mini">${candidate.email || ''}</div>
        <button type="button" data-ts-related="candidate" data-id="${candidate.id}">Open candidate</button>
      </div>
    `
    : '<span class="mini">No candidate linked.</span>';

  const clientHtml = client
    ? `
      <div>
        <div>${client.name || '(no name)'}</div>
        <div class="mini">${client.cli_ref ? 'Client ref: ' + client.cli_ref : ''}</div>
        <button type="button" data-ts-related="client" data-id="${client.id}">Open client</button>
      </div>
    `
    : '<span class="mini">No client linked.</span>';

  const contractHtml = contract
    ? `
      <div>
        <div>${contract.role || ''}${contract.band ? ' (Band ' + contract.band + ')' : ''}</div>
        <div class="mini">
          ${contract.display_site || ''}<br/>
          ${contract.start_date || ''} â†’ ${contract.end_date || ''}
        </div>
        <button type="button" data-ts-related="contract" data-id="${contract.id}">Open contract</button>
      </div>
    `
    : '<span class="mini">No contract linked for this timesheet.</span>';

  const invoiceHtml = invoice
    ? `
      <div>
        <div>Invoice ${invoice.invoice_no || invoice.invoice_id}</div>
        <div class="mini">
          Status: ${invoice.status || 'UNKNOWN'}<br/>
          Issued: ${invoice.issued_at_utc || 'â€”'}<br/>
          Total inc VAT: ${invoice.total_inc_vat != null ? invoice.total_inc_vat : 'â€”'}
        </div>
        <button type="button" data-ts-related="invoice" data-id="${invoice.invoice_id}">Open invoice</button>
      </div>
    `
    : '<span class="mini">No invoice currently linked.</span>';

  const umbrellaHtml = umbrella
    ? `
      <div>
        <div>${umbrella.name || '(no name)'}</div>
        <button type="button" data-ts-related="umbrella" data-id="${umbrella.id}">Open umbrella</button>
      </div>
    `
    : '<span class="mini">No umbrella linked (PAYE or no umbrella).</span>';

  const seriesHtml = series.length
    ? `
      <table class="grid mini">
        <thead>
          <tr>
            <th>TS ID</th>
            <th>Seq</th>
            <th>Adj?</th>
            <th>Status</th>
            <th>Basis</th>
            <th>Hours</th>
            <th>Pay ex VAT</th>
            <th></th>
          </tr>
        </thead>
        <tbody>
          ${series.map(s => `
            <tr data-timesheet-id="${s.timesheet_id}">
              <td>${s.timesheet_id.slice(0, 8)}â€¦${s.is_current ? ' <span class="mini">(current)</span>' : ''}</td>
              <td>${s.additional_seq == null ? '0' : s.additional_seq}</td>
              <td>${s.is_adjustment ? 'Yes' : 'No'}</td>
              <td>${s.processing_status || 'â€”'}</td>
              <td>${s.basis || 'â€”'}</td>
              <td>${s.total_hours != null ? s.total_hours : 'â€”'}</td>
              <td>${s.total_pay_ex_vat != null ? s.total_pay_ex_vat : 'â€”'}</td>
              <td>
                <button type="button"
                  data-ts-related="series-timesheet"
                  data-id="${s.timesheet_id}">
                  Open
                </button>
              </td>
            </tr>
          `).join('')}
        </tbody>
      </table>
    `
    : '<span class="mini">No other timesheets in this contract/week series.</span>';

  return `
    <div class="tabc">
      ${renderBlock('Candidate', candidateHtml)}
      ${renderBlock('Client', clientHtml)}
      ${renderBlock('Contract', contractHtml)}
      ${renderBlock('Invoice', invoiceHtml)}
      ${renderBlock('Umbrella', umbrellaHtml)}
      ${renderBlock('Series (base + adjustments)', seriesHtml)}
    </div>
  `;
}

function renderTimesheetEvidenceTab(ctx) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][EVIDENCE]');
  const { row, details, state } = normaliseTimesheetCtx(ctx);

  GC('render');
  const ts         = details.timesheet || {};
  const sheetScope = row.sheet_scope || details.sheet_scope || ts.sheet_scope || null;
  const qrStatus   = row.qr_status || details.qr_status || ts.qr_status || null;
  const qrGen      = details.qr_generated_at || ts.qr_generated_at || null;
  const qrScan     = details.qr_scanned_at   || ts.qr_scanned_at   || null;
  const manualKey  = details.manual_pdf_r2_key || ts.manual_pdf_r2_key || null;

  const tsId = row.timesheet_id || ts.timesheet_id || '';

  // Evidence state â€“ populated by the tab open handler via /api/timesheets/:id/evidence
  const evList = Array.isArray(state.evidence) ? state.evidence : [];

  L('snapshot', {
    tsId,
    sheetScope,
    qrStatus,
    qrGen,
    qrScan,
    manualKey,
    evidenceCount: evList.length
  });
  GE();

  const qrInfoHtml = (sheetScope === 'WEEKLY' && qrStatus) ? `
    <div class="card" style="margin-top:10px;">
      <div class="row">
        <label>QR status</label>
        <div class="controls">
          <span class="mini">${qrStatus}</span>
          ${qrGen ? `<br/><span class="mini">Generated at: ${qrGen}</span>` : ''}
          ${qrScan ? `<br/><span class="mini">Scanned at: ${qrScan}</span>` : ''}
        </div>
      </div>
    </div>
  ` : '';

  // Base URL for public R2 access (configured globally)
  const r2Base = (window && (window.R2_PUBLIC_URL || (window.__config && window.__config.R2_PUBLIC_URL))) || '';

  const evidenceListHtml = evList.length
    ? `
      <ul class="ts-evidence-list">
        ${evList.map(ev => {
          const name = escapeHtml(ev.display_name || ev.kind || 'Evidence');
          const key  = ev.storage_key || '';
          const href = (r2Base && key)
            ? `${r2Base}/${encodeURIComponent(key)}`
            : '#';
          const id   = ev.id || '';
          return `
            <li data-evidence-id="${escapeHtml(String(id))}">
              <span class="mini">${name}</span>
              ${key ? ` â€“ <a href="${href}" target="_blank" rel="noopener noreferrer">Open</a>` : ''}
              <button type="button"
                      class="btn mini"
                      data-evidence-remove="${escapeHtml(String(id))}">
                Remove
              </button>
            </li>
          `;
        }).join('')}
      </ul>
    `
    : `
      <span class="mini">
        No evidence uploaded yet. Use the dropzone below to add scanned timesheets or other supporting documents.
      </span>
    `;

  const dropHint = evList.length
    ? 'Drag a PDF or image here to add further evidence. Existing files will remain attached.'
    : 'Drag a PDF or image here to upload your first evidence file (e.g. a scanned timesheet).';

  return `
    <div class="tabc">
      <div class="card">
        <div class="row">
          <label>Timesheet PDF</label>
          <div class="controls">
            <button type="button" data-ts-action="open-pdf" data-timesheet-id="${tsId}">
              Open timesheet PDF
            </button>
            <span class="mini" style="margin-left:8px;">
              This will call /api/timesheets/${tsId || ':id'}/pdf and open the resulting document.
            </span>
          </div>
        </div>
        <div class="row">
          <label>Manual scan key</label>
          <div class="controls">
            ${manualKey ? `<span class="mini">${manualKey}</span>` : '<span class="mini">No manual PDF attached (legacy field).</span>'}
            <span class="mini" style="display:block;margin-top:4px;">
              New uploads are recorded as evidence items below; this field remains for legacy compatibility.
            </span>
          </div>
        </div>
      </div>

      <div class="card" style="margin-top:10px;">
        <div class="row">
          <label>Evidence</label>
          <div class="controls">
            ${evidenceListHtml}
          </div>
        </div>
      </div>

      <div class="card" style="margin-top:10px;" data-ts-drop-zone="evidence">
        <div class="row">
          <label>Add evidence</label>
          <div class="controls">
            <div class="mini">
              ${dropHint}<br/>
              <span class="mini">Accepted file types: PDF, JPEG, PNG, HEIC/HEIF.</span>
            </div>
          </div>
        </div>
      </div>

      ${qrInfoHtml}
    </div>
  `;
}

async function getTimesheetPdfUrl(timesheetId) {
  const LOGM = (typeof window.__LOG_MODAL === 'boolean') ? window.__LOG_MODAL : false;
  const L    = (...a) => { if (LOGM) console.log('[TS][PDF][GET]', ...a); };
  const GC   = (label) => { if (LOGM) console.groupCollapsed('[TS][PDF][GET]', label); };
  const GE   = () => { if (LOGM) console.groupEnd(); };

  if (!timesheetId) {
    throw new Error('getTimesheetPdfUrl: timesheetId is required');
  }

  GC('getTimesheetPdfUrl');
  L('START', { timesheetId });

  const encId = encodeURIComponent(timesheetId);
  const pdfMetaUrl = API(`/api/timesheets/${encId}/pdf`);

  let pdfMeta;
  try {
    const res = await authFetch(pdfMetaUrl);
    const text = await res.text();
    if (!res.ok) {
      L('timesheet pdf meta failed', { status: res.status, bodyPreview: text.slice(0, 400) });
      GE();
      return null;
    }
    pdfMeta = text ? JSON.parse(text) : {};
  } catch (err) {
    L('meta fetch error', err);
    GE();
    return null;
  }

  const r2Key = pdfMeta.r2_key || pdfMeta.key || pdfMeta.manual_pdf_r2_key || null;
  if (!r2Key) {
    L('no r2_key in pdfMeta', pdfMeta);
    GE();
    return null;
  }

  L('meta resolved', { r2Key, rotation_degrees: pdfMeta.rotation_degrees });

  // Ask files API for a presigned download URL
  const presignUrl = API(`/api/files/presign-download`);
  let signed;
  try {
    const res = await authFetch(presignUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ key: r2Key })
    });
    const text = await res.text();
    if (!res.ok) {
      L('presign-download failed', { status: res.status, bodyPreview: text.slice(0, 400) });
      GE();
      return null;
    }
    signed = text ? JSON.parse(text) : {};
  } catch (err) {
    L('presign error', err);
    GE();
    return null;
  }

  const url = signed.url || signed.signed_url || null;
  if (!url) {
    L('no URL in presign response', signed);
    GE();
    return null;
  }

  L('RESOLVE OK', { url });
  GE();
  return {
    url,
    r2_key: r2Key,
    rotation_degrees: pdfMeta.rotation_degrees ?? 0,
    meta: pdfMeta
  };
}

async function openTimesheetPdf(timesheetId) {
  const LOGM = (typeof window.__LOG_MODAL === 'boolean') ? window.__LOG_MODAL : false;
  const L    = (...a) => { if (LOGM) console.log('[TS][PDF]', ...a); };
  const GC   = (label) => { if (LOGM) console.groupCollapsed('[TS][PDF]', label); };
  const GE   = () => { if (LOGM) console.groupEnd(); };

  if (!timesheetId) {
    throw new Error('openTimesheetPdf: timesheetId is required');
  }

  GC('openTimesheetPdf');
  L('START', { timesheetId });

  const info = await getTimesheetPdfUrl(timesheetId).catch(err => {
    L('getTimesheetPdfUrl failed', err);
    return null;
  });

  if (!info || !info.url) {
    GE();
    alert('No PDF is available for this timesheet yet.');
    return;
  }

  L('opening window', { url: info.url });
  GE();
  try {
    window.open(info.url, '_blank', 'noopener');
  } catch (err) {
    if (LOGM) console.warn('[TS][PDF] window.open failed', err);
    alert('Unable to open PDF window. Please check your popup blocker.');
  }
}

async function openTimesheetEvidenceReplaceDialog(file) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][EVIDENCE][DIALOG]');
  GC('openTimesheetEvidenceReplaceDialog');

  const mc = window.modalCtx || {};
  const tsId   = mc.data?.timesheet_id || mc.data?.id || null;
  const weekId = mc.data?.contract_week_id || mc.timesheetDetails?.contract_week_id || null;

  if (!tsId) {
    GE();
    throw new Error('Timesheet context missing; cannot replace evidence.');
  }
  if (!file) {
    GE();
    throw new Error('File is required for evidence replacement dialog.');
  }

  L('ENTRY', {
    tsId,
    weekId,
    name: file.name,
    type: file.type,
    size: file.size
  });

  // 1) Determine whether there is CURRENT evidence via getTimesheetPdfUrl
  const current = await getTimesheetPdfUrl(tsId);
  const hasCurrent = !!(current && current.url);
  const currentUrl = hasCurrent ? current.url : null;

  // 2) Blob URL for NEW file
  const newUrl = URL.createObjectURL(file);

  const isReplacement = !!hasCurrent;
  const title = isReplacement
    ? `Replace timesheet evidence ${String(tsId).slice(0, 8)}â€¦`
    : `Upload timesheet evidence ${String(tsId).slice(0, 8)}â€¦`;

  const bodyHtml = (() => {
    if (isReplacement && currentUrl) {
      // CURRENT vs NEW side-by-side
      return `
        <div class="tabc">
          <div class="card">
            <div class="row">
              <label>Compare</label>
              <div class="controls">
                <div style="display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:10px;max-height:450px;overflow:auto;">
                  <div>
                    <div class="mini" style="margin-bottom:4px;">CURRENT</div>
                    <iframe
                      src="${currentUrl}"
                      style="width:100%;height:380px;border:1px solid var(--line);border-radius:8px;background:#000;"
                    ></iframe>
                  </div>
                  <div>
                    <div class="mini" style="margin-bottom:4px;">NEW</div>
                    <iframe
                      src="${newUrl}"
                      style="width:100%;height:380px;border:1px solid var(--line);border-radius:8px;background:#000;"
                    ></iframe>
                  </div>
                </div>
                <div class="mini" style="margin-top:8px;">
                  Confirm to replace the existing scan for this timesheet with the new file.
                </div>
              </div>
            </div>
          </div>
        </div>
      `;
    }

    // FIRST UPLOAD: NEW only
    return `
      <div class="tabc">
        <div class="card">
          <div class="row">
            <label>Preview</label>
            <div class="controls">
              <iframe
                src="${newUrl}"
                style="width:100%;height:400px;border:1px solid var(--line);border-radius:8px;background:#000;"
              ></iframe>
            </div>
          </div>
          <div class="row">
            <label></label>
            <div class="controls">
              <span class="mini">
                No existing timesheet scan is on file. Confirm to upload this file as the current evidence.
              </span>
            </div>
          </div>
        </div>
      </div>
    `;
  })();

  const tabs = [{ key: 'compare', title: 'Evidence' }];

 const onSave = async () => {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][EVIDENCE][DIALOG][SAVE]');
  GC('onSave (evidence replace)');

  try {
    const encTsId = encodeURIComponent(tsId);

    // 1) Upload evidence (timesheet-level) or legacy contract-week replace
    await uploadTimesheetEvidence(tsId, weekId, file);

    // 2) Refresh evidence list so the Evidence tab shows the new items
    try {
      const res  = await authFetch(API(`/api/timesheets/${encTsId}/evidence`));
      const json = await res.json().catch(() => []);
      const evidence = Array.isArray(json) ? json : [];

      window.modalCtx = window.modalCtx || {};
      const st = (window.modalCtx.timesheetState ||= {});
      st.evidence = evidence;

      // If the main timesheet modal is currently on the Evidence tab, repaint it
      if (typeof window.__getModalFrame === 'function') {
        const fr = window.__getModalFrame();
        if (fr && fr.entity === 'timesheets' && fr.currentTabKey === 'evidence') {
          fr.setTab('evidence');
        }
      }
    } catch (err) {
      L('refresh evidence after upload failed (non-fatal)', err);
    }

    if (window.__toast) {
      window.__toast(isReplacement ? 'Timesheet scan replaced' : 'Timesheet scan uploaded');
    }

    GE();
    return { ok: true, saved: { timesheet_id: tsId } };
  } catch (err) {
    L('uploadTimesheetEvidence failed', err);
    alert(err?.message || 'Failed to update timesheet evidence.');
    GE();
    return { ok: false };
  }
};

  showModal(
    title,
    tabs,
    () => bodyHtml,
    onSave,
    false, // treat as a create/edit-only child frame so Save is visible
    undefined,
    {
      kind: 'timesheet-evidence-replace',
      noParentGate: true,
      forceEdit: true   // start in edit mode instead of view
    }
  );

  GE();
}
async function uploadTimesheetEvidence(timesheetId, contractWeekId, file) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][EVIDENCE][UPLOAD]');
  GC('uploadTimesheetEvidence');

  if (!timesheetId) {
    GE();
    throw new Error('uploadTimesheetEvidence: timesheetId is required');
  }
  if (!file) {
    GE();
    throw new Error('uploadTimesheetEvidence: file is required');
  }

  const enc = encodeURIComponent;
  const contentType = file.type || 'application/octet-stream';
  const filename    = file.name || 'timesheet-evidence';

  L('ENTRY', { timesheetId, contractWeekId, contentType, filename, size: file.size });

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Weekly manual path: use contract-week presign + replace
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // We keep this legacy path for existing weekly/manual flows that still rely on
  // contract_weeks.manual_pdf_r2_key. The Evidence tab itself now uses
  // /api/timesheets/:id/evidence; contract-week replace remains for compatibility.
  if (contractWeekId) {
    const weekEnc = enc(contractWeekId);

    // 1) Presign upload for this contract_week
    let presignJson;
    try {
      const res  = await authFetch(API(`/api/contract-weeks/${weekEnc}/presign-manual-pdf`), {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({})
      });
      const text = await res.text();
      if (!res.ok) {
        L('presign-manual-pdf failed', { status: res.status, bodyPreview: text.slice(0, 400) });
        throw new Error(text || 'Failed to presign manual PDF upload');
      }
      presignJson = text ? JSON.parse(text) : {};
    } catch (err) {
      L('presign-manual-pdf error', err);
      GE();
      throw err;
    }

    const uploadUrl = presignJson.upload_url || null;
    const r2Key     = presignJson.key || presignJson.r2_key || null;
    if (!uploadUrl || !r2Key) {
      GE();
      throw new Error('Presign response missing upload_url or key');
    }

    L('presign (contract-week) OK', { uploadUrl, r2Key });

    // 2) Upload file to R2
    try {
      const res = await fetch(uploadUrl, {
        method: 'PUT',
        headers: { 'Content-Type': contentType },
        body: file
      });
      if (!res.ok) {
        const text = await res.text().catch(() => '');
        L('contract-week upload failed', { status: res.status, bodyPreview: text.slice(0, 400) });
        throw new Error(text || 'Failed to upload manual PDF');
      }
    } catch (err) {
      L('contract-week upload error', err);
      GE();
      throw err;
    }

    // 3) Confirm replacement on the week (legacy manual_pdf_r2_key flow)
    try {
      const res  = await authFetch(API(`/api/contract-weeks/${weekEnc}/replace-manual-pdf`), {
        method: 'POST',
        headers: { 'Content-Type':'application/json' },
        body: JSON.stringify({ r2_key: r2Key })
      });
      const text = await res.text();
      if (!res.ok) {
        L('replace-manual-pdf failed', { status: res.status, bodyPreview: text.slice(0, 400) });
        throw new Error(text || 'Failed to update contract-week scan');
      }
    } catch (err) {
      L('replace-manual-pdf error', err);
      GE();
      throw err;
    }

    L('UPLOAD OK (contract-week)', { timesheetId, contractWeekId, r2Key });
    GE();
    return { ok: true, manual_pdf_r2_key: r2Key };
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Timesheet-level path: files presign + evidence POST
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let presignJson;
  try {
    const res  = await authFetch(API('/api/files/presign-upload'), {
      method: 'POST',
      headers: { 'Content-Type':'application/json' },
      body: JSON.stringify({
        content_type: contentType,
        filename
      })
    });
    const text = await res.text();
    if (!res.ok) {
      L('files presign-upload failed', { status: res.status, bodyPreview: text.slice(0, 400) });
      throw new Error(text || 'Failed to presign timesheet evidence upload');
    }
    presignJson = text ? JSON.parse(text) : {};
  } catch (err) {
    L('files presign-upload error', err);
    GE();
    throw err;
  }

  const uploadUrl = presignJson.upload_url || null;
  const fileKey   = presignJson.key || null;
  if (!uploadUrl || !fileKey) {
    GE();
    throw new Error('Presign-upload response missing upload_url or key');
  }

  L('presign (timesheet-level) OK', { uploadUrl, fileKey });

  // 2) Upload file to R2
  try {
    const res = await fetch(uploadUrl, {
      method: 'PUT',
      headers: { 'Content-Type': contentType },
      body: file
    });
    if (!res.ok) {
      const text = await res.text().catch(() => '');
      L('timesheet-level upload failed', { status: res.status, bodyPreview: text.slice(0, 400) });
      throw new Error(text || 'Failed to upload timesheet evidence');
    }
  } catch (err) {
    L('timesheet-level upload error', err);
    GE();
    throw err;
  }

  // 3) Create a timesheet_evidence row (new behaviour)
  try {
    const encTsId = enc(timesheetId);
    const res  = await authFetch(API(`/api/timesheets/${encTsId}/evidence`), {
      method: 'POST',
      headers: { 'Content-Type':'application/json' },
      body: JSON.stringify({
        kind: 'MANUAL_PDF',
        display_name: file.name || filename,
        storage_key: fileKey
      })
    });
    const text = await res.text();
    if (!res.ok) {
      L('timesheet evidence POST failed', { status: res.status, bodyPreview: text.slice(0, 400) });
      throw new Error(text || 'Failed to record timesheet evidence');
    }
  } catch (err) {
    L('timesheet evidence POST error', err);
    GE();
    throw err;
  }

  L('UPLOAD OK (timesheet-level, evidence)', { timesheetId, storage_key: fileKey });
  GE();
  return { ok: true, storage_key: fileKey };
}
async function handleTimesheetEvidenceRemoveClick(ev) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][EVIDENCE][REMOVE]');
  GC('handleTimesheetEvidenceRemoveClick');

  const btn = ev.target.closest('[data-evidence-remove]');
  if (!btn) {
    GE();
    return;
  }

  const eid = btn.dataset.evidenceRemove;
  if (!eid) {
    GE();
    return;
  }

  const mc = window.modalCtx || {};
  const tsId =
    mc.data?.timesheet_id ||
    mc.data?.id ||
    (mc.timesheetDetails && mc.timesheetDetails.timesheet && mc.timesheetDetails.timesheet.timesheet_id) ||
    null;

  if (!tsId) {
    GE();
    alert('Timesheet context missing; cannot remove evidence.');
    return;
  }

  const enc = encodeURIComponent;
  const encTsId = enc(tsId);
  const encEid  = enc(eid);

  L('REMOVE ENTRY', { timesheetId: tsId, evidenceId: eid });

  try {
    // DELETE the evidence row
    const res = await authFetch(API(`/api/timesheets/${encTsId}/evidence/${encEid}`), {
      method: 'DELETE'
    });
    const text = await res.text();
    if (!res.ok) {
      L('DELETE evidence failed', { status: res.status, bodyPreview: text.slice(0, 400) });
      throw new Error(text || 'Failed to delete evidence item');
    }

    // Refetch evidence list
    const res2  = await authFetch(API(`/api/timesheets/${encTsId}/evidence`));
    const json2 = await res2.json().catch(() => []);
    const evidence = Array.isArray(json2) ? json2 : [];

    // Update modal state
    window.modalCtx = window.modalCtx || {};
    const st = (window.modalCtx.timesheetState ||= {});
    st.evidence = evidence;

    // Re-render the Evidence tab â€“ the exact function name depends on your modal
    // renderer. If you have a central render like `renderTimesheetModalTabs`,
    // you can call it here. Otherwise, you can force a full modal re-render.
    if (typeof renderTimesheetModal === 'function') {
      renderTimesheetModal('evidence');
    } else if (typeof renderTimesheetModalTabs === 'function') {
      renderTimesheetModalTabs('evidence');
    } else {
      // Fallback: if no central renderer, you can manually replace the Evidence tab
      // container's innerHTML with renderTimesheetEvidenceTab({ row, details, state }).
      // This is left minimal to avoid inventing unknown helpers.
    }

    if (window.__toast) {
      window.__toast('Evidence removed');
    }
  } catch (err) {
    L('evidence remove error', err);
    alert(err?.message || 'Failed to remove evidence item.');
  }

  GE();
}


async function authoriseTimesheet(ctxOrId) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][AUTH]');
  GC('authoriseTimesheet');

  // Normalise context
  const mc = window.modalCtx || {};
  const row = (mc.data && mc.data.timesheet_id) ? mc.data : (ctxOrId && ctxOrId.row ? ctxOrId.row : {});
  const tsId = (typeof ctxOrId === 'string') ? ctxOrId : (row.timesheet_id || row.id || mc.data?.id || null);

  if (!tsId) {
    L('ERROR: missing timesheetId');
    GE();
    throw new Error('authoriseTimesheet: timesheetId is required');
  }

  const encId = encodeURIComponent(tsId);
  const url   = API(`/api/timesheets/${encId}/authorise`);

  L('REQUEST', { url, tsId });

  let res, text;
  try {
    res  = await authFetch(url, { method: 'POST' });
    text = await res.text();
  } catch (err) {
    L('network error', err);
    GE();
    throw err;
  }

  if (!res.ok) {
    L('server error', { status: res.status, bodyPreview: text.slice(0, 400) });
    GE();
    throw new Error(text || `Failed to authorise timesheet ${tsId}`);
  }

  let json = {};
  try { json = text ? JSON.parse(text) : {}; } catch (err) {
    L('parse error', err);
  }

  L('authorise result', json);

  // Refresh details so Overview, Lines, Finance reflect new status
  let newDetails = mc.timesheetDetails;
  try {
    newDetails = await fetchTimesheetDetails(tsId);
    window.modalCtx.timesheetDetails = newDetails;
  } catch (err) {
    L('refresh details failed (non-fatal)', err);
  }

  // Update summary row if present
  const tsfin = newDetails?.tsfin || {};
  const updatedRow = {
    ...(mc.data || row),
    summary_stage: json.summary_stage || mc.data?.summary_stage || 'READY_FOR_INVOICE',
    processing_status: tsfin.processing_status || mc.data?.processing_status,
    total_pay_ex_vat: tsfin.total_pay_ex_vat ?? mc.data?.total_pay_ex_vat,
    total_charge_ex_vat: tsfin.total_charge_ex_vat ?? mc.data?.total_charge_ex_vat,
    margin_ex_vat: tsfin.margin_ex_vat ?? mc.data?.margin_ex_vat,
    id: tsId
  };

  window.modalCtx.data = updatedRow;

  // Focus this TS in summary grid on next refresh
  try {
    window.__pendingFocus = {
      section: 'timesheets',
      ids: [String(tsId)],
      primaryIds: [String(tsId)]
    };
  } catch {}

  L('UPDATED ROW', updatedRow);
  GE();
  return { ok: true, updatedRow, details: newDetails };
}

async function toggleTimesheetPayHold(ctxOrId, onHold, reason = '') {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][PAY-HOLD]');
  GC('toggleTimesheetPayHold');

  const mc  = window.modalCtx || {};
  const row = (mc.data && mc.data.timesheet_id) ? mc.data : (ctxOrId && ctxOrId.row ? ctxOrId.row : {});
  const tsId = (typeof ctxOrId === 'string') ? ctxOrId : (row.timesheet_id || row.id || mc.data?.id || null);

  if (!tsId) {
    L('ERROR: missing timesheetId');
    GE();
    throw new Error('toggleTimesheetPayHold: timesheetId is required');
  }

  const encId = encodeURIComponent(tsId);
  const url   = API(`/api/timesheets/${encId}/pay-hold`);

  const payload = { on_hold: !!onHold };
  if (onHold && reason) payload.reason = reason;

  L('REQUEST', { url, payload });

  let res, text;
  try {
    res  = await authFetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });
    text = await res.text();
  } catch (err) {
    L('network error', err);
    GE();
    throw err;
  }

  if (!res.ok) {
    L('server error', { status: res.status, bodyPreview: text.slice(0, 400) });
    GE();
    throw new Error(text || `Failed to ${onHold ? 'apply' : 'release'} pay hold`);
  }

  let json = {};
  try { json = text ? JSON.parse(text) : {}; } catch (err) {
    L('parse error', err);
  }

  L('pay-hold result', json);

  // Refresh details
  let newDetails = mc.timesheetDetails;
  try {
    newDetails = await fetchTimesheetDetails(tsId);
    window.modalCtx.timesheetDetails = newDetails;
  } catch (err) {
    L('refresh details failed (non-fatal)', err);
  }

  const tsfin = newDetails?.tsfin || {};
  const updatedRow = {
    ...(mc.data || row),
    pay_on_hold: !!tsfin.pay_on_hold,
    id: tsId
  };

  window.modalCtx.data = updatedRow;

  try {
    window.__pendingFocus = {
      section: 'timesheets',
      ids: [String(tsId)],
      primaryIds: [String(tsId)]
    };
  } catch {}

  L('UPDATED ROW', updatedRow);
  GE();
  return { ok: true, updatedRow, details: newDetails };
}

async function markTimesheetPaid(ctxOrId) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][MARK-PAID]');
  GC('markTimesheetPaid');

  const mc  = window.modalCtx || {};
  const row = (mc.data && mc.data.timesheet_id) ? mc.data : (ctxOrId && ctxOrId.row ? ctxOrId.row : {});
  const tsId = (typeof ctxOrId === 'string') ? ctxOrId : (row.timesheet_id || row.id || mc.data?.id || null);

  if (!tsId) {
    L('ERROR: missing timesheetId');
    GE();
    throw new Error('markTimesheetPaid: timesheetId is required');
  }

  const encId = encodeURIComponent(tsId);
  const url   = API(`/api/timesheets/${encId}/mark-paid`);

  L('REQUEST', { url, tsId });

  let res, text;
  try {
    res  = await authFetch(url, { method: 'POST' });
    text = await res.text();
  } catch (err) {
    L('network error', err);
    GE();
    throw err;
  }

  if (!res.ok) {
    L('server error', { status: res.status, bodyPreview: text.slice(0, 400) });
    GE();
    throw new Error(text || `Failed to mark timesheet ${tsId} as paid`);
  }

  let json = {};
  try { json = text ? JSON.parse(text) : {}; } catch (err) {
    L('parse error', err);
  }

  L('mark-paid result', json);

  // Refresh details
  let newDetails = mc.timesheetDetails;
  try {
    newDetails = await fetchTimesheetDetails(tsId);
    window.modalCtx.timesheetDetails = newDetails;
  } catch (err) {
    L('refresh details failed (non-fatal)', err);
  }

  const tsfin = newDetails?.tsfin || {};
  const updatedRow = {
    ...(mc.data || row),
    paid_at_utc: tsfin.paid_at_utc || mc.data?.paid_at_utc,
    summary_stage: 'PAID',
    id: tsId
  };

  window.modalCtx.data = updatedRow;

  try {
    window.__pendingFocus = {
      section: 'timesheets',
      ids: [String(tsId)],
      primaryIds: [String(tsId)]
    };
  } catch {}

  L('UPDATED ROW', updatedRow);
  GE();
  return { ok: true, updatedRow, details: newDetails };
}

async function updateTimesheetReference(ctxOrId, newReference) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][REF]');
  GC('updateTimesheetReference');

  const mc  = window.modalCtx || {};
  const row = (mc.data && mc.data.timesheet_id) ? mc.data : (ctxOrId && ctxOrId.row ? ctxOrId.row : {});
  const tsId = (typeof ctxOrId === 'string') ? ctxOrId : (row.timesheet_id || row.id || mc.data?.id || null);

  if (!tsId) {
    L('ERROR: missing timesheetId');
    GE();
    throw new Error('updateTimesheetReference: timesheetId is required');
  }

  const encId = encodeURIComponent(tsId);
  const url   = API(`/api/timesheets/${encId}/reference`);

  const reference_number = newReference == null ? '' : String(newReference);
  L('REQUEST', { url, reference_number });

  let res, text;
  try {
    res  = await authFetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ reference_number })
    });
    text = await res.text();
  } catch (err) {
    L('network error', err);
    GE();
    throw err;
  }

  if (!res.ok) {
    L('server error', { status: res.status, bodyPreview: text.slice(0, 400) });
    GE();
    throw new Error(text || `Failed to update reference for timesheet ${tsId}`);
  }

  let json = {};
  try { json = text ? JSON.parse(text) : {}; } catch (err) {
    L('parse error', err);
  }

  L('reference result', json);

  // Refresh details
  let newDetails = mc.timesheetDetails;
  try {
    newDetails = await fetchTimesheetDetails(tsId);
    window.modalCtx.timesheetDetails = newDetails;
  } catch (err) {
    L('refresh details failed (non-fatal)', err);
  }

  const ts = newDetails?.timesheet || {};
  const updatedRow = {
    ...(mc.data || row),
    reference_number: ts.reference_number || reference_number,
    id: tsId
  };

  window.modalCtx.data = updatedRow;

  // Keep staged state in sync
  if (mc.timesheetState) {
    mc.timesheetState.reference = updatedRow.reference_number;
  }

  L('UPDATED ROW', updatedRow);
  GE();
  return { ok: true, updatedRow, details: newDetails };
}

async function updateTimesheetSegmentsPayFlags(ctxOrId, overrides) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][SEGMENTS]');
  GC('updateTimesheetSegmentsPayFlags');

  const mc  = window.modalCtx || {};
  const row = (mc.data && mc.data.timesheet_id) ? mc.data : (ctxOrId && ctxOrId.row ? ctxOrId.row : {});
  const tsId = (typeof ctxOrId === 'string') ? ctxOrId : (row.timesheet_id || row.id || mc.data?.id || null);

  if (!tsId) {
    L('ERROR: missing timesheetId');
    GE();
    throw new Error('updateTimesheetSegmentsPayFlags: timesheetId is required');
  }

  const det = mc.timesheetDetails || {};
  if (!det.isSegmentsMode || !Array.isArray(det.segments)) {
    L('NOT SEGMENTS MODE, no-op', { isSegmentsMode: det.isSegmentsMode });
    GE();
    return { ok: true };
  }

  const baseSegs = det.segments || [];
  const overridesMap = overrides || (mc.timesheetState && mc.timesheetState.segmentOverrides) || {};
  const segIds = Object.keys(overridesMap);
  if (!segIds.length) {
    L('no overrides to apply, no-op');
    GE();
    return { ok: true };
  }

  const segmentsPayload = segIds.map(segId => ({
    segment_id: segId,
    exclude_from_pay: !!overridesMap[segId].exclude_from_pay
  }));

  const encId = encodeURIComponent(tsId);
  const url   = API(`/api/timesheets/${encId}/segments`);

  L('REQUEST', { url, count: segmentsPayload.length, segmentsPayload });

  let res, text;
  try {
    res  = await authFetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ segments: segmentsPayload })
    });
    text = await res.text();
  } catch (err) {
    L('network error', err);
    GE();
    throw err;
  }

  if (!res.ok) {
    L('server error', { status: res.status, bodyPreview: text.slice(0, 400) });
    GE();
    throw new Error(text || 'Failed to apply segment overrides');
  }

  let json = {};
  try { json = text ? JSON.parse(text) : {}; } catch (err) {
    L('parse error', err);
  }

  L('segment overrides applied', json);

  // Refresh details
  let newDetails = det;
  try {
    newDetails = await fetchTimesheetDetails(tsId);
    window.modalCtx.timesheetDetails = newDetails;
    if (window.modalCtx.timesheetState) {
      window.modalCtx.timesheetState.segmentOverrides = {};
    }
    L('details refreshed after segments', {
      newTotalPay: newDetails.tsfin?.total_pay_ex_vat,
      newTotalCharge: newDetails.tsfin?.total_charge_ex_vat
    });
  } catch (err) {
    L('refresh details failed (non-fatal)', err);
  }

  // Update row totals
  const tsfin = newDetails?.tsfin || {};
  const updatedRow = {
    ...(mc.data || row),
    total_pay_ex_vat: tsfin.total_pay_ex_vat ?? mc.data?.total_pay_ex_vat,
    total_charge_ex_vat: tsfin.total_charge_ex_vat ?? mc.data?.total_charge_ex_vat,
    margin_ex_vat: tsfin.margin_ex_vat ?? mc.data?.margin_ex_vat,
    id: tsId
  };

  window.modalCtx.data = updatedRow;

  try {
    window.__pendingFocus = {
      section: 'timesheets',
      ids: [String(tsId)],
      primaryIds: [String(tsId)]
    };
  } catch {}

  L('UPDATED ROW', updatedRow);
  GE();
  return { ok: true, updatedRow, details: newDetails };
}

async function deferNhspShift(shiftId, runAtIso = null) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][NHSP-DEFER]');
  GC('deferNhspShift');

  if (!shiftId) {
    L('ERROR: missing shiftId');
    GE();
    throw new Error('deferNhspShift: shiftId is required');
  }

  const encId = encodeURIComponent(shiftId);
  const url   = API(`/api/nhsp/shifts/${encId}/defer`);

  const body = {};
  if (runAtIso) body.run_at = runAtIso;

  L('REQUEST', { url, body });

  let res, text;
  try {
    res  = await authFetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body)
    });
    text = await res.text();
  } catch (err) {
    L('network error', err);
    GE();
    throw err;
  }

  if (!res.ok) {
    L('server error', { status: res.status, bodyPreview: text.slice(0, 400) });
    GE();
    throw new Error(text || `Failed to defer NHSP shift ${shiftId}`);
  }

  let json = {};
  try { json = text ? JSON.parse(text) : {}; } catch (err) {
    L('parse error', err);
  }

  L('defer result', json);
  GE();
  return { ok: true, result: json };
}


async function saveNhspDeferrals(ctxOrId, deferrals) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][NHSP-SAVE]');
  GC('saveNhspDeferrals');

  const mc  = window.modalCtx || {};
  const row = (mc.data && mc.data.timesheet_id) ? mc.data : (ctxOrId && ctxOrId.row ? ctxOrId.row : {});
  const tsId = (typeof ctxOrId === 'string') ? ctxOrId : (row.timesheet_id || row.id || mc.data?.id || null);

  const map = deferrals || (mc.timesheetState && mc.timesheetState.nhspDeferrals) || {};
  const shiftIds = Object.keys(map || {});
  if (!shiftIds.length) {
    L('no NHSP deferrals staged, no-op');
    GE();
    return { ok: true };
  }

  L('staged deferrals', map);

  for (const shiftId of shiftIds) {
    const cfg = map[shiftId] || {};
    const runAtIso = cfg.defer_until_run_after || null;
    try {
      await deferNhspShift(shiftId, runAtIso);
    } catch (err) {
      L('deferNhspShift failed', { shiftId, err });
      GE();
      throw err;
    }
  }

  // After deferring, refresh details so shifts/validations reflect new status
  if (tsId) {
    try {
      const newDetails = await fetchTimesheetDetails(tsId);
      window.modalCtx.timesheetDetails = newDetails;
      if (mc.timesheetState) {
        mc.timesheetState.nhspDeferrals = {};
      }
      L('details refreshed after NHSP deferrals', {
        shiftsCount: (newDetails.shifts || []).length
      });
    } catch (err) {
      L('refresh details failed (non-fatal)', err);
    }
  }

  GE();
  return { ok: true };
}

async function listTimesheetsSummary(filters = {}) {
  window.__listState = window.__listState || {};
  const st = (window.__listState['timesheets'] ||= {
    page: 1,
    pageSize: 50,
    total: null,
    hasMore: false,
    filters: {},
    sort: { key: null, dir: 'asc' }
  });

  const pageRaw     = st.page || 1;
  const pageSizeRaw = st.pageSize || 50;
  const page        = Number(pageRaw) || 1;
  const pageSize    = (pageSizeRaw === 'ALL')
    ? 200
    : Number(pageSizeRaw) || 50;

  const qs = new URLSearchParams();
  qs.set('page', String(page));
  qs.set('page_size', String(pageSize));

  const f = filters || {};

  // Stage filter (Tools use ts_stage; we also support summary_stage for future calls)
  const stage = (f.ts_stage || f.summary_stage || '').toUpperCase();
  if (stage && stage !== 'ALL') qs.set('summary_stage', stage);

  // Route filter (aggregated: ELECTRONIC / MANUAL / NHSP / HEALTHROSTER / QR)
  const route = (f.route_type || '').toUpperCase();
  if (route && route !== 'ALL') {
    if (route === 'QR') {
      // Route = QR timesheets â†’ filter via is_qr=true
      qs.set('is_qr', 'true');
    } else {
      // Other route codes handled by backend switch (ELECTRONIC/MANUAL/NHSP/HEALTHROSTER)
      qs.set('route_type', route);
    }
  }

  // Scope filter
  const scope = (f.sheet_scope || '').toUpperCase();
  if (scope && scope !== 'ALL') qs.set('sheet_scope', scope);

  // processing_status filter (supports single or comma-joined list)
  const procStatusRaw = f.processing_status || '';
  if (procStatusRaw && procStatusRaw !== 'ALL') {
    const procStatus = procStatusRaw.includes(',')
      ? procStatusRaw
      : procStatusRaw.toUpperCase();
    qs.set('processing_status', procStatus);
  }

  // Adjusted-only flag
  if (f.is_adjusted === true)  qs.set('is_adjusted', 'true');

  // QR-only flag still supported if someone uses it directly (though Route=QR is preferred)
  if (f.is_qr === true)        qs.set('is_qr', 'true');

  // Needs attention (also wired from Tools)
  if (f.needs_attention === true) qs.set('needs_attention', 'true');

  // NEW: Tools filters â€“ Candidate Paid / Client Invoiced
  if (f.candidate_paid === true)   qs.set('candidate_paid', 'true');
  if (f.client_invoiced === true)  qs.set('client_invoiced', 'true');

  // NEW: HR issue filter â€“ e.g. 'HOURS_MISMATCH_HR'
  if (f.hr_issue) {
    qs.set('hr_issue', f.hr_issue);
  }

  const sortState = st.sort || { key: null, dir: 'asc' };
  const sortKeyRaw = (sortState.key || '').toLowerCase();
  const sortDir    = (sortState.dir === 'desc') ? 'desc' : 'asc';

  const sortMap = {
    week_ending_date:    'week_ending_date',
    client_name:         'client_name',
    candidate_name:      'candidate_name',
    summary_stage:       'summary_stage',
    route_type:          'route_type',
    sheet_scope:         'sheet_scope',
    total_pay_ex_vat:    'total_pay_ex_vat',
    total_charge_ex_vat: 'total_charge_ex_vat',
    margin_ex_vat:       'margin_ex_vat',
    pay:                 'total_pay_ex_vat',
    charge:              'total_charge_ex_vat',
    margin:              'margin_ex_vat'
  };

  const orderBy = sortMap[sortKeyRaw] || 'week_ending_date';
  qs.set('order_by', orderBy);
  qs.set('order_dir', sortDir);

  const url = `/api/timesheets/summary?${qs.toString()}`;

  const res  = await authFetch(API(url));
  const text = await res.text();
  if (!res.ok) {
    throw new Error(text || `Failed to fetch timesheets summary (${res.status})`);
  }

  let json;
  try { json = text ? JSON.parse(text) : {}; } catch { json = {}; }

  const rows  = Array.isArray(json.items) ? json.items : (json.rows || []);
  const total = (typeof json.count === 'number') ? json.count : rows.length;

  rows.forEach(r => {
    if (!r.id && r.timesheet_id) {
      r.id = r.timesheet_id;
    } else if (!r.id && !r.timesheet_id && r.contract_week_id) {
      // Planned / OPEN week without a TS yet â€“ use contract_week_id as stable id
      r.id = r.contract_week_id;
    }
  });

  st.hasMore = rows.length === pageSize;
  st.total   = total;
  st.filters = { ...(f || {}) };

  return rows;
}



// ======== Manual weekly upsert (contract weeks) ========

async function manualUpsertContractWeek(weekId, payload) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][MANUAL-UPsert]');
  GC('manualUpsertContractWeek');

  if (!weekId) {
    GE();
    throw new Error('manualUpsertContractWeek: weekId is required');
  }

  const encId = encodeURIComponent(weekId);
  const url   = API(`/api/contract-weeks/${encId}/manual-upsert`);

  // We expect payload to contain at least:
  //   - either hours or actual_schedule_json
  //   - optionally additional_units_week / additional_units_per_day
  L('REQUEST', { url, weekId, payload });

  let res, text;
  try {
    res = await authFetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload || {})
    });
    text = await res.text();
  } catch (err) {
    L('network error', err);
    GE();
    throw err;
  }

  if (!res.ok) {
    L('server error', { status: res.status, bodyPreview: text.slice(0, 400) });
    GE();
    throw new Error(text || `Manual upsert failed (${res.status})`);
  }

  let json = {};
  try {
    json = text ? JSON.parse(text) : {};
  } catch (err) {
    L('parse error', err);
  }

  L('RESULT', json);
  GE();
  return json;
}


// ======== Switch a timesheet to MANUAL (weekly) ========

async function switchTimesheetToManual(timesheetId) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][SWITCH-MANUAL]');
  GC('switchTimesheetToManual');

  if (!timesheetId) {
    GE();
    throw new Error('switchTimesheetToManual: timesheetId is required');
  }

  const encId = encodeURIComponent(timesheetId);
  const url   = API(`/api/timesheets/${encId}/switch-to-manual`);

  L('REQUEST', { url, timesheetId });

  let res, text;
  try {
    res  = await authFetch(url, { method: 'POST' });
    text = await res.text();
  } catch (err) {
    L('network error', err);
    GE();
    throw err;
  }

  if (!res.ok) {
    L('server error', { status: res.status, bodyPreview: text.slice(0, 400) });
    GE();
    throw new Error(text || `Failed to switch timesheet ${timesheetId} to manual`);
  }

  let json = {};
  try {
    json = text ? JSON.parse(text) : {};
  } catch (err) {
    L('parse error', err);
  }

  L('RESULT', json);
  GE();
  return json;
}


async function revertTimesheetToElectronic(timesheetId) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][REVERT-ELEC]');
  GC('revertTimesheetToElectronic');

  if (!timesheetId) {
    GE();
    throw new Error('revertTimesheetToElectronic: timesheetId is required');
  }

  const encId = encodeURIComponent(timesheetId);
  const url   = API(`/api/timesheets/${encId}/revert-to-electronic`);

  L('REQUEST', { url, timesheetId });

  let res;
  let text = '';
  try {
    res  = await authFetch(url, { method: 'POST' });
    text = await res.text();
  } catch (err) {
    L('network error', err);
    GE();
    throw err;
  }

  if (!res.ok) {
    L('server error', { status: res.status, bodyPreview: (text || '').slice(0, 400) });
    GE();
    throw new Error(text || `Failed to revert timesheet ${timesheetId} to electronic`);
  }

  let json = {};
  try {
    json = text ? JSON.parse(text) : {};
  } catch (err) {
    L('parse error (non-fatal)', err);
  }

  L('RESULT', json);
  GE();
  return json;
}


async function deleteManualTimesheetAndReopenWeek(timesheetId, contractWeekId) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][DELETE-REOPEN]');
  GC('deleteManualTimesheetAndReopenWeek');

  if (!contractWeekId) {
    GE();
    throw new Error('deleteManualTimesheetAndReopenWeek: contractWeekId is required');
  }

  const encWeekId = encodeURIComponent(contractWeekId);
  const url       = API(`/api/contract-weeks/${encWeekId}/timesheet`);

  L('REQUEST', { url, timesheetId, contractWeekId });

  let res;
  let text = '';
  try {
    res  = await authFetch(url, { method: 'DELETE' });
    text = await res.text();
  } catch (err) {
    L('network error', err);
    GE();
    throw err;
  }

  if (!res.ok) {
    L('server error', { status: res.status, bodyPreview: (text || '').slice(0, 400) });
    GE();
    throw new Error(text || `Failed to delete manual timesheet ${timesheetId || ''} and reopen week ${contractWeekId}`);
  }

  let json = {};
  try {
    json = text ? JSON.parse(text) : {};
  } catch (err) {
    L('parse error (non-fatal)', err);
  }

  L('RESULT', json);
  GE();
  return json;
}

async function deleteTimesheetPermanent(timesheetId) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][DELETE-PERM]');
  GC('deleteTimesheetPermanent');

  if (!timesheetId) {
    GE();
    throw new Error('deleteTimesheetPermanent: timesheetId is required');
  }

  const encId = encodeURIComponent(timesheetId);
  const url   = API(`/api/timesheets/${encId}`);

  L('REQUEST', { url, timesheetId });

  let res;
  let text = '';
  try {
    res  = await authFetch(url, { method: 'DELETE' });
    text = await res.text();
  } catch (err) {
    L('network error', err);
    GE();
    throw err;
  }

  if (!res.ok) {
    L('server error', { status: res.status, bodyPreview: (text || '').slice(0, 400) });
    GE();
    throw new Error(text || `Failed to permanently delete timesheet ${timesheetId}`);
  }

  let json = {};
  try {
    json = text ? JSON.parse(text) : {};
  } catch (err) {
    L('parse error (non-fatal)', err);
  }

  L('RESULT', json);
  GE();
  return json;
}









































































// ===== Boot =====
async function renderAll(){
  // seed defaults for first login / first visit to section
  window.__listState = window.__listState || {};
  if (!window.__listState[currentSection]) {
    window.__listState[currentSection] = {
      page: 1,
      pageSize: 50,
      total: null,
      hasMore: false,
      filters: null,
      sort: { key: null, dir: 'asc' }
    };
  }
  renderTopNav();
  renderTools();
  const data = await loadSection();
  renderSummary(data);
}

async function bootstrapApp(){
  // Belt & braces: if loadSession() ran but globals are not mirrored, mirror now
  try {
    if (typeof window !== 'undefined') {
      if (window.SESSION !== SESSION) window.SESSION = SESSION;
      window.__auth = window.__auth || {};
      if (!window.__auth.user && SESSION?.user) window.__auth.user = SESSION.user;
      if (!window.__USER_ID && SESSION?.user?.id) window.__USER_ID = SESSION.user.id;
    }

    // If token exists but user.id is missing, hydrate via /api/me (non-blocking safety)
    if (SESSION?.accessToken && (!SESSION.user || !SESSION.user.id)) {
      try {
        const meRes = await fetch(API('/api/me'), { headers: { 'Authorization': `Bearer ${SESSION.accessToken}` } });
        if (meRes.ok) {
          const meJson = await meRes.json().catch(()=> ({}));
          const profile = meJson && (meJson.user || meJson);
          if (profile && profile.id) {
            saveSession({ ...SESSION, user: profile }); // also re-mirrors globals
          }
        }
      } catch {}
    }
  } catch {}

  ensureSelectionStyles();   // â† ensure the highlight is clearly visible
  renderTopNav();
  renderTools();
  await renderAll();
}


// Initialize
initAuthUI();
if (loadSession()) { scheduleRefresh(); bootstrapApp(); }
else openLogin();
