// ===== Base URL + helpers =====
const BROKER_BASE_URL = window.BROKER_BASE_URL;
const API = (path)=> `${BROKER_BASE_URL}${path}`;

let SESSION = null;  // {accessToken, user, exp}
let refreshTimer = 0;

// ==== DEBUG SWITCHES (global) ====
// Put this at the very top of main.js so all functions can read them.
window.__LOG_RATES  = true;   // logs for rate staging + rates table + rates tab
window.__LOG_PAYTAB = true;   // logs for payment tab + umbrella prefill
window.__LOG_CONTRACTS = true;

window.__LOG_MODAL  = true;   // logs from modal framework (showModal)
const __LOG_API = true;   // turns on authFetch + rates/hospitals/client POST/PATCH logging

// Default friendly labels (fallbacks if user hasn't set custom labels for a section)
const DEFAULT_COLUMN_LABELS = {
  candidates: {
    first_name: 'First Name',
    last_name: 'Last Name',
    email: 'Email',
    phone: 'Phone',
    postcode: 'Postcode',
    role: 'Role',
    tms_ref: 'TMS Ref',
    job_titles_display: 'Job Titles',
    rev: 'Revision'
  },
  clients: {
    name: 'Client Name',
    primary_invoice_email: 'Invoice Email',
    invoice_address: 'Invoice Address',
    postcode: 'Postcode',
    ap_phone: 'A/P Phone',
    cli_ref: 'Client Ref',
    rev: 'Revision'
  },
  contracts: {
    candidate_display: 'Candidate',
    client_name: 'Client',
    role: 'Role',
    band: 'Band',
    pay_method_snapshot: 'Pay Method',
    default_submission_mode: 'Submission Mode',
    start_date: 'Start',
    end_date: 'End',
    bucket_labels_preview: 'Buckets'
  },
  audit: {
    created_at_utc: 'Created (UTC)',
    last_error: 'Last Error'
  }
};

const GRID_COLUMN_META_DEFAULTS = {
  // Candidate list (drawn from candidates + any summary fields you render)
  candidates: {
    id:                     { selectable: false },
    tms_ref:                { selectable: true },
    first_name:             { selectable: true },
    last_name:              { selectable: true },
    display_name:           { selectable: true },
    email:                  { selectable: true },
    phone:                  { selectable: true },
    mobile:                 { selectable: true },
    address_line1:          { selectable: false },
    address_line2:          { selectable: false },
    address_line3:          { selectable: false },
    town_city:              { selectable: true },
    county:                 { selectable: false },
    postcode:               { selectable: true },
    country:                { selectable: false },
    ni_number:              { selectable: true },
    date_of_birth:          { selectable: true },
    gender:                 { selectable: true },
    nationality:            { selectable: true },
    right_to_work_status:   { selectable: false },
    right_to_work_expiry:   { selectable: false },
    pay_method:             { selectable: true },
    job_titles_display:     { selectable: true },
    umbrella_id:            { selectable: false },
    bank_name:              { selectable: false },
    bank_account_name:      { selectable: true },
    bank_account_number:    { selectable: true },
    bank_sort_code:         { selectable: true },
    umbrella_name:          { selectable: true },
    umbrella_reference:     { selectable: false },
    notes:                  { selectable: true },
    status:                 { selectable: true },
    archived:               { selectable: true },
    active:                 { selectable: true },
    key_norm:               { selectable: false },
    created_at:             { selectable: true },
    updated_at:             { selectable: true },
    rev:                    { selectable: false },
    // derived / summary fields you show:
    roles_display:          { selectable: true },
    primary_role:           { selectable: true },
    bands_display:          { selectable: true },
    last_booking_date:      { selectable: true },
    next_booking_date:      { selectable: true }
  },

  // Clients (public.clients)
  clients: {
    id:                        { selectable: false },
    cli_ref:                   { selectable: true },
    name:                      { selectable: true },
    invoice_address:           { selectable: true },
    primary_invoice_email:     { selectable: true },
    ap_phone:                  { selectable: true },
    vat_chargeable:            { selectable: true },
    payment_terms_days:        { selectable: true },
    created_at:                { selectable: true },
    updated_at:                { selectable: true },
    mileage_charge_rate:       { selectable: true },
    ts_queries_email:          { selectable: true },
    rev:                       { selectable: false },
    // any extra client_settings snapshot fields you show in the grid:
    default_submission_mode:   { selectable: true },
    week_ending_weekday:       { selectable: true },
    pay_reference_required:    { selectable: true },
    invoice_reference_required:{ selectable: true },
    auto_invoice_default:      { selectable: true }
  },

  // Contracts (public.contracts + summary fields)
  contracts: {
    id:                           { selectable: false },
    tms_ref:                      { selectable: true },
    candidate_id:                 { selectable: false },
    client_id:                    { selectable: false },
    candidate_display:            { selectable: true }, // your summary label
    client_name:                  { selectable: true }, // joined from clients.name
    role:                         { selectable: true },
    band:                         { selectable: true },
    display_site:                 { selectable: true },
    ward_hint:                    { selectable: true },
    start_date:                   { selectable: true },
    end_date:                     { selectable: true },
    pay_method_snapshot:          { selectable: true },
    default_submission_mode:      { selectable: true },
    week_ending_weekday_snapshot: { selectable: true },
    auto_invoice:                 { selectable: true },
    require_reference_to_pay:     { selectable: true },
    require_reference_to_invoice: { selectable: true },
    status:                       { selectable: true }, // high-level status you derive (e.g. Active/Unassigned/Completed)
    status_detail:                { selectable: true }, // e.g. next action / next week
    // bucket labels
    bucket_labels_json:           { selectable: false },
    bucket_day:                   { selectable: false },
    bucket_night:                 { selectable: false },
    bucket_sat:                   { selectable: false },
    bucket_sun:                   { selectable: false },
    bucket_bh:                    { selectable: false },
    // convenience label columns you render:
    bucket_label_day:             { selectable: true },
    bucket_label_night:           { selectable: true },
    bucket_label_sat:             { selectable: true },
    bucket_label_sun:             { selectable: true },
    bucket_label_bh:              { selectable: true },
    // rates_json is complex; but you might expose individual buckets:
    paye_day:                     { selectable: true },
    paye_night:                   { selectable: true },
    paye_sat:                     { selectable: true },
    paye_sun:                     { selectable: true },
    paye_bh:                      { selectable: true },
    umb_day:                      { selectable: true },
    umb_night:                    { selectable: true },
    umb_sat:                      { selectable: true },
    umb_sun:                      { selectable: true },
    umb_bh:                       { selectable: true },
    charge_day:                   { selectable: true },
    charge_night:                 { selectable: true },
    charge_sat:                   { selectable: true },
    charge_sun:                   { selectable: true },
    charge_bh:                    { selectable: true },
    // mileage
    mileage_pay_rate:             { selectable: true },
    mileage_charge_rate:          { selectable: true },
    // schedule / hours if ever surfaced:
    std_schedule_json:            { selectable: false },
    std_hours_json:               { selectable: false },
    gh_mon:                       { selectable: false },
    gh_tue:                       { selectable: false },
    gh_wed:                       { selectable: false },
    gh_thu:                       { selectable: false },
    gh_fri:                       { selectable: false },
    gh_sat:                       { selectable: false },
    gh_sun:                       { selectable: false },
    // meta
    created_at:                   { selectable: true },
    updated_at:                   { selectable: true },
    rev:                          { selectable: false }
  },

  // Timesheets (timesheet summary view)
  timesheets: {
    id:                      { selectable: true },
    timesheet_id:            { selectable: true },
    booking_id:              { selectable: true },
    candidate_id:            { selectable: true },
    candidate_display:       { selectable: true },
    client_id:               { selectable: true },
    client_name:             { selectable: true },
    hospital:                { selectable: true },
    ward:                    { selectable: true },
    unit:                    { selectable: true },
    role_code:               { selectable: true },
    band:                    { selectable: true },
    start_utc:               { selectable: true },
    end_utc:                 { selectable: true },
    work_date:               { selectable: true },
    week_ending_date:        { selectable: true },
    submission_mode:         { selectable: true },
    authorised:              { selectable: true },
    authorised_at_utc:       { selectable: true },
    status:                  { selectable: true },   // high-level status string
    processing_status:       { selectable: true },   // ts_fin_processing_status_enum
    fin_basis:               { selectable: true },   // timesheet_fin_basis_enum
    pay_method:              { selectable: true },
    hours_day:               { selectable: true },
    hours_night:             { selectable: true },
    hours_sat:               { selectable: true },
    hours_sun:               { selectable: true },
    hours_bh:                { selectable: true },
    total_hours:             { selectable: true },
    pay_rate_day:            { selectable: true },
    pay_rate_night:          { selectable: true },
    pay_rate_sat:            { selectable: true },
    pay_rate_sun:            { selectable: true },
    pay_rate_bh:             { selectable: true },
    charge_rate_day:         { selectable: true },
    charge_rate_night:       { selectable: true },
    charge_rate_sat:         { selectable: true },
    charge_rate_sun:         { selectable: true },
    charge_rate_bh:          { selectable: true },
    pay_total:               { selectable: true },
    charge_total:            { selectable: true },
    margin_total:            { selectable: true },
    pay_on_hold:             { selectable: true },
    remittance_last_sent_at: { selectable: true },
    created_at:              { selectable: true },
    updated_at:              { selectable: true },

    // NEW: Issues badges column from v_timesheets_summary
    issue_codes:             { selectable: true }
  },

  // Invoices (public.invoices)
  invoices: {
    id:                     { selectable: true },
    type:                   { selectable: true },
    invoice_no:             { selectable: true },
    client_id:              { selectable: true },
    client_name:            { selectable: true }, // joined from clients
    issued_at_utc:          { selectable: true },
    due_at_utc:             { selectable: true },
    paid_at_utc:            { selectable: true },
    status:                 { selectable: true },
    status_date_utc:        { selectable: true },
    currency:               { selectable: true },
    subtotal_ex_vat:        { selectable: true },
    vat_rate_pct:           { selectable: true },
    vat_amount:             { selectable: true },
    total_inc_vat:          { selectable: true },
    credit_note_total:      { selectable: true },
    balance_outstanding:    { selectable: true },
    on_hold:                { selectable: true },
    on_hold_reason:         { selectable: true },
    original_invoice_id:    { selectable: true },
    created_at:             { selectable: true },
    updated_at:             { selectable: true }
  },

  // Umbrellas (public.umbrellas)
  umbrellas: {
    id:             { selectable: false },
    name:           { selectable: true },
    email:          { selectable: true },
    phone:          { selectable: true },
    address_line1:  { selectable: false },
    address_line2:  { selectable: false },
    address_line3:  { selectable: false },
    town_city:      { selectable: false },
    county:         { selectable: false },
    postcode:       { selectable: false },
    country:        { selectable: false },
    bank_name:      { selectable: true },
    bank_account:   { selectable: true },
    bank_sort_code: { selectable: true },
    vat_number:     { selectable: true },
    company_number: { selectable: true },
    active:         { selectable: true },
    created_at:     { selectable: true },
    updated_at:     { selectable: true },
    rev:            { selectable: false }
  },

  // Audit / mail_outbox (public.mail_outbox)
  audit: {
    id:           { selectable: true },
    type:         { selectable: true },
    to:           { selectable: true },
    cc:           { selectable: true },
    subject:      { selectable: true },
    body_html:    { selectable: true },
    body_text:    { selectable: true },
    attachments:  { selectable: true },
    status:       { selectable: true },
    last_error:   { selectable: true },
    provider:     { selectable: true },
    provider_id:  { selectable: true },
    created_at:   { selectable: true },
    updated_at:   { selectable: true },
    sent_at:      { selectable: true },
    failed_at:    { selectable: true },
    attempts:     { selectable: true }
  }
};

const fmtMoney = (n) => {
  const x = invoiceModalRound2(Number(n || 0));
  const abs = Math.abs(x).toFixed(2);
  // show negatives as -Â£12.34, positives as Â£12.34
  return (x < 0) ? `-Â£${abs}` : `Â£${abs}`;
};

// Quick DOM helper
const byId = (id)=>document.getElementById(id);

// ===== Session handling =====
function saveSession(sess){
  SESSION = sess;
  const persist = document.getElementById('rememberMe')?.checked ?? true;
  const store = persist ? localStorage : sessionStorage;
  store.setItem('cloudtms.session', JSON.stringify(sess));
  if (persist) sessionStorage.removeItem('cloudtms.session');
  scheduleRefresh();
  renderUserChip();
}
// FRONTEND â€” loadUserGridPrefs
async function loadUserGridPrefs(section) {
  // If already loaded and shaped correctly, just reuse
  if (window.__gridPrefs && typeof window.__gridPrefs === 'object') {
    if (!window.__gridPrefs.grid || typeof window.__gridPrefs.grid !== 'object') {
      window.__gridPrefs = { grid: {} };
    }
    if (!window.__gridPrefs.grid[section] || typeof window.__gridPrefs.grid[section] !== 'object') {
      window.__gridPrefs.grid[section] = {};
    }
    return window.__gridPrefs;
  }

  // GET once per app session from backend (which applies defaults if needed)
  let prefs;
  try {
    const res = await authFetch(API('/api/users/me/grid-prefs'));
    prefs = (await res.json()) || {};
  } catch (e) {
    console.error('[GRID] failed to load user grid prefs', e);
    prefs = {};
  }

  // Normalise to at least { grid: {} }
  if (!prefs || typeof prefs !== 'object') {
    prefs = { grid: {} };
  }
  if (!prefs.grid || typeof prefs.grid !== 'object') {
    prefs.grid = {};
  }
  // ensure object for this section
  if (!prefs.grid[section] || typeof prefs.grid[section] !== 'object') {
    prefs.grid[section] = {};
  }

  // One-time import from legacy localStorage, if present and no columns yet
  try {
    const legacyKey = 'cloudtms.cols.' + section;
    const legacy = localStorage.getItem(legacyKey);
    if (legacy && !prefs.grid[section].columns) {
      const cols = JSON.parse(legacy);
      if (Array.isArray(cols)) {
        const columns = {};
        cols.forEach((k, i) => {
          columns[k] = { visible: true, order: i };
        });
        prefs.grid[section].columns = columns;
        // Persist immediately so backend has them
        window.__gridPrefs = prefs;
        await saveUserGridPrefsDebounced(section, { columns }, true);
      }
      try { localStorage.removeItem(legacyKey); } catch (_) {}
    }
  } catch (e) {
    console.warn('[GRID] legacy grid prefs import failed', e);
  }

  window.__gridPrefs = prefs;
  return prefs;
}

const __saveTimers = new Map();
async function saveUserGridPrefsDebounced(section, partial, immediate = false) {
  // Ensure global shape
  if (!window.__gridPrefs || typeof window.__gridPrefs !== 'object') {
    window.__gridPrefs = { grid: {} };
  }
  if (!window.__gridPrefs.grid || typeof window.__gridPrefs.grid !== 'object') {
    window.__gridPrefs.grid = {};
  }

  const grid = window.__gridPrefs.grid;
  const existing = (grid[section] && typeof grid[section] === 'object') ? grid[section] : {};
  grid[section] = { ...existing, ...(partial || {}) };

  const key = `grid:${section}`;

  const fire = async () => {
   const body = {
  section,
  prefs: grid[section] || {}
};

    try {
      const res = await authFetch(API('/api/users/me/grid-prefs'), {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body)
      });
      const saved = await res.json().catch(() => null);
      // If server returned a full prefs object with .grid, adopt it as source of truth
      if (saved && typeof saved === 'object' && saved.grid && typeof saved.grid === 'object') {
        window.__gridPrefs = saved;
      }
    } catch (e) {
      console.error('Failed to save grid prefs', e);
    }
  };

  if (immediate) {
    return fire();
  }

  window.__saveTimers = window.__saveTimers || new Map();
  if (window.__saveTimers.has(key)) {
    clearTimeout(window.__saveTimers.get(key));
  }
  window.__saveTimers.set(key, setTimeout(fire, 300));
}

function getVisibleColumnsForSection(section, rows) {
  const defaults = (typeof defaultColumnKeysForSection === 'function')
    ? defaultColumnKeysForSection(section)
    : (typeof defaultColumnsFor === 'function'
        ? defaultColumnsFor(section)
        : []);

  const root = (window.__gridPrefs && window.__gridPrefs.grid) || {};
  const prefsRoot = (root[section] && typeof root[section] === 'object') ? root[section] : {};
  const colPrefs  = prefsRoot.columns      || {};
  const userMeta  = prefsRoot.columns_meta || {};

  const globalMeta =
    (typeof GRID_COLUMN_META_DEFAULTS === 'object' &&
     GRID_COLUMN_META_DEFAULTS[section]) || {};

  // Build catalog of known columns: defaults + first row's keys
  const known = new Set(defaults);
  if (Array.isArray(rows) && rows.length > 0 && rows[0] && typeof rows[0] === 'object') {
    Object.keys(rows[0]).forEach((k) => known.add(k));
  }

  const entries = Array.from(known).map((k) => {
    const p = colPrefs[k] || {};
    const meta = {
      ...(globalMeta[k] || {}),
      ...(userMeta[k]   || {})
    };

    const selectable = (meta.selectable !== false); // default true
    const visible    = (p.visible !== false);       // default true

    const order = (typeof p.order === 'number')
      ? p.order
      : (defaults.indexOf(k) >= 0 ? defaults.indexOf(k) : 9999);

    const width = (typeof p.width === 'number') ? p.width : null;

    return { key: k, selectable, visible, order, width };
  });

  // Only include columns that are globally/user-selectable AND marked visible
  const filtered = entries.filter((e) => e.selectable && e.visible);
  filtered.sort((a, b) => a.order - b.order);

  return filtered.map((e) => e.key);
}

function applyUserGridPrefs(section, tables, cols) {
  const root = (window.__gridPrefs && window.__gridPrefs.grid) || {};
  const prefsRoot = root[section] || {};
  const colPrefs = prefsRoot.columns || {};
  const MIN_W = 80, MAX_W = 600;

  const headTable = (tables && tables.head) ? tables.head : tables;
  const bodyTable = (tables && tables.body) ? tables.body : tables;

  const widthOf = (k) => {
    let w = colPrefs[k]?.width;
    if (typeof w !== 'number' || !(w > 0)) return null; // auto â†’ weâ€™ll measure below
    if (w < MIN_W) w = MIN_W;
    if (w > MAX_W) w = MAX_W;
    return w;
  };

  const setColWidthPx = (colKey, pxOrNull) => {
    if (headTable) {
      const th = headTable.querySelector(
        `thead th[data-col-key="${CSS.escape(colKey)}"]`
      );
      if (th) {
        th.style.width = (pxOrNull == null ? '' : `${pxOrNull}px`);
      }
    }

    if (bodyTable) {
      const tds = bodyTable.querySelectorAll(
        `tbody td[data-col-key="${CSS.escape(colKey)}"]`
      );
      tds.forEach(td => {
        td.style.width = (pxOrNull == null ? '' : `${pxOrNull}px`);
      });
    }
  };

  // ðŸ”‘ NEW: ensure we have a mutable columns prefs object so we can persist
  const ensureColsPrefs = () => {
    window.__gridPrefs = window.__gridPrefs || { grid: {} };
    window.__gridPrefs.grid = window.__gridPrefs.grid || {};
    const g = window.__gridPrefs.grid;
    g[section] = g[section] || {};
    g[section].columns = g[section].columns || {};
    return g[section].columns;
  };

  (cols || []).forEach((k) => {
    let w = widthOf(k);

    // If no saved width, measure the header cellâ€™s current width
    if (w == null && headTable) {
      const th = headTable.querySelector(
        `thead th[data-col-key="${CSS.escape(k)}"]`
      );
      if (th) {
        const rect = th.getBoundingClientRect();
        w = Math.round(rect.width);
        if (w < MIN_W) w = MIN_W;
        if (w > MAX_W) w = MAX_W;

        // Persist this as the columnâ€™s width so future renders stay aligned
        const colsPrefs = ensureColsPrefs();
        colsPrefs[k] = { ...(colsPrefs[k] || {}), width: w };
        // Fire-and-forget; no need to await
        saveUserGridPrefsDebounced(section, { columns: colsPrefs });
      }
    }

    // Now apply the width (either from prefs or measured)
    if (w != null) {
      setColWidthPx(k, w);
    }
  });
}

function wireGridColumnResizing(section, tables) {
  const MIN_W = 80, MAX_W = 600;

  const headTable = (tables && tables.head) ? tables.head : tables;
  const bodyTable = (tables && tables.body) ? tables.body : tables;

  const ensureColsPrefs = () => {
    if (!window.__gridPrefs || typeof window.__gridPrefs !== 'object') {
      window.__gridPrefs = { grid: {} };
    }
    if (!window.__gridPrefs.grid || typeof window.__gridPrefs.grid !== 'object') {
      window.__gridPrefs.grid = {};
    }
    const g = window.__gridPrefs.grid;
    g[section] = g[section] || {};
    g[section].columns = g[section].columns || {};
    return g[section].columns;
  };

  let drag = null;

  const onMove = (ev) => {
    if (!drag) return;
    const dx = (ev.clientX || 0) - drag.startX;
    let w = Math.max(MIN_W, Math.min(MAX_W, drag.startW + dx));
    drag.th.style.width = `${w}px`;
    drag.cells.forEach(td => { td.style.width = `${w}px`; });
  };

  const onUp = () => {
    if (!drag) return;
    const th = drag.th;
    const key = th.dataset.colKey;
    const rect = th.getBoundingClientRect();
    const w = Math.max(MIN_W, Math.min(MAX_W, Math.round(rect.width)));
    const colsPrefs = ensureColsPrefs();
    colsPrefs[key] = { ...(colsPrefs[key] || {}), width: w };
    saveUserGridPrefsDebounced(section, { columns: colsPrefs });
    drag = null;
    document.removeEventListener('mousemove', onMove);
    document.removeEventListener('mouseup', onUp, true);
  };

  if (!headTable) return;

  headTable.querySelectorAll('thead th').forEach((th) => {
    const handle = th.querySelector('.col-resizer');
    if (!handle) return;

    handle.addEventListener('mousedown', (ev) => {
      ev.preventDefault();
      ev.stopPropagation();
      const key = th.dataset.colKey;
      const cells = bodyTable
        ? Array.from(bodyTable.querySelectorAll(`tbody td[data-col-key="${CSS.escape(key)}"]`))
        : [];
      drag = {
        th,
        startX: ev.clientX || 0,
        startW: Math.round(th.getBoundingClientRect().width || MIN_W),
        cells
      };
      document.addEventListener('mousemove', onMove);
      document.addEventListener('mouseup', onUp, true);
    });

    // Double-click handle resets width for this column to auto
    handle.addEventListener('dblclick', (ev) => {
      ev.preventDefault();
      ev.stopPropagation();
      const key = th.dataset.colKey;
      th.style.width = '';
      if (bodyTable) {
        bodyTable
          .querySelectorAll(`tbody td[data-col-key="${CSS.escape(key)}"]`)
          .forEach(td => { td.style.width = ''; });
      }
      const colsPrefs = ensureColsPrefs();
      if (colsPrefs[key]) delete colsPrefs[key].width;
      saveUserGridPrefsDebounced(section, { columns: colsPrefs });
    });
  });
}

// FRONTEND â€” wireGridColumnReorder
function wireGridColumnReorder(section, tables) {
  const headTable = (tables && tables.head) ? tables.head : tables;

  const ensureSectionPrefs = () => {
    if (!window.__gridPrefs || typeof window.__gridPrefs !== 'object') {
      window.__gridPrefs = { grid: {} };
    }
    if (!window.__gridPrefs.grid || typeof window.__gridPrefs.grid !== 'object') {
      window.__gridPrefs.grid = {};
    }
    const g = window.__gridPrefs.grid;
    g[section] = g[section] || {};
    g[section].columns = g[section].columns || {};
    return g[section];
  };

  if (!headTable) return;

  let dragKey = null;

  headTable.querySelectorAll('thead th[data-col-key]').forEach((th) => {
    if (!th.dataset.colKey) return;

    th.addEventListener('dragstart', (ev) => {
      dragKey = th.dataset.colKey;
      if (ev.dataTransfer) {
        ev.dataTransfer.setData('text/plain', dragKey);
        ev.dataTransfer.effectAllowed = 'move';
      }
    });

    th.addEventListener('dragover', (ev) => {
      ev.preventDefault();
      if (ev.dataTransfer) {
        ev.dataTransfer.dropEffect = 'move';
      }
    });

    th.addEventListener('drop', async (ev) => {
      ev.preventDefault();
      const targetKey = th.dataset.colKey;
      if (!dragKey || dragKey === targetKey) return;

      const headers = Array.from(headTable.querySelectorAll('thead th[data-col-key]'));
      const keys = headers.map((h) => h.dataset.colKey);

      const from = keys.indexOf(dragKey);
      const to   = keys.indexOf(targetKey);
      if (from < 0 || to < 0) return;

      // Move dragKey to the index of targetKey
      keys.splice(to, 0, keys.splice(from, 1)[0]);

      const secPrefs = ensureSectionPrefs();
      const colPrefs = { ...(secPrefs.columns || {}) };

      keys.forEach((k, i) => {
        colPrefs[k] = { ...(colPrefs[k] || {}), order: i };
      });

      await saveUserGridPrefsDebounced(section, { columns: colPrefs }, true);

      const data = await loadSection();
      renderSummary(data);
    });
  });
}

// === Shared field error helpers (red highlight + âœ–) =======================

function clearFieldErrors(root) {
  if (!root) return;
  root.querySelectorAll('.field-error, .error').forEach(el => {
    el.classList.remove('field-error');
    el.classList.remove('error');
  });
  root.querySelectorAll('.field-error-msg').forEach(el => el.remove());
  root.querySelectorAll('.field-error-icon').forEach(el => el.remove());
}

function markFieldError(root, fieldName, message) {
  if (!root) return;
  let field = root.querySelector(`[name="${fieldName}"]`);
  if (!field) field = root.querySelector(`#${fieldName}`);
  if (!field) return;

  const row = field.closest('.row') || field.parentElement;
  if (!row) return;

  row.classList.add('field-error');
  row.classList.add('error');
  field.classList.add('field-error');

  const label = row.querySelector('label');
  if (label && !label.querySelector('.field-error-icon')) {
    const icon = document.createElement('span');
    icon.className = 'field-error-icon';
    icon.textContent = 'âœ–';
    icon.style.color = 'red';
    icon.style.marginLeft = '4px';
    label.appendChild(icon);
  }

  if (message) {
    let msg = row.querySelector('.field-error-msg');
    if (!msg) {
      msg = document.createElement('div');
      msg.className = 'field-error-msg';
      msg.style.color = 'red';
      msg.style.fontSize = '0.8em';
      msg.style.marginTop = '4px';
      row.appendChild(msg);
    }
    msg.textContent = message;
  }
}

// === Candidate main tab validation =======================================

function validateCandidateMain(payload) {
  const root = document.querySelector('#tab-main');
  if (!root) return true;

  clearFieldErrors(root);
  let ok = true;

  const first = (payload.first_name || '').trim();
  const last  = (payload.last_name  || '').trim();
  if (!first) {
    ok = false;
    markFieldError(root, 'first_name', 'First name is required');
  }
  if (!last) {
    ok = false;
    markFieldError(root, 'last_name', 'Last name is required');
  }

  // Telephone: required, optional leading +, digits only, >= 11 digits
  const phoneRaw = (payload.phone || '').trim();
  if (!phoneRaw) {
    ok = false;
    markFieldError(root, 'phone', 'Telephone number is required');
  } else {
    const phoneDigits = phoneRaw.replace(/\D/g, '');
    const phonePattern = /^\+?\d+$/;
    if (!phonePattern.test(phoneRaw) || phoneDigits.length < 11) {
      ok = false;
      markFieldError(root, 'phone', 'Telephone must be numbers only (optionally leading +) and at least 11 digits');
    }
  }

  // Email: required, simple email format
  const emailRaw = (payload.email || '').trim();
  if (!emailRaw) {
    ok = false;
    markFieldError(root, 'email', 'Email is required');
  } else {
    const emailPattern = /^[^@\s]+@[^@\s]+\.[^@\s]+$/;
    if (!emailPattern.test(emailRaw)) {
      ok = false;
      markFieldError(root, 'email', 'Please enter a valid email address');
    }
  }

  // NI: optional, but if present must be AA999999A (2 letters, 6 digits, 1 letter)
  const niRaw = (payload.ni_number || '').trim();
  if (niRaw) {
    const normNi = niRaw.replace(/\s+/g, '').toUpperCase();
    const niPattern = /^[A-Z]{2}\d{6}[A-Z]$/;
    if (!niPattern.test(normNi)) {
      ok = false;
      markFieldError(root, 'ni_number', 'Format must be like JR547853B');
    } else {
      payload.ni_number = normNi; // normalise for save
    }
  }

  // Gender: must be selected (not blank option)
  const genderRaw = (payload.gender || '').trim();
  if (!genderRaw) {
    ok = false;
    markFieldError(root, 'gender', 'Please select a gender');
  }

  // Address: either completely blank, or must have line 1 AND postcode
  const address1 = (payload.address_line1 || '').trim();
  const address2 = (payload.address_line2 || '').trim();
  const address3 = (payload.address_line3 || '').trim();
  const town     = (payload.town_city     || '').trim();
  const county   = (payload.county        || '').trim();
  const postcode = (payload.postcode      || '').trim();

  const anyAddress = address1 || address2 || address3 || town || county || postcode;
  if (anyAddress) {
    if (!address1) {
      ok = false;
      markFieldError(root, 'address_line1', 'Address line 1 is required when an address is entered');
    }
    if (!postcode) {
      ok = false;
      markFieldError(root, 'postcode', 'Postcode is required when an address is entered');
    }
  }

  return ok;
}

// === Client main tab validation ==========================================

function validateClientMain(payload) {
  const root = document.querySelector('#tab-main');
  if (!root) return true;

  clearFieldErrors(root);
  let ok = true;

  const name = (payload.name || '').trim();
  if (!name) {
    ok = false;
    markFieldError(root, 'name', 'Client name is required');
  }

  // Primary invoice email: required, simple email format
  const emailRaw = (payload.primary_invoice_email || '').trim();
  if (!emailRaw) {
    ok = false;
    markFieldError(root, 'primary_invoice_email', 'Primary invoice email is required');
  } else {
    const emailPattern = /^[^@\s]+@[^@\s]+\.[^@\s]+$/;
    if (!emailPattern.test(emailRaw)) {
      ok = false;
      markFieldError(root, 'primary_invoice_email', 'Please enter a valid invoice email');
    }
  }

  // A/P phone: blank OR >= 8 digits, numbers only (no letters)
  const apPhoneRaw = (payload.ap_phone || '').trim();
  if (apPhoneRaw) {
    const digitsOnly = /^\d+$/;
    const digits = apPhoneRaw.replace(/\D/g, '');
    if (!digitsOnly.test(apPhoneRaw) || digits.length < 8) {
      ok = false;
      markFieldError(root, 'ap_phone', 'A/P phone must be numbers only and at least 8 digits if entered');
    }
  }

  return ok;
}





async function restoreGridPrefsToDefault(section) {
  try {
    const res = await authFetch(API('/api/users/me/grid-prefs'), {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ section, reset: true })
    });
    const prefs = await res.json().catch(() => null);
    if (prefs && typeof prefs === 'object' && prefs.grid) {
      window.__gridPrefs = prefs;
    } else {
      window.__gridPrefs = prefs || { grid: {} };
    }

    await loadUserGridPrefs(section);
    const data = await loadSection();
    renderSummary(data);
  } catch (e) {
    console.error('[GRID] restoreGridPrefsToDefault failed', e);
  }
}
// FRONTEND â€” attachHeaderContextMenu
function attachHeaderContextMenu(section, tables) {
  const headTable = (tables && tables.head) ? tables.head : tables;
  const bodyTable = (tables && tables.body) ? tables.body : tables;

  let menu = document.createElement('div');
  menu.style.cssText =
    'position:fixed;z-index:10000;background:#0b1528;border:1px solid var(--line);' +
    'padding:6px;border-radius:8px;display:none;min-width:220px;';
  document.body.appendChild(menu);

  const hide = () => { menu.style.display = 'none'; };
  document.addEventListener('click', hide);
  document.addEventListener('keydown', (e) => { if (e.key === 'Escape') hide(); });

  const mkItem = (label, cb) => {
    const it = document.createElement('div');
    it.textContent = label;
    it.style.cssText = 'padding:6px 10px;cursor:pointer;';
    it.addEventListener('click', () => { hide(); cb && cb(); });
    it.addEventListener('mouseover', () => { it.style.background = '#101c36'; });
    it.addEventListener('mouseout',  () => { it.style.background = 'transparent'; });
    return it;
  };

  const ensureSectionPrefs = () => {
    if (!window.__gridPrefs || typeof window.__gridPrefs !== 'object') {
      window.__gridPrefs = { grid: {} };
    }
    if (!window.__gridPrefs.grid || typeof window.__gridPrefs.grid !== 'object') {
      window.__gridPrefs.grid = {};
    }
    const g = window.__gridPrefs.grid;
    g[section] = g[section] || {};
    g[section].columns = g[section].columns || {};
    return g[section];
  };

  const resetAllWidths = () => {
    const sec = ensureSectionPrefs();
    const cols = { ...(sec.columns || {}) };
    Object.keys(cols).forEach((k) => {
      if ('width' in cols[k]) delete cols[k].width;
    });

    if (headTable) {
      headTable.querySelectorAll('thead th[data-col-key]').forEach((th) => {
        th.style.width = '';
      });
    }
    if (bodyTable) {
      bodyTable.querySelectorAll('tbody td[data-col-key]').forEach((td) => {
        td.style.width = '';
      });
    }

    saveUserGridPrefsDebounced(section, { columns: cols }, true);
  };

  const autoWidthThisColumn = (colKey) => {
    if (!headTable) return;
    const th = headTable.querySelector(`thead th[data-col-key="${CSS.escape(colKey)}"]`);
    if (!th) return;

    const cells = bodyTable
      ? bodyTable.querySelectorAll(`tbody td[data-col-key="${CSS.escape(colKey)}"]`)
      : [];

    const measure = (el) => Math.ceil(el.scrollWidth) + 16;
    let maxW = measure(th);
    cells.forEach((td) => { maxW = Math.max(maxW, measure(td)); });

    const w = Math.max(80, Math.min(600, maxW));
    th.style.width = `${w}px`;
    cells.forEach((td) => { td.style.width = `${w}px`; });

    const sec = ensureSectionPrefs();
    const cols = { ...(sec.columns || {}) };
    cols[colKey] = { ...(cols[colKey] || {}), width: w };
    saveUserGridPrefsDebounced(section, { columns: cols }, true);
  };

  if (!headTable) return;

  headTable.addEventListener('contextmenu', (ev) => {
    const th = ev.target && ev.target.closest('th');
    if (!th || !th.dataset || !th.dataset.colKey) return;
    ev.preventDefault();

    const colKey = th.dataset.colKey;
    menu.innerHTML = '';

    // Restore full layout for this section from backend defaults
    menu.appendChild(
      mkItem('Restore layout to default', () => {
        restoreGridPrefsToDefault(section);
      })
    );

    // Reset only widths for this section
    menu.appendChild(
      mkItem('Reset View (Auto widths)', () => resetAllWidths())
    );

    const hr = document.createElement('hr');
    hr.style.border = '1px solid var(' + '--line' + ')';
    menu.appendChild(hr);

    menu.appendChild(
      mkItem('Auto-size this column', () => autoWidthThisColumn(colKey))
    );

    menu.appendChild(
      mkItem('Reset this column width', () => {
        th.style.width = '';
        if (bodyTable) {
          bodyTable
            .querySelectorAll(`tbody td[data-col-key="${CSS.escape(colKey)}"]`)
            .forEach(td => { td.style.width = ''; });
        }

        const sec = ensureSectionPrefs();
        const cols = { ...(sec.columns || {}) };
        if (cols[colKey]) delete cols[colKey].width;
        saveUserGridPrefsDebounced(section, { columns: cols }, true);
      })
    );

    menu.appendChild(
      mkItem('Hide column', async () => {
        const sec = ensureSectionPrefs();
        const cols = { ...(sec.columns || {}) };
        cols[colKey] = { ...(cols[colKey] || {}), visible: false };
        await saveUserGridPrefsDebounced(section, { columns: cols }, true);
        const data = await loadSection();
        renderSummary(data);
      })
    );

    menu.appendChild(
      mkItem('Columnsâ€¦', () => openColumnsDialog(section))
    );

    // Position the context menu
    menu.style.left = `${ev.clientX}px`;
    menu.style.top  = `${ev.clientY}px`;
    menu.style.display = 'block';
  });
}

function openColumnsDialog(section) {
  const rootPrefs =
    (window.__gridPrefs &&
     window.__gridPrefs.grid &&
     window.__gridPrefs.grid[section]) || {};

  const colPrefs  = rootPrefs.columns      || {};
  const userMeta  = rootPrefs.columns_meta || {};
  const globalMeta = (typeof GRID_COLUMN_META_DEFAULTS === 'object' && GRID_COLUMN_META_DEFAULTS[section]) || {};

  const mergeMetaFor = (key) => ({
    ...(globalMeta[key] || {}),
    ...(userMeta[key]   || {})
  });

  const useFriendly = (rootPrefs.use_friendly_labels !== false);
  const labels      = rootPrefs.labels || {};

  // Build master key list: visible columns, defaults, current row keys
  const known = new Set(
    getVisibleColumnsForSection(section, currentRows).concat(defaultColumnsFor(section))
  );
  if (Array.isArray(currentRows) && currentRows[0]) {
    Object.keys(currentRows[0]).forEach(k => known.add(k));
  }

  // Filter out columns that are globally/user marked selectable:false
  const list = Array.from(known).filter(k => {
    const meta = mergeMetaFor(k);
    return meta.selectable !== false;
  });

  const overlay = document.createElement('div');
  overlay.style.cssText =
    'position:fixed;inset:0;background:rgba(0,0,0,0.5);z-index:10000;' +
    'display:flex;align-items:center;justify-content:center;';
  const modal = document.createElement('div');
  modal.style.cssText =
    'background:#0b152a;border:1px solid var(--line);border-radius:10px;' +
    'min-width:480px;max-width:80vw;max-height:80vh;overflow:auto;padding:14px;';
  overlay.appendChild(modal);

  const title = document.createElement('div');
  title.textContent = `Columns â€” ${section}`;
  title.style.cssText = 'font-weight:600;margin-bottom:10px;';
  modal.appendChild(title);

  // Friendly labels toggle
  const lblWrap = document.createElement('label');
  const lblCb = document.createElement('input');
  lblCb.type = 'checkbox';
  lblCb.checked = useFriendly;
  lblWrap.appendChild(lblCb);
  lblWrap.appendChild(document.createTextNode(' Use friendly header labels'));
  lblWrap.style.cssText = 'display:flex;align-items:center;gap:8px;margin-bottom:8px;font-size:12px;';
  modal.appendChild(lblWrap);

  lblCb.addEventListener('change', () => {
    saveUserGridPrefsDebounced(section, { use_friendly_labels: !!lblCb.checked });
  });

  // Table: Visible + Column key + Display name + Order
  const t = document.createElement('table');
  t.style.cssText = 'width:100%;border-collapse:collapse;font-size:12px;';
  t.innerHTML = `
    <thead>
      <tr>
        <th style="text-align:left;padding:6px;border-bottom:1px solid var(--line)">Visible</th>
        <th style="text-align:left;padding:6px;border-bottom:1px solid var(--line)">Column key</th>
        <th style="text-align:left;padding:6px;border-bottom:1px solid var(--line)">Display name</th>
        <th style="text-align:left;padding:6px;border-bottom:1px solid var(--line)">Order</th>
      </tr>
    </thead>
    <tbody></tbody>
  `;
  modal.appendChild(t);
  const tb = t.querySelector('tbody');

  const orderOf = (k) => {
    const cp = colPrefs[k];
    if (cp && typeof cp.order === 'number') return cp.order;
    const idx = defaultColumnsFor(section).indexOf(k);
    return (idx >= 0 ? idx : 9999);
  };

  const rowsModel = list
    .map(k => ({
      key: k,
      visible: (colPrefs[k]?.visible !== false),
      label: labels[k] || k,
      order: orderOf(k)
    }))
    .sort((a, b) => a.order - b.order);

  const persist = () => {
    const columns   = {};
    const labelsOut = {};
    const metaOut   = { ...(rootPrefs.columns_meta || {}) }; // carry existing meta

    rowsModel.forEach((r, idx) => {
      columns[r.key] = { visible: !!r.visible, order: r.order };
      labelsOut[r.key] = String(r.label || r.key);
    });

    saveUserGridPrefsDebounced(section, {
      columns,
      labels: labelsOut,
      columns_meta: metaOut,
      use_friendly_labels: !!lblCb.checked
    });
  };

  const reindex = () => {
    rowsModel.forEach((r, i) => { r.order = i; });
    persist();
    refresh();
  };

  const refresh = () => {
    tb.innerHTML = '';
    rowsModel.sort((a, b) => a.order - b.order).forEach(r => {
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td style="padding:6px"><input type="checkbox" ${r.visible ? 'checked' : ''}></td>
        <td style="padding:6px;font-family:monospace">${r.key}</td>
        <td style="padding:6px"><input type="text" style="width:100%;background:#000;border:1px solid var(--line);color:var(--text);border-radius:6px;padding:4px 8px;font-size:12px;"></td>
        <td style="padding:6px;white-space:nowrap">
          <button class="btn mini" data-move="up">â–²</button>
          <button class="btn mini" data-move="down">â–¼</button>
        </td>
      `;

      const elVisible = tr.querySelector('td:nth-child(1) input');
      const elLabel   = tr.querySelector('td:nth-child(3) input');
      const btnUp     = tr.querySelector('button[data-move="up"]');
      const btnDown   = tr.querySelector('button[data-move="down"]');

      elLabel.value = r.label;

      elVisible.addEventListener('change', () => {
        r.visible = !!elVisible.checked;
        persist();
      });

      elLabel.addEventListener('change', () => {
        r.label = elLabel.value;
        persist();
      });

      btnUp.addEventListener('click', () => {
        const i = rowsModel.indexOf(r);
        if (i > 0) {
          [rowsModel[i - 1], rowsModel[i]] = [rowsModel[i], rowsModel[i - 1]];
          reindex();
        }
      });

      btnDown.addEventListener('click', () => {
        const i = rowsModel.indexOf(r);
        if (i >= 0 && i < rowsModel.length - 1) {
          [rowsModel[i + 1], rowsModel[i]] = [rowsModel[i], rowsModel[i - 1]];
          reindex();
        }
      });

      tb.appendChild(tr);
    });
  };

  refresh();

  // Footer: Reset widths + Close
  const footer = document.createElement('div');
  footer.style.cssText = 'display:flex;justify-content:space-between;gap:8px;margin-top:10px;';
  const left  = document.createElement('div');
  const right = document.createElement('div');
  footer.appendChild(left);
  footer.appendChild(right);

  const btnResetWidths = document.createElement('button');
  btnResetWidths.textContent = 'Reset all widths';
  btnResetWidths.className = 'btn mini';
  btnResetWidths.addEventListener('click', () => {
    const prefsRoot =
      (window.__gridPrefs &&
       window.__gridPrefs.grid &&
       window.__gridPrefs.grid[section]) || {};

    const cols = { ...(prefsRoot.columns || {}) };
    Object.keys(cols).forEach(k => { if ('width' in cols[k]) delete cols[k].width; });
    saveUserGridPrefsDebounced(section, { columns: cols });
  });
  left.appendChild(btnResetWidths);

  const btnClose = document.createElement('button');
  btnClose.textContent = 'Close';
  btnClose.className = 'btn mini';
  btnClose.addEventListener('click', async () => {
    document.body.removeChild(overlay);
    const data = await loadSection();
    renderSummary(data);
  });
  right.appendChild(btnClose);

  modal.appendChild(footer);
  document.body.appendChild(overlay);
}


function loadSession(){
  try {
    const raw = localStorage.getItem('cloudtms.session') || sessionStorage.getItem('cloudtms.session');
    const sess = raw ? JSON.parse(raw) : null;
    if (!sess || !sess.accessToken) return false;
    saveSession(sess);             // mirrors globals & schedules refresh
    return true;
  } catch { return false; }
}


// Get label honoring section prefs toggle and overrides
function getFriendlyHeaderLabel(section, key) {
  const prefs = (window.__gridPrefs && window.__gridPrefs.grid && window.__gridPrefs.grid[section]) || {};
  const useFriendly = prefs.use_friendly_labels !== false; // default ON
  if (!useFriendly) return key;

  const overrides = prefs.labels || {};
  const def = (DEFAULT_COLUMN_LABELS[section] || {});
  const hit = overrides[key] || def[key];
  if (hit) return hit;

  const k = String(key || '');
  if (k.includes('_')) {
    const raw = k.replace(/_/g, ' ').toLowerCase();
    const tc = raw.replace(/\b\w/g, (c) => c.toUpperCase());
    return tc
      .replace(/\bNhsp\b/g, 'NHSP')
      .replace(/\bHr\b/g, 'HR')
      .replace(/\bNhs\b/g, 'NHS')
      .replace(/\bVat\b/g, 'VAT');
  }

  return k;
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UPDATED: loadSection()
// - After loading the visible page, triggers background priming of membership
//   (ALL matching ids for current filters) regardless of page size.
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UPDATED: loadSection()
// - Ensures grid prefs are loaded
// - Defaults Contracts status quick filter to "active"
// - After loading the visible page, triggers background priming of membership
//   (ALL matching ids for current filters) regardless of page size.
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function loadSection() {
  const gl = beginGlobalLoading('Loading listâ€¦');

  try {
    window.__listState = window.__listState || {};
    const st = (window.__listState[currentSection] ||= {
      page: 1,
      pageSize: 50,
      total: null,
      hasMore: false,
      filters: null,
      sort: { key: null, dir: 'asc' }
    });

    // Ensure sort object exists (for older sessions where it wasn't seeded)
    if (!st.sort || typeof st.sort !== 'object') {
      st.sort = { key: null, dir: 'asc' };
    }

    // âœ… Related mode detection (exclusive list mode)
    const related = (st.filters && typeof st.filters === 'object' && st.filters.related && typeof st.filters.related === 'object')
      ? st.filters.related
      : null;

    const inRelatedMode =
      !!related &&
      String(related.source_entity || '').trim() &&
      String(related.source_id || '').trim() &&
      String(related.relation_type || '').trim();

    // Default Contracts quick-filter to "active" if nothing specified
    // âœ… Ignore incompatible normal defaults while in related mode
    if (!inRelatedMode && currentSection === 'contracts') {
      if (!st.filters || typeof st.filters !== 'object') st.filters = {};
      if (!('status' in st.filters) || !st.filters.status) {
        st.filters.status = 'active';
      }
    }

    // âœ… Default Invoices filter (only if not already specified)
    // âœ… Ignore incompatible normal defaults while in related mode
    if (!inRelatedMode && currentSection === 'invoices') {
      if (!st.filters || typeof st.filters !== 'object') st.filters = {};
      const cur = st.filters.status;
      const hasStatus =
        (Array.isArray(cur) && cur.length > 0) ||
        (typeof cur === 'string' && cur.trim().length > 0);
      if (!hasStatus) {
        st.filters.status = ['DRAFT','ON_HOLD','ISSUED','PAID'];
      }
    }

    // Ensure user grid prefs are loaded once per session (per section).
    await loadUserGridPrefs(currentSection);

    const hasFilters = !!st.filters && Object.keys(st.filters).length > 0;
    const hasSort    = !!(st.sort && st.sort.key);

    // âœ… ALWAYS use search for candidates + contracts + invoices
    // âœ… But related mode is a dedicated branch and does NOT use search()
    const useSearch =
      (currentSection === 'candidates' || currentSection === 'contracts' || currentSection === 'invoices')
        ? true
        : (hasFilters || hasSort);

    const fetchRelatedPage = async (section, page, pageSize, rel) => {
      // âœ… Keep fetchRelated(...) as the single fetcher for related views.
      // It handles v2 RPC routing server-side and normalizes via toList().
      //
      // NOTE: the related endpoint may not return the same row shape as the normal list/search endpoint.
      // For invoices specifically, the summary grid expects the canonical /api/search/invoices shape so
      // configured columns work. We therefore:
      //   1) fetch related â†’ extract ids
      //   2) fetch canonical invoices via search('invoices', { ids })
      //   3) return canonical rows (same shape as normal invoices list)

      window.__listState = window.__listState || {};
      const stSec = (window.__listState[section] ||= {
        page: 1,
        pageSize: 50,
        total: null,
        hasMore: false,
        filters: null,
        sort: { key: null, dir: 'asc' }
      });

      stSec.page = page;
      stSec.pageSize = pageSize;

      const srcEntity = String(rel.source_entity || '').trim();
      const srcId     = String(rel.source_id || '').trim();
      const relType   = String(rel.relation_type || '').trim();

      // fetchRelated returns a normalized list via toList(res)
      const list = await fetchRelated(srcEntity, srcId, relType);

      // Tolerate both shapes:
      // - { items: [...], total: number|null }
      // - [...items] (legacy)
      const items = Array.isArray(list?.items) ? list.items : (Array.isArray(list) ? list : []);
      const totalFromApi = (list && typeof list === 'object' && typeof list.total === 'number') ? list.total : null;

      // âœ… SPECIAL CASE: invoices in related mode â†’ return canonical row shape (so configured columns work)
      if (section === 'invoices') {
        const idsAll = [];
        try {
          (items || []).forEach(it => {
            if (!it || typeof it !== 'object') return;
            const id = it.id ?? it.invoice_id ?? null;
            if (id != null) idsAll.push(String(id));
          });
        } catch {}

        // de-dupe but keep first-seen order
        const seen = new Set();
        const idsDedup = [];
        for (const id of idsAll) {
          const s = String(id || '').trim();
          if (!s || seen.has(s)) continue;
          seen.add(s);
          idsDedup.push(s);
        }

        const total = (typeof totalFromApi === 'number') ? totalFromApi : idsDedup.length;
        stSec.total = total;

        const ps = (pageSize === 'ALL') ? idsDedup.length : Number(pageSize || 50);
        const pg = Math.max(1, Number(page || 1));

        stSec.hasMore =
          (typeof total === 'number')
            ? ((pg * ps) < total)
            : (idsDedup.length > ((pg - 1) * ps + ps));

        // Apply paging slice locally (related endpoint may not page)
        let pageIds = idsDedup;
        if (pageSize !== 'ALL') {
          const start = (pg - 1) * ps;
          pageIds = idsDedup.slice(start, start + ps);
        }

        if (!pageIds.length) return [];

        // Canonical fetch via existing invoices search pipeline
        const canon = await search('invoices', { ids: pageIds });

        const canonRows = Array.isArray(canon?.rows) ? canon.rows : (Array.isArray(canon) ? canon : []);

        // Preserve the related id order if the search endpoint returns different order
        const byId = new Map();
        canonRows.forEach(r => {
          const rid = r && (r.id ?? r.invoice_id);
          if (rid != null) byId.set(String(rid), r);
        });

        const ordered = [];
        pageIds.forEach(id => {
          const row = byId.get(String(id)) || null;
          if (row) ordered.push(row);
        });

        // If anything didnâ€™t match (defensive), append remaining rows
        if (ordered.length !== canonRows.length) {
          canonRows.forEach(r => {
            const rid = r && (r.id ?? r.invoice_id);
            const k = (rid != null) ? String(rid) : '';
            if (!k) return;
            if (pageIds.includes(k) && byId.get(k) && ordered.find(x => String((x.id ?? x.invoice_id) || '') === k)) return;
            if (!ordered.includes(r)) ordered.push(r);
          });
        }

        return ordered;
      }

      // Default: non-invoices related mode returns related endpoint items as-is
      stSec.total = totalFromApi;

      const ps = (pageSize === 'ALL') ? items.length : Number(pageSize || 50);
      const pg = Math.max(1, Number(page || 1));

      stSec.hasMore =
        (typeof totalFromApi === 'number')
          ? ((pg * ps) < totalFromApi)
          : (Array.isArray(items) && items.length === ps);

      return items;
    };

    const fetchOne = async (section, page, pageSize) => {
      window.__listState[section].page = page;
      window.__listState[section].pageSize = pageSize;

      // âœ… Related mode branch (exclusive; ignore other filters)
      if (inRelatedMode) {
        return await fetchRelatedPage(section, page, pageSize, related);
      }

      // Timesheets always go via the summary endpoint (v_timesheets_summary)
      if (section === 'timesheets') {
        const filters = window.__listState[section].filters || {};
        return await listTimesheetsSummary(filters);
      }

      if (useSearch) {
        return await search(section, window.__listState[section].filters || {});
      } else {
        switch (section) {
          case 'candidates': return await listCandidates();
          case 'clients':    return await listClients();
          case 'umbrellas':  return await listUmbrellas();
          case 'settings':   return await getSettings();
          case 'audit':      return await listOutbox();
          default:           return [];
        }
      }
    };

    // PageSize = ALL â†’ fetch all pages sequentially (respecting filters + sort)
    // âœ… Related mode: keep using the single related fetcher; just page through.
    if (st.pageSize === 'ALL') {
      const acc = [];
      let p = 1;

      // Related fetcher is page-based; use 200 for non-related, and 100 for related if backend caps.
      const chunk = inRelatedMode ? 100 : 200;

      let gotMore = true;
      while (gotMore) {
        const rows = await fetchOne(currentSection, p, chunk);
        acc.push(...(rows || []));

        if (inRelatedMode) {
          const total = window.__listState[currentSection].total;
          if (typeof total === 'number') {
            gotMore = acc.length < total;
          } else {
            gotMore = Array.isArray(rows) && rows.length === chunk;
          }
        } else {
          gotMore = Array.isArray(rows) && rows.length === chunk;
        }

        p += 1;
        if (!gotMore) break;
      }

      window.__listState[currentSection].page = 1;
      window.__listState[currentSection].hasMore = false;
      window.__listState[currentSection].total = acc.length;

      try {
        primeSummaryMembership(currentSection, getSummaryFingerprint(currentSection));
      } catch {}
      return acc;
    }

    // Normal paged case
    const page = Number(st.page || 1);
    const ps   = Number(st.pageSize || 50);

    const rows = await fetchOne(currentSection, page, ps);

    // âœ… In related mode, hasMore/total are set by fetchRelatedPage()
    if (!inRelatedMode) {
      const hasMore = Array.isArray(rows) && rows.length === ps;
      window.__listState[currentSection].hasMore = hasMore;
    }

    try {
      primeSummaryMembership(currentSection, getSummaryFingerprint(currentSection));
    } catch {}
    return rows;
  } finally {
    endGlobalLoading();
  }
}



function clearSession(){
  localStorage.removeItem('cloudtms.session');
  sessionStorage.removeItem('cloudtms.session');
  SESSION = null; renderUserChip();
}
function scheduleRefresh(){
  clearTimeout(refreshTimer);
  if (!SESSION?.exp) return;
  const ms = Math.max(15_000, (SESSION.exp*1000) - Date.now() - 60_000);
  refreshTimer = setTimeout(refreshToken, ms);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// API helpers: Assignment â†” Band mappings
// Endpoints (backend):
//  GET    /api/assignment-band-mappings
//  POST   /api/assignment-band-mappings
//  PATCH  /api/assignment-band-mappings/:id
//  DELETE /api/assignment-band-mappings/:id   (soft delete on backend)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function __qs(params) {
  const q = new URLSearchParams();
  Object.entries(params || {}).forEach(([k, v]) => {
    if (v === undefined || v === null) return;
    const s = String(v);
    if (!s.trim()) return;
    q.set(k, s);
  });
  const out = q.toString();
  return out ? `?${out}` : '';
}

function __unwrapRows(json) {
  if (!json) return [];
  if (Array.isArray(json)) return json;
  if (Array.isArray(json.rows)) return json.rows;
  if (Array.isArray(json.items)) return json.items;
  if (Array.isArray(json.data)) return json.data;
  return [];
}

function __unwrapSingle(json) {
  if (!json) return null;
  if (json.row && typeof json.row === 'object') return json.row;
  if (json.item && typeof json.item === 'object') return json.item;
  if (json.data && typeof json.data === 'object') return json.data;
  if (typeof json === 'object' && !Array.isArray(json)) return json;
  return null;
}



async function apiCreateAssignmentBandMapping(payload) {
  const res = await authFetch(API(`/api/assignment-band-mappings`), {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify(payload || {})
  });

  const txt = await res.text().catch(() => '');
  if (!res.ok) throw new Error(txt || `Failed to create assignment-band-mapping (${res.status})`);

  let json;
  try { json = txt ? JSON.parse(txt) : null; } catch { json = null; }

  return __unwrapSingle(json);
}

async function apiUpdateAssignmentBandMapping(id, patch) {
  if (!id) throw new Error('Missing id for apiUpdateAssignmentBandMapping');
  const encId = encodeURIComponent(String(id));

  const res = await authFetch(API(`/api/assignment-band-mappings/${encId}`), {
    method: 'PATCH',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify(patch || {})
  });

  const txt = await res.text().catch(() => '');
  if (!res.ok) throw new Error(txt || `Failed to update assignment-band-mapping (${res.status})`);

  let json;
  try { json = txt ? JSON.parse(txt) : null; } catch { json = null; }

  return __unwrapSingle(json);
}

async function apiDeleteAssignmentBandMapping(id) {
  if (!id) throw new Error('Missing id for apiDeleteAssignmentBandMapping');
  const encId = encodeURIComponent(String(id));

  const res = await authFetch(API(`/api/assignment-band-mappings/${encId}`), {
    method: 'DELETE'
  });

  const txt = await res.text().catch(() => '');
  if (!res.ok) throw new Error(txt || `Failed to delete assignment-band-mapping (${res.status})`);

  let json;
  try { json = txt ? JSON.parse(txt) : null; } catch { json = null; }

  // backend returns the updated row (active=false) if using soft delete
  return __unwrapSingle(json) || { id };
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// API helpers: Import Column Aliases
// Endpoints (backend):
//  GET    /api/import-column-aliases
//  POST   /api/import-column-aliases
//  PATCH  /api/import-column-aliases/:id
//  DELETE /api/import-column-aliases/:id   (soft delete on backend)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function apiListImportColumnAliases(params) {
  const p = params || {};
  const query = __qs({
    system_type: p.system_type,
    field_key: p.field_key,
    include_inactive: p.include_inactive ? 'true' : undefined
  });

  const res = await authFetch(API(`/api/import-column-aliases${query}`), { method: 'GET' });
  const txt = await res.text().catch(() => '');
  if (!res.ok) throw new Error(txt || `Failed to list import-column-aliases (${res.status})`);

  let json;
  try { json = txt ? JSON.parse(txt) : null; } catch { json = null; }

  return __unwrapRows(json);
}

async function apiCreateImportColumnAlias(payload) {
  const res = await authFetch(API(`/api/import-column-aliases`), {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify(payload || {})
  });

  const txt = await res.text().catch(() => '');
  if (!res.ok) throw new Error(txt || `Failed to create import-column-alias (${res.status})`);

  let json;
  try { json = txt ? JSON.parse(txt) : null; } catch { json = null; }

  return __unwrapSingle(json);
}

async function apiUpdateImportColumnAlias(id, patch) {
  if (!id) throw new Error('Missing id for apiUpdateImportColumnAlias');
  const encId = encodeURIComponent(String(id));

  const res = await authFetch(API(`/api/import-column-aliases/${encId}`), {
    method: 'PATCH',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify(patch || {})
  });

  const txt = await res.text().catch(() => '');
  if (!res.ok) throw new Error(txt || `Failed to update import-column-alias (${res.status})`);

  let json;
  try { json = txt ? JSON.parse(txt) : null; } catch { json = null; }

  return __unwrapSingle(json);
}

async function apiDeleteImportColumnAlias(id) {
  if (!id) throw new Error('Missing id for apiDeleteImportColumnAlias');
  const encId = encodeURIComponent(String(id));

  const res = await authFetch(API(`/api/import-column-aliases/${encId}`), {
    method: 'DELETE'
  });

  const txt = await res.text().catch(() => '');
  if (!res.ok) throw new Error(txt || `Failed to delete import-column-alias (${res.status})`);

  let json;
  try { json = txt ? JSON.parse(txt) : null; } catch { json = null; }

  return __unwrapSingle(json) || { id };
}



// Unwrap list/envelope responses into arrays
async function toList(res) {
  if (!res.ok) throw new Error(`Request failed: ${res.status}`);
  const j = await res.json();
  if (Array.isArray(j)) return j;
  if (Array.isArray(j.items)) return j.items;
  if (Array.isArray(j.rows))  return j.rows;
  if (j.data && Array.isArray(j.data)) return j.data;
  return [];
}

// --- helpers for normalising/time validation ---
function _toHHMM(val) {
  if (val == null) return '';
  const s = String(val).trim();
  if (!s) return '';
  // accept HH:MM, HH:MM:SS, H:MM, HHMM
  const m = s.match(/^(\d{1,2}):?(\d{2})(?::(\d{2}))?$/);
  if (!m) return '';
  let hh = Number(m[1]), mm = Number(m[2]);
  if (!Number.isFinite(hh) || !Number.isFinite(mm) || hh < 0 || hh > 23 || mm < 0 || mm > 59) return '';
  return String(hh).padStart(2,'0') + ':' + String(mm).padStart(2,'0');
}

function _toHHMMSS(val) {
  const hm = _toHHMM(val);
  return hm ? hm + ':00' : null; // server likes HH:MM:SS (supabase time)
}

// Build a clean object to send to the API

function normalizeClientSettingsForSave(raw) {
  const src = raw || {};
  const out = {};
  let invalid = false;

  const asBool = (v) => {
    if (v === true) return true;
    if (v === false) return false;
    const s = String(v ?? '').trim().toLowerCase();
    return s === 'true' || s === 'yes' || s === 'y' || s === '1' || s === 'on';
  };

  // When settings are coming from the mounted UI, we can safely default missing keys.
  // This prevents â€œuncheckedâ€ boxes becoming â€œmissing keyâ€.
  const fromUi = (src && src.__from_ui === true);

  const isHHMM = (s) => {
    if (typeof s !== 'string') return false;
    const m = /^(\d{2}):(\d{2})$/.exec(s.trim());
    if (!m) return false;
    const hh = Number(m[1]), mm = Number(m[2]);
    return Number.isInteger(hh) && Number.isInteger(mm) && hh >= 0 && hh <= 23 && mm >= 0 && mm <= 59;
  };

  // âœ… Time windows (include even when blank; validate HH:MM when present)
  // âœ… Includes bh_start + bh_end
  const TIME_KEYS = [
    'day_start','day_end','night_start','night_end',
    'sat_start','sat_end','sun_start','sun_end',
    'bh_start','bh_end'
  ];

  for (const k of TIME_KEYS) {
    if (fromUi || (k in src)) {
      const v = (src[k] == null) ? '' : String(src[k]).trim();
      if (v === '') out[k] = null;            // allow clearing
      else if (isHHMM(v)) out[k] = v;
      else invalid = true;
    }
  }

  // âœ… timezone_id (allow null)
  if (fromUi || ('timezone_id' in src)) {
    const tz = (src.timezone_id == null) ? '' : String(src.timezone_id).trim();
    out.timezone_id = (tz === '') ? null : tz;
  }

  // âœ… week_ending_weekday (0..6; 0 is valid) â€” keep NULL if empty
  if (fromUi || ('week_ending_weekday' in src)) {
    const rawW = src.week_ending_weekday;
    if (rawW === '' || rawW === null || rawW === undefined) {
      out.week_ending_weekday = null;
    } else {
      const n = Number(rawW);
      if (!Number.isInteger(n) || n < 0 || n > 6) invalid = true;
      else out.week_ending_weekday = n;
    }
  }

  // âœ… Auto-invoice by default (client-level) â€” was missing
  if (fromUi || ('auto_invoice_default' in src)) {
    out.auto_invoice_default = asBool(src.auto_invoice_default);
  }
  const BOOL_KEYS = [
    'pay_reference_required',
    'invoice_reference_required',
    'requires_hr',
    'hr_validation_required',
    'autoprocess_hr',
    'hr_attach_to_invoice',
    'ts_attach_to_invoice',
    'is_nhsp',
    'self_bill_no_invoices_sent',
    'daily_calc_of_invoices',
    'no_timesheet_required',
    'group_nightsat_sunbh'
  ];


  for (const k of BOOL_KEYS) {
    if (fromUi || (k in src)) {
      out[k] = asBool(src[k]);
    }
  }

  // default submission mode (only include if UI provided it or it exists)
  if (fromUi || ('default_submission_mode' in src)) {
    let mode = String(src.default_submission_mode || '').toUpperCase();
    if (mode !== 'ELECTRONIC' && mode !== 'MANUAL') mode = 'ELECTRONIC';
    out.default_submission_mode = mode;
  }

  return { cleaned: out, invalid };
}




// ===== Auth fetch with refresh retry =====

async function apiPostJson(path, body) {
  const url = API(path);

  const hasBody = (body !== undefined && body !== null);
  const init = {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' }
  };
  if (hasBody) init.body = JSON.stringify(body);

  let res, txt = '', parsed = null;

  try {
    res = await authFetch(url, init);
    txt = await res.text().catch(() => '');
  } catch (e) {
    // network / CORS / authFetch failure (no HTTP status)
    throw e;
  }

  try { parsed = txt ? JSON.parse(txt) : null; } catch { parsed = null; }

  if (!res.ok) {
    const msg =
      (parsed && typeof parsed === 'object' && (parsed.message || parsed.error))
        ? String(parsed.message || parsed.error)
        : (txt || `Request failed (${res.status})`);

    const err = new Error(msg);
    err.status = res.status;
    err.body = txt || '';
    err.json = parsed;
    throw err;
  }

  return (parsed != null) ? parsed : {};
}

async function apiPatchJson(path, body) {
  const url = API(path);

  const hasBody = (body !== undefined && body !== null);
  const init = {
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' }
  };
  if (hasBody) init.body = JSON.stringify(body);

  let res, txt = '', parsed = null;

  try {
    res = await authFetch(url, init);
    txt = await res.text().catch(() => '');
  } catch (e) {
    throw e;
  }

  try { parsed = txt ? JSON.parse(txt) : null; } catch { parsed = null; }

  if (!res.ok) {
    const msg =
      (parsed && typeof parsed === 'object' && (parsed.message || parsed.error))
        ? String(parsed.message || parsed.error)
        : (txt || `Request failed (${res.status})`);

    const err = new Error(msg);
    err.status = res.status;
    err.body = txt || '';
    err.json = parsed;
    throw err;
  }

  return (parsed != null) ? parsed : {};
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Weekly import helpers
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Weekly resolve helpers (NHSP + HR_WEEKLY)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function postWeeklyResolveMappings(importId, type, payload) {
  const LOG = (typeof window.__LOG_IMPORTS === 'boolean') ? window.__LOG_IMPORTS : true;
  const L   = (...a) => { if (LOG) console.log('[IMPORTS][WEEKLY][RESOLVE]', ...a); };

  if (!importId) {
    throw new Error('Missing importId for postWeeklyResolveMappings');
  }
  if (!type) {
    throw new Error('Missing type for postWeeklyResolveMappings');
  }

  const t = String(type || '').toUpperCase();

  let urlPath;
  if (t === 'NHSP') {
    urlPath = `/api/nhsp/${encodeURIComponent(importId)}/resolve-conflicts`;
  } else if (t === 'HR_WEEKLY') {
    urlPath = `/api/healthroster/autoprocess/${encodeURIComponent(importId)}/resolve-conflicts`;
  } else {
    throw new Error(`Unsupported weekly import type for resolve-conflicts: ${t}`);
  }

  const candidate_mappings = Array.isArray(payload?.candidate_mappings)
    ? payload.candidate_mappings
    : [];

  const client_aliases = Array.isArray(payload?.client_aliases)
    ? payload.client_aliases
    : [];

  if (!candidate_mappings.length && !client_aliases.length) {
    L('no mappings to send; returning early', { importId, type: t });
    return { ok: true, candidate_mappings_applied: 0, client_aliases_applied: 0 };
  }

  if (typeof authFetch !== 'function' || typeof API !== 'function') {
    throw new Error('authFetch/API helper missing in postWeeklyResolveMappings');
  }

  const url = API(urlPath);

  // Debug log of hr_row_ids being sent for client aliases
  const aliasDebug = client_aliases.map(a => ({
    client_id: a.client_id || null,
    hr_row_ids: Array.isArray(a.hr_row_ids) ? a.hr_row_ids : [],
    hospital_norm: a.hospital_norm || null
  }));

  L('posting weekly resolve-conflicts', {
    importId,
    type: t,
    url,
    candidate_mappings_count: candidate_mappings.length,
    client_aliases_count: client_aliases.length,
    client_aliases_hr_row_ids: aliasDebug
  });

  const res  = await authFetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ candidate_mappings, client_aliases })
  });

  const text = await res.text().catch(() => '');

  if (!res.ok) {
    let msg = text || `Weekly resolve-conflicts failed (${res.status})`;

    // Try to pull a nicer message from JSON
    try {
      if (text) {
        const parsed = JSON.parse(text);
        if (parsed && typeof parsed === 'object') {
          if (parsed.message && typeof parsed.message === 'string') {
            msg = parsed.message;
          } else if (parsed.error && typeof parsed.error === 'string') {
            msg = parsed.error;
          }
        }
      }
    } catch {
      // ignore JSON parse errors, fall back to text/default
    }

    L('resolve-conflicts ERROR', { status: res.status, msg, raw: text });
    throw new Error(msg);
  }

  let json = {};
  try { json = text ? JSON.parse(text) : {}; } catch {
    json = { ok: true };
  }

  L('resolve-conflicts OK', json);
  return json;
}




// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// HR Rota Daily helpers
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function refreshHrRotaSummary(importId) {
  const LOG = (typeof window.__LOG_IMPORTS === 'boolean') ? window.__LOG_IMPORTS : true;
  const L   = (...a) => { if (LOG) console.log('[IMPORTS][HR_ROTA][REFRESH]', ...a); };

  try {
    if (!importId) {
      throw new Error('Missing importId for refreshHrRotaSummary');
    }

    if (typeof authFetch !== 'function' || typeof API !== 'function') {
      throw new Error('authFetch/API helper missing in refreshHrRotaSummary');
    }

    const url = `/api/imports/hr-rota/${encodeURIComponent(importId)}/preview`;
    L('fetching HR rota preview', { importId, url: API(url) });

    const res  = await authFetch(API(url));
    const text = await res.text();
    if (!res.ok) {
      throw new Error(text || `HR rota preview refresh failed (${res.status})`);
    }

    const summaryState = text ? JSON.parse(text) : {};
    if (typeof renderImportSummaryModal === 'function') {
      renderImportSummaryModal('HR_ROTA_DAILY', summaryState);
    } else {
      throw new Error('renderImportSummaryModal is not defined');
    }
  } catch (e) {
    console.error('[IMPORTS][HR_ROTA][REFRESH] failed', e);
    const msg = e?.message || 'Failed to refresh HR rota daily summary.';
    if (window.__toast) window.__toast(msg); else alert(msg);
  }
}

async function postHrRotaResolveMappings(importId, payload) {
  const LOG = (typeof window.__LOG_IMPORTS === 'boolean') ? window.__LOG_IMPORTS : true;
  const L   = (...a) => { if (LOG) console.log('[IMPORTS][HR_ROTA][RESOLVE]', ...a); };

  if (!importId) {
    throw new Error('Missing importId for postHrRotaResolveMappings');
  }

  const body = payload || {};
  const candidate_mappings = Array.isArray(body.candidate_mappings) ? body.candidate_mappings : [];
  const client_aliases     = Array.isArray(body.client_aliases)     ? body.client_aliases     : [];

  // âœ… NEW: optional role mappings (hr_row_id â†’ selected target id)
  const role_mappings =
    Array.isArray(body.role_mappings) ? body.role_mappings :
    Array.isArray(body.timesheet_target_mappings) ? body.timesheet_target_mappings :
    Array.isArray(body.roleMappings) ? body.roleMappings :
    [];

  if (!candidate_mappings.length && !client_aliases.length && !role_mappings.length) {
    L('no mappings to send; returning early', { importId });
    return {
      ok: true,
      candidate_mappings_applied: 0,
      client_aliases_applied: 0,
      role_mappings_applied: 0
    };
  }

  if (typeof authFetch !== 'function' || typeof API !== 'function') {
    throw new Error('authFetch/API helper missing in postHrRotaResolveMappings');
  }

  const url = `/api/imports/hr-rota/${encodeURIComponent(importId)}/resolve-conflicts`;

  const aliasDebug = client_aliases.map(a => ({
    client_id: a.client_id || null,
    hr_row_ids: Array.isArray(a.hr_row_ids) ? a.hr_row_ids : [],
    hospital_norm: a.hospital_norm || null
  }));

  const roleDebug = role_mappings.map(r => ({
    hr_row_id: r.hr_row_id || null,
    target_id: r.target_id || r.timesheet_target_id || null,
    candidate_id: r.candidate_id || null,
    client_id: r.client_id || null,
    work_date: r.work_date || null,
    grade_raw: r.grade_raw || null
  }));

  L('posting HR rota resolve-conflicts', {
    importId,
    url: API(url),
    candidate_mappings_count: candidate_mappings.length,
    client_aliases_count: client_aliases.length,
    role_mappings_count: role_mappings.length,
    client_aliases_hr_row_ids: aliasDebug,
    role_mappings_debug: roleDebug
  });

  // âœ… Only include role_mappings if present (backward compatible with older backend)
  const postBody = { candidate_mappings, client_aliases };
  if (role_mappings.length) postBody.role_mappings = role_mappings;

  const res  = await authFetch(API(url), {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(postBody)
  });

  const text = await res.text().catch(() => '');
  if (!res.ok) {
    const msg = text || `HR rota resolve-conflicts failed (${res.status})`;
    throw new Error(msg);
  }

  let json = {};
  try { json = text ? JSON.parse(text) : {}; } catch {}

  L('resolve-conflicts OK', json);
  return json;
}

function openHrRotaAssignCandidateModal(importId, rowIndex) {
  const LOG = (typeof window.__LOG_IMPORTS === 'boolean') ? window.__LOG_IMPORTS : true;
  const L   = (...a) => { if (LOG) console.log('[IMPORTS][HR_ROTA][ASSIGN_CAND]', ...a); };

  try {
    if (!importId && importId !== 0) {
      throw new Error('Missing importId in openHrRotaAssignCandidateModal');
    }

    const st = window.__importSummaryState && window.__importSummaryState['HR_ROTA_DAILY'];
    const rows = st && Array.isArray(st.rows) ? st.rows : [];
    const idx  = Number(rowIndex);
    const row  = (idx >= 0 && idx < rows.length) ? rows[idx] : null;

    if (!row) {
      throw new Error(`Row index ${rowIndex} is out of range for HR_ROTA_DAILY summary`);
    }

    const staffRaw = row.staff_name || row.staff_raw || '';
    const unitRaw  = row.unit || row.hospital_or_trust || row.hospital_norm || '';

    if (typeof openCandidatePicker !== 'function') {
      throw new Error('openCandidatePicker is not defined');
    }

    L('opening Assign Candidate picker', { importId, rowIndex, staffRaw, unitRaw });

    openCandidatePicker(async ({ id, label }) => {
      try {
        const staff_norm =
          row.staff_norm ||
          staffRaw ||
          '';

        const hospital_or_trust =
          unitRaw
            ? unitRaw
            : (row.hospital_or_trust || row.unit || row.hospital_norm || null);

        const payload = {
          candidate_mappings: [
            {
              staff_norm,
              hospital_or_trust,
              candidate_id: id
            }
          ],
          client_aliases: []
        };

        await postHrRotaResolveMappings(importId, payload);

        if (window.__toast) {
          window.__toast(`Candidate ${label} linked. Reclassifying HR rotaâ€¦`);
        }

        await refreshHrRotaSummary(importId);
      } catch (err) {
        console.error('[IMPORTS][HR_ROTA][ASSIGN_CAND] failed', err);
        const msg = err?.message || 'Failed to assign candidate for HR rota row.';
        if (window.__toast) window.__toast(msg); else alert(msg);
      }
    });
  } catch (e) {
    console.error('[IMPORTS][HR_ROTA][ASSIGN_CAND] open failed', e);
    const msg = e?.message || 'Failed to open Assign candidate dialog.';
    if (window.__toast) window.__toast(msg); else alert(msg);
  }
}


function openHrRotaAssignClientModal(importId, rowIndex) {
  const LOG = (typeof window.__LOG_IMPORTS === 'boolean') ? window.__LOG_IMPORTS : true;
  const L   = (...a) => { if (LOG) console.log('[IMPORTS][HR_ROTA][ASSIGN_CLIENT]', ...a); };

  try {
    if (!importId && importId !== 0) {
      throw new Error('Missing importId in openHrRotaAssignClientModal');
    }

    const st = window.__importSummaryState && window.__importSummaryState['HR_ROTA_DAILY'];
    const rows = st && Array.isArray(st.rows) ? st.rows : [];
    const idx  = Number(rowIndex);
    const row  = (idx >= 0 && idx < rows.length) ? rows[idx] : null;

    if (!row) {
      throw new Error(`Row index ${rowIndex} is out of range for HR_ROTA_DAILY summary`);
    }

    const unitRaw =
      row.unit ||
      row.hospital_or_trust ||
      row.hospital_norm ||
      '';

    if (typeof openClientPicker !== 'function') {
      throw new Error('openClientPicker is not defined');
    }

    L('opening Assign Client/Site picker', { importId, rowIndex, unitRaw });

    openClientPicker(async ({ id, label }) => {
      try {
        const hospital_norm =
          row.hospital_norm ||
          unitRaw ||
          '';

        // NEW: derive hr_row_ids for this rota row so the backend can
        // compute the canonical alias from hr_rows.
        const hrRowId = row.hr_row_id || row.id || null;
        const hr_row_ids = hrRowId ? [String(hrRowId).trim()] : [];

        const payload = {
          candidate_mappings: [],
          client_aliases: [
            {
              hospital_norm,
              client_id: id,
              hr_row_ids
            }
          ]
        };

        L('ASSIGN_CLIENT payload', {
          importId,
          rowIndex,
          client_id: id,
          hr_row_ids,
          hospital_norm
        });

        await postHrRotaResolveMappings(importId, payload);

        if (window.__toast) {
          window.__toast(`Client ${label} linked. Reclassifying HR rotaâ€¦`);
        }

        await refreshHrRotaSummary(importId);
      } catch (err) {
        console.error('[IMPORTS][HR_ROTA][ASSIGN_CLIENT] failed', err);
        const msg = err?.message || 'Failed to assign client/site for HR rota row.';
        if (window.__toast) window.__toast(msg); else alert(msg);
      }
    });
  } catch (e) {
    console.error('[IMPORTS][HR_ROTA][ASSIGN_CLIENT] open failed', e);
    const msg = e?.message || 'Failed to open Assign client/site dialog.';
    if (window.__toast) window.__toast(msg); else alert(msg);
  }
}

async function refreshOpenWeeklyImportSummariesAfterContractSave() {
  const LOG = (typeof window.__LOG_IMPORTS === 'boolean') ? window.__LOG_IMPORTS : true;
  const L   = (...a) => { if (LOG) console.log('[IMPORTS][WEEKLY][REFRESH_AFTER_CONTRACT]', ...a); };

  try {
    const state = window.__importSummaryState || null;
    if (!state || typeof refreshWeeklyImportSummary !== 'function') {
      L('no importSummaryState or refreshWeeklyImportSummary not defined; nothing to refresh');
      return;
    }

    const types = ['NHSP', 'HR_WEEKLY'];

    for (const t of types) {
      const st = state[t];
      if (!st || !st.import_id) continue;

      const importId = st.import_id;
      L('auto-refreshing weekly import after contract save', { type: t, importId });

      try {
        await refreshWeeklyImportSummary(t, importId);
      } catch (e) {
        console.warn('[IMPORTS][WEEKLY][REFRESH_AFTER_CONTRACT] single refresh failed', {
          type: t,
          importId,
          err: e?.message || String(e)
        });
      }
    }
  } catch (e) {
    console.warn('[IMPORTS][WEEKLY][REFRESH_AFTER_CONTRACT] wrapper failed', e);
  }
}

async function authFetch(input, init={}){
  const APILOG = (typeof window !== 'undefined' && !!window.__LOG_API) || (typeof __LOG_API !== 'undefined' && !!__LOG_API);
  const headers = new Headers(init.headers || {});
  if (SESSION?.accessToken) headers.set('Authorization', `Bearer ${SESSION.accessToken}`);
  if (APILOG) {
    const safeHeaders = {};
    headers.forEach((v,k)=>{ safeHeaders[k] = (k.toLowerCase()==='authorization') ? '***' : v; });
    const bodyPreview = typeof init.body === 'string' ? (init.body.length > 500 ? init.body.slice(0,500)+'â€¦' : init.body) : init.body;
    console.log('[authFetch] â†’', { url: typeof input==='string'?input:input?.url, method: (init.method||'GET'), headers: safeHeaders, body: bodyPreview });
  }
  let res = await fetch(input, { ...init, headers, credentials: init.credentials || 'omit' });
  if (APILOG) {
    try { const txt = await res.clone().text(); console.log('[authFetch] â†', res.status, res.ok, txt.slice(0,500)); } catch {}
  }
  if (res.status === 401) {
    const ok = await refreshToken();
    if (!ok) throw new Error('Unauthorised');
    headers.set('Authorization', `Bearer ${SESSION.accessToken}`);
    if (APILOG) console.log('[authFetch] retrying after 401');
    res = await fetch(input, { ...init, headers, credentials: init.credentials || 'omit' });
    if (APILOG) {
      try { const txt2 = await res.clone().text(); console.log('[authFetch] â† (retry)', res.status, res.ok, txt2.slice(0,500)); } catch {}
    }
  }
  return res;
}

// ===== Auth API calls =====
async function apiLogin(email, password){
  const res = await fetch(API('/auth/login'), {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    credentials: 'include', // cookie for refresh
    body: JSON.stringify({ email, password })
  });

  let data = {};
  try { data = await res.json(); } catch {}

  if (!res.ok) {
    const msg = data?.error || data?.message || 'Invalid credentials';
    throw new Error(msg);
  }

  const token =
    data.access_token ||
    data.token ||
    data.accessToken;

  if (!token) {
    throw new Error('No access token returned');
  }

  const rawTtl = data.expires_in ?? data.token_ttl_sec ?? data.ttl ?? 3600; // seconds
  const ttl    = Math.max(60, Number(rawTtl) || 3600); // floor at 60s
  const skew   = 30; // renew slightly early

  saveSession({
    accessToken: token,
    user: data.user || data.profile || null,
    exp: Math.floor(Date.now() / 1000) + (ttl - skew)
  });

  if (typeof scheduleRefresh === 'function') {
    scheduleRefresh();
  }

  return data;
}

// single, de-duplicated definition
async function refreshToken(){
  try{
    const res = await fetch(API('/auth/refresh'), {
      method:'POST',
      credentials:'include',
      headers:{'content-type':'application/json'},
      body: JSON.stringify({})
    });
    if (!res.ok) { clearSession(); return false; }

    const data  = await res.json();
    const token = data.access_token || data.token || data.accessToken;
    const ttl   = data.expires_in || data.token_ttl_sec || data.ttl || 3600;

    // Preserve existing user; hydrate if missing id
    let user = SESSION?.user || data.user || null;
    if (!user || !user.id) {
      try {
        const meRes = await fetch(API('/api/me'), { headers: { 'Authorization': `Bearer ${token}` } });
        if (meRes.ok) {
          const meJson = await meRes.json().catch(()=> ({}));
          user = (meJson && (meJson.user || meJson)) || user;
        }
      } catch {}
      // Extra guard: fall back to persisted user if present
      if (!user || !user.id) {
        try {
          const persisted = JSON.parse(localStorage.getItem('cloudtms.session')
                           || sessionStorage.getItem('cloudtms.session') || 'null');
          if (persisted?.user?.id) user = persisted.user;
        } catch {}
      }
    }

    saveSession({
      accessToken: token,
      user,
      exp: Math.floor(Date.now()/1000) + ttl
    });
    return true;
  }catch{
    clearSession();
    return false;
  }
}



async function apiForgot(email){
  const r = await fetch(API('/auth/forgot'), { method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify({ email })});
  if(!r.ok) throw new Error('Failed to request reset');
  return true;
}
async function apiReset(token, newPassword){
  const r = await fetch(API('/auth/reset'), { method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify({ token, new_password: newPassword })});
  if(!r.ok) throw new Error('Failed to reset password');
  return true;
}

// ===== Auth overlays wiring (login / forgot / reset) =====
function openLogin(){ byId('loginOverlay').style.display='grid'; byId('forgotOverlay').style.display='none'; byId('resetOverlay').style.display='none'; }
function openForgot(){ byId('loginOverlay').style.display='none'; byId('forgotOverlay').style.display='grid'; byId('resetOverlay').style.display='none'; }
function openReset(){ byId('loginOverlay').style.display='none'; byId('forgotOverlay').style.display='none'; byId('resetOverlay').style.display='grid'; }

// show/hide password helpers
function toggleVis(inputId, toggleId){
  const inp = byId(inputId), t = byId(toggleId);
  t.onclick = ()=>{ inp.type = inp.type==='password' ? 'text' : 'password'; };
}

function renderUserChip(){
  const chip = byId('userChip');
  if (SESSION?.user) {
    chip.textContent = (SESSION.user.display_name || SESSION.user.email || 'User');
  } else chip.textContent = 'Signed out';
}
function initAuthUI(){
  // Buttons and links
  byId('btnLogout').onclick = ()=>{ clearSession(); openLogin(); };

  toggleVis('loginPassword','toggleLoginPw');
  toggleVis('resetPw1','toggleResetPw1'); toggleVis('resetPw2','toggleResetPw2');

  byId('linkForgot').onclick = openForgot;
  byId('linkBackToLogin').onclick = openLogin;
  byId('linkResetToLogin').onclick = openLogin;

  byId('loginForm').onsubmit = async (e)=>{
    e.preventDefault();
    const email = byId('loginEmail').value.trim();
    const pw = byId('loginPassword').value;
    const err = byId('loginError'); err.style.display='none';
    try{
      await apiLogin(email, pw);
      if (typeof scheduleRefresh === 'function') scheduleRefresh();
      byId('loginOverlay').style.display='none';
      bootstrapApp();
    }catch(ex){
      err.textContent = ex.message || 'Sign in failed'; err.style.display='block';
    }
  };

  byId('forgotForm').onsubmit = async (e)=>{
    e.preventDefault();
    const email = byId('forgotEmail').value.trim();
    byId('forgotError').style.display='none';
    byId('forgotMsg').style.display='none';
    try{
      await apiForgot(email);
      byId('forgotMsg').textContent = 'If that email exists, a reset link has been sent.'; byId('forgotMsg').style.display='block';
    }catch(ex){
      byId('forgotError').textContent = ex.message || 'Could not send reset email'; byId('forgotError').style.display='block';
    }
  };

  byId('resetForm').onsubmit = async (e)=>{
    e.preventDefault();
    const p1 = byId('resetPw1').value, p2 = byId('resetPw2').value;
    const err = byId('resetError'), ok = byId('resetMsg'); err.style.display='none'; ok.style.display='none';
    if (p1.length < 8) { err.textContent='Use at least 8 characters'; err.style.display='block'; return; }
    if (p1 !== p2) { err.textContent='Passwords do not match'; err.style.display='block'; return; }
    const url = new URL(location.href); const token = url.searchParams.get('k') || url.searchParams.get('token');
    if (!token){ err.textContent='Reset token missing. Use the email link again.'; err.style.display='block'; return; }
    try{
      await apiReset(token, p1);
      ok.textContent='Password updated. You can sign in now.'; ok.style.display='block';
    }catch(ex){
      err.textContent = ex.message || 'Reset failed'; err.style.display='block';
    }
  };

  // Open reset overlay automatically if URL carries a token (only if not already signed in)
  const url = new URL(location.href);
  const hasResetToken = url.searchParams.get('k') || url.searchParams.get('token');
  if (hasResetToken && !(typeof getSession === 'function' && getSession()?.accessToken)) openReset();
}
// ===== App state + rendering =====
const sections = [
  {key:'candidates', label:'Candidates', icon:'ðŸ‘¤'},
  {key:'clients', label:'Clients', icon:'ðŸ¥'},
  {key:'contracts', label:'Contracts', icon:'ðŸ“„'},
  {key:'timesheets', label:'Timesheets', icon:'ðŸ—’ï¸'},
 {key:'imports', label:'Imports', icon:'ðŸ“¥'},

  {key:'invoices', label:'Invoices', icon:'ðŸ“„'},
  {key:'umbrellas', label:'Umbrellas', icon:'â˜‚ï¸'},
  {key:'settings', label:'Settings', icon:'âš™ï¸'},
  {key:'audit', label:'Audit', icon:'ðŸ›¡ï¸'}
];

let currentSection = 'candidates';
let currentRows = [];
let currentSelection = null;

// =========================== renderTopNav (kept with reset) ===========================
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// renderTopNav (amended) â€” adds Contracts quick-search branch { q: text }
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function renderTopNav(){
  const nav = byId('nav'); nav.innerHTML = '';

  // ensure per-section list + selection exist
  window.__listState = window.__listState || {};
  window.__selection = window.__selection || {};

  // helper: common section switch (mirrors original behaviour)
  const switchToSection = (sectionKey) => {
    if (!confirmDiscardChangesIfDirty()) return;

    // âœ… Settings is modal-only: do NOT change the summary section
    if (sectionKey === 'settings') {
      if ((window.__modalStack?.length || 0) > 0 || modalCtx?.entity) {
        discardAllModalsAndState();
      }
      try { openSettings(); } catch (e) { alert('Could not open settings'); }
      return;
    }

    if ((window.__modalStack?.length || 0) > 0 || modalCtx?.entity) {
      discardAllModalsAndState();
    }

    if (!window.__listState[sectionKey]) {
      window.__listState[sectionKey] = { page: 1, pageSize: 50, total: null, hasMore: false, filters: null };
    }

    // IDs-only selection seed for the new section
    window.__selection[sectionKey] = window.__selection[sectionKey] || { fingerprint:'', ids:new Set() };

    currentSection   = sectionKey;
    currentRows      = [];
    currentSelection = null;

    renderAll();
  };

  // Helper: close any open settings dropdown
  const closeSettingsMenu = () => {
    const m = document.getElementById('__settingsMenu');
    if (m) m.remove();
    const btn = document.querySelector('button.__settingsBtn');
    if (btn) btn.classList.remove('active');
    document.removeEventListener('click', onAnyDocClick, true);
    document.removeEventListener('keydown', onEsc, true);
  };
  const onAnyDocClick = (e) => {
    const menu = document.getElementById('__settingsMenu');
    const anchor = document.querySelector('button.__settingsBtn');
    if (!menu) return;
    if (menu.contains(e.target) || anchor?.contains(e.target)) return;
    closeSettingsMenu();
  };
  const onEsc = (e) => { if (e.key === 'Escape') closeSettingsMenu(); };

  // Helper: close any open invoices dropdown
  const closeInvoicesMenu = () => {
    const m = document.getElementById('__invoicesMenu');
    if (m) m.remove();
    const btn = document.querySelector('button.__invoicesCaret');
    if (btn) btn.classList.remove('active');
    document.removeEventListener('click', onAnyDocClickInv, true);
    document.removeEventListener('keydown', onEscInv, true);
  };
  const onAnyDocClickInv = (e) => {
    const menu = document.getElementById('__invoicesMenu');
    const anchor = document.querySelector('button.__invoicesCaret');
    if (!menu) return;
    if (menu.contains(e.target) || anchor?.contains(e.target)) return;
    closeInvoicesMenu();
  };
  const onEscInv = (e) => { if (e.key === 'Escape') closeInvoicesMenu(); };

  // Build buttons
  sections.forEach(s => {
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // INVOICES: split button (main click opens invoices; caret opens batch menu)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if (s.key === 'invoices') {
      const wrap = document.createElement('div');
      wrap.style.display = 'flex';
      wrap.style.gap = '6px';
      wrap.style.alignItems = 'center';

      const main = document.createElement('button');
      main.innerHTML = `<span class="ico">${s.icon}</span> ${s.label}`;
      if (s.key === currentSection) main.classList.add('active');
      main.onclick = () => switchToSection('invoices');

      const caret = document.createElement('button');
      caret.classList.add('__invoicesCaret');
      caret.innerHTML = `â–¾`;
      caret.title = 'Invoice actions';
      caret.onclick = (ev) => {
        ev.preventDefault();

        // toggle
        const existing = document.getElementById('__invoicesMenu');
        if (existing) { closeInvoicesMenu(); return; }

        // avoid dual menus
        try { closeSettingsMenu(); } catch {}

        const m = document.createElement('div');
        m.id = '__invoicesMenu';
        m.style.position      = 'absolute';
        m.style.zIndex        = '1000';
        m.style.background    = 'var(--panel, #0b1221)';
        m.style.border        = '1px solid var(--line, #334155)';
        m.style.borderRadius  = '10px';
        m.style.boxShadow     = 'var(--shadow, 0 6px 20px rgba(0,0,0,.25))';
        m.style.padding       = '6px';
        m.style.minWidth      = '220px';
        m.style.userSelect    = 'none';

        m.innerHTML = `
          <button type="button" class="inv-menu-item" data-k="batch-generate"
                  style="display:flex;gap:8px;align-items:center;width:100%;
                         background:#0b1427;border:1px solid var(--line);color:#fff;
                         padding:8px 10px;border-radius:8px;cursor:pointer;margin:4px 0;">
            ðŸ§¾ Batch Generate
          </button>
          <button type="button" class="inv-menu-item" data-k="batch-issue"
                  style="display:flex;gap:8px;align-items:center;width:100%;
                         background:#0b1427;border:1px solid var(--line);color:#fff;
                         padding:8px 10px;border-radius:8px;cursor:pointer;margin:4px 0;">
            ðŸ“¤ Batch Issue
          </button>
        `;

        document.body.appendChild(m);
        const r = caret.getBoundingClientRect();
        m.style.left = `${Math.round(window.scrollX + r.left)}px`;
        m.style.top  = `${Math.round(window.scrollY + r.bottom + 6)}px`;

        m.addEventListener('click', (e) => {
          const it = e.target.closest('.inv-menu-item');
          if (!it) return;
          const k = it.getAttribute('data-k');
          closeInvoicesMenu();

          if (!confirmDiscardChangesIfDirty()) return;

          if (k === 'batch-generate') {
            if (typeof openInvoiceBatchGenerateModal !== 'function') {
              alert('Batch Generate modal not yet implemented.');
              return;
            }
            openInvoiceBatchGenerateModal();
            return;
          }

          if (k === 'batch-issue') {
            if (typeof openInvoiceBatchIssueModal !== 'function') {
              alert('Batch Issue modal not yet implemented.');
              return;
            }
            openInvoiceBatchIssueModal();
            return;
          }
        });

        // Close on outside click / Esc
        setTimeout(() => {
          document.addEventListener('click', onAnyDocClickInv, true);
          document.addEventListener('keydown', onEscInv, true);
        }, 0);

        caret.classList.add('active');
      };

      wrap.appendChild(main);
      wrap.appendChild(caret);
      nav.appendChild(wrap);
      return;
    }

    // Normal button for all other sections
    const b = document.createElement('button');
    b.innerHTML = `<span class="ico">${s.icon}</span> ${s.label}`;
    if (s.key === currentSection) b.classList.add('active');

    if (s.key === 'imports') {
      // IMPORTS: launch the Imports modal (NHSP / HR weekly / HR rota)
      b.onclick = () => {
        if (!confirmDiscardChangesIfDirty()) return;
        try {
          openImportsModal();          // <-- your existing imports UI entry point
        } catch (e) {
          console.error('[NAV][IMPORTS] openImportsModal failed', e);
          alert(e?.message || 'Failed to open Imports.');
        }
      };
    } else if (s.key !== 'settings') {
      // normal buttons keep the original click behaviour
      b.onclick = () => switchToSection(s.key);
    } else {
      // SETTINGS: small dropdown instead of direct navigation
      b.classList.add('__settingsBtn');
      b.onclick = (ev) => {
        ev.preventDefault();
        // toggle
        const existing = document.getElementById('__settingsMenu');
        if (existing) { closeSettingsMenu(); return; }

        // avoid dual menus
        try { closeInvoicesMenu(); } catch {}

        // Build a light menu styled with your palette
        const m = document.createElement('div');
        m.id = '__settingsMenu';
        m.style.position      = 'absolute';
        m.style.zIndex        = '1000';
        m.style.background    = 'var(--panel, #0b1221)';
        m.style.border        = '1px solid var(--line, #334155)';
        m.style.borderRadius  = '10px';
        m.style.boxShadow     = 'var(--shadow, 0 6px 20px rgba(0,0,0,.25))';
        m.style.padding       = '6px';
        m.style.minWidth      = '220px';
        m.style.userSelect    = 'none';

        m.innerHTML = `
          <button type="button" class="menu-item" data-k="global"
                  style="display:flex;gap:8px;align-items:center;width:100%;
                         background:#0b1427;border:1px solid var(--line);color:#fff;
                         padding:8px 10px;border-radius:8px;cursor:pointer;margin:4px 0;">
            ðŸŒ Global settings
          </button>
          <button type="button" class="menu-item" data-k="rates"
                  style="display:flex;gap:8px;align-items:center;width:100%;
                         background:#0b1427;border:1px solid var(--line);color:#fff;
                         padding:8px 10px;border-radius:8px;cursor:pointer;margin:4px 0;">
            ðŸ’± Preset Rates
          </button>
          <button type="button" class="menu-item" data-k="job-titles"
                  style="display:flex;gap:8px;align-items:center;width:100%;
                         background:#0b1427;border:1px solid var(--line);color:#fff;
                         padding:8px 10px;border-radius:8px;cursor:pointer;margin:4px 0;">
            ðŸ· Job Titles
          </button>
          <button type="button" class="menu-item" data-k="user-management"
                  style="display:flex;gap:8px;align-items:center;width:100%;
                         background:#0b1427;border:1px solid var(--line);color:#fff;
                         padding:8px 10px;border-radius:8px;cursor:pointer;margin:4px 0;">
            ðŸ‘¤ User Management
          </button>

          <div style="height:1px;background:var(--line,#334155);margin:8px 4px;"></div>

          <button type="button" class="menu-item" data-k="band-mappings"
                  style="display:flex;gap:8px;align-items:center;width:100%;
                         background:#0b1427;border:1px solid var(--line);color:#fff;
                         padding:8px 10px;border-radius:8px;cursor:pointer;margin:4px 0;">
            ðŸ§© Weekly band mappings
          </button>
          <button type="button" class="menu-item" data-k="import-col-aliases"
                  style="display:flex;gap:8px;align-items:center;width:100%;
                         background:#0b1427;border:1px solid var(--line);color:#fff;
                         padding:8px 10px;border-radius:8px;cursor:pointer;margin:4px 0;">
            ðŸ§¾ Import column aliases
          </button>
        `;

        // Position under the button
        document.body.appendChild(m);
        const r = b.getBoundingClientRect();
        m.style.left = `${Math.round(window.scrollX + r.left)}px`;
        m.style.top  = `${Math.round(window.scrollY + r.bottom + 6)}px`;

        // Wire actions
        m.addEventListener('click', (e) => {
          const it = e.target.closest('.menu-item');
          if (!it) return;
          const k = it.getAttribute('data-k');
          closeSettingsMenu();

          if (k === 'global') {
            // âœ… Open global settings modal WITHOUT switching the summary section
            if (!confirmDiscardChangesIfDirty()) return;
            try { openSettings(); } catch (err) { alert('Could not open settings'); }
            return;

          } else if (k === 'rates') {
            if (!confirmDiscardChangesIfDirty()) return;
            openPresetRatesManager();

          } else if (k === 'job-titles') {
            if (!confirmDiscardChangesIfDirty()) return;
            openJobTitleSettingsModal();

          } else if (k === 'user-management') {
            if (!confirmDiscardChangesIfDirty()) return;
            if (typeof openUserManagementModal !== 'function') {
              alert('User Management modal not yet implemented.');
              return;
            }
            openUserManagementModal();

          } else if (k === 'band-mappings') {
            if (!confirmDiscardChangesIfDirty()) return;
            if (typeof openAssignmentBandMappingsModal !== 'function') {
              alert('Band mappings modal not yet implemented.');
              return;
            }
            openAssignmentBandMappingsModal();

          } else if (k === 'import-col-aliases') {
            if (!confirmDiscardChangesIfDirty()) return;
            if (typeof openImportColumnAliasesModal !== 'function') {
              alert('Import column aliases modal not yet implemented.');
              return;
            }
            openImportColumnAliasesModal();
          }
        });

        // Close on outside click / Esc
        setTimeout(() => {
          document.addEventListener('click', onAnyDocClick, true);
          document.addEventListener('keydown', onEsc, true);
        }, 0);

        // Visual cue
        b.classList.add('active');
      };
    }

    nav.appendChild(b);
  });

  // Quick search: Enter runs a search and resets to page 1
  try {
    const q = byId('quickSearch');
    if (q && !q.__wired) {
      q.addEventListener('keydown', async (e) => {
        if (e.key !== 'Enter') return;
        if (!confirmDiscardChangesIfDirty()) return;

        window.__listState = window.__listState || {};
        window.__selection = window.__selection || {};

        const st  = (window.__listState[currentSection]  ||= { page: 1, pageSize: 50, total: null, hasMore: false, filters: null });
        const sel = (window.__selection[currentSection] ||= { fingerprint:'', ids:new Set() });

        st.page = 1;
        const text = (q.value || '').trim();

        if (!text) {
          st.filters = null;
          sel.fingerprint = JSON.stringify({ section: currentSection, filters: {} });
          sel.ids.clear();
          const data = await loadSection();
          return renderSummary(data);
        }

        // Minimal quick-search filters by section
        let filters = null;
        if (currentSection === 'candidates') {
          if (text.includes('@'))       filters = { email: text };
          else if (text.replace(/\D/g,'').length >= 7) filters = { phone: text };
          else if (text.includes(' ')) {
            const [fn, ln] = text.split(' ').filter(Boolean);
            filters = { first_name: fn || text, last_name: ln || '' };
          } else filters = { first_name: text };
        } else if (currentSection === 'clients' || currentSection === 'umbrellas') {
          filters = { name: text };
        } else if (currentSection === 'contracts') {
          // free-text passthrough for contracts
          filters = { q: text };
        } else {
          const data = await loadSection();
          return renderSummary(data);
        }

        st.filters = filters;
        sel.fingerprint = JSON.stringify({ section: currentSection, filters });
        sel.ids.clear();

        const rows = await search(currentSection, filters);
        renderSummary(rows);
      });
      q.__wired = true;
    }
  } catch {}
}



// NEW: advanced, section-aware search modal
// === UPDATED: Advanced Search â€” add Roles (any) multi-select, use UK date pickers ===
// -----------------------------
// Search presets FE cache (optional but handy)
// -----------------------------
const __PRESETS_CACHE__ = new Map(); // key = `${section}:${kind}|shared=${0/1}|q=...|p=..|ps=..`

function cacheKey(section, kind = 'search', opts = {}) {
  const shared = opts.include_shared ? 1 : 0;
  const q      = opts.q ? String(opts.q) : '';
  const page   = Number.isFinite(opts.page) ? opts.page : 1;
  const ps     = Number.isFinite(opts.page_size) ? opts.page_size : 100;
  return `${section || ''}:${kind || 'search'}|shared=${shared}|q=${q}|p=${page}|ps=${ps}`;
}

function invalidatePresetCache(section, kind = 'search', opts) {
  if (opts) {
    __PRESETS_CACHE__.delete(cacheKey(section, kind, opts));
    return;
  }
  // No opts provided: clear all variants for this (section,kind)
  const prefix = `${section || ''}:${kind || 'search'}|`;
  for (const key of __PRESETS_CACHE__.keys()) {
    if (key.startsWith(prefix)) __PRESETS_CACHE__.delete(key);
  }
}



function getPresetCache(section, kind = 'search', opts) {
  return __PRESETS_CACHE__.get(cacheKey(section, kind, opts)) || null;
}

function setPresetCache(section, kind, rows, opts) {
  __PRESETS_CACHE__.set(
    cacheKey(section, kind, opts),
    Array.isArray(rows) ? rows : []
  );
}
// Quick helper for ownership checks; adapt if you keep user in a different global
function currentUserId(){
  try {
    return (window.SESSION && window.SESSION.user && window.SESSION.user.id)
        || (window.__auth && window.__auth.user && window.__auth.user.id)
        || window.__USER_ID
        || null;
  } catch (_) {
    return null;
  }
}






// -----------------------------
// Preset API wrappers
// -----------------------------
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Child modal â€” Rate preset (create / view / edit)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function computeRatePresetMargins(state){
  const buckets = ['day','night','sat','sun','bh'];
  const out = { bucket:{}, anyNegative:false };
  if (!state || typeof state !== 'object') return out;

  let erniDec = 0;
  try { if (typeof ensureErniMultiplier === 'function') ensureErniMultiplier(); } catch {}

  if (typeof window !== 'undefined' && Number.isFinite(window.__ERNI_MULT__)) {
    erniDec = Math.max(0, Number(window.__ERNI_MULT__) - 1);
  } else if (typeof getCurrentErniMultiplier === 'function') {
    const m = getCurrentErniMultiplier();
    if (Number.isFinite(m)) erniDec = Math.max(0, m - 1);
  } else if (typeof getCurrentErniPct === 'function') {
    const p = getCurrentErniPct();
    if (Number.isFinite(p)) erniDec = Math.max(0, p / 100);
  } else if (Number.isFinite(window?.__erniMultiplier)) {
    erniDec = Math.max(0, Number(window.__erniMultiplier) - 1);
  } else if (Number.isFinite(window?.__erniPct)) {
    erniDec = Math.max(0, Number(window.__erniPct) / 100);
  }

  const num = (v) => { const n = Number(v); return Number.isFinite(n) ? n : NaN; };

  buckets.forEach(b => {
    const paye   = num(state[`paye_${b}`]);
    const umb    = num(state[`umb_${b}`]);
    const charge = num(state[`charge_${b}`]);

    const hasP = !!state.enable_paye && Number.isFinite(paye);
    const hasU = !!state.enable_umbrella && Number.isFinite(umb);
    const hasC = Number.isFinite(charge);

    const marginP = (hasP && hasC) ? (charge - (paye + (paye * erniDec))) : null;
    const marginU = (hasU && hasC) ? (charge - umb) : null;

    const negP = (marginP != null) && (marginP < 0);
    const negU = (marginU != null) && (marginU < 0);
    if (negP || negU) out.anyNegative = true;

    out.bucket[b] = {
      paye:        hasP ? paye   : null,
      umb:         hasU ? umb    : null,
      charge:      hasC ? charge : null,
      marginPaye:  marginP,
      marginUmb:   marginU,
      negPaye:     negP,
      negUmb:      negU
    };
  });

  return out;
}

function openRatePresetPicker(applyCb, opts = {}) {
  const LOG = (typeof window.__LOG_RATES === 'boolean') ? window.__LOG_RATES : true;
  const L   = (...a)=> { if (LOG) console.log('[PRESETS]', ...a); };

  const {
    client_id = null,
    start_date = null,
    defaultScope = (client_id ? 'CLIENT' : 'GLOBAL')
  } = opts;

  let pickerRows = [];
  let pickerSelectedIndex = -1;
  let pickerSelectedId = null;
  let applyInFlight = false; // debounce guard

  const content = () => `
    <div class="tabc" id="ratePresetPicker">
      <div class="row">
        <label>Scope</label>
        <div class="controls">
          <label><input type="radio" name="rp_scope" value="ALL" ${defaultScope==='ALL'?'checked':''}/> All</label>
          <label><input type="radio" name="rp_scope" value="GLOBAL" ${defaultScope==='GLOBAL'?'checked':''}/> Global</label>
          <label ${client_id?'':'title="Pick a client to enable Client presets"'} >
            <input type="radio" name="rp_scope" value="CLIENT" ${defaultScope==='CLIENT'?'checked':''} ${client_id?'':'disabled'}/> Client
          </label>
          <input type="text" id="rp_search" class="input" placeholder="Searchâ€¦" style="margin-left:auto;min-width:200px"/>
        </div>
      </div>
      <div class="hint" style="margin:6px 0 10px">
        Double-click a row to apply. Single-click selects; click <em>Apply</em> to use the selected preset.
      </div>
      <div style="border:1px solid var(--line);border-radius:10px;overflow:hidden">
        <table class="grid" id="rp_table">
          <thead>
            <tr>
              <th style="width:36px"></th>
              <th>Name / Role / Band</th>
              <th>Scope</th>
              <th>Dates</th>
              <th>Charge (D/N/Sa/Su/BH)</th>
              <th>PAYE</th>
              <th>Umbrella</th>
              <th>Mileage</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>`;

  // onApply: just apply the preset and tell saveForFrame we're OK.
  const onApply = async () => {
    if (applyInFlight) return false;
    if (!pickerRows || pickerSelectedIndex < 0) return false;
    const chosen = pickerRows[pickerSelectedIndex];
    if (!chosen) return false;

    applyInFlight = true;
    L('onApply: applying preset row', { chosen });

    try {
      if (typeof applyCb === 'function') {
        await applyCb(chosen);
      }
      // Let saveForFrame() close this child modal normally.
      return { ok: true };
    } catch (e) {
      console.error('[PRESETS] onApply failed', e);
      return false;
    } finally {
      applyInFlight = false;
    }
  };

  showModal(
    'Rate Presets',
    [{ key: 'p', title: 'Presets' }],
    () => content(),
    onApply,
    false,
    async () => {
      const root   = document.getElementById('ratePresetPicker');
      const tbody  = root?.querySelector('#rp_table tbody');
      const search = root?.querySelector('#rp_search');
      const radios = Array.from(root?.querySelectorAll('input[name="rp_scope"]') || []);
      if (!tbody) return;

      // Scope any header/button lookups to THIS picker modal
      const pickerModalEl = root?.closest('.modal');

      const scopeVal = () =>
        (radios.find(r => r.checked)?.value || (client_id ? 'CLIENT' : 'GLOBAL'));

      const pill = (v) => (v == null || v === '' ? '-' : String(v));

      const rateRow = (p) => [
        `D:${pill(p.charge_day)} N:${pill(p.charge_night)} Sa:${pill(p.charge_sat)} Su:${pill(p.charge_sun)} BH:${pill(p.charge_bh)}`,
        `D:${pill(p.umb_day)   } N:${pill(p.umb_night)   } Sa:${pill(p.umb_sat)   } Su:${pill(p.umb_sun)   } BH:${pill(p.umb_bh)   }`,
        `D:${pill(p.paye_day)  } N:${pill(p.paye_night)  } Sa:${pill(p.paye_sat)  } Su:${pill(p.paye_sun)  } BH:${pill(p.paye_bh)  }`
      ];

      const updateApplyState = () => {
        const canApply = !!(pickerRows.length && pickerSelectedIndex >= 0);

        // Only touch THIS pickerâ€™s Save/Apply button
        const btn = pickerModalEl?.querySelector('#btnSave');
        if (btn) {
          btn.disabled = !canApply;
          btn.title = canApply ? '' : 'Select a preset to apply';
        }

        // Only update the picker frame (not the parent contracts frame)
        const fr = window.__getModalFrame?.();
        if (fr?.kind === 'rate-presets-picker' && typeof fr._updateButtons === 'function') {
          fr.__canSave = canApply;
          fr._updateButtons();
        }
      };

      const paint = () => {
        const activeIndex = pickerSelectedIndex;
        const body = pickerRows.map((r, i) => {
          const scope = String(r.scope || (r.client_id ? 'CLIENT' : 'GLOBAL')).toUpperCase();
          const name =
            r.name ||
            [r.role, r.band ? `Band ${r.band}` : ''].filter(Boolean).join(' / ') ||
            'Preset';

          const [chg, umb, paye] = rateRow(r);
          const isActive = (i === activeIndex);
          const cls = isActive ? ' class="active selected"' : '';

          const mileagePay = pill(r.mileage_pay_rate);
          const mileageCharge = pill(r.mileage_charge_rate);
          const mileageTxt =
            (mileagePay === '-' && mileageCharge === '-') ? '-' : `Pay ${mileagePay} / Charge ${mileageCharge}`;

          return `
            <tr data-i="${i}"${cls}>
              <td></td>
              <td>${name}</td>
              <td>${scope}</td>
              <td>${r.from_date || '-'} â†’ ${r.to_date || '-'}</td>
              <td>${chg}</td>
              <td>${paye}</td>
              <td>${umb}</td>
              <td>${mileageTxt}</td>
            </tr>`;
        }).join('');

        tbody.innerHTML =
          body || '<tr><td colspan="8" class="mini" style="text-align:center">No presets found</td></tr>';

        updateApplyState();
      };

      const fetchRows = async () => {
        const scope = scopeVal();
        const qRaw = (search?.value || '').trim();
        const q = qRaw.toLowerCase();
        const cid = client_id ? String(client_id) : null;

        try {
          let rows = [];

          if (scope === 'GLOBAL') {
            // All GLOBAL presets (search handled client-side)
            rows = await listRatePresets({ scope: 'GLOBAL' });
          } else if (scope === 'CLIENT') {
            // All CLIENT presets for this client id
            rows = cid ? await listRatePresets({ scope: 'CLIENT', client_id: cid }) : [];
          } else { // ALL
            const globals = await listRatePresets({ scope: 'GLOBAL' });
            const clientRows = cid ? await listRatePresets({ scope: 'CLIENT', client_id: cid }) : [];
            rows = [...globals, ...clientRows];
          }

          rows = Array.isArray(rows) ? rows : [];

          // Front-end search: match on name / role / band / display_site
          if (q) {
            rows = rows.filter(r => {
              const name = String(r.name || '').toLowerCase();
              const role = String(r.role || '').toLowerCase();
              const band = String(r.band || '').toLowerCase();
              const site = String(r.display_site || '').toLowerCase();
              return (
                name.includes(q) ||
                role.includes(q) ||
                band.includes(q) ||
                site.includes(q)
              );
            });
          }

          // Alphabetical by Name, then Role/Band
          rows.sort((a, b) => {
            const aName = (a.name || a.role || '').toString().toLowerCase();
            const bName = (b.name || b.role || '').toString().toLowerCase();
            if (aName < bName) return -1;
            if (aName > bName) return 1;
            return 0;
          });

          // If you have sortPresetsForView, keep using it; otherwise rows as-is
          pickerRows = (typeof sortPresetsForView === 'function')
            ? sortPresetsForView(scope, rows)
            : rows;

          L('fetchRows: got presets', { scope, q: qRaw, count: pickerRows.length });
        } catch (e) {
          console.error('[PRESETS] fetchRows error', e);
          pickerRows = [];
        }

        // reset selection
        pickerSelectedIndex = -1;
        pickerSelectedId = null;
        paint();
      };

      // Single-click: just select the row; don't repaint tbody
      tbody.addEventListener('click', (e) => {
        const tr = e.target.closest('tr[data-i]');
        if (!tr) return;
        const idx = +tr.getAttribute('data-i');
        if (!Number.isFinite(idx)) return;

        pickerSelectedIndex = idx;
        pickerSelectedId = pickerRows[idx]?.id || null;
        L('row click â†’ select', { idx, id: pickerSelectedId });

        // Toggle selection classes without rebuilding the tbody
        tbody.querySelectorAll('tr.active, tr.selected').forEach(n => n.classList.remove('active','selected'));
        tr.classList.add('active','selected');

        updateApplyState();
      });

      // Double-click: select + programmatically press the pickerâ€™s Apply button
      tbody.addEventListener('dblclick', (e) => {
        let idx = pickerSelectedIndex;
        const tr = e.target.closest('tr[data-i]');
        if (tr && Number.isFinite(+tr.getAttribute('data-i'))) {
          idx = +tr.getAttribute('data-i');
        }
        if (!Number.isFinite(idx) || idx < 0) return;

        pickerSelectedIndex = idx;
        pickerSelectedId = pickerRows[idx]?.id || null;
        L('row dblclick â†’ apply', { idx, id: pickerSelectedId });

        const btn = pickerModalEl?.querySelector('#btnSave');
        if (btn && !btn.disabled) {
          btn.click();   // triggers saveForFrame â†’ onApply â†’ framework closes child properly
        }

        e.preventDefault();
        e.stopPropagation();
      });

      search?.addEventListener('input', fetchRows);
      radios.forEach(r => r.addEventListener('change', fetchRows));

      await fetchRows();

      try {
        const fr = window.__getModalFrame?.();
        if (fr && fr.kind === 'rate-presets-picker' && typeof setFrameMode === 'function') {
          setFrameMode(fr, 'view');
          fr._updateButtons && fr._updateButtons();
        }
      } catch {}
    },
    { kind: 'rate-presets-picker', noParentGate: false }
  );

  setTimeout(() => {
    const fr = window.__getModalFrame?.();
    if (!fr || fr.kind !== 'rate-presets-picker') return;

    if (typeof fr.onReturn === 'function' && !fr.__init__) {
      fr.__init__ = true;
      fr.onReturn(fr);
    }
    fr._onSave = onApply;
  }, 0);
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Parent modal â€” Preset Rates manager
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


function openPresetRatesManager(){
  // Shared state for the manager; child modals can request refresh via this handle
  window.__ratesPresets__ = window.__ratesPresets__ || {};
  const S = window.__ratesPresets__;

  S.scope     = S.scope || 'ALL';     // 'ALL' | 'GLOBAL' | 'CLIENT'
  S.client_id = S.client_id || null;  // when scope === 'CLIENT'
  S.client_label = S.client_label || '';
  S.q         = S.q || '';

  const renderTable = (rows) => {
    const hasRows = Array.isArray(rows) && rows.length;
    if (!hasRows) {
      if (S.scope === 'CLIENT') {
        if (!S.client_id) {
          return `<div class="hint">Pick a client to see client-specific presets.</div>`;
        }
        return `<div class="hint">No presets exist for this client yet.</div>`;
      }
      return `<div class="hint">No presets match the current filter.</div>`;
    }

    const fmtWhen = (iso) => {
      if (!iso) return '';
      try { return (new Date(iso)).toLocaleString(); } catch { return iso; }
    };
    return `
      <table class="grid" id="ratesPresetsTable">
        <thead>
          <tr>
            <th>Name</th>
            <th>Scope</th>
            <th>Client</th>
            <th>Role</th>
            <th>Band</th>
            <th>Last edited</th>
            <th></th>
          </tr>
        </thead>
        <tbody>
          ${rows.map(r => `
            <tr data-id="${r.id}">
              <td>${r.name || ''}</td>
              <td>${(String(r.scope || (r.client_id ? 'CLIENT' : 'GLOBAL')).toUpperCase())}</td>
              <td>${(r.client && r.client.name) ? r.client.name : (r.client_name || '')}</td>
              <td>${r.role || ''}</td>
              <td>${r.band ?? ''}</td>
              <td class="mini">${fmtWhen(r.updated_at)}</td>
              <td class="mini">
                <button
                  type="button"
                  class="icon bin"
                  data-del="${r.id}"
                  title="Delete"
                >ðŸ—‘</button>
              </td>
            </tr>
          `).join('')}
        </tbody>
      </table>
    `;
  };

  const buildBody = (rows=[]) => {
    const scopeAll    = S.scope === 'ALL'    ? 'checked' : '';
    const scopeGlobal = S.scope === 'GLOBAL' ? 'checked' : '';
    const scopeClient = S.scope === 'CLIENT' ? 'checked' : '';

    const clientBadgeInner = S.client_label
      ? `<span class="pill">${S.client_label}</span>`
      : `<span class="mini">No client selected</span>`;

    return `
      <div class="tabc">
        <div class="row">
          <label>Scope</label>
          <div class="controls">
            <label><input type="radio" name="rp_scope" value="ALL" ${scopeAll}/> All</label>
            <label><input type="radio" name="rp_scope" value="GLOBAL" ${scopeGlobal}/> Global</label>
            <label><input type="radio" name="rp_scope" value="CLIENT" ${scopeClient}/> Client</label>
          </div>
        </div>

        <div class="row" id="rp_client_row" style="display:${S.scope==='CLIENT' ? 'block':'none'}">
          <label>Client</label>
          <div class="controls">
            <div class="split">
              <button type="button" class="btn mini" id="rp_pick_client">Pickâ€¦</button>
              <button type="button" class="btn mini" id="rp_clear_client">Clear</button>
              <div id="rp_cli_badge">${clientBadgeInner}</div>
            </div>
          </div>
        </div>

        <div class="row">
          <label>Search</label>
          <div class="controls">
            <input class="input" type="text" id="rp_q" value="${S.q || ''}" placeholder="Filter by name, role, bandâ€¦"/>
          </div>
        </div>

        <div id="rp_table_wrap">${renderTable(rows)}</div>
      </div>
    `;
  };

  const fetchRows = async () => {
    const params = {
      scope: S.scope,
      client_id: (S.scope === 'CLIENT' ? S.client_id : null),
      q: S.q || undefined
    };

    // Avoid noisy calls when client scope is chosen but no client selected yet.
    if (params.scope === 'CLIENT' && !params.client_id) {
      return [];
    }

    const raw = await listRatePresets(params);
    let rows = Array.isArray(raw) ? raw : [];

    // Hard filter: in CLIENT scope we only ever show client-specific rows for this client.
    if (S.scope === 'CLIENT' && S.client_id) {
      const cid = String(S.client_id);
      rows = rows.filter(r => {
        const sc = String(r.scope || (r.client_id ? 'CLIENT' : 'GLOBAL')).toUpperCase();
        return sc === 'CLIENT' && String(r.client_id || '') === cid;
      });
    }

    return sortPresetsForView(S.scope, rows);
  };

  // Keep selected row id in the manager context
  S.selectedId = null;

  showModal(
    'Preset Rates',
    [{ key: 'main', title: 'Presets' }],
    () => '<div class="tabc"><div class="hint">Loadingâ€¦</div></div>',
    async () => true, // no save in parent
    false,
    async () => {
      const rows = await fetchRows();
      const mb = document.getElementById('modalBody');
      if (mb) mb.innerHTML = buildBody(rows);

      // Make sure header Delete stays hidden for this manager
      const delBtn = document.getElementById('btnDelete');
      if (delBtn) {
        delBtn.style.display = 'none';
        delBtn.onclick = null;
      }

      // Inject a scoped "New" button (idempotent) into the real actions bar
      if (!document.getElementById('btnRpNew')) {
        const bar = document.getElementById('btnSave')?.parentElement;
        if (bar) {
          const nb = document.createElement('button');
          nb.id = 'btnRpNew';
          nb.type = 'button';
          nb.className = 'btn';
          nb.textContent = 'New';
          nb.style.marginLeft = 'auto';
          nb.onclick = () => openRatePresetModal({ mode: 'edit' });
          bar.insertBefore(nb, document.getElementById('btnSave'));
        }
      }

      // Clean-up hook so "New" disappears when this frame is not top-most
      try {
        const fr = window.__getModalFrame?.();
        const prevDetach = fr && fr._detachGlobal;
        if (fr) {
          fr._detachGlobal = () => {
            try { document.getElementById('btnRpNew')?.remove(); } catch {}
            if (typeof prevDetach === 'function') { try { prevDetach(); } catch {} }
          };
        }
      } catch {}

      // Expose refresh to child modal
      S.refresh = async () => {
        const newRows = await fetchRows();
        const host = document.getElementById('rp_table_wrap');
        if (!host) return; // parent closed or not mounted
        host.innerHTML = renderTable(newRows);
        S.selectedId = null;
        wireTable();
      };

      function wireTable(){
        const tbl = document.getElementById('ratesPresetsTable');
        if (!tbl) return;

        tbl.addEventListener('click', (e) => {
          const delEl = e.target.closest('button[data-del]');
          if (delEl) {
            const id = delEl.getAttribute('data-del');
            if (!id) return;
            if (!confirm('Delete this preset?')) return;
            (async () => {
              try {
                await deleteRatePreset(id);
                if (S.selectedId === id) S.selectedId = null;
                await S.refresh();
              } catch (err) {
                alert(err?.message || 'Delete failed');
              }
            })();
            e.stopPropagation();
            return;
          }

          const tr = e.target.closest('tr[data-id]');
          if (!tr) return;
          S.selectedId = tr.getAttribute('data-id');
          tbl.querySelectorAll('tr').forEach(n => n.classList.remove('active'));
          tr.classList.add('active');
        });

        tbl.addEventListener('dblclick', (e) => {
          const tr = e.target.closest('tr[data-id]'); if (!tr) return;
          const id = tr.getAttribute('data-id');
          openRatePresetModal({ id, mode:'view' });
        });
      }

      function wireFilters(){
        const radios = Array.from(document.querySelectorAll('input[name="rp_scope"]'));
        radios.forEach(r => r.addEventListener('change', async () => {
          S.scope = r.value;
          const row = document.getElementById('rp_client_row');
          if (row) row.style.display = (S.scope === 'CLIENT' ? 'block':'none');
          await S.refresh();
        }));

        const pick = document.getElementById('rp_pick_client');
        if (pick) pick.onclick = () => {
          openClientPicker(({ id, label }) => {
            S.client_id = id;
            S.client_label = label;
            const badge = document.getElementById('rp_cli_badge');
            if (badge) badge.innerHTML = `<span class="pill">${label}</span>`;
            S.refresh();
          });
        };
        const clr = document.getElementById('rp_clear_client');
        if (clr) clr.onclick = () => {
          S.client_id = null;
          S.client_label = '';
          const badge = document.getElementById('rp_cli_badge');
          if (badge) badge.innerHTML = '<span class="mini">No client selected</span>';
          S.refresh();
        };

        const inpQ = document.getElementById('rp_q');
        if (inpQ && !inpQ.__wired) {
          inpQ.__wired = true;
          let t = 0;
          inpQ.addEventListener('input', () => {
            if (t) clearTimeout(t);
            t = setTimeout(() => { S.q = inpQ.value.trim(); S.refresh(); }, 180);
          });
        }
      }

      wireTable();
      wireFilters();
    },
    { kind:'rates-presets' }
  );

  // Kick the managerâ€™s onReturn so it replaces the â€œLoadingâ€¦â€ stub
  setTimeout(() => {
    const fr = window.__getModalFrame?.();
    if (fr && fr.kind === 'rates-presets' && typeof fr.onReturn === 'function' && !fr.__init__) {
      fr.__init__ = true;
      fr.onReturn();
    }
  }, 0);
}


async function openRatePresetModal({ id, mode } = {}) {
  const isCreate = !id;
  let initialMode = mode || (isCreate ? 'edit' : 'view');
  initialMode = String(initialMode || '').toLowerCase();
  if (initialMode === 'create') initialMode = 'edit';
  if (initialMode !== 'edit' && initialMode !== 'view') {
    initialMode = isCreate ? 'edit' : 'view';
  }

  const st = {
    id: id || null,
    scope: 'GLOBAL',
    client_id: null,
    client_label: '',
    name: '',
    role: '',
    band: '',
    display_site: '',
    bucket_day: 'Day',
    bucket_night: 'Night',
    bucket_sat: 'Sat',
    bucket_sun: 'Sun',
    bucket_bh: 'BH',
    enable_paye: false,
    enable_umbrella: false,
    payMode: 'PAYE', // 'PAYE' | 'UMB' | 'BOTH'
    paye_day: '',
    paye_night: '',
    paye_sat: '',
    paye_sun: '',
    paye_bh: '',
    umb_day: '',
    umb_night: '',
    umb_sat: '',
    umb_sun: '',
    umb_bh: '',
    charge_day: '',
    charge_night: '',
    charge_sat: '',
    charge_sun: '',
    charge_bh: '',
    mileage_pay_rate: '',
    mileage_charge_rate: '',
    use_schedule: false,
    mon_start: '',
    mon_end: '',
    mon_break: '',
    tue_start: '',
    tue_end: '',
    tue_break: '',
    wed_start: '',
    wed_end: '',
    wed_break: '',
    thu_start: '',
    thu_end: '',
    thu_break: '',
    fri_start: '',
    fri_end: '',
    fri_break: '',
    sat_start: '',
    sat_end: '',
    sat_break: '',
    sun_start: '',
    sun_end: '',
    sun_break: ''
  };

  if (id) {
    try {
      const row = await loadRatePreset(id);
      st.id = row.id || id;
      st.scope = (String(row.scope || (row.client_id ? 'CLIENT' : 'GLOBAL')).toUpperCase() === 'CLIENT') ? 'CLIENT' : 'GLOBAL';
      st.client_id = row.client_id || null;
      st.client_label = (row.client && row.client.name) ? row.client.name : (row.client_name || '');
      st.name = row.name || '';
      st.role = row.role || '';
      st.band = (row.band == null ? '' : String(row.band));
      st.display_site = row.display_site || '';

      const L = normaliseBucketLabelsInput(row.bucket_labels_json || null) || labelsDefault();
      st.bucket_day = L.day;
      st.bucket_night = L.night;
      st.bucket_sat = L.sat;
      st.bucket_sun = L.sun;
      st.bucket_bh = L.bh;

      st.enable_paye = !!row.enable_paye;
      st.enable_umbrella = !!row.enable_umbrella;

      if (st.enable_paye && st.enable_umbrella) {
        st.payMode = 'BOTH';
      } else if (st.enable_paye) {
        st.payMode = 'PAYE';
      } else if (st.enable_umbrella) {
        st.payMode = 'UMB';
      } else {
        st.payMode = 'PAYE';
      }

      const put = (k, v) => { if (v === 0 || (v != null && v !== '')) st[k] = String(v); };
      const R = row || {};

      put('paye_day', R.paye_day);
      put('paye_night', R.paye_night);
      put('paye_sat', R.paye_sat);
      put('paye_sun', R.paye_sun);
      put('paye_bh', R.paye_bh);

      put('umb_day', R.umb_day);
      put('umb_night', R.umb_night);
      put('umb_sat', R.umb_sat);
      put('umb_sun', R.umb_sun);
      put('umb_bh', R.umb_bh);

      put('charge_day', R.charge_day);
      put('charge_night', R.charge_night);
      put('charge_sat', R.charge_sat);
      put('charge_sun', R.charge_sun);
      put('charge_bh', R.charge_bh);

      put('mileage_pay_rate', R.mileage_pay_rate);
      put('mileage_charge_rate', R.mileage_charge_rate);

      if (row.std_schedule_json && typeof row.std_schedule_json === 'object') {
        st.use_schedule = true;
        const S = row.std_schedule_json || {};
        const days = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'];
        days.forEach(d => {
          if (S[d]) {
            st[`${d}_start`] = S[d].start || '';
            st[`${d}_end`] = S[d].end || '';
            st[`${d}_break`] = (S[d].break_minutes == null ? '' : String(S[d].break_minutes));
          }
        });
      }
    } catch (e) {
      alert(e?.message || 'Failed to load preset');
      return;
    }
  }

  const buckets = ['day', 'night', 'sat', 'sun', 'bh'];

  function getFieldValue(root, name) {
    if (!root) return '';
    const el = root.querySelector(`[name="${name}"]`);
    return (el && typeof el.value === 'string') ? el.value.trim() : '';
  }

  function parseNumeric(raw) {
    if (raw == null) return null;
    const s = String(raw).trim();
    if (!s) return null;
    const n = Number(s);
    return Number.isFinite(n) ? n : null;
  }

  function parseNumericFromRoot(root, name) {
    return parseNumeric(getFieldValue(root, name));
  }

  function computePresetEligibility(root, st) {
    const result = { margin: null, eligible: false, rateState: null, scope: '', payMode: '', reasons: [] };
    if (!root) return result;

    const rtEl = root.querySelector('#rp_rate_type');
    let scopeVal = (rtEl && rtEl.value) ? String(rtEl.value).toUpperCase() : '';
    if (scopeVal !== 'GLOBAL' && scopeVal !== 'CLIENT') scopeVal = '';
    result.scope = scopeVal;
    if (scopeVal) st.scope = scopeVal;

    const pmEl = root.querySelector('#rp_pay_mode');
    let payModeVal = (pmEl && pmEl.value) ? String(pmEl.value).toUpperCase() : (st.payMode || '');
    if (!['PAYE', 'UMB', 'BOTH'].includes(payModeVal)) payModeVal = '';
    result.payMode = payModeVal;

    const rateState = {
      enable_paye: ['PAYE', 'BOTH'].includes(payModeVal),
      enable_umbrella: ['UMB', 'BOTH'].includes(payModeVal)
    };

    buckets.forEach(b => {
      ['paye', 'umb', 'charge'].forEach(prefix => {
        rateState[`${prefix}_${b}`] = parseNumericFromRoot(root, `${prefix}_${b}`);
      });
    });

    result.rateState = rateState;
    const margin = computeRatePresetMargins(rateState);
    result.margin = margin;

    let eligible = true;

    const nameVal = getFieldValue(root, 'name');
    if (!nameVal) { eligible = false; result.reasons.push('name'); }

    const roleVal = getFieldValue(root, 'role');
    if (!roleVal) { eligible = false; result.reasons.push('role'); }

    if (!scopeVal) { eligible = false; result.reasons.push('scope'); }
    if (scopeVal === 'CLIENT') {
      const cid = st.client_id || '';
      if (!cid) { eligible = false; result.reasons.push('client'); }
    }

    const labelNames = ['bucket_day', 'bucket_night', 'bucket_sat', 'bucket_sun', 'bucket_bh'];
    const anyLabel = labelNames.some(n => !!getFieldValue(root, n));
    if (!anyLabel) { eligible = false; result.reasons.push('labels'); }

    if (!payModeVal) { eligible = false; result.reasons.push('payMode'); }

    const hasCharge = buckets.some(b => Number.isFinite(rateState[`charge_${b}`]));
    if (!hasCharge) { eligible = false; result.reasons.push('rates_charge'); }

    if (payModeVal === 'PAYE') {
      const okRow = buckets.some(
        b => Number.isFinite(rateState[`paye_${b}`]) && Number.isFinite(rateState[`charge_${b}`])
      );
      if (!okRow) { eligible = false; result.reasons.push('rates_paye'); }
    } else if (payModeVal === 'UMB') {
      const okRow = buckets.some(
        b => Number.isFinite(rateState[`umb_${b}`]) && Number.isFinite(rateState[`charge_${b}`])
      );
      if (!okRow) { eligible = false; result.reasons.push('rates_umb'); }
    } else if (payModeVal === 'BOTH') {
      const okRow = buckets.some(
        b =>
          Number.isFinite(rateState[`paye_${b}`]) &&
          Number.isFinite(rateState[`umb_${b}`]) &&
          Number.isFinite(rateState[`charge_${b}`])
      );
      if (!okRow) { eligible = false; result.reasons.push('rates_both'); }
    }

    const useScheduleEl = root.querySelector('#rp_use_schedule');
    const useSchedule = !!useScheduleEl && !!useScheduleEl.checked;
    if (useSchedule) {
      const days = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'];
      const S = {};
      const hhmm = (s) => {
        if (!s) return '';
        const m = String(s).match(/^(\d{1,2}):?(\d{2})$/);
        if (!m) return '';
        const h = +m[1], mi = +m[2];
        if (h < 0 || h > 23 || mi < 0 || mi > 59) return '';
        return String(h).padStart(2, '0') + ':' + String(mi).padStart(2, '0');
      };
      days.forEach(d => {
        const s = hhmm(getFieldValue(root, `${d}_start`));
        const e = hhmm(getFieldValue(root, `${d}_end`));
        const br = getFieldValue(root, `${d}_break`);
        if (s && e) {
          S[d] = { start: s, end: e, break_minutes: Math.max(0, Number(br || 0)) };
        }
      });
      if (Object.keys(S).length === 0) {
        eligible = false;
        result.reasons.push('schedule');
      }
    }

    result.eligible = eligible;
    return result;
  }

  const renderGrid = () => {
    const tempState = {
      enable_paye: ['PAYE', 'BOTH'].includes(st.payMode),
      enable_umbrella: ['UMB', 'BOTH'].includes(st.payMode)
    };
    buckets.forEach(b => {
      tempState[`paye_${b}`] = parseNumeric(st[`paye_${b}`]);
      tempState[`umb_${b}`] = parseNumeric(st[`umb_${b}`]);
      tempState[`charge_${b}`] = parseNumeric(st[`charge_${b}`]);
    });
    const margin = computeRatePresetMargins(tempState);

    const row = (lab, key) => {
      const MP = margin.bucket[key]?.marginPaye;
      const MU = margin.bucket[key]?.marginUmb;
      const negP = margin.bucket[key]?.negPaye;
      const negU = margin.bucket[key]?.negUmb;
      const mTxt = [
        (tempState.enable_paye ? `PAYE: ${MP == null ? 'â€”' : MP.toFixed(2)}${negP ? ' âš ' : ''}` : ''),
        (tempState.enable_umbrella ? `Umb: ${MU == null ? 'â€”' : MU.toFixed(2)}${negU ? ' âš ' : ''}` : '')
      ].filter(Boolean).join(' â€¢ ');

      return `
        <div class="grid-5 rp-rate-row" data-bucket="${key}">
          <div class="split"><span class="lbl">${lab}</span></div>
          <div class="rp-col-paye">
            <input class="input" name="paye_${key}" placeholder="PAYE" value="${st[`paye_${key}`] || ''}"/>
          </div>
          <div class="rp-col-umb">
            <input class="input" name="umb_${key}" placeholder="Umbrella" value="${st[`umb_${key}`] || ''}"/>
          </div>
          <div class="rp-col-charge">
            <input class="input" name="charge_${key}" placeholder="Charge" value="${st[`charge_${key}`] || ''}"/>
          </div>
          <div class="mini" data-role="margin">${mTxt || ''}</div>
        </div>`;
    };

    return `
      <div class="group">
        <div class="row"><label>Rates</label>
          <div class="controls small">
            <div class="grid-5" id="rp_rates_header">
              <div></div>
              <div class="mini rp-col-paye">PAYE</div>
              <div class="mini rp-col-umb">Umbrella</div>
              <div class="mini rp-col-charge">Charge</div>
              <div class="mini">Margin</div>
            </div>
            ${row(st.bucket_day, 'day')}
            ${row(st.bucket_night, 'night')}
            ${row(st.bucket_sat, 'sat')}
            ${row(st.bucket_sun, 'sun')}
            ${row(st.bucket_bh, 'bh')}
            <div class="mini" id="rp_margin_warn" style="margin-top:6px;${margin.anyNegative ? '' : 'display:none'}">Margin can't be negative.</div>
          </div>
        </div>
      </div>
    `;
  };

  const renderSchedule = () => {
    const timeInput = (name, val) => `<input class="input rp-time" name="${name}" value="${val || ''}" placeholder="HH:MM" />`;
    const breakInput = (name, val) => `<input class="input rp-break" type="number" min="0" step="1" name="${name}" value="${val || ''}" placeholder="0" />`;
    const row = (key, label) => `
      <div class="rp-day" data-day="${key}" style="margin-bottom:10px">
        <div class="grid-3">
          <div class="split"><span class="mini">${label} start</span>${timeInput(`${key}_start`, st[`${key}_start`])}</div>
          <div class="split"><span class="mini">${label} end</span>${timeInput(`${key}_end`, st[`${key}_end`])}</div>
          <div class="split"><span class="mini">Break (min)</span>${breakInput(`${key}_break`, st[`${key}_break`])}</div>
        </div>
        <div class="split" style="margin-top:6px">
          <button type="button" class="btn mini rp_copy" data-day="${key}">Copy</button>
          <button type="button" class="btn mini rp_paste" data-day="${key}">Paste</button>
        </div>
      </div>`;
    return `
      <div class="group">
        <label><input type="checkbox" id="rp_use_schedule" ${st.use_schedule ? 'checked' : ''}/> Default shift times</label>
        <div id="rp_sched_block" style="display:${st.use_schedule ? 'block' : 'none'}; margin-top:8px">
          ${row('mon', 'Mon')}${row('tue', 'Tue')}${row('wed', 'Wed')}
          ${row('thu', 'Thu')}${row('fri', 'Fri')}${row('sat', 'Sat')}
          ${row('sun', 'Sun')}
        </div>
      </div>`;
  };

  const renderLabels = () => `
    <div class="group">
      <div class="row"><label>Bucket labels</label>
        <div class="controls small">
          <div class="grid-5" id="rp_labels_grid">
            <div><span class="mini">Standard</span><input class="input" name="bucket_day"   value="${st.bucket_day}"/></div>
            <div><span class="mini">OT1</span>     <input class="input" name="bucket_night" value="${st.bucket_night}"/></div>
            <div><span class="mini">OT2</span>     <input class="input" name="bucket_sat"   value="${st.bucket_sat}"/></div>
            <div><span class="mini">OT3</span>     <input class="input" name="bucket_sun"   value="${st.bucket_sun}"/></div>
            <div><span class="mini">OT4</span>     <input class="input" name="bucket_bh"    value="${st.bucket_bh}"/></div>
          </div>
          <div style="margin-top:8px">
            <span class="mini">Pay mode</span>
            <select class="input" name="rp_pay_mode" id="rp_pay_mode">
              <option value="PAYE" ${st.payMode === 'PAYE' ? 'selected' : ''}>PAYE</option>
              <option value="UMB" ${st.payMode === 'UMB' ? 'selected' : ''}>Umbrella</option>
              <option value="BOTH" ${st.payMode === 'BOTH' ? 'selected' : ''}>PAYE &amp; Umbrella</option>
            </select>
          </div>
        </div>
      </div>
    </div>`;

  const renderTop = () => `
    <div class="group">
      <div class="row">
        <label>Name</label>
        <div class="controls"><input class="input" name="name" value="${st.name}"/></div>
      </div>

      <div class="row">
        <label>Rate type</label>
        <div class="controls">
          <select id="rp_rate_type" class="input">
            <option value="">Please select</option>
            <option value="GLOBAL" ${st.scope === 'GLOBAL' ? 'selected' : ''}>Global</option>
            <option value="CLIENT" ${st.scope === 'CLIENT' ? 'selected' : ''}>Client specific</option>
          </select>
        </div>
      </div>

      <div class="row" id="rp_client_row" style="margin-top:6px; display:${st.scope === 'CLIENT' ? 'block' : 'none'}">
        <label>Client rate</label>
        <div class="controls">
          <div class="split">
            <button type="button" class="btn mini" id="rp_pick_cli_btn">Pickâ€¦</button>
            <button type="button" class="btn mini" id="rp_clear_cli_btn">Clear</button>
            <span class="mini" id="rp_cli_lbl">${st.client_label ? `Chosen: ${st.client_label}` : 'No client chosen'}</span>
          </div>
        </div>
      </div>

      <div class="grid-3">
        <div class="row"><label>Role</label><div class="controls"><input class="input" name="role" value="${st.role}"/></div></div>
        <div class="row"><label>Band</label><div class="controls"><input class="input" name="band" value="${st.band}"/></div></div>
        <div class="row"><label>Display site</label><div class="controls"><input class="input" name="display_site" value="${st.display_site}"/></div></div>
      </div>
    </div>`;

  const renderMileage = () => `
    <div class="group">
      <div class="row"><label>Mileage</label>
        <div class="controls">
          <div class="grid-3">
            <div class="split"><span class="mini">Pay</span>   <input class="input" name="mileage_pay_rate"    value="${st.mileage_pay_rate || ''}" placeholder="0.00"/></div>
            <div class="split"><span class="mini">Charge</span><input class="input" name="mileage_charge_rate" value="${st.mileage_charge_rate || ''}" placeholder="0.00"/></div>
          </div>
        </div>
      </div>
    </div>`;

  const renderer = () => `
    <div class="tabc">
      <div class="form" id="rp_form">
        <div>
          ${renderTop()}
          ${renderLabels()}
          ${renderGrid()}
          ${renderMileage()}
        </div>
        <div>
          ${renderSchedule()}
        </div>
      </div>
    </div>
  `;

  const onSave = async () => {
    const root = document.getElementById('rp_form');
    if (!root) return false;

    const v = (n) => getFieldValue(root, n);

    const rtEl = root.querySelector('#rp_rate_type');
    let scopeVal = (rtEl && rtEl.value) ? String(rtEl.value).toUpperCase() : '';
    const scopeIsClient = (scopeVal === 'CLIENT');
    const scopeIsGlobal = (scopeVal === 'GLOBAL');

    if (!scopeIsClient && !scopeIsGlobal) {
      showModalHint('Select a rate type (Global or Client specific).', 'warn');
      return false;
    }

    const name = v('name');
    if (!name) {
      showModalHint('Name is required.', 'warn');
      return false;
    }

    const clientId = scopeIsClient ? (st.client_id || '') : '';
    if (scopeIsClient && !clientId) {
      showModalHint('Pick a client for a Client scope preset.', 'warn');
      return false;
    }

    const roleVal = v('role');
    if (!roleVal) {
      showModalHint('Role is required.', 'warn');
      return false;
    }

    const pmEl = root.querySelector('#rp_pay_mode');
    let payModeVal = (pmEl && pmEl.value) ? String(pmEl.value).toUpperCase() : (st.payMode || '');
    if (!['PAYE', 'UMB', 'BOTH'].includes(payModeVal)) {
      showModalHint('Choose PAYE, Umbrella or PAYE & Umbrella.', 'warn');
      return false;
    }

    const eligibility = computePresetEligibility(root, st);
    const margin = eligibility.margin || { anyNegative: false };
    if (margin.anyNegative) {
      showModalHint('Margin canâ€™t be negative.', 'warn');
      return false;
    }
    if (!eligibility.eligible) {
      showModalHint('Fill in all required fields (name, role, labels, rates and schedule if used).', 'warn');
      return false;
    }

    const enable_paye = ['PAYE', 'BOTH'].includes(payModeVal);
    const enable_umbrella = ['UMB', 'BOTH'].includes(payModeVal);

    const payload = {
      id: st.id || undefined,
      name,
      scope: scopeIsClient ? 'CLIENT' : 'GLOBAL',
      client_id: scopeIsClient ? st.client_id : null,
      role: roleVal || null,
      band: (v('band') === '' ? null : v('band')),
      display_site: v('display_site') || null,
      enable_paye,
      enable_umbrella
    };

    const labels = {
      day: v('bucket_day'),
      night: v('bucket_night'),
      sat: v('bucket_sat'),
      sun: v('bucket_sun'),
      bh: v('bucket_bh')
    };
    const Lnorm = normaliseBucketLabelsInput(labels);
    if (Lnorm) payload.bucket_labels_json = Lnorm;

    const bucketsList = ['day','night','sat','sun','bh'];
    const push5 = (prefix, enabled) => {
      if (!enabled) return;
      bucketsList.forEach(b => {
        const key = `${prefix}_${b}`;
        const n = parseNumericFromRoot(root, key);
        if (n != null) payload[key] = n;
      });
    };
    push5('paye', enable_paye);
    push5('umb', enable_umbrella);
    push5('charge', true);

    const mileage_pay = parseNumericFromRoot(root, 'mileage_pay_rate');
    const mileage_charge = parseNumericFromRoot(root, 'mileage_charge_rate');
    if (mileage_pay != null && mileage_pay < 0) {
      showModalHint('Mileage pay must be â‰¥ 0', 'warn');
      return false;
    }
    if (mileage_charge != null && mileage_charge < 0) {
      showModalHint('Mileage charge must be â‰¥ 0', 'warn');
      return false;
    }
    if (mileage_pay != null) payload.mileage_pay_rate = mileage_pay;
    if (mileage_charge != null) payload.mileage_charge_rate = mileage_charge;

    const use_schedule = !!document.getElementById('rp_use_schedule')?.checked;
    if (use_schedule) {
      const days = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'];
      const S = {};
      const hhmm = (s) => {
        if (!s) return '';
        const m = String(s).match(/^(\d{1,2}):?(\d{2})$/);
        if (!m) return '';
        const h = +m[1], mi = +m[2];
        if (h < 0 || h > 23 || mi < 0 || mi > 59) return '';
        return String(h).padStart(2, '0') + ':' + String(mi).padStart(2, '0');
      };
      days.forEach(d => {
        const s = hhmm(v(`${d}_start`));
        const e = hhmm(v(`${d}_end`));
        const br = v(`${d}_break`);
        if (s && e) {
          S[d] = { start: s, end: e, break_minutes: Math.max(0, Number(br || 0)) };
        }
      });
      if (Object.keys(S).length) payload.std_schedule_json = S;
    }

    try {
      await saveRatePreset(payload);
      try { window.__ratesPresets__?.refresh && window.__ratesPresets__.refresh(); } catch {}
      return true;
    } catch (e) {
      showModalHint(e?.message || 'Save failed', 'fail');
      return false;
    }
  };

  showModal(
    isCreate ? 'Create preset' : 'Rate preset',
    [{ key: 'main', title: 'Main' }],
    () => renderer(),
    onSave,
    !!st.id,
    () => {
      const root = document.getElementById('rp_form');

      const saveBtn = document.getElementById('btnSave');
      if (saveBtn && initialMode === 'view') {
        saveBtn.disabled = true;
        saveBtn.title = 'Click Edit to make changes';
      }

      const rateTypeSel = root?.querySelector('#rp_rate_type');
      const cliRow = root?.querySelector('#rp_client_row');
      const cliLbl = root?.querySelector('#rp_cli_lbl');
      const btnPick = root?.querySelector('#rp_pick_cli_btn');
      const btnClr = root?.querySelector('#rp_clear_cli_btn');

      const ensureMileagePrefill = async () => {
        const isCreateNow = !st.id;
        if (isCreateNow && st.scope === 'CLIENT' && st.client_id) {
          try {
            const cli = await getClient(st.client_id);
            const ch = Number(cli?.mileage_charge_rate);
            if (Number.isFinite(ch)) {
              const pay = Math.max(0, ch - 0.10);
              const payEl = root.querySelector('[name="mileage_pay_rate"]');
              const chEl = root.querySelector('[name="mileage_charge_rate"]');
              if (chEl && !chEl.value) { chEl.value = String(ch); st.mileage_charge_rate = String(ch); }
              if (payEl && !payEl.value) { payEl.value = pay.toFixed(2); st.mileage_pay_rate = payEl.value; }
            }
          } catch {}
        }
      };

      const toggleColDisplay = (selector, on) => {
        root?.querySelectorAll(selector).forEach(el => {
          el.style.display = on ? '' : 'none';
        });
      };

      function refreshPayModeColumns() {
        const payMode = st.payMode || 'PAYE';
        st.enable_paye = (payMode === 'PAYE' || payMode === 'BOTH');
        st.enable_umbrella = (payMode === 'UMB' || payMode === 'BOTH');

        buckets.forEach(b => {
          const paye = root?.querySelector(`[name="paye_${b}"]`);
          const umb = root?.querySelector(`[name="umb_${b}"]`);
          if (paye) paye.disabled = !st.enable_paye;
          if (umb) umb.disabled = !st.enable_umbrella;
        });

        toggleColDisplay('#rp_form .rp-col-paye', st.enable_paye);
        toggleColDisplay('#rp_form .rp-col-umb', st.enable_umbrella);
      }

      function updatePresetSaveState() {
        const { margin, rateState, eligible } = computePresetEligibility(root, st);

        const warn = root?.querySelector('#rp_margin_warn');
        if (warn) warn.style.display = (margin && margin.anyNegative) ? '' : 'none';

        buckets.forEach(b => {
          const cell = root?.querySelector(`.rp-rate-row[data-bucket="${b}"] [data-role="margin"]`);
          if (!cell) return;
          const bucketMargin = margin?.bucket?.[b] || {};
          const mp = bucketMargin.marginPaye;
          const mu = bucketMargin.marginUmb;
          const negP = bucketMargin.negPaye;
          const negU = bucketMargin.negUmb;
          const parts = [];
          if (rateState.enable_paye) {
            parts.push(`PAYE: ${mp == null || Number.isNaN(mp) ? 'â€”' : mp.toFixed(2)}${negP ? ' âš ' : ''}`);
          }
          if (rateState.enable_umbrella) {
            parts.push(`Umb: ${mu == null || Number.isNaN(mu) ? 'â€”' : mu.toFixed(2)}${negU ? ' âš ' : ''}`);
          }
          cell.textContent = parts.filter(Boolean).join(' â€¢ ');
        });

        const fr = window.__getModalFrame?.();
        const btn = document.getElementById('btnSave');
        const modeNow = fr?.mode || initialMode || 'view';
        const canSave = !!(modeNow === 'edit' && margin && !margin.anyNegative && eligible);
        if (btn) {
          btn.disabled = !canSave;
          if (modeNow !== 'edit') {
            btn.title = 'Click Edit to make changes';
          } else {
            btn.title = canSave ? '' : 'Fill required fields and fix any negative margins';
          }
        }
        if (fr && typeof fr._updateButtons === 'function') {
          fr.__canSave = canSave;
          fr._updateButtons();
        }
      }

      function setPayMode(newMode, opts) {
        const optsNorm = opts || {};
        const clearPrev = !!optsNorm.clearPrev;
        const prevMode = st.payMode || 'PAYE';
        if (!newMode) return;
        const modeNorm = String(newMode).toUpperCase();
        if (!['PAYE', 'UMB', 'BOTH'].includes(modeNorm)) return;

        if (clearPrev && prevMode !== modeNorm) {
          if (prevMode === 'PAYE' && modeNorm === 'UMB') {
            buckets.forEach(b => {
              st[`paye_${b}`] = '';
              const inp = root?.querySelector(`[name="paye_${b}"]`);
              if (inp) inp.value = '';
            });
          } else if (prevMode === 'UMB' && modeNorm === 'PAYE') {
            buckets.forEach(b => {
              st[`umb_${b}`] = '';
              const inp = root?.querySelector(`[name="umb_${b}"]`);
              if (inp) inp.value = '';
            });
          }
        }

        st.payMode = modeNorm;
        refreshPayModeColumns();
        updatePresetSaveState();
      }

      function syncPayModeFromDom(opts) {
        const pmEl = root?.querySelector('#rp_pay_mode');
        const valRaw = pmEl?.value || st.payMode || 'PAYE';
        const val = String(valRaw).toUpperCase();
        const mode = ['PAYE', 'UMB', 'BOTH'].includes(val) ? val : 'PAYE';
        setPayMode(mode, opts);
      }

      function applyScopeFromControl(isInit) {
        if (!rateTypeSel) return;
        const prevScope = st.scope || 'GLOBAL';
        let val = String(rateTypeSel.value || '').toUpperCase();
        if (val !== 'GLOBAL' && val !== 'CLIENT') val = 'GLOBAL';
        const nextScope = val;

        if (nextScope === 'CLIENT') {
          st.scope = 'CLIENT';
          if (cliRow) cliRow.style.display = 'block';
          ensureMileagePrefill();
        } else {
          st.scope = 'GLOBAL';
          if (cliRow) cliRow.style.display = 'none';
          if (!isInit && prevScope === 'CLIENT') {
            st.client_id = null;
            st.client_label = '';
            if (cliLbl) cliLbl.textContent = 'No client chosen';
          }
        }
        updatePresetSaveState();
      }

      if (rateTypeSel) {
        rateTypeSel.addEventListener('change', () => applyScopeFromControl(false));
        applyScopeFromControl(true);
      }

      if (btnPick) {
        btnPick.onclick = () => {
          openClientPicker(({ id, label }) => {
            st.client_id = id;
            st.client_label = label || '';
            if (cliLbl) cliLbl.textContent = label ? `Chosen: ${label}` : 'No client chosen';
            ensureMileagePrefill();
            updatePresetSaveState();
          }, { allowBackdropModal: true });
        };
      }

      if (btnClr) {
        btnClr.onclick = () => {
          st.client_id = null;
          st.client_label = '';
          if (cliLbl) cliLbl.textContent = 'No client chosen';
          updatePresetSaveState();
        };
      }

      const pmSelect = root?.querySelector('#rp_pay_mode');
      if (pmSelect) {
        pmSelect.addEventListener('change', () => syncPayModeFromDom({ clearPrev: true }));
        syncPayModeFromDom({ clearPrev: false });
      } else {
        st.payMode = st.payMode || 'PAYE';
        refreshPayModeColumns();
      }

      const lblMap = {
        bucket_day: 'day',
        bucket_night: 'night',
        bucket_sat: 'sat',
        bucket_sun: 'sun',
        bucket_bh: 'bh'
      };
      Object.keys(lblMap).forEach(n => {
        const el = root?.querySelector(`#rp_labels_grid [name="${n}"]`);
        if (!el) return;
        el.addEventListener('input', () => {
          const k = lblMap[n];
          st[`bucket_${k}`] = el.value || '';
          const cell = root?.querySelector(`.rp-rate-row[data-bucket="${k}"] .lbl`);
          if (cell) cell.textContent = st[`bucket_${k}`] || cell.textContent;
          updatePresetSaveState();
        });
      });

      const useSch = document.getElementById('rp_use_schedule');
      const schBlk = document.getElementById('rp_sched_block');
      if (useSch && schBlk) {
        const togg = () => {
          st.use_schedule = !!useSch.checked;
          schBlk.style.display = st.use_schedule ? 'block' : 'none';
          updatePresetSaveState();
        };
        useSch.addEventListener('change', togg);
        togg();
      }

      const normalizeRateInput = (el) => {
        if (!el) return;
        let v = (el.value || '').trim();
        if (!v) return;
        v = v.replace(/\s+/g, '');
        if (v.startsWith('.')) v = '0' + v;
        const n = Number(v);
        if (!Number.isFinite(n)) return;
        el.value = n.toFixed(2);
      };

      buckets.forEach(b => {
        ['paye', 'umb', 'charge'].forEach(prefix => {
          const inp = root?.querySelector(`[name="${prefix}_${b}"]`);
          if (inp) {
            inp.addEventListener('blur', () => {
              normalizeRateInput(inp);
              st[`${prefix}_${b}`] = inp.value || '';
              updatePresetSaveState();
            });
            inp.addEventListener('input', () => {
              st[`${prefix}_${b}`] = inp.value || '';
            });
          }
        });
      });

      const mileagePayEl = root?.querySelector('[name="mileage_pay_rate"]');
      const mileageChargeEl = root?.querySelector('[name="mileage_charge_rate"]');
      const normalizeMileageInput = (el) => {
        if (!el) return;
        let v = (el.value || '').trim();
        if (!v) return;
        if (v.startsWith('.')) v = '0' + v;
        let numVal;
        if (v.includes('.')) {
          numVal = Number(v);
        } else {
          numVal = Number(v) / 100;
        }
        if (!Number.isFinite(numVal)) return;
        el.value = numVal.toFixed(2);
      };
      if (mileagePayEl) {
        mileagePayEl.addEventListener('blur', () => {
          normalizeMileageInput(mileagePayEl);
          st.mileage_pay_rate = mileagePayEl.value || '';
          const isCreateNow = !st.id;
          if (isCreateNow && mileageChargeEl && !(mileageChargeEl.value || '').trim()) {
            mileageChargeEl.value = mileagePayEl.value;
            st.mileage_charge_rate = mileageChargeEl.value || '';
          }
          updatePresetSaveState();
        });
        mileagePayEl.addEventListener('input', () => {
          st.mileage_pay_rate = mileagePayEl.value || '';
        });
      }
      if (mileageChargeEl) {
        mileageChargeEl.addEventListener('blur', () => {
          normalizeMileageInput(mileageChargeEl);
          st.mileage_charge_rate = mileageChargeEl.value || '';
          updatePresetSaveState();
        });
        mileageChargeEl.addEventListener('input', () => {
          st.mileage_charge_rate = mileageChargeEl.value || '';
        });
      }

      let schedClipboard = null;
      const schedRoot = document.getElementById('rp_sched_block');

      const normaliseTimeInput = (t) => {
        if (!t || !/^(mon|tue|wed|thu|fri|sat|sun)_(start|end)$/.test(t.name)) return;
        const raw = (t.value || '').trim();
        const norm = (function (x) {
          if (!x) return '';
          const y = x.replace(/\s+/g, '');
          let h, m;
          if (/^\d{3,4}$/.test(y)) {
            const s = y.padStart(4, '0'); h = +s.slice(0, 2); m = +s.slice(2, 4);
          } else if (/^\d{1,2}:\d{1,2}$/.test(y)) {
            const parts = y.split(':'); h = +parts[0]; m = +parts[1];
          } else return '';
          if (h < 0 || h > 23 || m < 0 || m > 59) return '';
          return String(h).padStart(2, '0') + ':' + String(m).padStart(2, '0');
        })(raw);

        if (!norm && raw) {
          t.value = '';
          t.setAttribute('data-invalid', '1');
          t.setAttribute('title', 'Enter a valid time HH:MM (00:00â€“23:59)');
          try {
            t.dispatchEvent(new Event('input', { bubbles: true }));
            t.dispatchEvent(new Event('change', { bubbles: true }));
          } catch {}
          st[t.name] = '';
          return;
        }

        if (norm) {
          t.value = norm;
          t.removeAttribute('data-invalid');
          t.removeAttribute('title');
          st[t.name] = norm;
          try {
            t.dispatchEvent(new Event('input', { bubbles: true }));
            t.dispatchEvent(new Event('change', { bubbles: true }));
          } catch {}
        }
      };

      if (schedRoot) {
        schedRoot.addEventListener('blur', (e) => {
          normaliseTimeInput(e.target);
        }, true);

        schedRoot.addEventListener('keydown', (e) => {
          if (e.key === 'Tab') normaliseTimeInput(e.target);
        }, true);

        schedRoot.addEventListener('click', (e) => {
          const copyBtn = e.target.closest('button.rp_copy');
          const pasteBtn = e.target.closest('button.rp_paste');
          if (copyBtn) {
            const day = copyBtn.dataset.day;
            const sEl = root.querySelector(`[name="${day}_start"]`);
            const eEl = root.querySelector(`[name="${day}_end"]`);
            const bEl = root.querySelector(`[name="${day}_break"]`);
            schedClipboard = {
              start: sEl?.value || '',
              end: eEl?.value || '',
              br: bEl?.value || ''
            };
            return;
          }
          if (pasteBtn && schedClipboard) {
            const day = pasteBtn.dataset.day;
            const sEl = root.querySelector(`[name="${day}_start"]`);
            const eEl = root.querySelector(`[name="${day}_end"]`);
            const bEl = root.querySelector(`[name="${day}_break"]`);
            if (sEl) { sEl.value = schedClipboard.start; st[`${day}_start`] = sEl.value || ''; }
            if (eEl) { eEl.value = schedClipboard.end;   st[`${day}_end`]   = eEl.value || ''; }
            if (bEl) { bEl.value = schedClipboard.br;    st[`${day}_break`] = bEl.value || ''; }
            updatePresetSaveState();
          }
        });
      }

      ['input', 'change'].forEach(evt => {
        root?.addEventListener(evt, (e) => {
          const t = e.target;
          if (!t?.name) return;
          if (t.name === 'rp_pay_mode' || t.name === 'rp_rate_type') return;
          if (/^(name|role|band|display_site)$/.test(t.name)) {
            st[t.name] = t.value || '';
          } else if (/^bucket_(day|night|sat|sun|bh)$/.test(t.name)) {
            st[t.name] = t.value || '';
          } else if (/^mileage_(pay|charge)_rate$/.test(t.name)) {
            st[t.name] = t.value || '';
          } else if (/^(mon|tue|wed|thu|fri|sat|sun)_(start|end|break)$/.test(t.name)) {
            st[t.name] = t.value || '';
          } else if (/^(paye|umb|charge)_(day|night|sat|sun|bh)$/.test(t.name)) {
            st[t.name] = t.value || '';
          }
          if (
            /^(paye|umb|charge)_(day|night|sat|sun|bh)$/.test(t.name) ||
            /^(name|role|band|display_site|bucket_(day|night|sat|sun|bh)|mileage_(pay|charge)_rate)$/.test(t.name) ||
            /^(mon|tue|wed|thu|fri|sat|sun)_(start|end|break)$/.test(t.name)
          ) {
            updatePresetSaveState();
          }
        }, true);
      });

      updatePresetSaveState();
    },
    {
      kind: 'rate-preset',
      noParentGate: true,
      forceEdit: initialMode === 'edit'
    }
  );

  setTimeout(() => {
    const fr = window.__getModalFrame?.();
    if (fr && fr.kind === 'rate-preset' && typeof fr.onReturn === 'function' && !fr.__init__) {
      fr.__init__ = true;
      fr.onReturn();
    }
  }, 0);
}
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Rates Presets â€” API wrappers
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function listRatePresets({ scope, client_id, q } = {}) {
  const qs = new URLSearchParams();
  if (scope && scope !== 'ALL') qs.set('scope', String(scope).toUpperCase()); // 'GLOBAL' | 'CLIENT'
  if (client_id) qs.set('client_id', String(client_id));
  if (q) qs.set('q', String(q));
  const url = API(`/api/rates/presets${qs.toString() ? `?${qs.toString()}` : ''}`);
  const r = await authFetch(url);
  const j = await r.json().catch(()=>({ rows: [] }));
  // Return array of full rows (endpoint returns extended shape)
  const rows =
    (Array.isArray(j) ? j :
     Array.isArray(j.rows) ? j.rows :
     Array.isArray(j.data) ? j.data : []);
  return rows;
}

async function deleteRatePreset(id) {
  const r = await authFetch(API(`/api/rates/presets/${encodeURIComponent(String(id))}`), { method:'DELETE' });
  if (!r.ok) throw new Error(await r.text().catch(()=> 'Delete failed'));
  return true;
}

async function loadRatePreset(id) {
  const r = await authFetch(API(`/api/rates/presets/${encodeURIComponent(String(id))}`));
  if (!r.ok) throw new Error(await r.text().catch(()=> 'Failed to load'));
  const j = await r.json().catch(()=> ({}));
  return (j && (j.preset || j.row || j)) || {};
}

async function saveRatePreset(payload /* { id?, ... } */) {
  const hasId = !!payload?.id;
  const url   = hasId
    ? API(`/api/rates/presets/${encodeURIComponent(String(payload.id))}`)
    : API(`/api/rates/presets`);
  const method = hasId ? 'PATCH' : 'POST';

  const body = { ...payload };
  // Do not send id inside body on PATCH
  if (hasId) delete body.id;

  const r = await authFetch(url, {
    method,
    headers: { 'content-type':'application/json' },
    body: JSON.stringify(body)
  });
  if (!r.ok) throw new Error(await r.text().catch(()=> 'Save failed'));
  return r.json().catch(()=> ({}));
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Stable sort helper per spec
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function sortPresetsForView(scopeFilter /* 'ALL'|'GLOBAL'|'CLIENT' */, rows = []) {
  const arr = (rows || []).map((r, i) => ({ r, i })); // keep stable index
  const name = (x) => (x?.name || '').toString().toLowerCase();
  const cli  = (x) => (x?.client?.name || x?.client_name || '').toString().toLowerCase();
  const isGlobal = (x) => !x?.client_id && (String(x?.scope || '').toUpperCase() !== 'CLIENT');

  const cmpStr = (a, b) => (a < b ? -1 : a > b ? 1 : 0);

  arr.sort((A,B) => {
    const a = A.r, b = B.r;
    if (scopeFilter === 'GLOBAL') {
      const c = cmpStr(name(a), name(b));
      return c !== 0 ? c : (A.i - B.i);
    }
    if (scopeFilter === 'CLIENT') {
      const c1 = cmpStr(cli(a), cli(b));
      if (c1 !== 0) return c1;
      const c2 = cmpStr(name(a), name(b));
      return c2 !== 0 ? c2 : (A.i - B.i);
    }
    // ALL â†’ globals first, then client name, then rate name
    const gA = isGlobal(a) ? 0 : 1;
    const gB = isGlobal(b) ? 0 : 1;
    if (gA !== gB) return gA - gB;
    const c1 = cmpStr(cli(a), cli(b));
    if (c1 !== 0) return c1;
    const c2 = cmpStr(name(a), name(b));
    return c2 !== 0 ? c2 : (A.i - B.i);
  });

  return arr.map(x => x.r);
}




async function listReportPresets({ section, kind = 'search', include_shared = true, q, page = 1, page_size = 100 } = {}) {
  const opts = { include_shared, q, page, page_size };
  const cached = getPresetCache(section, kind, opts);
  if (cached) return cached;

  const qs = new URLSearchParams();
  if (section) qs.set('section', section);
  if (kind) qs.set('kind', kind);
  if (include_shared) qs.set('include_shared', 'true');
  if (q) qs.set('q', q);
  qs.set('page', page);
  qs.set('page_size', page_size);

  const res = await authFetch(API(`/api/report-presets?${qs.toString()}`));
  const data = await res.json().catch(() => ({ rows: [] }));
  // Keep user_id in cache so ownership checks work downstream
  const rows = data && Array.isArray(data.rows) ? data.rows : [];
  setPresetCache(section, kind, rows, opts);
  return rows;
}

async function createReportPreset({ section, kind='search', name, filters, selection, is_shared=false, is_default=false }) {
  const res = await authFetch(
    API(`/api/report-presets`),
    {
      method: 'POST',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify({ section, kind, name, filters, selection, is_shared, is_default })
    }
  );

  if (res.status === 409) {
    let conflicting = null;
    try {
      const presets = await listReportPresets({ section, kind, include_shared: false, q: name, page: 1, page_size: 100 });
      const lower = String(name || '').toLowerCase();
      conflicting = (presets || []).find(p => String(p.name || '').toLowerCase() === lower) || null;
    } catch {}

    try {
      const form = document.getElementById('saveSearchForm');
      if (form) {
        const overwriteRadio = form.querySelector('input[name="mode"][value="overwrite"]') || form.querySelector('input[name="mode"][value="append"]');
        const overwriteWrap  = form.querySelector('#overwriteWrap') || form.querySelector('#appendWrap');
        const selectEl       = form.querySelector('#overwritePresetId') || form.querySelector('#appendPresetId');
        if (overwriteRadio) overwriteRadio.checked = true;
        if (overwriteWrap)  overwriteWrap.style.display = 'block';
        if (selectEl && conflicting) {
          const hasOption = Array.from(selectEl.options).some(o => o.value === String(conflicting.id));
          if (!hasOption) {
            const opt = document.createElement('option');
            opt.value = String(conflicting.id);
            opt.textContent = conflicting.name || '(unnamed)';
            selectEl.appendChild(opt);
          }
          selectEl.value = String(conflicting.id);
        }
      }
    } catch {}

    const err = new Error('Preset name already exists. Switched to Overwriteâ€”pick the preset and save again.');
    err.code = 'PRESET_NAME_CONFLICT';
    if (conflicting) err.preset = conflicting;
    err.section = section;
    err.kind = kind;
    throw err;
  }

  if (!res.ok) throw new Error(await res.text());

  invalidatePresetCache(section, kind);
  const data = await res.json().catch(()=>({}));
  return data.row || null;
}


async function updateReportPreset({ id, name, filters, selection, is_shared, is_default, section, kind }) {
  const patch = {};
  if (typeof name === 'string') patch.name = name;
  if (filters && typeof filters === 'object') patch.filters = filters;
  if (selection && typeof selection === 'object') patch.selection = selection;
  if (typeof is_shared === 'boolean') patch.is_shared = is_shared;
  if (typeof is_default === 'boolean') patch.is_default = is_default;
  if (typeof section === 'string') patch.section = section;
  if (typeof kind === 'string') patch.kind = kind;

  const res = await authFetch(
    API(`/api/report-presets/${encodeURIComponent(id)}`),
    {
      method: 'PATCH',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify(patch)
    }
  );
  if (!res.ok) throw new Error(await res.text());
  __PRESETS_CACHE__.clear();
  const data = await res.json().catch(()=>({}));
  return data.row || null;
}

async function deleteReportPreset(id) {
  const res = await authFetch(API(`/api/report-presets/${encodeURIComponent(id)}`), { method: 'DELETE' });
  if (!res.ok) throw new Error(await res.text());
  __PRESETS_CACHE__.clear();
  const data = await res.json().catch(()=> ({}));
  return data.deleted_id || id;
}

// -----------------------------
// Search helpers
// -----------------------------
function extractFiltersFromForm(formSel='#searchForm'){
  const raw = collectForm(formSel, false);

  // Convert select[multiple] to array and booleans from "true"/"false"
  Object.keys(raw).forEach(k=>{
    const el = document.querySelector(`${formSel} [name="${k}"]`);
    if (!el) return;
    if (el.tagName==='SELECT' && el.multiple){
      raw[k] = Array.from(el.selectedOptions).map(o=>o.value);
    }
    if (el.tagName==='SELECT' && (el.value === 'true' || el.value === 'false')){
      raw[k] = (el.value === 'true');
    }
    if (el.type === 'number' && raw[k] === '') raw[k] = null;
    if (raw[k] === '') delete raw[k];
  });

  // Convert UK dates â†’ ISO (backend expects ISO)
  const dateFields = [
    'created_from','created_to',
    'updated_from','updated_to',
    'worked_from','worked_to',
    'week_ending_from','week_ending_to',
    'issued_from','issued_to',
    'due_from','due_to',
    'dob',
    'start_date_from','start_date_to',
    'end_date_from','end_date_to',
    'active_on'
  ];

  dateFields.forEach(f => {
    if (raw[f]) {
      const iso = parseUkDateToIso(raw[f]);
      if (iso) raw[f] = iso;
    }
  });

  // âœ… Safety: strip legacy timesheets-summary keys if they ever appear in the form payload
  // (these must not drive summary filtering anymore)
  [
    'ts_stage',
    'summary_stage',
    'status_code',
    'processing_status',
    'client_invoiced',
    'needs_attention'
  ].forEach(k => {
    if (Object.prototype.hasOwnProperty.call(raw, k)) delete raw[k];
  });

  return raw;
}

function populateSearchFormFromFilters(filters={}, formSel='#searchForm'){
  const form = document.querySelector(formSel);
  if (!form) return;

  const dateFields = [
    'created_from','created_to',
    'updated_from','updated_to',
    'worked_from','worked_to',
    'week_ending_from','week_ending_to',
    'issued_from','issued_to',
    'due_from','due_to',
    'dob',
    'start_date_from','start_date_to',
    'end_date_from','end_date_to',
    'active_on'
  ];

  for (const [k,v] of Object.entries(filters || {})) {
    // âœ… Ignore legacy keys if they exist in state (they should not be reapplied to the form)
    if (k === 'ts_stage' ||
        k === 'summary_stage' ||
        k === 'status_code' ||
        k === 'processing_status' ||
        k === 'client_invoiced' ||
        k === 'needs_attention') {
      continue;
    }

    const el = form.querySelector(`[name="${k}"]`);
    if (!el) continue;

    if (Array.isArray(v) && el.tagName === 'SELECT' && el.multiple) {
      const values = new Set(v.map(String));
      Array.from(el.options).forEach(opt => { opt.selected = values.has(opt.value); });
      continue;
    }

    if (typeof v === 'boolean' && el.tagName === 'SELECT') {
      el.value = v ? 'true' : 'false';
      continue;
    }

    const isDateField = dateFields.includes(k);
    if (isDateField && typeof v === 'string') {
      const uk = (typeof formatIsoToUk === 'function') ? formatIsoToUk(v) : v;
      el.value = uk || '';
      continue;
    }

    // Default
    el.value = (v == null ? '' : String(v));
  }
}




// Build querystring per section


// -----------------------------
// UPDATED: search()
// -----------------------------
// ======================================
// FRONTEND â€” search (UPDATED: no extra logic beyond existing; kept for completeness)
// ======================================

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// FIX 1: Search route mismatch (contracts now calls /api/contracts with filters)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function search(section, filters = {}) {
  window.__listState = window.__listState || {};
  const st = (window.__listState[section] ||= {
    page: 1,
    pageSize: 50,
    total: null,
    hasMore: false,
    filters: null,
    sort: { key: null, dir: 'asc' }
  });

  if (!st.sort || typeof st.sort !== 'object') {
    st.sort = { key: null, dir: 'asc' };
  }

  // Reset selection when applying a new dataset (fingerprint change)
  window.__selection = window.__selection || {};
  const sel = (window.__selection[section] ||= { fingerprint: '', ids: new Set() });
  sel.fingerprint = JSON.stringify({
    section,
    filters: filters || {},
    sort: st.sort
  });
  sel.ids.clear();

  // Default mappings for existing sections (KEEP)
  const map = {
    candidates: '/api/search/candidates',
    clients: '/api/search/clients',
    umbrellas: '/api/search/umbrellas',
    timesheets: '/api/search/timesheets',
    invoices: '/api/invoices' // âœ… invoices use list endpoint (supports include_count/include_totals)
  };

  // Contracts use /api/contracts (admin list)
  let p = (section === 'contracts') ? '/api/contracts' : map[section];
  if (!p) return [];

  const qs = new URLSearchParams();

  // Apply filters
  Object.entries(filters || {}).forEach(([k, v]) => {
    if (v == null || v === '') return;

    // Contracts + count endpoint expects ids as CSV (q('ids')), not repeated params
    if (k === 'ids' && Array.isArray(v)) {
      const csv = v.map(x => String(x || '').trim()).filter(Boolean).join(',');
      if (csv) qs.set('ids', csv);
      return;
    }

    if (Array.isArray(v)) {
      v.forEach(vv => {
        if (vv == null || vv === '') return;
        qs.append(k, vv);
      });
    } else {
      qs.set(k, v);
    }
  });

  // Paging (fixes â€œstuck on page 1â€)
  const page = Math.max(1, Number(st.page || 1));
  const pageSize = st.pageSize;

  if (pageSize !== 'ALL') {
    qs.set('page', String(page));
    qs.set('page_size', String(Number(pageSize || 50)));
  }

  // Sorting (when set)
  if (st.sort && st.sort.key) {
    qs.set('order_by', String(st.sort.key));
    qs.set('order_dir', String(st.sort.dir || 'asc'));
  }

  // Invoices: request count + totals so footer/paging can be correct
  if (section === 'invoices') {
    qs.set('include_count', 'true');
    qs.set('include_totals', 'true');
  }

  const url = qs.toString() ? `${p}?${qs.toString()}` : p;

  const safeJson = async (res) => { try { return await res.json(); } catch { return null; } };

  const r = await authFetch(API(url));
  const j = await safeJson(r);

  // Normalize rows
  const rows =
    Array.isArray(j) ? j :
    (j && Array.isArray(j.items)) ? j.items :
    (j && Array.isArray(j.rows)) ? j.rows :
    [];

  // update state
  st.filters = { ...(filters || {}) };
  const ps = (st.pageSize === 'ALL') ? null : Number(st.pageSize || 50);
  st.hasMore = (ps != null) ? (Array.isArray(rows) && rows.length === ps) : false;

  // Persist list meta where available
  try {
    if (section === 'invoices' && j && typeof j === 'object') {
      if (typeof j.count === 'number') st.total = Number(j.count);
      if (j.totals && typeof j.totals === 'object') st.totals = j.totals;
    }
  } catch {}

  // Contracts: count comes from /api/contracts/count (for footer + paging)
  if (section === 'contracts') {
    try {
      const qsCount = new URLSearchParams(qs);
      qsCount.delete('page');
      qsCount.delete('page_size');
      qsCount.delete('order_by');
      qsCount.delete('order_dir');

      const cr = await authFetch(API(`/api/contracts/count?${qsCount.toString()}`));
      const cj = await safeJson(cr);
      if (cr.ok && cj && typeof cj.count === 'number') {
        st.total = Number(cj.count);
      }
    } catch {}
  }

  return rows;
}


function defaultColumnsFor(section){
  // No longer read localStorage; server grid prefs are the source of truth.
  switch(section){
    case 'candidates':
      return ['last_name','first_name','phone','role','postcode','email'];
    case 'clients':
      return ['name','primary_invoice_email','invoice_address','postcode','ap_phone'];
    case 'umbrellas':
      return ['name','vat_chargeable','bank_name','sort_code','account_number','enabled'];
    case 'audit':
      return ['type','to','subject','status','created_at_utc','last_error'];
    case 'contracts':
      // Sensible defaults for the new section
      return ['candidate_display','client_name','role','band','pay_method_snapshot','default_submission_mode','start_date','end_date','bucket_labels_preview'];
    default:
      return ['id'];
  }
}






// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Data / API wrappers â€” Contracts + Weeks + Utilities
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€-

const _enc = (v) => encodeURIComponent(String(v ?? ''));
const _json = (o) => JSON.stringify(o ?? {});

async function listContracts(filters = {}) {
  // Mirrors /api/contracts (admin list) with common FE filters.
  const qs = new URLSearchParams();
  if (filters.candidate_id) qs.set('candidate_id', filters.candidate_id);
  if (filters.client_id)    qs.set('client_id',    filters.client_id);
  if (filters.role)         qs.set('role',         filters.role);
  if (filters.band != null) qs.set('band',         filters.band);
  if (filters.pay_method_snapshot) qs.set('pay_method_snapshot', String(filters.pay_method_snapshot).toUpperCase());
  if (filters.active_on)    qs.set('active_on',    filters.active_on);  // YYYY-MM-DD
  if (typeof filters.auto_invoice === 'boolean') qs.set('auto_invoice', String(filters.auto_invoice));
  if (filters.status) qs.set('status', String(filters.status)); // NEW

  const url = qs.toString() ? `/api/contracts?${qs}` : `/api/contracts`;
  const r = await authFetch(API(url));
  return toList(r);
}


// âœ… CHANGED: add cache-busting and explicit no-cache header

async function getContract(contract_id) {
  const url = API(`/api/contracts/${_enc(contract_id)}?ts=${Date.now()}`);
  const r = await authFetch(url);
  if (!r?.ok) return null;
  const j = await r.json();

  // âœ… Keep full wrapper so callers can access:
  //   j.contract, j.finance, j.margins, j.counts, j.weeks, j.warnings, etc.
  if (j && typeof j === 'object' && j.contract && typeof j.contract === 'object') {
    // âœ… Back-compat: some call sites (or logs) may still expect row.id
    // If wrapper doesn't have id, mirror contract.id onto wrapper.id
    if (j.id == null && j.contract.id != null) j.id = j.contract.id;

    return j;
  }

  // Legacy fallback (older endpoints might return contract row directly)
  return j || null;
}



async function upsertContract(payload, id /* optional */) {
  const LOGC = (typeof window.__LOG_CONTRACTS === 'boolean') ? window.__LOG_CONTRACTS : true;
  const patch = { ...payload };

  // Ensure required window fields are present for PUT without re-clobber.
  if (id && patch.__userChangedDates !== true) {
    const snap = (window.modalCtx && window.modalCtx.data) || {};
    if (!patch.start_date && snap.start_date) patch.start_date = snap.start_date;
    if (!patch.end_date   && snap.end_date)   patch.end_date   = snap.end_date;

    // If caller didn't include additional_rates_json on an edit,
    // keep whatever is already stored on the contract instead of wiping it.
    if (!Object.prototype.hasOwnProperty.call(patch, 'additional_rates_json') &&
        Object.prototype.hasOwnProperty.call(snap, 'additional_rates_json')) {
      patch.additional_rates_json = snap.additional_rates_json;
    }
  }

  if ('__userChangedDates' in patch) delete patch.__userChangedDates;

  if ('bucket_labels_json' in patch) {
    const norm = normaliseBucketLabelsInput(patch.bucket_labels_json);
    patch.bucket_labels_json = (norm === false) ? null : norm;
  }

  const BUCKETS = [
    'paye_day','paye_night','paye_sat','paye_sun','paye_bh',
    'umb_day','umb_night','umb_sat','umb_sun','umb_bh',
    'charge_day','charge_night','charge_sat','charge_sun','charge_bh'
  ];

  const method = id ? 'PUT' : 'POST';
  const url = id ? `/api/contracts/${_enc(id)}` : `/api/contracts`;

  try {
    const currentTab = (window.modalCtx && window.modalCtx.currentTabKey) || null;
    const snapRow   = (window.modalCtx && window.modalCtx.data) || {};
    const baseRates = (snapRow && snapRow.rates_json) || {};
    const incoming  = (patch.rates_json && typeof patch.rates_json === 'object') ? patch.rates_json : {};

    const pmOld = String(snapRow.pay_method_snapshot || '').toUpperCase();
    const pmNew = String(patch.pay_method_snapshot || '').toUpperCase();

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // âœ… FIX: avoid â€œrates changedâ€ drift when user didnâ€™t edit rates
    //
    // - On PUT (edit), we DO NOT prune keys by pay_method_snapshot.
    //   Pruning changes the object shape and can trip backend â€œrates changedâ€
    //   protection even when amounts are identical.
    //
    // - We only apply pruning on POST (create) OR if pay_method_snapshot changed.
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if (id) {
      const merged = { ...(baseRates && typeof baseRates === 'object' ? baseRates : {}) };

      for (const k of BUCKETS) {
        if (!Object.prototype.hasOwnProperty.call(incoming, k)) continue;

        const raw = incoming[k];
        if (raw === '' || raw === null || raw === undefined) continue;

        const n = Number(raw);
        if (!Number.isFinite(n)) continue;

        merged[k] = n;
      }

      patch.rates_json = merged;
    } else {
      // Create: ensure rates_json is at least an object
      if (!patch.rates_json || typeof patch.rates_json !== 'object') patch.rates_json = {};
    }

    // Prune PAYE vs Umbrella buckets:
    // - Create (POST): yes
    // - Edit (PUT): only if pay_method_snapshot changed (rare / intentional)
    try {
      const shouldPrune =
        (!id) || (pmOld && pmNew && pmOld !== pmNew);

      if (shouldPrune) {
        const pm = String(patch.pay_method_snapshot || '').toUpperCase();
        if (patch.rates_json && typeof patch.rates_json === 'object') {
          const keepPrefixes =
            pm === 'PAYE'     ? ['paye_','charge_'] :
            pm === 'UMBRELLA' ? ['umb_','charge_'] :
                                ['charge_'];
          for (const key of Object.keys(patch.rates_json)) {
            if (!keepPrefixes.some(pre => key.startsWith(pre))) {
              delete patch.rates_json[key];
            }
          }
        }
      }
    } catch (e) {
      if (LOGC) console.warn('[CONTRACTS][UPSERT] rate pruning failed (non-fatal)', e);
    }

    if (LOGC) {
      console.groupCollapsed('[CONTRACTS][UPSERT] sending');
      console.log('method', method, 'url', API(url));
      console.log('currentTab', currentTab);
      console.log('payload (final)', patch);
      if (id) console.log('baseRates (from modalCtx.data.rates_json)', baseRates);
      console.groupEnd();
    }
  } catch (e) {
    if (LOGC) console.warn('[CONTRACTS][UPSERT] logging/pre-seed failed', e);
  }

   // âœ… CRITICAL: never send default_submission_mode unless overrideclientsettings is TRUE.
  // This prevents â€œCannot change default_submission_mode after timesheets have been submittedâ€
  // when the user is only adding/removing weeks (calendar workflow) and the contract inherits client settings.
  try {
    const ocs = patch.overrideclientsettings;
    const ocsTrue =
      (ocs === true) ||
      (ocs === 'on') ||
      (ocs === 'true') ||
      (ocs === 1) ||
      (ocs === '1');

    if (!ocsTrue) {
      if (Object.prototype.hasOwnProperty.call(patch, 'default_submission_mode')) {
        delete patch.default_submission_mode;
      }
    }
  } catch (e) {
    if (LOGC) console.warn('[CONTRACTS][UPSERT] overrideclientsettings gate failed (non-fatal)', e);
  }

  const res = await authFetch(API(url), {
    method,
    headers: { 'content-type': 'application/json' },
    body: _json(patch)
  });


  let data = null;
  try { data = await res.json(); } catch (_) {}

  if (!res || !res.ok) {
    const msg =
      (data && (data.error || data.message || data.detail)) ||
      (res && res.statusText) ||
      `Contract ${id ? 'update' : 'create'} failed`;
    if (LOGC) console.error('[CONTRACTS][UPSERT] error', { status: res?.status, msg, data });
    throw new Error(msg);
  }

  if (LOGC) {
    console.log('[CONTRACTS][UPSERT] success', { method, id, status: res.status });
    if (data) console.log('[CONTRACTS][UPSERT] response body', data);
  }

  // Merge saved contract into list cache so reopen uses fresh values
  try {
    const savedContract = (data && (data.contract || data)) || null;
    const savedId = savedContract && savedContract.id;
    if (savedId && Array.isArray(window.currentRows)) {
      const idx = window.currentRows.findIndex(r => String(r.id) === String(savedId));
      if (idx >= 0) {
        window.currentRows[idx] = { ...window.currentRows[idx], ...savedContract };
      }
    }
  } catch (e) {
    if (LOGC) console.warn('[CONTRACTS][UPSERT] list cache merge failed', e);
  }

  // Auto-refresh any open weekly import resolve panels (NHSP / HR_WEEKLY)
  try {
    if (typeof refreshOpenWeeklyImportSummariesAfterContractSave === 'function') {
      await refreshOpenWeeklyImportSummariesAfterContractSave();
    }
  } catch (e) {
    if (LOGC) console.warn('[CONTRACTS][UPSERT] weekly import auto-refresh failed', e);
  }

  return data;
}



// âœ… CHANGED: after successful upsert, also merge into currentRows and stamp recency


async function deleteContract(contract_id) {
  const r = await authFetch(API(`/api/contracts/${_enc(contract_id)}`), { method: 'DELETE' });
  if (!r?.ok) throw new Error('Delete contract failed');
  return r.json();
}
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UPDATED: checkContractOverlap (adds logging)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function checkContractOverlap(payload /* {candidate_id,start_date,end_date,ignore_contract_id?} */) {
  const LOGC = (typeof window.__LOG_CONTRACTS === 'boolean') ? window.__LOG_CONTRACTS : false;
  if (LOGC) console.log('[CONTRACTS] POST /api/contracts/check-overlap', payload);
  const r = await authFetch(API(`/api/contracts/check-overlap`), {
    method: 'POST', headers: { 'content-type':'application/json' }, body: _json(payload)
  });
  if (!r?.ok) {
    if (LOGC) console.error('[CONTRACTS] overlap check failed', r);
    throw new Error('Overlap check failed');
  }
  const json = await r.json();
  if (LOGC) console.log('[CONTRACTS] overlap check OK', json);
  return json;
}

async function generateContractWeeks(contract_id) {
  const r = await authFetch(API(`/api/contracts/${_enc(contract_id)}/generate-weeks`), { method: 'POST' });
  if (!r?.ok) throw new Error('Generate weeks failed');
  return r.json();
}


async function listContractWeeks(contract_id, filters = {}) {
  const qs = new URLSearchParams();
  if (contract_id) qs.set('contract_id', contract_id);
  if (filters.status) qs.set('status', filters.status);
  if (filters.submission_mode_snapshot) qs.set('submission_mode_snapshot', filters.submission_mode_snapshot);
  if (filters.week_ending_from) qs.set('week_ending_from', filters.week_ending_from);
  if (filters.week_ending_to)   qs.set('week_ending_to',   filters.week_ending_to);
  const url = qs.toString() ? `/api/contract-weeks?${qs}` : `/api/contract-weeks`;
  const r = await authFetch(API(url));
  return toList(r);
}

async function contractWeekSwitchMode(week_id, newMode /* optional; server toggles if omitted */) {
  // Backend toggles if no body; allow hint mode to be explicit
  const init = newMode
    ? { method:'POST', headers:{'content-type':'application/json'}, body:_json({ submission_mode_snapshot: String(newMode).toUpperCase() }) }
    : { method:'POST' };
  const r = await authFetch(API(`/api/contract-weeks/${_enc(week_id)}/switch-mode`), init);
  if (!r?.ok) throw new Error('Switch mode failed');
  return r.json();
}

async function contractWeekPresignPdf(week_id) {
  const r = await authFetch(API(`/api/contract-weeks/${_enc(week_id)}/presign-manual-pdf`), { method:'POST' });
  if (!r?.ok) throw new Error('Presign failed');
  return r.json(); // { key, upload_url, token, expires_in }
}

async function contractWeekReplacePdf(week_id, r2_key) {
  const r = await authFetch(API(`/api/contract-weeks/${_enc(week_id)}/replace-manual-pdf`), {
    method:'POST', headers:{'content-type':'application/json'}, body:_json({ r2_key })
  });
  if (!r?.ok) throw new Error('Replace manual PDF failed');
  return r.json();
}



// FE FIX: rotation-safe manual upsert (uses apiPostJson + includes expected_timesheet_id when available)
async function contractWeekManualUpsert(week_id, payload /* schedule-driven weekly manual OR legacy bucket-hours */) {
  const out = { ...(payload || {}) };

  const normaliseScheduleField = (x) => {
    if (x == null) return x;
    if (Array.isArray(x) || typeof x === 'object') return x;
    if (typeof x === 'string') {
      try {
        const p = JSON.parse(x);
        if (Array.isArray(p) || typeof p === 'object') return p;
      } catch {}
    }
    return x;
  };

  // âœ… Schedule-driven weekly manual: normalise actual_schedule_json and drop legacy fields
  if (Object.prototype.hasOwnProperty.call(out, 'actual_schedule_json')) {
    out.actual_schedule_json = normaliseScheduleField(out.actual_schedule_json);

    // If schedule is provided, do not send legacy bucket totals / day refs for weekly manual
    if (out.actual_schedule_json != null) {
      if (Object.prototype.hasOwnProperty.call(out, 'hours')) delete out.hours;
      if (Object.prototype.hasOwnProperty.call(out, 'day_entries_json')) delete out.day_entries_json;
      if (Object.prototype.hasOwnProperty.call(out, 'day_references_json')) delete out.day_references_json;
    }
  }

  // âœ… Legacy fallback: if hours present (old editor), ensure numeric 5-bucket totals
  if (out?.hours) {
    const h = out.hours;
    out.hours = {
      day: Number(h?.day || 0),
      night: Number(h?.night || 0),
      sat: Number(h?.sat || 0),
      sun: Number(h?.sun || 0),
      bh: Number(h?.bh || 0)
    };
  }

  // âœ… Attach expected_timesheet_id ONLY when a timesheet exists (updates), not when creating from planned week
  const mc = window.modalCtx || {};
  const hasTs =
    !!(out.expected_timesheet_id != null) ||
    !!(mc.timesheetMeta && mc.timesheetMeta.hasTs) ||
    !!(mc.data && mc.data.timesheet_id) ||
    !!(mc.timesheetDetails && mc.timesheetDetails.timesheet && mc.timesheetDetails.timesheet.timesheet_id);

  const expected =
    (out.expected_timesheet_id != null ? String(out.expected_timesheet_id) : '') ||
    (hasTs && mc.timesheetMeta?.expected_timesheet_id ? String(mc.timesheetMeta.expected_timesheet_id) : '') ||
    (hasTs && mc.data?.timesheet_id ? String(mc.data.timesheet_id) : '') ||
    (hasTs && mc.timesheetDetails?.timesheet?.timesheet_id ? String(mc.timesheetDetails.timesheet.timesheet_id) : '') ||
    '';

  if (expected) {
    out.expected_timesheet_id = expected;
  } else {
    if (Object.prototype.hasOwnProperty.call(out, 'expected_timesheet_id')) delete out.expected_timesheet_id;
  }

  // âœ… apiPostJson ensures thrown errors have .status + .json (409 TIMESHEET_MOVED supported)
  return apiPostJson(`/api/contract-weeks/${_enc(week_id)}/manual-upsert`, out);
}


// FE FIX: authorise must be expected-guarded (uses apiPostJson)
async function contractWeekAuthorise(week_id, expectedTimesheetId /* optional */) {
  const expected =
    (expectedTimesheetId != null ? String(expectedTimesheetId) : '') ||
    (window.modalCtx?.timesheetMeta?.expected_timesheet_id
      ? String(window.modalCtx.timesheetMeta.expected_timesheet_id)
      : '');

  if (!expected) throw new Error('contractWeekAuthorise: expected_timesheet_id is required');

  return apiPostJson(`/api/contract-weeks/${_enc(week_id)}/manual-authorise`, {
    expected_timesheet_id: expected
  });
}

// FE FIX: delete timesheet must be expected-guarded (uses apiDeleteJson)
async function contractWeekDeleteTimesheet(week_id, expectedTimesheetId /* optional */) {
  const expected =
    (expectedTimesheetId != null ? String(expectedTimesheetId) : '') ||
    (window.modalCtx?.timesheetMeta?.expected_timesheet_id
      ? String(window.modalCtx.timesheetMeta.expected_timesheet_id)
      : '');

  if (!expected) throw new Error('contractWeekDeleteTimesheet: expected_timesheet_id is required');

  return apiDeleteJson(`/api/contract-weeks/${_enc(week_id)}/timesheet`, {
    expected_timesheet_id: expected
  });
}
// FE FIX: mutation should not use raw authFetch; use apiPostJson for consistent error shape
async function contractWeekCreateExpenseSheet(week_id) {
  return apiPostJson(`/api/contract-weeks/${_enc(week_id)}/create-expense-sheet`, {});
}






// Minimal picker feed
async function listContractsBasic() {
  const rows = await listContracts({});
  return (rows || []).map(c => ({
    id: c.id,
    label: [
      (c.candidate_display || c.candidate_id || '').toString(),
      'â€”',
      (c.client_name || c.client_id || '').toString(),
      (c.role ? `(${c.role}${c.band ? ` ${c.band}` : ''})` : ''),
      ' ',
      `[${c.start_date || ''} â†’ ${c.end_date || ''}]`
    ].join(' ').replace(/\s+/g, ' ').trim()
  }));
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Bucket label helpers (display-only; math stays canonical)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€-

function labelsDefault() {
  return { day:'Day', night:'Night', sat:'Sat', sun:'Sun', bh:'BH' };
}

/**
 * @returns {object|false} normalized labels object or false if invalid (to clear)
 */
function normaliseBucketLabelsInput(raw) {
  if (!raw || typeof raw !== 'object') return false;
  const keys = ['day','night','sat','sun','bh'];
  const out = {};
  for (const k of keys) {
    const v = raw[k];
    if (typeof v !== 'string' || !v.trim()) return false;
    out[k] = v.trim();
  }
  return out;
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Summary patching helpers for modal saves (NEW)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function captureSummaryContextForModalOpen() {
  const deep = (o) => {
    try { return JSON.parse(JSON.stringify(o)); } catch { return null; }
  };

  const stableStringify = (obj) => {
    const seen = new WeakSet();
    const norm = (v) => {
      if (v == null) return v;
      if (typeof v !== 'object') return v;
      if (seen.has(v)) return null;
      seen.add(v);

      if (Array.isArray(v)) return v.map(norm);

      const out = {};
      Object.keys(v).sort().forEach(k => {
        out[k] = norm(v[k]);
      });
      return out;
    };

    try { return JSON.stringify(norm(obj)); } catch { return ''; }
  };

  window.__listState = window.__listState || {};
  const st = window.__listState[currentSection] || {
    page: 1,
    pageSize: 50,
    total: null,
    hasMore: false,
    filters: null,
    sort: { key: null, dir: 'asc' }
  };

  const filters = (st && typeof st.filters === 'object' && st.filters) ? st.filters : {};
  const sort    = (st && typeof st.sort === 'object' && st.sort) ? st.sort : { key: null, dir: 'asc' };

  const related = (filters && typeof filters === 'object' && filters.related && typeof filters.related === 'object')
    ? filters.related
    : null;

  const inRelatedMode =
    !!related &&
    String(related.source_entity || '').trim() &&
    String(related.source_id || '').trim() &&
    String(related.relation_type || '').trim();

  // Attempt to capture the id the modal opened for (helps rotation-safe patching)
  let openedId = null;
  try {
    const mc = (window.modalCtx && typeof window.modalCtx === 'object') ? window.modalCtx : null;
    openedId =
      (mc && mc.data && (mc.data.id || mc.data.invoice_id || mc.data.timesheet_id || mc.data.contract_week_id))
        ? String(mc.data.id || mc.data.invoice_id || mc.data.timesheet_id || mc.data.contract_week_id)
        : null;
  } catch { openedId = null; }

  const fp = (typeof getSummaryFingerprint === 'function')
    ? getSummaryFingerprint(currentSection)
    : stableStringify({ section: currentSection, filters });

  return {
    // identity
    section: String(currentSection || ''),
    opened_id: openedId || null,

    // dataset state
    page: Number(st.page || 1) || 1,
    pageSize: st.pageSize,
    inRelatedMode: !!inRelatedMode,

    // signatures for â€œstill active?â€
    fingerprint: String(fp || ''),
    filters_sig: stableStringify(filters || {}),
    sort_sig: stableStringify({ key: sort.key || null, dir: (sort.dir === 'desc') ? 'desc' : 'asc' }),

    // metadata
    captured_at_ms: Date.now()
  };
}

function isSummaryContextStillActive(ctx) {
  if (!ctx || typeof ctx !== 'object') return false;

  const stableStringify = (obj) => {
    const seen = new WeakSet();
    const norm = (v) => {
      if (v == null) return v;
      if (typeof v !== 'object') return v;
      if (seen.has(v)) return null;
      seen.add(v);
      if (Array.isArray(v)) return v.map(norm);
      const out = {};
      Object.keys(v).sort().forEach(k => { out[k] = norm(v[k]); });
      return out;
    };
    try { return JSON.stringify(norm(obj)); } catch { return ''; }
  };

  // Must still be on the same section
  if (String(currentSection || '') !== String(ctx.section || '')) return false;

  window.__listState = window.__listState || {};
  const st = window.__listState[currentSection] || null;
  if (!st || typeof st !== 'object') return false;

  const filtersNow = (st.filters && typeof st.filters === 'object') ? st.filters : {};
  const sortNow    = (st.sort && typeof st.sort === 'object') ? st.sort : { key: null, dir: 'asc' };

  const filtersSigNow = stableStringify(filtersNow || {});
  const sortSigNow    = stableStringify({ key: sortNow.key || null, dir: (sortNow.dir === 'desc') ? 'desc' : 'asc' });

  // If filters/sort changed since modal opened, do NOT patch the visible summary
  if (String(filtersSigNow) !== String(ctx.filters_sig || '')) return false;
  if (String(sortSigNow)    !== String(ctx.sort_sig    || '')) return false;

  // Optional: fingerprint parity when available
  if (typeof getSummaryFingerprint === 'function') {
    const fpNow = String(getSummaryFingerprint(currentSection) || '');
    if (ctx.fingerprint && fpNow && fpNow !== String(ctx.fingerprint)) return false;
  }

  return true;
}

function getSectionForEntity(entity) {
  const e = String(entity || '').trim().toLowerCase();

  // Your modal entities map 1:1 to sections in the left nav.
  if (e === 'candidates') return 'candidates';
  if (e === 'clients')    return 'clients';
  if (e === 'contracts')  return 'contracts';
  if (e === 'timesheets') return 'timesheets';
  if (e === 'invoices')   return 'invoices';
  if (e === 'umbrellas')  return 'umbrellas';
  if (e === 'imports')    return 'imports';
  if (e === 'audit')      return 'audit';
  if (e === 'settings')   return 'settings';

  // Fallback: treat unknown entity as current section (safe no-op patching)
  return String(currentSection || '');
}

function normalizeSavedRecordForSummary(entity, saved) {
  const ent = String(entity || '').trim().toLowerCase();
  const s = (saved && typeof saved === 'object') ? saved : null;

  // Build an id candidate from common shapes
  const pickId = (obj) => {
    if (!obj || typeof obj !== 'object') return null;
    const v =
      obj.id ??
      obj.invoice_id ??
      obj.timesheet_id ??
      obj.contract_week_id ??
      null;
    return v != null ? String(v) : null;
  };

  // Merge with existing row (if present) so we donâ€™t lose summary-only fields
  const mergeWithExistingIfPresent = (section, id, patch) => {
    try {
      if (String(currentSection || '') !== String(section || '')) return patch;
      if (!Array.isArray(currentRows) || !id) return patch;

      const idStr = String(id);

      const rowIdOf = (r) => {
        if (!r || typeof r !== 'object') return '';
        return String(
          r.id ??
          r.invoice_id ??
          r.timesheet_id ??
          r.contract_week_id ??
          ''
        );
      };

      const idx = currentRows.findIndex(r => rowIdOf(r) === idStr);
      if (idx < 0) return patch;

      const base = (currentRows[idx] && typeof currentRows[idx] === 'object') ? currentRows[idx] : {};
      return { ...base, ...patch };
    } catch {
      return patch;
    }
  };

  // If no saved payload, return null so caller can decide to fetch canonical
  if (!s) return null;

  let section = getSectionForEntity(ent);

  // TIMESHEETS: your summary rows use id = timesheet_id else contract_week_id
  if (ent === 'timesheets') {
    const tsId = (s.timesheet_id != null) ? String(s.timesheet_id) : null;
    const cwId = (s.contract_week_id != null) ? String(s.contract_week_id) : null;

    const id = tsId || cwId || pickId(s);
    if (!id) return null;

    const out = { ...(s || {}) };

    // Ensure canonical identifiers exist
    out.timesheet_id = tsId || out.timesheet_id || null;
    out.contract_week_id = cwId || out.contract_week_id || null;
    out.id = id;

    // Merge with existing summary row to preserve summary-only columns
    return mergeWithExistingIfPresent(section, id, out);
  }

  // INVOICES: summary list expects id to be invoice id
  if (ent === 'invoices') {
    const id = pickId(s);
    if (!id) return null;

    const out = { ...(s || {}) };
    out.id = id;

    return mergeWithExistingIfPresent(section, id, out);
  }

  // CONTRACTS: preserve candidate_display/client_name if present in existing row
  if (ent === 'contracts') {
    const id = pickId(s);
    if (!id) return null;
    const out = { ...(s || {}) };
    out.id = id;
    return mergeWithExistingIfPresent(section, id, out);
  }

  // Default: candidates/clients/umbrellas/etc
  const id = pickId(s);
  if (!id) return null;

  const out = { ...(s || {}) };
  out.id = id;

  return mergeWithExistingIfPresent(section, id, out);
}

async function summaryApplySavedRecordToActiveSummary(arg1, arg2, arg3) {
  // Supports both signatures:
  //  A) (ctx, saved)
  //  B) (entity, saved, ctx)
  let ctx = null;
  let saved = null;
  let entity = null;

  if (typeof arg1 === 'string') {
    entity = arg1;
    saved  = arg2;
    ctx    = arg3 || null;
  } else {
    ctx    = arg1 || null;
    saved  = arg2;
    entity = (ctx && ctx.section) ? ctx.section : (window.modalCtx?.entity || currentSection || '');
  }

  const section =
    (typeof getSectionForEntity === 'function')
      ? getSectionForEntity(entity)
      : String(entity || '');

  if (!section) return { ok: false, reason: 'no-section' };

  // If ctx was not provided, capture best-effort now (still guarded by isSummaryContextStillActive)
  if (!ctx && typeof captureSummaryContextForModalOpen === 'function') {
    try { ctx = captureSummaryContextForModalOpen(); } catch { ctx = null; }
  }

  // Only patch the visible summary if the user is still on that dataset
  if (ctx && typeof isSummaryContextStillActive === 'function') {
    if (!isSummaryContextStillActive(ctx)) {
      return { ok: false, reason: 'context-not-active' };
    }
  } else {
    // Without ctx validation, never patch cross-section
    if (String(currentSection || '') !== String(section || '')) {
      return { ok: false, reason: 'section-not-active' };
    }
  }

  const inRelatedMode = !!(ctx && ctx.inRelatedMode);

  const pickId = (obj) => {
    if (!obj || typeof obj !== 'object') return null;
    const v = obj.id ?? obj.invoice_id ?? obj.timesheet_id ?? obj.contract_week_id ?? null;
    return v != null ? String(v) : null;
  };

  const rawId =
    pickId(saved) ||
    (ctx && ctx.opened_id ? String(ctx.opened_id) : null) ||
    (window.modalCtx && window.modalCtx.data ? pickId(window.modalCtx.data) : null);

  if (!rawId) return { ok: false, reason: 'no-id' };

  // Normalize locally (may merge with existing summary row)
  let patchedRow = null;
  try {
    if (typeof normalizeSavedRecordForSummary === 'function') {
      patchedRow = normalizeSavedRecordForSummary(section, saved);
    } else {
      patchedRow = (saved && typeof saved === 'object') ? { ...(saved || {}) } : null;
      if (patchedRow) patchedRow.id = String(patchedRow.id ?? rawId);
    }
  } catch {
    patchedRow = null;
  }

  // RELATED MODE: do not fetch canonical, do not insert/remove.
  // Only patch if the row is already present (safe + minimal).
  if (inRelatedMode) {
    const id = String((patchedRow && patchedRow.id) ? patchedRow.id : rawId);

    const patched = (typeof summaryPatchRowIfPresent === 'function')
      ? summaryPatchRowIfPresent(section, id, patchedRow || { id })
      : false;

    if (patched) {
      try { if (typeof summaryUpdateRowDom === 'function') summaryUpdateRowDom(section, id, patchedRow || { id }); } catch {}
      try { if (typeof summaryMaybeResortDom === 'function') summaryMaybeResortDom(section); } catch {}
      return { ok: true, action: 'patched', id, related: true };
    }

    // âœ… Optional future improvement (implemented safely): if not present in related-mode,
    // do a minimal related-list reload instead of inserting/removing.
    try {
      if (String(currentSection || '') === String(section || '') &&
          typeof loadSection === 'function' &&
          typeof renderSummary === 'function') {
        await loadSection();
        try { renderSummary(currentRows || []); } catch {}
        return { ok: true, action: 'reloaded', id, related: true };
      }
    } catch {}

    return { ok: false, reason: 'related-not-present', id, related: true };
  }

  // For TIMESHEETS/INVOICES we sometimes only have â€œdetailsâ€ shapes.
  // Minimise calls: fetch canonical ONLY if weâ€™re missing key summary fields.
  const needsCanonical = (() => {
    if (!patchedRow || typeof patchedRow !== 'object') return true;

    if (section === 'timesheets') {
      return !(
        patchedRow.week_ending_date &&
        (patchedRow.client_name || patchedRow.client_id) &&
        (patchedRow.candidate_name || patchedRow.candidate_id) &&
        ('tools_stage' in patchedRow || 'processing_status_display' in patchedRow)
      );
    }

    if (section === 'invoices') {
      return !(
        patchedRow.invoice_no &&
        patchedRow.status &&
        ('subtotal_ex_vat' in patchedRow) &&
        ('total_inc_vat' in patchedRow)
      );
    }

    return false;
  })();

  if (needsCanonical && typeof summaryFetchCanonicalRow === 'function') {
    try {
      const canon = await summaryFetchCanonicalRow(section, rawId, ctx);
      if (canon && typeof canon === 'object') patchedRow = canon;
    } catch {
      // non-fatal
    }
  }

  if (!patchedRow || typeof patchedRow !== 'object') {
    return { ok: false, reason: 'no-row' };
  }

  const id = String(patchedRow.id ?? rawId);
  patchedRow.id = id;

  // Patch in-memory list + DOM
  const patched = (typeof summaryPatchRowIfPresent === 'function')
    ? summaryPatchRowIfPresent(section, id, patchedRow)
    : false;

  if (patched) {
    try { if (typeof summaryUpdateRowDom === 'function') summaryUpdateRowDom(section, id, patchedRow); } catch {}
    try { if (typeof summaryMaybeResortDom === 'function') summaryMaybeResortDom(section); } catch {}

    // Enforce filter parity (async)
    try {
      if (typeof summaryRemoveRowIfNowExcluded === 'function') {
        const removed = await summaryRemoveRowIfNowExcluded(section, id, ctx);
        if (removed) return { ok: true, action: 'removed', id };
      }
    } catch {}

    return { ok: true, action: 'patched', id };
  }

  // Not present â†’ insert (memory), then DOM, then resort, then parity check
  let inserted = false;
  try {
    if (typeof summaryInsertRowIfMissing === 'function') {
      inserted = !!summaryInsertRowIfMissing(section, patchedRow);
    }
  } catch { inserted = false; }

  if (inserted) {
    try { if (typeof summaryInsertRowDom === 'function') summaryInsertRowDom(section, patchedRow); } catch {}
    try { if (typeof summaryMaybeResortDom === 'function') summaryMaybeResortDom(section); } catch {}

    try {
      if (typeof summaryRemoveRowIfNowExcluded === 'function') {
        const removed = await summaryRemoveRowIfNowExcluded(section, id, ctx);
        if (removed) return { ok: true, action: 'removed', id };
      }
    } catch {}

    return { ok: true, action: 'inserted', id };
  }

  return { ok: false, reason: 'not-present-and-no-insert', id };
}


function summaryPatchRowIfPresent(section, id, patchedRow) {
  try {
    const sec = String(section || '');
    const idStr = String(id || '');
    if (!sec || !idStr) return false;

    // Only patch the currently visible section list
    if (String(currentSection || '') !== sec) return false;
    if (!Array.isArray(currentRows)) return false;

    const rowIdOf = (r) => {
      if (!r || typeof r !== 'object') return '';
      return String(
        r.id ??
        r.invoice_id ??
        r.timesheet_id ??
        r.contract_week_id ??
        ''
      );
    };

    const idx = currentRows.findIndex(r => rowIdOf(r) === idStr);
    if (idx < 0) return false;

    const base = (currentRows[idx] && typeof currentRows[idx] === 'object') ? currentRows[idx] : {};
    const merged = { ...base, ...(patchedRow || {}) };

    // Ensure a stable id field for the grid
    merged.id = String(merged.id ?? idStr);

    currentRows[idx] = merged;
    return true;
  } catch {
    return false;
  }
}





async function summaryRemoveRowIfNowExcluded(section, id, ctx) {
  section = String(section || '').trim();
  id      = String(id || '').trim();

  if (!section || !id) return false;
  if (typeof currentSection !== 'string' || currentSection !== section) return false;

  // If ctx provided and context no longer active, skip (donâ€™t mutate a different dataset)
  if (ctx && typeof isSummaryContextStillActive === 'function') {
    if (!isSummaryContextStillActive(ctx)) return false;
  }

  // Related mode: we cannot reliably test inclusion without a dedicated id fetcher,
  // so do not remove automatically.
  if (ctx && ctx.inRelatedMode) return false;

  if (typeof summaryFetchCanonicalRow !== 'function') return false;

  let canonical = null;
  try { canonical = await summaryFetchCanonicalRow(section, id, ctx); } catch { canonical = null; }

  const included = !!(canonical && typeof canonical === 'object');
  if (included) {
    // Still included â†’ optionally refresh row
    try { if (typeof summaryPatchRowIfPresent === 'function') summaryPatchRowIfPresent(section, id, canonical); } catch {}
    try { if (typeof summaryUpdateRowDom === 'function') summaryUpdateRowDom(section, id, canonical); } catch {}
    try { if (typeof summaryMaybeResortDom === 'function') summaryMaybeResortDom(section); } catch {}
    return false;
  }

  // Remove from currentRows
  try {
    if (Array.isArray(window.currentRows)) {
      window.currentRows = window.currentRows.filter(r => {
        const rid = r && (r.id ?? r.timesheet_id ?? r.contract_week_id ?? r.invoice_id);
        return String(rid || '') !== id;
      });
    }
  } catch {}

  // Clear currentSelection if it was this row
  try {
    if (window.currentSelection) {
      const selId = window.currentSelection.id ?? window.currentSelection.timesheet_id ?? window.currentSelection.contract_week_id ?? window.currentSelection.invoice_id;
      if (String(selId || '') === id) window.currentSelection = null;
    }
  } catch {}

  // Remove from selection set if present
  try {
    window.__selection = window.__selection || {};
    const sel = window.__selection[section];
    if (sel && sel.ids instanceof Set) sel.ids.delete(id);
  } catch {}

  // Remove from DOM
  try {
    const content = document.getElementById('content');
    const bodyWrap = content ? content.querySelector('.summary-body') : null;
    const tbl = bodyWrap ? bodyWrap.querySelector('table.grid') : null;
    const tb = tbl ? tbl.querySelector('tbody') : null;
    if (tb) {
      const tr = Array.from(tb.querySelectorAll('tr[data-id]'))
        .find(x => String(x.dataset.id || '') === id) || null;
      if (tr && tr.parentNode) tr.parentNode.removeChild(tr);
    }
  } catch {}

  // Refresh header checkbox state + toolbar disables (best-effort)
  try {
    const content = document.getElementById('content');
    if (content) {
      const hdrCbEl = document.getElementById('summarySelectAll');

      const bodyWrap = content.querySelector('.summary-body');
      const tbl = bodyWrap ? bodyWrap.querySelector('table.grid') : null;
      const tb = tbl ? tbl.querySelector('tbody') : null;

      const visibleIds = tb ? Array.from(tb.querySelectorAll('tr[data-id]')).map(tr => String(tr.dataset.id || '')) : [];

      const sel = (window.__selection && window.__selection[section]) ? window.__selection[section] : null;
      const ids = (sel && sel.ids instanceof Set) ? sel.ids : new Set();

      const selectedOfVisible = visibleIds.filter(x => ids.has(x)).length;

      if (hdrCbEl) {
        hdrCbEl.checked = (visibleIds.length > 0 && selectedOfVisible === visibleIds.length);
        hdrCbEl.indeterminate = (selectedOfVisible > 0 && selectedOfVisible < visibleIds.length);
      }

      const any = (ids.size > 0);
      const btns = Array.from(content.querySelectorAll('button'));
      const focusBtn   = btns.find(b => b.title === 'Focus on records') || null;
      const saveBtn    = btns.find(b => b.title === 'Save selection') || null;
      const resolveBtn = btns.find(b => b.title === 'Resolve candidate/client for selected timesheets') || null;

      if (focusBtn) focusBtn.disabled = !any;
      if (saveBtn) saveBtn.disabled = !any;
      if (resolveBtn) resolveBtn.disabled = !any;

      // Clear selection button visibility (best-effort by label)
      const clearBtn = btns.find(b => (b.textContent || '').trim() === 'Clear selection') || null;
      if (clearBtn) clearBtn.style.display = any ? '' : 'none';

      // Selected count label (best-effort)
      const topControls = (function () {
        const ps = document.getElementById('summaryPageSize');
        return ps ? ps.parentElement : null;
      })();
      if (topControls) {
        const minis = Array.from(topControls.querySelectorAll('div.mini'));
        const selInfo = minis.length ? minis[minis.length - 1] : null;
        if (selInfo) selInfo.textContent = any ? `${ids.size} selected.` : '';
      }
    }
  } catch {}

  return true;
}

function summaryInsertRowIfMissing(section, patchedRow) {
  try {
    section = String(section || '').trim();
    if (!section) return false;
    if (typeof currentSection !== 'string' || currentSection !== section) return false;

    const row = (patchedRow && typeof patchedRow === 'object') ? patchedRow : null;
    if (!row) return false;

    const id =
      (row.id != null ? String(row.id) : '') ||
      (row.invoice_id != null ? String(row.invoice_id) : '') ||
      (row.timesheet_id != null ? String(row.timesheet_id) : '') ||
      (row.contract_week_id != null ? String(row.contract_week_id) : '');

    if (!id) return false;

    if (!Array.isArray(window.currentRows)) return false;

    const exists = window.currentRows.some(r => {
      const rid = r && (r.id ?? r.timesheet_id ?? r.contract_week_id ?? r.invoice_id);
      return String(rid || '') === id;
    });

    if (exists) return false;

    // Insert into in-memory list. DOM insertion is handled by caller (summaryInsertRowDom).
    window.currentRows.push({ ...(row || {}), id });

    return true;
  } catch {
    return false;
  }
}
function summaryUpdateRowDom(section, id, patchedRow) {
  section = String(section || '').trim();
  id = String(id || '').trim();
  const row = (patchedRow && typeof patchedRow === 'object') ? patchedRow : null;
  if (!section || !id || !row) return false;
  if (typeof currentSection !== 'string' || currentSection !== section) return false;

  // Update currentRows cache
  try {
    if (Array.isArray(window.currentRows)) {
      const idx = window.currentRows.findIndex(r => {
        const rid = r && (r.id ?? r.timesheet_id ?? r.contract_week_id ?? r.invoice_id);
        return String(rid || '') === id;
      });
      if (idx >= 0) {
        window.currentRows[idx] = { ...(window.currentRows[idx] || {}), ...(row || {}) };
      }
    }
  } catch {}

  const content = document.getElementById('content');
  const bodyWrap = content ? content.querySelector('.summary-body') : null;
  const tbl = bodyWrap ? bodyWrap.querySelector('table.grid') : null;
  const tb = tbl ? tbl.querySelector('tbody') : null;
  if (!tb) return false;

  const trList = Array.from(tb.querySelectorAll('tr[data-id]'));
  const tr = trList.find(x => String(x.dataset.id || '') === id) || null;
  if (!tr) return false;

  // Determine visible columns from the current header
  const ths = tbl ? Array.from(tbl.querySelectorAll('thead th[data-col-key]')) : [];
  const cols = ths.map(th => String(th.dataset.colKey || '')).filter(Boolean);

  const clearStyleClasses = () => {
    try {
      tr.classList.remove('row-deep-green');
      tr.classList.remove('row-light-green');
    } catch {}
  };

  const applyRowStyle = () => {
    clearStyleClasses();

    try {
      if (section === 'timesheets') {
        const toolsStage = String(row?.tools_stage || '').trim().toUpperCase();
        const invSegStage   = String(row?.invoice_segment_stage || '').trim().toUpperCase();
        const invIssueStage = String(row?.invoice_issue_stage || '').trim().toUpperCase();

        const isFullyInvoiced      = (invSegStage === 'FULLY_INVOICED');
        const isPaidToCandidate    = !!row?.paid_at_utc;
        const isInvoiceIssued      = (invIssueStage === 'INVOICED_ISSUED');
        const isInvoiceNotIssued   = (invIssueStage === 'INVOICED_NOT_ISSUED');

        const isReadyForInvoiceUninvoiced =
          (toolsStage === 'AUTHORISED_FOR_INVOICING');

        if (isFullyInvoiced && isPaidToCandidate && isInvoiceIssued) {
          tr.classList.add('row-deep-green');
        } else if (isFullyInvoiced && isInvoiceNotIssued) {
          tr.classList.add('row-light-green');
        } else if (isReadyForInvoiceUninvoiced) {
          tr.classList.add('row-light-green');
        }
      }

      if (section === 'invoices') {
        const stInv = String(row?.status || '').trim().toUpperCase();
        const isIssued = !!row?.issued_at_utc && (stInv === 'ISSUED' || stInv === 'PAID');
        if (isIssued) tr.classList.add('row-deep-green');
      }
    } catch {}
  };

  const renderIssueBadges = (codes) => {
    const wrap = document.createElement('div');
    wrap.className = 'issue-badges';

    const raw = Array.isArray(codes) ? codes.filter(Boolean) : [];
    const arr0 = raw.map(x => String(x || '').trim()).filter(Boolean);

    // âœ… Reference blocker pills (Option A: DB emits exact strings into issue_codes)
    // Ensure we never display more than one, even if legacy data ever contains multiples.
    const REF_ALL = new Set([
      'Refs (Invoicing Blocked)',
      'Refs (Issue Invoice Blocked)',
      'Refs (Invoice and Issue Blocked)'
    ]);
    const REF_PRECEDENCE = [
      'Refs (Invoice and Issue Blocked)',
      'Refs (Invoicing Blocked)',
      'Refs (Issue Invoice Blocked)'
    ];

    let refChosen = '';
    for (const k of REF_PRECEDENCE) {
      if (arr0.includes(k)) { refChosen = k; break; }
    }

    const rest = arr0.filter(x => !REF_ALL.has(x));
    const arr = refChosen ? [refChosen, ...rest] : rest;

    if (!arr.length) {
      const ok = document.createElement('span');
      ok.className = 'pill pill-ok';
      ok.textContent = 'OK';
      wrap.appendChild(ok);
      return wrap;
    }

    arr.forEach(code => {
      const span = document.createElement('span');
      const label = String(code || '').trim() || 'Issue';

      let cls = 'pill pill-bad';
      const up = label.toUpperCase();
      if (up === 'ON HOLD' || up === 'VALIDATION' || up === 'AUTHORISATION') {
        cls = 'pill pill-warn';
      }

      span.className = cls;
      span.textContent = label;
      wrap.appendChild(span);
    });

    return wrap;
  };

  const buildCell = (colKey) => {
    const td = document.createElement('td');
    td.dataset.colKey = String(colKey);

    const v = row[colKey];

    // Match renderSummary special cases
    if (section === 'candidates' && colKey === 'job_titles_display') {
      const raw = typeof row.job_titles_display === 'string' ? row.job_titles_display : (v || '');
      if (!String(raw || '').trim()) {
        td.textContent = '';
      } else {
        const parts = String(raw).split(';').map(s => s.trim()).filter(Boolean);
        const rest  = parts.slice(1);
        td.textContent = rest.join('; ');
      }
      return td;
    }

    if (section === 'timesheets' && colKey === 'issue_codes') {
      td.classList.add('mini');
      const hasTs = !!row.timesheet_id;
      const codes = Array.isArray(v) ? v.filter(Boolean) : [];
      if (!hasTs) td.textContent = '';
      else td.appendChild(renderIssueBadges(codes));
      return td;
    }

    if (section === 'timesheets' && colKey === 'candidate_name') {
      const txt = String((typeof formatDisplayValue === 'function' ? formatDisplayValue(colKey, v) : (v ?? '')) ?? '');
      const isPaidToCandidate = !!row?.paid_at_utc;

      if (isPaidToCandidate && txt) {
        const wrap = document.createElement('div');
        wrap.className = 'cell-right-icon';

        const main = document.createElement('span');
        main.className = 'cell-main';
        main.textContent = txt;

        const coin = document.createElement('span');
        coin.className = 'coin-badge';
        coin.textContent = 'Â£';

        wrap.appendChild(main);
        wrap.appendChild(coin);
        td.appendChild(wrap);
      } else {
        td.textContent = txt;
      }
      return td;
    }

    if (section === 'timesheets' && (colKey === 'processing_status' || colKey === 'processing_status_display')) {
      const txtBase = String(row?.processing_status_display || '').trim();
      const txt = txtBase || String((typeof formatDisplayValue === 'function' ? formatDisplayValue(colKey, v) : (v ?? '')) ?? '');

      const invoicePaid = (row && (row.invoice_is_paid === true || String(row.invoice_is_paid).toLowerCase() === 'true'));
      const stageNow = String(row?.tools_stage || '').trim().toUpperCase();

      if (invoicePaid && stageNow === 'INVOICED' && txt) {
        const wrap = document.createElement('div');
        wrap.className = 'cell-right-icon';

        const main = document.createElement('span');
        main.className = 'cell-main';
        main.textContent = txt;

        const coin = document.createElement('span');
        coin.className = 'coin-badge';
        coin.textContent = 'Â£';

        wrap.appendChild(main);
        wrap.appendChild(coin);
        td.appendChild(wrap);
      } else {
        td.textContent = txt;
      }
      return td;
    }

    if (section === 'invoices' && colKey === 'invoice_no') {
      const txt = String((typeof formatDisplayValue === 'function' ? formatDisplayValue(colKey, v) : (v ?? '')) ?? '');
      const isPaid = !!row?.paid_at_utc;

      if (isPaid && txt) {
        const wrap = document.createElement('div');
        wrap.className = 'cell-right-icon';

        const main = document.createElement('span');
        main.className = 'cell-main';
        main.textContent = txt;

        const coin = document.createElement('span');
        coin.className = 'coin-badge';
        coin.textContent = 'Â£';

        wrap.appendChild(main);
        wrap.appendChild(coin);
        td.appendChild(wrap);
      } else {
        td.textContent = txt;
      }
      return td;
    }

    if (section === 'invoices' && colKey === 'client_name') {
      td.textContent = String(row.client_name || '');
      return td;
    }

    td.textContent = (typeof formatDisplayValue === 'function')
      ? formatDisplayValue(colKey, v)
      : String(v == null ? 'â€”' : v);

    return td;
  };

  // Update each visible column cell in-place
  cols.forEach(colKey => {
    const existing = Array.from(tr.querySelectorAll('td[data-col-key]'))
      .find(td => String(td.dataset.colKey || '') === colKey) || null;

    const next = buildCell(colKey);

    if (existing) {
      existing.replaceWith(next);
    } else {
      tr.appendChild(next);
    }
  });

  applyRowStyle();
  return true;
}

function summaryInsertRowDom(section, patchedRow) {
  section = String(section || '').trim();
  const row = (patchedRow && typeof patchedRow === 'object') ? patchedRow : null;
  if (!section || !row) return false;
  if (typeof currentSection !== 'string' || currentSection !== section) return false;

  const content = document.getElementById('content');
  const bodyWrap = content ? content.querySelector('.summary-body') : null;
  const tbl = bodyWrap ? bodyWrap.querySelector('table.grid') : null;
  const tb = tbl ? tbl.querySelector('tbody') : null;
  if (!tb) return false;

  // Determine visible columns
  const cols = Array.from(tbl.querySelectorAll('thead th[data-col-key]'))
    .map(th => String(th.dataset.colKey || ''))
    .filter(Boolean);

  // Stable id
  const stableId =
    (row.id != null ? String(row.id) : '') ||
    (row.timesheet_id != null ? String(row.timesheet_id) : '') ||
    (row.contract_week_id != null ? String(row.contract_week_id) : '') ||
    (row.invoice_id != null ? String(row.invoice_id) : '');

  if (!stableId) return false;

  // If already exists, do nothing
  const exists = Array.from(tb.querySelectorAll('tr[data-id]')).some(tr => String(tr.dataset.id || '') === stableId);
  if (exists) return false;

  // Update currentRows cache (append for now; resort can reposition)
  try {
    if (Array.isArray(window.currentRows)) window.currentRows.push({ ...(row || {}), id: stableId });
  } catch {}

  const renderIssueBadges = (codes) => {
    const wrap = document.createElement('div');
    wrap.className = 'issue-badges';

    const raw = Array.isArray(codes) ? codes.filter(Boolean) : [];
    const arr0 = raw.map(x => String(x || '').trim()).filter(Boolean);

    // âœ… Reference blocker pills (Option A: DB emits exact strings into issue_codes)
    // Ensure we never display more than one, even if legacy data ever contains multiples.
    const REF_ALL = new Set([
      'Refs (Invoicing Blocked)',
      'Refs (Issue Invoice Blocked)',
      'Refs (Invoice and Issue Blocked)'
    ]);
    const REF_PRECEDENCE = [
      'Refs (Invoice and Issue Blocked)',
      'Refs (Invoicing Blocked)',
      'Refs (Issue Invoice Blocked)'
    ];

    let refChosen = '';
    for (const k of REF_PRECEDENCE) {
      if (arr0.includes(k)) { refChosen = k; break; }
    }

    const rest = arr0.filter(x => !REF_ALL.has(x));
    const arr = refChosen ? [refChosen, ...rest] : rest;

    if (!arr.length) {
      const ok = document.createElement('span');
      ok.className = 'pill pill-ok';
      ok.textContent = 'OK';
      wrap.appendChild(ok);
      return wrap;
    }

    arr.forEach(code => {
      const span = document.createElement('span');
      const label = String(code || '').trim() || 'Issue';

      let cls = 'pill pill-bad';
      const up = label.toUpperCase();
      if (up === 'ON HOLD' || up === 'VALIDATION' || up === 'AUTHORISATION') {
        cls = 'pill pill-warn';
      }

      span.className = cls;
      span.textContent = label;
      wrap.appendChild(span);
    });

    return wrap;
  };

  const buildCell = (colKey) => {
    const td = document.createElement('td');
    td.dataset.colKey = String(colKey);

    const v = row[colKey];

    if (section === 'candidates' && colKey === 'job_titles_display') {
      const raw = typeof row.job_titles_display === 'string' ? row.job_titles_display : (v || '');
      if (!String(raw || '').trim()) {
        td.textContent = '';
      } else {
        const parts = String(raw).split(';').map(s => s.trim()).filter(Boolean);
        const rest  = parts.slice(1);
        td.textContent = rest.join('; ');
      }
      return td;
    }

    if (section === 'timesheets' && colKey === 'issue_codes') {
      td.classList.add('mini');
      const hasTs = !!row.timesheet_id;
      const codes = Array.isArray(v) ? v.filter(Boolean) : [];
      if (!hasTs) td.textContent = '';
      else td.appendChild(renderIssueBadges(codes));
      return td;
    }

    if (section === 'timesheets' && colKey === 'candidate_name') {
      const txt = String((typeof formatDisplayValue === 'function' ? formatDisplayValue(colKey, v) : (v ?? '')) ?? '');
      const isPaidToCandidate = !!row?.paid_at_utc;

      if (isPaidToCandidate && txt) {
        const wrap = document.createElement('div');
        wrap.className = 'cell-right-icon';

        const main = document.createElement('span');
        main.className = 'cell-main';
        main.textContent = txt;

        const coin = document.createElement('span');
        coin.className = 'coin-badge';
        coin.textContent = 'Â£';

        wrap.appendChild(main);
        wrap.appendChild(coin);
        td.appendChild(wrap);
      } else {
        td.textContent = txt;
      }
      return td;
    }

    if (section === 'timesheets' && (colKey === 'processing_status' || colKey === 'processing_status_display')) {
      const txtBase = String(row?.processing_status_display || '').trim();
      const txt = txtBase || String((typeof formatDisplayValue === 'function' ? formatDisplayValue(colKey, v) : (v ?? '')) ?? '');

      const invoicePaid = (row && (row.invoice_is_paid === true || String(row.invoice_is_paid).toLowerCase() === 'true'));
      const stageNow = String(row?.tools_stage || '').trim().toUpperCase();

      if (invoicePaid && stageNow === 'INVOICED' && txt) {
        const wrap = document.createElement('div');
        wrap.className = 'cell-right-icon';

        const main = document.createElement('span');
        main.className = 'cell-main';
        main.textContent = txt;

        const coin = document.createElement('span');
        coin.className = 'coin-badge';
        coin.textContent = 'Â£';

        wrap.appendChild(main);
        wrap.appendChild(coin);
        td.appendChild(wrap);
      } else {
        td.textContent = txt;
      }
      return td;
    }

    if (section === 'invoices' && colKey === 'invoice_no') {
      const txt = String((typeof formatDisplayValue === 'function' ? formatDisplayValue(colKey, v) : (v ?? '')) ?? '');
      const isPaid = !!row?.paid_at_utc;

      if (isPaid && txt) {
        const wrap = document.createElement('div');
        wrap.className = 'cell-right-icon';

        const main = document.createElement('span');
        main.className = 'cell-main';
        main.textContent = txt;

        const coin = document.createElement('span');
        coin.className = 'coin-badge';
        coin.textContent = 'Â£';

        wrap.appendChild(main);
        wrap.appendChild(coin);
        td.appendChild(wrap);
      } else {
        td.textContent = txt;
      }
      return td;
    }

    if (section === 'invoices' && colKey === 'client_name') {
      td.textContent = String(row.client_name || '');
      return td;
    }

    td.textContent = (typeof formatDisplayValue === 'function')
      ? formatDisplayValue(colKey, v)
      : String(v == null ? 'â€”' : v);

    return td;
  };

  const applyRowStyle = (tr) => {
    try {
      tr.classList.remove('row-deep-green', 'row-light-green');

      if (section === 'timesheets') {
        const toolsStage = String(row?.tools_stage || '').trim().toUpperCase();
        const invSegStage   = String(row?.invoice_segment_stage || '').trim().toUpperCase();
        const invIssueStage = String(row?.invoice_issue_stage || '').trim().toUpperCase();

        const isFullyInvoiced      = (invSegStage === 'FULLY_INVOICED');
        const isPaidToCandidate    = !!row?.paid_at_utc;
        const isInvoiceIssued      = (invIssueStage === 'INVOICED_ISSUED');
        const isInvoiceNotIssued   = (invIssueStage === 'INVOICED_NOT_ISSUED');

        const isReadyForInvoiceUninvoiced = (toolsStage === 'AUTHORISED_FOR_INVOICING');

        if (isFullyInvoiced && isPaidToCandidate && isInvoiceIssued) tr.classList.add('row-deep-green');
        else if (isFullyInvoiced && isInvoiceNotIssued) tr.classList.add('row-light-green');
        else if (isReadyForInvoiceUninvoiced) tr.classList.add('row-light-green');
      }

      if (section === 'invoices') {
        const stInv = String(row?.status || '').trim().toUpperCase();
        const isIssued = !!row?.issued_at_utc && (stInv === 'ISSUED' || stInv === 'PAID');
        if (isIssued) tr.classList.add('row-deep-green');
      }
    } catch {}
  };

  const refreshSelectionUi = () => {
    try {
      window.__selection = window.__selection || {};
      const sel = window.__selection[section] || { ids: new Set() };
      const ids = (sel.ids instanceof Set) ? sel.ids : new Set();

      const hdrCbEl = document.getElementById('summarySelectAll');
      const visibleIds = Array.from(tb.querySelectorAll('tr[data-id]')).map(tr => String(tr.dataset.id || ''));
      const selectedOfVisible = visibleIds.filter(x => ids.has(x)).length;

      if (hdrCbEl) {
        hdrCbEl.checked = (visibleIds.length > 0 && selectedOfVisible === visibleIds.length);
        hdrCbEl.indeterminate = (selectedOfVisible > 0 && selectedOfVisible < visibleIds.length);
      }

      const topControls = (function () {
        const ps = document.getElementById('summaryPageSize');
        return ps ? ps.parentElement : null;
      })();

      if (topControls) {
        const selInfo = topControls.querySelector('div.mini');
        if (selInfo) selInfo.textContent = (ids.size > 0) ? `${ids.size} selected.` : '';

        const clearBtn = Array.from(topControls.querySelectorAll('button')).find(b => (b.textContent || '').trim() === 'Clear selection') || null;
        if (clearBtn) clearBtn.style.display = (ids.size > 0) ? '' : 'none';
      }

      const btns = Array.from((content || document).querySelectorAll('button'));
      const focusBtn   = btns.find(b => b.title === 'Focus on records') || null;
      const saveBtn    = btns.find(b => b.title === 'Save selection') || null;
      const resolveBtn = btns.find(b => b.title === 'Resolve candidate/client for selected timesheets') || null;

      const any = (ids.size > 0);
      if (focusBtn) focusBtn.disabled = !any;
      if (saveBtn) saveBtn.disabled = !any;
      if (resolveBtn) resolveBtn.disabled = !any;
    } catch {}
  };

  const tr = document.createElement('tr');
  tr.dataset.id = stableId;
  tr.dataset.section = section;

  // Selection cell
  const tdSel = document.createElement('td');
  tdSel.style.width = '40px';
  tdSel.style.minWidth = '40px';
  tdSel.style.maxWidth = '40px';

  const cb = document.createElement('input');
  cb.type = 'checkbox';
  cb.className = 'row-select';

  try {
    window.__selection = window.__selection || {};
    const sel = window.__selection[section] || { ids: new Set() };
    const ids = (sel.ids instanceof Set) ? sel.ids : new Set();
    cb.checked = ids.has(stableId);
  } catch {
    cb.checked = false;
  }

  cb.addEventListener('click', (e) => {
    e.stopPropagation();
    try {
      window.__selection = window.__selection || {};
      const sel = (window.__selection[section] ||= { fingerprint: '', ids: new Set() });
      if (!(sel.ids instanceof Set)) sel.ids = new Set();
      if (cb.checked) sel.ids.add(stableId);
      else sel.ids.delete(stableId);
    } catch {}
    refreshSelectionUi();
  });

  tdSel.appendChild(cb);
  tr.appendChild(tdSel);

  // Data cells
  cols.forEach(colKey => {
    tr.appendChild(buildCell(colKey));
  });

  applyRowStyle(tr);
  tb.appendChild(tr);

  refreshSelectionUi();
  return true;
}




function summaryMaybeResortDom(section) {
  section = String(section || '').trim();
  if (!section) return false;
  if (typeof currentSection !== 'string' || currentSection !== section) return false;

  const st = (window.__listState && window.__listState[section]) ? window.__listState[section] : null;
  const sort = (st && st.sort && typeof st.sort === 'object') ? st.sort : { key: null, dir: 'asc' };

  const key = String(sort.key || '').trim();
  const dir = (String(sort.dir || 'asc').toLowerCase() === 'desc') ? 'desc' : 'asc';
  if (!key) return false;

  if (!Array.isArray(window.currentRows)) return false;

  // Stable sort using existing order as tie-breaker
  const rowsWithIdx = window.currentRows.map((r, idx) => ({ r, idx }));

  const isIsoDate = (s) => /^\d{4}-\d{2}-\d{2}$/.test(s);
  const isIsoTs = (s) => typeof s === 'string' && /\d{4}-\d{2}-\d{2}T/.test(s);

  const norm = (v) => {
    if (v == null) return { t: 'null', v: null };
    if (typeof v === 'number') return { t: 'num', v };
    if (typeof v === 'boolean') return { t: 'num', v: v ? 1 : 0 };
    if (typeof v === 'string') {
      const s = v.trim();
      if (!s) return { t: 'null', v: null };
      if (isIsoDate(s)) return { t: 'date', v: s };
      if (isIsoTs(s)) {
        const ms = Date.parse(s);
        if (Number.isFinite(ms)) return { t: 'ms', v: ms };
      }
      const n = Number(s);
      if (Number.isFinite(n) && String(n) === s) return { t: 'num', v: n };
      return { t: 'str', v: s.toLowerCase() };
    }
    return { t: 'str', v: String(v).toLowerCase() };
  };

  const cmp = (a0, b0) => {
    const a = norm(a0);
    const b = norm(b0);

    // nulls last always
    if (a.t === 'null' && b.t === 'null') return 0;
    if (a.t === 'null') return 1;
    if (b.t === 'null') return -1;

    // compare
    if (a.t === 'num' && b.t === 'num') return a.v - b.v;
    if ((a.t === 'ms' || a.t === 'date') && (b.t === 'ms' || b.t === 'date')) {
      const av = (a.t === 'ms') ? a.v : a.v;
      const bv = (b.t === 'ms') ? b.v : b.v;
      return (av < bv ? -1 : av > bv ? 1 : 0);
    }
    if (a.t === 'str' && b.t === 'str') return a.v.localeCompare(b.v);

    // mixed types: string compare
    return String(a0).localeCompare(String(b0));
  };

  rowsWithIdx.sort((A, B) => {
    const av = (A.r && Object.prototype.hasOwnProperty.call(A.r, key)) ? A.r[key] : null;
    const bv = (B.r && Object.prototype.hasOwnProperty.call(B.r, key)) ? B.r[key] : null;

    const c = cmp(av, bv);
    if (c !== 0) return (dir === 'desc') ? -c : c;

    // stable tie-break
    return A.idx - B.idx;
  });

  const sorted = rowsWithIdx.map(x => x.r);
  window.currentRows = sorted;

  // Reorder DOM rows to match sorted currentRows, but only for ids currently visible in DOM
  const content = document.getElementById('content');
  const bodyWrap = content ? content.querySelector('.summary-body') : null;
  const tbl = bodyWrap ? bodyWrap.querySelector('table.grid') : null;
  const tb = tbl ? tbl.querySelector('tbody') : null;
  if (!tb) return false;

  const domById = new Map();
  Array.from(tb.querySelectorAll('tr[data-id]')).forEach(tr => {
    domById.set(String(tr.dataset.id || ''), tr);
  });

  // Append in sorted order (appendChild moves nodes)
  sorted.forEach(r => {
    const rid = r && (r.id ?? r.timesheet_id ?? r.contract_week_id ?? r.invoice_id);
    const id = String(rid || '');
    const tr = domById.get(id);
    if (tr) tb.appendChild(tr);
  });

  return true;
}


async function summaryFetchCanonicalRow(section, id, ctx) {
  section = String(section || '').trim();
  id      = String(id || '').trim();
  if (!section || !id) return null;

  // Related mode: do not attempt server canonical fetch (no dedicated id fetcher).
  // If the row is already in-memory, return it; else return null.
  const inferredRelated =
    !!(window.__listState &&
       window.__listState[section] &&
       window.__listState[section].filters &&
       window.__listState[section].filters.related);

  const inRelatedMode = !!((ctx && ctx.inRelatedMode) || inferredRelated);

  if (inRelatedMode) {
    try {
      if (String(currentSection || '') !== section) return null;
      if (!Array.isArray(window.currentRows)) return null;

      const row = window.currentRows.find(r => {
        const rid = r && (r.id ?? r.timesheet_id ?? r.contract_week_id ?? r.invoice_id);
        return String(rid || '') === id;
      }) || null;

      return row && typeof row === 'object' ? { ...(row || {}) } : null;
    } catch {
      return null;
    }
  }

  // Cache by section + fingerprint + id to avoid repeat calls
  const fp = (typeof getSummaryFingerprint === 'function')
    ? String(getSummaryFingerprint(section) || '')
    : (() => {
        const st0 = (window.__listState && window.__listState[section]) ? window.__listState[section] : {};
        const filters0 = st0 && st0.filters ? st0.filters : {};
        try { return JSON.stringify({ section, filters: filters0 }); } catch { return `${section}`; }
      })();

  window.__summaryCanonicalCache = window.__summaryCanonicalCache || {};
  const cacheKey = `${section}::${fp}::${id}`;
  const now = Date.now();

  const hit = window.__summaryCanonicalCache[cacheKey];
  if (hit && hit.t && (now - hit.t) < 8000) {
    return hit.row || null;
  }

  const st = (window.__listState && window.__listState[section]) ? window.__listState[section] : null;
  const filters = (st && st.filters && typeof st.filters === 'object') ? st.filters : {};
  const sort    = (st && st.sort && typeof st.sort === 'object') ? st.sort : { key: null, dir: 'asc' };

  // â”€â”€ Selection-filter parity (avoid incorrect â€œincludedâ€ fetch) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const parseIdSetFromFilters = (f) => {
    const out = new Set();

    const add = (v) => {
      const s = String(v || '').trim();
      if (s) out.add(s);
    };

    // ids can be array OR csv
    if (Object.prototype.hasOwnProperty.call(f, 'ids')) {
      const v = f.ids;
      if (Array.isArray(v)) v.forEach(add);
      else String(v || '').split(',').map(x => x.trim()).filter(Boolean).forEach(add);
    }

    // id can be a single uuid OR an in.(...) expression
    if (Object.prototype.hasOwnProperty.call(f, 'id')) {
      const v = String(f.id || '').trim();
      if (v) {
        if (/^in\.\(.+\)$/.test(v)) {
          const inner = v.replace(/^in\.\(/, '').replace(/\)$/, '');
          inner.split(',').map(x => x.trim()).filter(Boolean).forEach(add);
        } else {
          add(v);
        }
      }
    }

    return out;
  };

  try {
    const selIds = parseIdSetFromFilters(filters || {});
    if (selIds.size > 0 && !selIds.has(id)) {
      window.__summaryCanonicalCache[cacheKey] = { t: now, row: null };
      return null;
    }
  } catch {}

  const qs = new URLSearchParams();

  // Always request a single row
  qs.set('page', '1');
  qs.set('page_size', '1');

  const appendFilter = (k, v) => {
    if (v == null) return;
    if (typeof v === 'string' && v.trim() === '') return;

    if (Array.isArray(v)) {
      v.forEach(x => {
        if (x == null) return;
        const s = String(x).trim();
        if (!s) return;
        qs.append(k, s);
      });
      return;
    }

    qs.set(k, String(v));
  };

  // Apply existing filters, but strip:
  // - related (handled elsewhere)
  // - id/ids (we already validated selection parity; weâ€™ll set our own id fetch)
  // - pagination keys (we set page/page_size)
  Object.entries(filters || {}).forEach(([k, v]) => {
    if (k === 'related') return;
    if (k === 'page' || k === 'page_size' || k === 'limit' || k === 'offset') return;
    if (k === 'id' || k === 'ids') return;
    appendFilter(k, v);
  });

  // Apply sort where supported (best-effort; backend will ignore if unsupported)
  try {
    if (sort && sort.key) {
      qs.set('order_by', String(sort.key));
      qs.set('order_dir', (String(sort.dir).toLowerCase() === 'desc') ? 'desc' : 'asc');
    }
  } catch {}

  // Choose path + id filter
  let path = '';
  if (section === 'timesheets') {
    path = '/api/timesheets/summary';
    qs.set('include_totals', 'false');
    qs.set('id', id); // backend supports OR(timesheet_id, contract_week_id)
  } else if (section === 'invoices') {
    path = '/api/search/invoices';
    qs.set('ids', id);
  } else if (section === 'contracts') {
    path = '/api/contracts';
    qs.set('ids', id);
  } else if (section === 'candidates') {
    path = '/api/search/candidates';
    qs.set('ids', id);
  } else if (section === 'clients') {
    path = '/api/search/clients';
    qs.set('ids', id);
  } else if (section === 'umbrellas') {
    path = '/api/search/umbrellas';
    qs.set('ids', id);
  } else {
    path = `/api/search/${encodeURIComponent(section)}`;
    qs.set('ids', id);
  }

  const url = `${path}?${qs.toString()}`;

  try {
    const res = await authFetch(API(url));
    if (!res || !res.ok) {
      window.__summaryCanonicalCache[cacheKey] = { t: now, row: null };
      return null;
    }

    const j = await res.json().catch(() => null);

    let rows = [];
    if (Array.isArray(j)) rows = j;
    else if (j && Array.isArray(j.items)) rows = j.items;
    else if (j && Array.isArray(j.rows))  rows = j.rows;
    else if (j && Array.isArray(j.data))  rows = j.data;

    const row = (rows && rows.length) ? rows[0] : null;
    if (!row || typeof row !== 'object') {
      window.__summaryCanonicalCache[cacheKey] = { t: now, row: null };
      return null;
    }

    // Normalizations to match renderSummary expectations
    try {
      if (section === 'timesheets') {
        if (!row.id) row.id = row.timesheet_id || row.contract_week_id || id;
      }

      if (section === 'invoices') {
        if (!row.id) row.id = row.invoice_id || id;

        // Flatten joined client name if present
        if ((row.client_name == null || row.client_name === '') && row.client && typeof row.client === 'object') {
          row.client_name = row.client.name || '';
        }
      }
    } catch {}

    window.__summaryCanonicalCache[cacheKey] = { t: now, row };
    return row;
  } catch {
    window.__summaryCanonicalCache[cacheKey] = { t: now, row: null };
    return null;
  }
}



function getBucketLabelsForContract(contract) {
  const userSet = normaliseBucketLabelsInput(contract?.bucket_labels_json || null);
  return userSet || labelsDefault();
}

function summariseBucketLabels(labels) {
  const L = normaliseBucketLabelsInput(labels);
  return L ? [L.day, L.night, L.sat, L.sun, L.bh].join('/') : '';
}

function applyBucketLabelsToHoursGrid(gridEl, labels) {
  const L = normaliseBucketLabelsInput(labels) || labelsDefault();
  if (!gridEl) return;
  const map = {
    day:   gridEl.querySelector('[data-bucket="day"] .lbl'),
    night: gridEl.querySelector('[data-bucket="night"] .lbl'),
    sat:   gridEl.querySelector('[data-bucket="sat"] .lbl'),
    sun:   gridEl.querySelector('[data-bucket="sun"] .lbl'),
    bh:    gridEl.querySelector('[data-bucket="bh"] .lbl'),
  };
  Object.entries(map).forEach(([k, el]) => { if (el) el.textContent = L[k]; });
}

function renderBucketLabelsEditor(ctx /* modalCtx */) {
  // Prefer staged labels from formState.main; fallback to contract's stored labels; finally to defaults
  const fsMain = (window.modalCtx && window.modalCtx.formState && window.modalCtx.formState.main) || {};
  const stored = getBucketLabelsForContract(ctx.data || {});
  const L = {
    day:   fsMain.bucket_day   ?? stored.day   ?? 'Day',
    night: fsMain.bucket_night ?? stored.night ?? 'Night',
    sat:   fsMain.bucket_sat   ?? stored.sat   ?? 'Sat',
    sun:   fsMain.bucket_sun   ?? stored.sun   ?? 'Sun',
    bh:    fsMain.bucket_bh    ?? stored.bh    ?? 'BH',
  };
  return `
    <div class="group">
      <div class="row"><label>Bucket labels (optional)</label>
        <div class="controls small">
          <div class="grid-5" id="bucketLabelsGrid">
            <div data-k="day"><span>Standard</span><input class="input" type="text" name="bucket_day"   value="${(L.day||'Day')}" /></div>
            <div data-k="night"><span>OT1</span>     <input class="input" type="text" name="bucket_night" value="${(L.night||'Night')}" /></div>
            <div data-k="sat"><span>OT2</span>       <input class="input" type="text" name="bucket_sat"   value="${(L.sat||'Sat')}" /></div>
            <div data-k="sun"><span>OT3</span>       <input class="input" type="text" name="bucket_sun"   value="${(L.sun||'Sun')}" /></div>
            <div data-k="bh"><span>OT4</span>        <input class="input" type="text" name="bucket_bh"    value="${(L.bh||'BH')}" /></div>
          </div>
        </div>
      </div>
    </div>`;
}


function _collectBucketLabelsFromForm(rootSel = '#contractForm') {
  const root = document.querySelector(rootSel);
  if (!root) return null;
  const day   = root.querySelector('input[name="bucket_day"]')?.value?.trim();
  const night = root.querySelector('input[name="bucket_night"]')?.value?.trim();
  const sat   = root.querySelector('input[name="bucket_sat"]')?.value?.trim();
  const sun   = root.querySelector('input[name="bucket_sun"]')?.value?.trim();
  const bh    = root.querySelector('input[name="bucket_bh"]')?.value?.trim();
  const raw = { day, night, sat, sun, bh };
  // If all empty â†’ treat as null; if partially filled â†’ require full 5, else clear to null
  const filled = Object.values(raw).filter(Boolean).length;
  if (filled === 0) return null;
  const norm = normaliseBucketLabelsInput(raw);
  return norm || null;
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Overlap guard flow
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€-

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UPDATED: preSaveContractWithOverlapCheck (adds logging)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function preSaveContractWithOverlapCheck(formData /* object */) {
  const LOGC = (typeof window.__LOG_CONTRACTS === 'boolean') ? window.__LOG_CONTRACTS : false;
  const payload = {
    candidate_id: formData.candidate_id,
    start_date:   formData.start_date,
    end_date:     formData.end_date,
    ignore_contract_id: formData.id || null
  };
  if (LOGC) console.log('[CONTRACTS] overlap check â†’ request', payload);
  const res = await checkContractOverlap(payload);
  if (LOGC) console.log('[CONTRACTS] overlap check â†’ response', res);
  if (!res?.has_overlap) return true;
  const ok = await showContractOverlapWarningDialog(res.overlaps || []);
  if (LOGC) console.log('[CONTRACTS] overlap dialog â†’ userChoice', ok);
  return !!ok;
}

function showContractOverlapWarningDialog(overlaps = []) {
  // Returns a Promise<boolean> that resolves when user chooses.
  return new Promise((resolve) => {
    const list = overlaps.map(o => `
      <li>
        <div><b>${(o.client_name || o.client_id || '')}</b> â€” ${o.role || ''}${o.band ? ` (Band ${o.band})` : ''}</div>
        <div class="mini">Existing: ${o.existing_start_date} â†’ ${o.existing_end_date}</div>
        <div class="mini">Overlap: <b>${o.overlap_start_date} â†’ ${o.overlap_end_date}</b> (${o.overlap_days} day(s))</div>
      </li>`).join('');

    const content = `
      <div class="warn">
        <p>The proposed dates overlap the following contract(s) for this candidate:</p>
        <ul class="overlap-list">${list || '<li>(none)</li>'}</ul>
        <p>Do you want to proceed anyway?</p>
      </div>`;

    showModal(
      'Overlap detected',
      [{ key: 'ov', title: 'Warning'}],
      () => content,
      async () => { resolve(true); return true; },
      false,
      () => {}, // onReturn
      {
        kind:'overlap-warning',
        extraButtons: [
          { label:'Cancel', role:'secondary', onClick: () => { resolve(false); discardTopModal && discardTopModal(); } }
        ]
      }
    );
  });
}
function confirmProceedWithOverlap(){ /* kept for API parity; handled in modal above */ return Promise.resolve(true); }
function cancelOverlapSave(){ /* kept for API parity; handled in modal above */ return Promise.resolve(false); }


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UI â€” Contracts section (table + modal tabs)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€-

function renderContractsTable(rows) {
  // Custom lightweight renderer that highlights <Unassigned> in red.
  // If your environment prefers the generic grid, you can still call that instead.
  // This function simply returns a DOM node that your caller can insert.

  const make = (tag, attrs = {}, children = []) => {
    const el = document.createElement(tag);
    Object.entries(attrs).forEach(([k, v]) => {
      if (k === 'style' && typeof v === 'object') {
        Object.assign(el.style, v);
      } else if (k === 'className') {
        el.className = v;
      } else {
        el.setAttribute(k, v);
      }
    });
    (Array.isArray(children) ? children : [children]).forEach(ch => {
      if (ch == null) return;
      if (typeof ch === 'string') el.appendChild(document.createTextNode(ch));
      else el.appendChild(ch);
    });
    return el;
  };

  const wrap = make('div');
  const style = make('style', {}, `
    .contracts-table { width:100%; border-collapse:collapse; font-size:13px; }
    .contracts-table th, .contracts-table td { border:1px solid var(--line,#e5e5e5); padding:8px; text-align:left; }
    .contracts-table th { background: var(--panel,#fafafa); }
    .contracts-table .unassigned { color: var(--danger,#c0392b); font-weight: 600; }
    .contracts-table .sm { color: var(--muted,#666); font-size: 12px; }
  `);
  wrap.appendChild(style);

  const table = make('table', { className: 'contracts-table' });
  const thead = make('thead');
  const trh = make('tr');
  ['ID','Candidate','Client','Role','Start','End'].forEach(h => trh.appendChild(make('th', {}, h)));
  thead.appendChild(trh);
  table.appendChild(thead);

  const tbody = make('tbody');

  (Array.isArray(rows) ? rows : []).forEach(r => {
    const tr = make('tr');

    // ID
    tr.appendChild(make('td', {}, String(r.id ?? '')));

    // Candidate (show <Unassigned> in red if missing)
    const candLabel = (r.candidate_display || r.candidate_name || '').trim();
    if (candLabel) {
      tr.appendChild(make('td', {}, candLabel));
    } else {
      const td = make('td');
      const span = make('span', { className: 'unassigned' }, '<Unassigned>');
      td.appendChild(span);
      tr.appendChild(td);
    }

    // Client
    tr.appendChild(make('td', {}, (r.client_name || '').trim()));

    // Role
    tr.appendChild(make('td', {}, (r.role || '').trim()));

    // Start / End (show raw ISO or formatted upstream)
    tr.appendChild(make('td', {}, (r.start_date || '')));
    tr.appendChild(make('td', {}, (r.end_date || '')));

    tbody.appendChild(tr);
  });

  table.appendChild(tbody);
  wrap.appendChild(table);

  return wrap;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// FIX 6: Add guarded Delete entry point inside openContract (plus std_hours_json save)
// (Delete only if unused; handled by backend; no change to global openDelete())
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// openContract (amended) â€” surface PAY_METHOD_MISMATCH warnings after save
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UPDATED: openContract (Rates tab enabled on create; picker wiring always-on;
// typing in Candidate/Client field will open the picker; rich logging)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UPDATED: openContract â€” adds initial onReturn() kick so Pick buttons are wired
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UPDATED: openContract(row)
// (unchanged logic except it opens the updated pickers; initial onReturn retained)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// âœ… CHANGED: honour fresh row; give the modal an openToken for stable formState binding


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// NEW: getSummaryFingerprint(section)
// Deterministic fingerprint of current filters (and section)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getSummaryFingerprint(section){
  window.__listState = window.__listState || {};
  const st = (window.__listState[section] ||= { page:1, pageSize:50, total:null, hasMore:false, filters:null });
  const filters = st.filters || {};
  const norm = (o)=> {
    const k = Object.keys(o||{}).sort();
    const out = {};
    for (const key of k) {
      const v = o[key];
      if (Array.isArray(v)) out[key] = v.slice().map(x=>String(x)).sort();
      else out[key] = v;
    }
    return out;
  };
  return JSON.stringify({ section, filters: norm(filters) });
}



// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
/* NEW: primeSummaryMembership(section, fingerprint)
   - Calls backend id-list endpoint to fetch **all ids** for the current filters
   - Stores into window.__summaryCache[section][fingerprint] = { ids, total, updatedAt }
   - Non-blocking; safe to call repeatedly (dedup by fingerprint)
*/
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function primeSummaryMembership(section, fingerprint){
  const LOGC = (typeof window.__LOG_CONTRACTS === 'boolean') ? window.__LOG_CONTRACTS : false;
  window.__summaryCache = window.__summaryCache || { candidates:{}, clients:{} };
  const secKey = (section==='candidates'||section==='clients') ? section : null;
  if (!secKey) return;

  const cache = window.__summaryCache[secKey] ||= {};
  const existing = cache[fingerprint];
  if (existing && existing._inflight) return;
  if (existing && Array.isArray(existing.ids) && existing.ids.length) return;
  if (existing && existing.updatedAt && (Date.now() - existing.updatedAt > 60_000)) existing.stale = true;

  cache[fingerprint] = cache[fingerprint] || {};
  cache[fingerprint]._inflight = true;

  try {
    window.__listState = window.__listState || {};
    const st   = window.__listState[secKey] || {};
    const qs   = buildSummaryFilterQSForIdList(secKey, st.filters || {});
    const url  = API(`/api/pickers/${secKey}/id-list${qs ? ('?'+qs) : ''}`);
    const resp = await authFetch(url);
    const json = await resp.json().catch(()=>null);

    const ids = Array.isArray(json?.ids) ? json.ids.map(String) : [];
    cache[fingerprint] = {
      ids,
      total: Number(json?.total || ids.length || 0),
      updatedAt: Date.now(),
      stale: false,
    };
    if (LOGC) console.log('[SUMMARY][primeMembership]', { section: secKey, total: ids.length });
  } catch (e) {
    cache[fingerprint] = { ids: [], total: 0, updatedAt: Date.now(), stale: true };
    if (LOGC) console.warn('[SUMMARY][primeMembership] failed', e);
  } finally {
    if (cache[fingerprint]) delete cache[fingerprint]._inflight;
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// NEW: getSummaryMembership(section, fingerprint)
// Returns { ids, total, updatedAt, stale } or a stub if missing
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getSummaryMembership(section, fingerprint){
  window.__summaryCache = window.__summaryCache || { candidates:{}, clients:{} };
  const secKey = (section==='candidates'||section==='clients') ? section : null;
  if (!secKey) return { ids: [], total: 0, updatedAt: 0, stale: true };
  const ent = window.__summaryCache[secKey] || {};
  const res = ent[fingerprint] || { ids: [], total: 0, updatedAt: 0, stale: true };
  return { ids: Array.isArray(res.ids) ? res.ids : [], total: Number(res.total||0), updatedAt: Number(res.updatedAt||0), stale: !!res.stale };
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// NEW: buildSummaryFilterQSForIdList(section, filters)
// Converts current summary filters to QS for id-list endpoints.
// Reuse your search QS rules; keep only filter params (no paging).
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function buildSummaryFilterQSForIdList(section, filters){
  const sp = new URLSearchParams();
  const f  = filters || {};

  if (Array.isArray(f.ids) && f.ids.length) sp.set('ids', f.ids.join(','));
  if (f.role)      sp.set('role', f.role);
  if (f.band)      sp.set('band', f.band);
  if (f.client_id) sp.set('client_id', f.client_id);
  if (f.q)         sp.set('q', f.q);

  if (f.active != null && section === 'candidates') sp.set('active', String(!!f.active));

  return sp.toString();
}
function renderHrWeeklyValidationSummary(type, importId, preview) {
  const T = String(type || '').toUpperCase();
  const impId = (importId != null) ? String(importId) : '';

  const enc = (typeof escapeHtml === 'function')
    ? escapeHtml
    : (s) => String(s ?? '').replace(/[&<>"']/g, (c) => ({
        '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
      }[c]));

  const p = (preview && typeof preview === 'object') ? preview : {};
  const sum = (p.summary && typeof p.summary === 'object') ? p.summary : {};

  const modeRaw = (p.mode_summary || p.modeSummary || sum.mode_summary || sum.modeSummary || '');
  let mode = String(modeRaw || '').trim().toUpperCase();

  // Safety fallback: never default to "apply" semantics if backend didn't provide mode.
  if (mode !== 'MODE_A_ONLY' && mode !== 'MODE_B_ONLY' && mode !== 'MIXED') {
    const vgN = Array.isArray(p.validation_groups) ? p.validation_groups.length : 0;
    const agN = Array.isArray(p.action_groups) ? p.action_groups.length : 0;
    const aN  = Array.isArray(p.actions) ? p.actions.length : 0;
    if (vgN > 0 && (agN > 0 || aN > 0)) mode = 'MIXED';
    else if (vgN > 0) mode = 'MODE_A_ONLY';
    else if (agN > 0 || aN > 0) mode = 'MODE_B_ONLY';
    else mode = 'MODE_A_ONLY';
  }

  const niceYmd = (ymd) => {
    const s = String(ymd || '').trim();
    if (!s) return '';
    if (typeof formatYmdToNiceDate === 'function' && /^\d{4}-\d{2}-\d{2}$/.test(s)) {
      try { return formatYmdToNiceDate(s); } catch {}
    }
    return s;
  };

  // Weekly preview payload fields
  const vg = Array.isArray(p.validation_groups) ? p.validation_groups : [];
  const allRows = Array.isArray(p.rows) ? p.rows : [];

  // Resolve import-level client_id fallback for mapping modal seeding
  const importClientId =
    String(
      (p.client_id || sum.client_id || p?.truth_meta?.client_id || sum?.truth_meta?.client_id || '') || ''
    ).trim();

  // UI store (emailSelection + invalidationSelection + altEmailByKey) used for checkbox/input state
  const ui = (window.__weeklyImportUi &&
              window.__weeklyImportUi.HR_WEEKLY &&
              window.__weeklyImportUi.HR_WEEKLY[impId] &&
              (window.__weeklyImportUi.HR_WEEKLY[impId].emailSelection instanceof Set
                || window.__weeklyImportUi.HR_WEEKLY[impId].emailSelection instanceof Map
                || window.__weeklyImportUi.HR_WEEKLY[impId].invalidationSelection instanceof Map
                || window.__weeklyImportUi.HR_WEEKLY[impId].altEmailByKey instanceof Map))
    ? window.__weeklyImportUi.HR_WEEKLY[impId]
    : null;

  // Back-compat:
  // - emailSelection may be Set (historical: presence=checked)
  // - OR Map (new: key -> boolean, where false means explicitly unticked)
  const selStore = (ui && (ui.emailSelection instanceof Set || ui.emailSelection instanceof Map)) ? ui.emailSelection : null;
  const invMap = (ui && ui.invalidationSelection instanceof Map) ? ui.invalidationSelection : new Map();
  const altEmailMap = (ui && ui.altEmailByKey instanceof Map) ? ui.altEmailByKey : new Map();

  const keyFor = (tsid, fp) => {
    const a = String(tsid || '').trim();
    const b = String(fp || '').trim();
    if (!a || !b) return '';
    return `${a}|${b}`;
  };

  const invKeyFor = (tsid, comparisonKey) => {
    const a = String(tsid || '').trim();
    const b = String(comparisonKey || '').trim();
    if (!a || !b) return '';
    return `${a}|${b}`;
  };

  const pillForStatus = (s) => {
    const v = String(s || '').toUpperCase();
    if (v === 'OK' || v === 'PASS' || v === 'VALIDATION_OK') return 'pill-ok';
    if (v === 'AMBIGUOUS' || v === 'WARN' || v === 'WARNING') return 'pill-warn';
    if (v === 'FAIL' || v === 'ERROR' || v === 'VALIDATION_ERROR' || v === 'MISSING_TIMESHEET' || v === 'AWAITING_AUTHORISATION') return 'pill-bad';
    return 'pill-info';
  };

  const statusTextNice = (raw) => {
    const a = String(raw || '').trim().toUpperCase();
    if (!a) return 'Unknown';

    if (a === 'REJECT_NO_CANDIDATE') return 'Reject â€“ Candidate not found';
    if (a === 'REJECT_NO_CLIENT') return 'Reject â€“ Client/site not found';
    if (a === 'REJECT_NO_CONTRACT') return 'Reject â€“ No matching contract';
    if (a === 'REJECT_NO_CONTRACT_BAND_MISMATCH') return 'Reject â€“ Grade/band mapping missing';
    if (a === 'REJECT_MISSING_EXTERNAL_ROW_KEY') return 'Reject â€“ Missing row key';
    if (a.startsWith('REJECT_')) return `Reject â€“ ${a.replace(/^REJECT_/, '').replace(/_/g, ' ').toLowerCase()}`;

    if (a === 'NO_CANDIDATE') return 'Reject â€“ Candidate not found';
    if (a === 'NO_CLIENT') return 'Reject â€“ Client/site not found';
    if (a === 'BAD_ROW') return 'Reject â€“ Invalid row';

    return a.replace(/_/g, ' ');
  };

  // Fallback: Flatten legacy days[].pairings[] => comparisons-like rows
  const flattenComparisonsFromDays = (days) => {
    const out = [];
    const arr = Array.isArray(days) ? days : [];
    for (const d of arr) {
      const ymd = String(d?.work_date || d?.ymd || d?.date_local || d?.date || '').trim();
      const pairings = Array.isArray(d?.pairings) ? d.pairings : [];
      for (const p0 of pairings) {
        const p2 = p0 || {};
        const hr = p2?.hr || p2?.hr_entry || p2?.hrEntry || null;
        const wk = p2?.worker || p2?.worker_entry || p2?.workerEntry || null;

        const sd = p2?.start_diff_mins ?? p2?.startDiffMins ?? null;
        const ed = p2?.end_diff_mins ?? p2?.endDiffMins ?? null;
        const bd = p2?.break_diff_mins ?? p2?.breakDiffMins ?? null;

        const matchStatus = String(p2?.match_status || p2?.matchStatus || '').trim().toUpperCase();
        const diffsAllZero =
          (sd == null || Number(sd) === 0) &&
          (ed == null || Number(ed) === 0) &&
          (bd == null || Number(bd) === 0);

        const isMatch =
          (matchStatus === 'MATCH' || matchStatus === 'OK' || matchStatus === 'PASS' || matchStatus === 'SAME' || matchStatus === 'MATCHED') ||
          (matchStatus === '' && diffsAllZero);

        const tsStart = wk?.start_local || wk?.start || wk?.start_utc || '';
        const tsEnd   = wk?.end_local || wk?.end || wk?.end_utc || '';
        const tsBreak = (wk?.break_mins ?? wk?.break_minutes ?? wk?.break ?? '');

        const hrStart = hr?.start_local || hr?.start || hr?.start_utc || '';
        const hrEnd   = hr?.end_local || hr?.end || hr?.end_utc || '';
        const hrBreak = (hr?.break_mins ?? hr?.break_minutes ?? hr?.break ?? '');

        out.push({
          comparison_key: `${String(ymd || '').trim()}|${String(tsStart || '').trim()}|${String(tsEnd || '').trim()}|${String(tsBreak == null ? 0 : tsBreak)}`,
          work_date: ymd,
          match: !!isMatch,
          match_status: matchStatus || (isMatch ? 'MATCH' : 'MISMATCH'),
          timesheet_start: String(tsStart || '').trim(),
          timesheet_end: String(tsEnd || '').trim(),
          timesheet_break_mins: (tsBreak == null || tsBreak === '' ? null : Number(tsBreak)),
          healthroster_start: String(hrStart || '').trim(),
          healthroster_end: String(hrEnd || '').trim(),
          healthroster_break_mins: (hrBreak == null || hrBreak === '' ? null : Number(hrBreak)),
          invoice_locked: false,
          invoice_locked_invoice_id: null,
          is_destructive_invalidation: false,
          default_invalidate_checked: false
        });
      }
    }
    return out;
  };

  // New contract: g.comparisons[] (preferred)
  const normaliseComparisons = (arr) => {
    const a = Array.isArray(arr) ? arr : [];
    return a.map((c0) => {
      const c = c0 && typeof c0 === 'object' ? c0 : {};
      const wd = String(c.work_date || c.workDate || c.date || c.ymd || '').trim();

      const matchVal = (c.match != null) ? c.match : (c.is_match != null ? c.is_match : c.isMatch);
      const match = (matchVal === true || matchVal === 'true' || matchVal === 1 || matchVal === '1');

      const tsStart = String(c.timesheet_start || c.timesheetStart || c.ts_start_hhmm || c.tsStart || '').trim();
      const tsEnd   = String(c.timesheet_end || c.timesheetEnd || c.ts_end_hhmm || c.tsEnd || '').trim();

      const hrStart = String(c.healthroster_start || c.healthrosterStart || c.hr_start_hhmm || c.hrStart || '').trim();
      const hrEnd   = String(c.healthroster_end || c.healthrosterEnd || c.hr_end_hhmm || c.hrEnd || '').trim();

      const tsBr = (c.timesheet_break_mins ?? c.timesheetBreakMins ?? c.ts_break_mins ?? c.tsBreakMins ?? null);
      const hrBr = (c.healthroster_break_mins ?? c.healthrosterBreakMins ?? c.hr_break_mins ?? c.hrBreakMins ?? null);

      const ms = String(c.match_status || c.matchStatus || '').trim().toUpperCase();

      const ck = String(c.comparison_key || c.comparisonKey || '').trim();
      const invoiceLockedVal = (c.invoice_locked != null) ? c.invoice_locked : (c.invoiceLocked != null ? c.invoiceLocked : null);
      const invoiceLocked = (invoiceLockedVal === true || invoiceLockedVal === 'true' || invoiceLockedVal === 1 || invoiceLockedVal === '1');
      const invoiceLockedId = String(c.invoice_locked_invoice_id || c.invoiceLockedInvoiceId || '').trim() || null;

      const destrVal = (c.is_destructive_invalidation != null) ? c.is_destructive_invalidation : (c.isDestructiveInvalidation != null ? c.isDestructiveInvalidation : null);
      const isDestructive = (destrVal === true || destrVal === 'true' || destrVal === 1 || destrVal === '1');

      const defInvVal = (c.default_invalidate_checked != null) ? c.default_invalidate_checked : (c.defaultInvalidateChecked != null ? c.defaultInvalidateChecked : null);
      const defaultInv = (defInvVal === true || defInvVal === 'true' || defInvVal === 1 || defInvVal === '1');

      return {
        comparison_key: ck || (wd ? `${wd}|${tsStart}|${tsEnd}|${String(tsBr == null ? 0 : tsBr)}` : ''),
        work_date: wd,
        match: !!match,
        match_status: ms || (match ? 'MATCH' : 'MISMATCH'),
        timesheet_start: tsStart,
        timesheet_end: tsEnd,
        timesheet_break_mins: (tsBr == null || tsBr === '' ? null : Number(tsBr)),
        healthroster_start: hrStart,
        healthroster_end: hrEnd,
        healthroster_break_mins: (hrBr == null || hrBr === '' ? null : Number(hrBr)),
        invoice_locked: !!invoiceLocked || !!invoiceLockedId,
        invoice_locked_invoice_id: invoiceLockedId,
        is_destructive_invalidation: !!isDestructive,
        default_invalidate_checked: !!defaultInv
      };
    }).filter(x => x.work_date || x.timesheet_start || x.healthroster_start);
  };

  // Unresolved / rejected items (derive from preview.rows)
  const unresolved = [];
  for (let i = 0; i < allRows.length; i++) {
    const r = allRows[i];
    if (!r || typeof r !== 'object') continue;

    const act = String(r.action || r.resolution_status || r.status || '').toUpperCase();
    if (!act) continue;

    const unresolvedHere =
      act.startsWith('REJECT_') ||
      act === 'NO_CANDIDATE' ||
      act === 'NO_CLIENT' ||
      act === 'BAD_ROW';

    if (!unresolvedHere) continue;

    unresolved.push({ idx: i, row: r, act });
  }

  const unresolvedTableFullWidth = () => {
    if (!unresolved.length) return '';

    const rowsHtml = unresolved.map(({ idx, row, act }) => {
      const staff = row.staff_name || row.staff_raw || row.staff_norm || '';
      const unit  = row.ward || row.unit || row.hospital_or_trust || row.trust_raw || row.unit_raw || '';
      const wd    = row.work_date || row.date_local || row.date || '';
      const we    = row.week_ending_date || row.weekEndingDate || '';
      const code  = row.incoming_code || row.grade_raw || row.assignment_code || row.assignment_grade_norm || '';
      const reason = row.reason || row.reason_text || row.reason_code || '';

      const actNice = statusTextNice(act);

      const canAssignCand = (act === 'NO_CANDIDATE' || act === 'REJECT_NO_CANDIDATE');
      const needsBandMap =
        (act === 'REJECT_NO_CONTRACT' || act === 'REJECT_NO_CONTRACT_BAND_MISMATCH');

      const btnCand = canAssignCand
        ? `<button type="button" class="btn mini" data-act="hr-weekly-val-resolve-candidate" data-row-idx="${enc(String(idx))}">Assign candidateâ€¦</button>`
        : '';

      const btnBand = needsBandMap
        ? `<button type="button"
                   class="btn mini"
                   data-act="hr-weekly-val-fix-band"
                   data-incoming-code="${enc(String(code || '').trim())}"
                   data-client-id="${enc(String(row.client_id || importClientId || '').trim())}"
                   data-candidate-id="${enc(String(row.candidate_id || '').trim())}"
                   data-work-date="${enc(String(wd || '').trim())}"
                   data-week-ending-date="${enc(String(we || '').trim())}"
                   data-import-id="${enc(impId)}">
             Fix band mappingâ€¦
           </button>`
        : '';

      const btns = (btnCand || btnBand)
        ? `<div style="display:flex;flex-wrap:wrap;gap:6px;align-items:flex-start;">${btnCand}${btnBand}</div>`
        : `<span class="mini">â€”</span>`;

      const statusPill = `<span class="pill pill-bad" style="white-space:normal;word-break:break-word;display:inline-block;">${enc(actNice)}</span>`;

      return `
        <tr data-row-idx="${enc(String(idx))}">
          <td class="mini" style="white-space:normal;word-break:break-word;">${enc(staff || 'â€”')}</td>
          <td class="mini" style="white-space:normal;word-break:break-word;">${enc(unit || 'â€”')}</td>
          <td class="mini">${enc(niceYmd(wd) || wd || 'â€”')}</td>
          <td class="mini" style="white-space:normal;word-break:break-word;">${enc(code || 'â€”')}</td>
          <td class="mini">${statusPill}</td>
          <td class="mini" style="white-space:normal;word-break:break-word;">${enc(String(reason || '').replace(/_/g,' '))}</td>
          <td>${btns}</td>
        </tr>
      `;
    }).join('');

    return html(`
      <div class="card" style="margin-top:10px;">
        <div class="mini" style="margin-bottom:8px;">
          Cannot validate yet â€” resolve these items then click <strong>Reclassify</strong>.
        </div>

        <div style="overflow:auto; border:1px solid var(--line); border-radius:10px;">
          <table class="grid" style="table-layout:auto; width:100%; min-width:1100px;">
            <thead>
              <tr>
                <th style="width:180px;">Staff</th>
                <th style="width:320px;">Unit / Site</th>
                <th style="width:140px;">Date</th>
                <th style="width:160px;">Grade / Code</th>
                <th style="width:240px;">Status</th>
                <th style="min-width:420px;">Reason</th>
                <th style="width:260px;">Resolve</th>
              </tr>
            </thead>
            <tbody>${rowsHtml}</tbody>
          </table>
        </div>

        <div class="hint" style="margin-top:8px;">
          Candidate mapping teaches the system which person a rota name refers to. Band mapping teaches which contracts/bands a Grade code should match.
        </div>
      </div>
    `);
  };

  // Helper: read explicit selection state (supports Set + Map)
  // Returns: true | false | null (null => not explicitly chosen yet)
  const getSelectionState = (k) => {
    if (!k) return null;
    if (selStore instanceof Map) {
      if (selStore.has(k)) return !!selStore.get(k);
      return null;
    }
    if (selStore instanceof Set) {
      // Set cannot represent explicit false; treat missing as null (so we can default)
      return selStore.has(k) ? true : null;
    }
    return null;
  };

  const getAltEmailValue = (k) => {
    if (!k) return '';
    if (altEmailMap instanceof Map && altEmailMap.has(k)) {
      return String(altEmailMap.get(k) || '').trim();
    }
    // Back-compat: some UIs may store this on ui.altEmail (plain object)
    try {
      const obj = (ui && ui.altEmail && typeof ui.altEmail === 'object') ? ui.altEmail : null;
      if (obj && Object.prototype.hasOwnProperty.call(obj, k)) {
        return String(obj[k] || '').trim();
      }
    } catch {}
    return '';
  };

  const groupsHtml = vg.length
    ? vg.map((g) => {
        const we = g?.week_ending_date || g?.weekEndingDate || null;
        const candName = String(g?.candidate_name || g?.candidateName || '').trim();

        const overall = g?.overall_status || g?.overallStatus || g?.status || 'UNKNOWN';
        const hasMismatch = (g?.has_mismatch === true) || (g?.hasMismatch === true);

        const failureReasons = g?.failure_reasons || g?.failureReasons || [];

        // Email controls (used for wiring only)
        const tsid = g?.timesheet_id || g?.timesheetId || null;
        const recip = String(g?.recipient_email || g?.recipientEmail || '').trim();
        const emailedAlready = (g?.emailed_already === true) || (g?.emailedAlready === true);
        const canEmail = (g?.can_email === true) || (g?.canEmail === true);
        const fp = String(g?.issue_fingerprint || g?.issueFingerprint || '').trim();

        const statusPill = `<span class="pill ${pillForStatus(overall)}" style="padding:2px 8px;">${enc(String(overall).toUpperCase())}</span>`;

        // Prefer comparisons[] from backend. Fallback to legacy days/pairings.
        const comparisonsNew = normaliseComparisons(g?.comparisons || g?.comparison_rows || g?.comparisonRows || []);
        const comparisonsFallback = (comparisonsNew.length === 0)
          ? flattenComparisonsFromDays(g?.days || [])
          : [];
        const comps = comparisonsNew.length ? comparisonsNew : comparisonsFallback;

        const compTable = (() => {
          if (!comps.length) {
            return html(`<div class="mini">No detailed comparisons returned for this candidate/week.</div>`);
          }

          const body = comps.map((c) => {
            const isMatch = (c.match === true);
            const icon = isMatch ? 'âœ…' : 'âŒ';

            const tsTxt = `${c.timesheet_start || 'â€”'} â†’ ${c.timesheet_end || 'â€”'} (break ${c.timesheet_break_mins == null ? 'â€”' : c.timesheet_break_mins})`;
            const hrTxt = `${c.healthroster_start || 'â€”'} â†’ ${c.healthroster_end || 'â€”'} (break ${c.healthroster_break_mins == null ? 'â€”' : c.healthroster_break_mins})`;

            const isDestructive = (c.is_destructive_invalidation === true);
            const invoiceLocked = (c.invoice_locked === true);

            const ck = String(c.comparison_key || '').trim();
            const invKey = (tsid && ck) ? invKeyFor(tsid, ck) : '';
            const invChecked = invKey ? (invMap.has(invKey) ? (invMap.get(invKey) === true) : true) : true;

            const showInvalidateCheckbox = !!(isDestructive && !invoiceLocked && tsid && ck);

            const rowStyle = isDestructive
              ? 'background:rgba(255,0,0,0.06);'
              : '';

            const cbHtml = showInvalidateCheckbox
              ? `<label class="inline mini" style="gap:6px; white-space:nowrap;">
                   <input type="checkbox"
                          data-act="hr-weekly-val-invalidate-toggle"
                          data-timesheet-id="${enc(String(tsid || ''))}"
                          data-comparison-key="${enc(String(ck || ''))}"
                          ${invChecked ? 'checked' : ''}/>
                   <span class="mini">Invalidate</span>
                 </label>`
              : (invoiceLocked && isDestructive
                  ? `<span class="mini" title="Invoice locked: informative only">â€”</span>`
                  : `<span class="mini">â€”</span>`);

            return html(`
              <tr style="${rowStyle}">
                <td class="mini" style="width:90px; text-align:center;">${cbHtml}</td>
                <td class="mini" style="width:80px; text-align:center;">${enc(icon)}</td>
                <td class="mini" style="width:140px;">${enc(niceYmd(c.work_date) || c.work_date || 'â€”')}</td>
                <td class="mini" style="white-space:normal;word-break:break-word;">${enc(tsTxt)}</td>
                <td class="mini" style="white-space:normal;word-break:break-word;">${enc(hrTxt)}</td>
              </tr>
            `);
          }).join('');

          return html(`
            <div style="overflow:auto; border:1px solid var(--line); border-radius:10px;">
              <table class="grid" style="table-layout:auto; width:100%; min-width:980px;">
                <thead>
                  <tr>
                    <th style="width:90px;">Invalidate</th>
                    <th style="width:80px;">Match</th>
                    <th style="width:140px;">Date</th>
                    <th>Timesheet start/finish/break</th>
                    <th>HealthRoster start/finish/break</th>
                  </tr>
                </thead>
                <tbody>${body}</tbody>
              </table>
            </div>
            <div class="hint" style="margin-top:6px;">
              Red rows with â€œInvalidateâ€ will remove previously stored reference numbers for missing shifts when you finalise.
              Invoice-locked rows are informative only.
            </div>
          `);
        })();

        // Email block:
        // - Always show Alternative Email textbox when mismatch exists
        // - Checkbox is selection-driven and defaults:
        //     - first-time email: checked
        //     - re-email: unchecked
        //   but explicit user toggle overrides both
        const emailBlock = (() => {
          if (!hasMismatch) return '';

          const hasKeyInputs = !!(String(tsid || '').trim() && String(fp || '').trim());
          const k = hasKeyInputs ? keyFor(tsid, fp) : '';

          const altVal = (k ? getAltEmailValue(k) : '');

          const explicit = k ? getSelectionState(k) : null;

          const checked = (() => {
            if (!k) return '';
            if (explicit === true) return 'checked';
            if (explicit === false) return '';
            if (emailedAlready) return '';
            return 'checked';
          })();

          const label = emailedAlready ? 'Re-email Temporary Staffing' : 'Email Temporary Staffing';

          const recipientDisplay = String(recip || '').trim() ? recip : 'â€”';

          // Explainability: when can_email=false OR default recipient missing, alt email is required to send.
          const needsAlt =
            (canEmail !== true) || (!String(recip || '').trim());

          const why =
            !tsid ? 'Email unavailable (timesheet missing).' :
            !String(fp || '').trim() ? 'Email unavailable (issue fingerprint missing).' :
            (needsAlt ? 'Default recipient not available; enter Alternative Email to send.' : 'Email available.');

          const showWhy = !!needsAlt;

          const altId = `hrAltEmail_${impId}_${String(tsid || '').slice(0,8)}_${Math.random().toString(36).slice(2)}`;

          return html(`
            <div class="mini" style="margin-top:10px;">
              <div style="display:flex; flex-wrap:wrap; gap:10px; align-items:center;">
                <label class="inline mini" style="gap:6px; margin-right:6px;">
                  <input type="checkbox"
                         data-act="hr-weekly-val-email-toggle"
                         data-timesheet-id="${enc(String(tsid || ''))}"
                         data-issue-fingerprint="${enc(String(fp || ''))}"
                         ${checked}
                         ${hasKeyInputs ? '' : 'disabled'}/>
                  <span>${enc(label)}</span>
                </label>

                <span class="mini" style="margin-left:0;">
                  Recipient: <span class="mono">${enc(recipientDisplay)}</span>
                  ${emailedAlready ? ` &nbsp;â€¢&nbsp; <span class="pill pill-warn" style="padding:2px 8px;">Emailed already</span>` : ''}
                </span>

                <span class="mini" style="margin-left:0;">
                  &nbsp;â€¢&nbsp; Alternative Email:
                  <input
                    id="${enc(altId)}"
                    type="email"
                    class="input"
                    placeholder="name@example.com"
                    value="${enc(altVal)}"
                    style="min-width:260px; margin-left:6px;"
                    data-act="hr-weekly-val-alt-email"
                    data-timesheet-id="${enc(String(tsid || ''))}"
                    data-issue-fingerprint="${enc(String(fp || ''))}"
                  />
                </span>
              </div>

              ${showWhy ? html(`
                <div class="mini" style="margin-top:6px; opacity:.85;">
                  ${enc(why)}
                </div>
              `) : ''}
            </div>
          `);
        })();

        return html(`
          <details style="margin:8px 0;">
            <summary style="cursor:pointer;">
              <span class="mini">${statusPill}</span>
              <span class="mini" style="margin-left:8px;">
                ${enc(candName || 'Unknown candidate')}
                ${we ? ` â€¢ W/E ${enc(niceYmd(we))}` : ''}
                ${hasMismatch ? ` â€¢ ${enc('Mismatch')}` : ''}
              </span>
            </summary>

            <div style="margin-top:8px; padding-left:10px;">
              ${Array.isArray(failureReasons) && failureReasons.length
                ? html(`
                    <div class="mini" style="margin-bottom:6px;">Notes</div>
                    <ul class="mini" style="margin:0; padding-left:18px;">
                      ${failureReasons.filter(Boolean).map(r => html(`<li>${enc(String(r))}</li>`)).join('')}
                    </ul>
                  `)
                : html(`<div class="mini" style="margin-bottom:6px;">No mismatch notes.</div>`)
              }

              <div style="margin-top:10px;">
                ${compTable}
              </div>

              ${emailBlock}
            </div>
          </details>
        `);
      }).join('')
    : html(`<div class="mini">No validation groups were returned by the preview.</div>`);

  const headerTitle = (() => {
    if (mode === 'MIXED') return 'HealthRoster hours check + apply actions';
    return 'HealthRoster hours check';
  })();

  const headerBlurb =
    'This screen shows mismatches and allows optional emails to Temporary Staffing with a copy of the candidate timesheet to request hours are amended.';

  const finaliseLabel = (mode === 'MIXED')
    ? 'Finalise (apply actions + emails)'
    : 'Finalise validations';

  return html(`
    <div id="hrWeeklyValidationSummary" data-import-id="${enc(impId)}" data-mode="${enc(mode)}">
      <div class="card">
        <div class="row">
          <label>${enc(headerTitle)}</label>
          <div class="controls">
            <div class="mini">
              Import ID: <span class="mono">${enc(impId || 'â€”')}</span><br/>
              Validation groups: <span class="mono">${enc(String(vg.length))}</span>
            </div>
            <div class="hint" style="margin-top:8px;">
              ${enc(headerBlurb)}
            </div>
          </div>
        </div>
      </div>

      <div class="card" style="margin-top:10px;">
        <div class="row">
          <label>Groups</label>
          <div class="controls">
            ${groupsHtml}
          </div>
        </div>
      </div>

      ${unresolvedTableFullWidth()}

      <div class="row" style="margin-top:10px;">
        <label></label>
        <div class="controls">
          <button type="button" class="btn" data-act="hr-weekly-val-reclassify">Reclassify</button>
          <button type="button" class="btn btn-primary" style="margin-left:8px;" data-act="hr-weekly-val-finalise">${enc(finaliseLabel)}</button>
          <span class="mini" style="margin-left:8px;">
            Reclassify refreshes validation after mapping changes. Finalise sends selected emails (and applies actions if mixed).
          </span>
        </div>
      </div>
    </div>
  `);
}

function ensureWeeklyUiStore(type, importId, previewState) {
  const T = String(type || '').trim().toUpperCase();
  const impId = String(importId || '').trim();
  const p = (previewState && typeof previewState === 'object' && !Array.isArray(previewState)) ? previewState : {};

  // Be safe in the browser: never hard-throw in UI init paths
  if (!impId) {
    console.warn('ensureWeeklyUiStore: importId is required');
    return null;
  }
  if (T !== 'HR_WEEKLY' && T !== 'NHSP') {
    console.warn(`ensureWeeklyUiStore: unsupported type ${T}`);
    return null;
  }

  const asYmd = (v) => {
    if (!v) return null;
    if (typeof v === 'string') {
      const s = v.trim();
      if (/^\d{4}-\d{2}-\d{2}$/.test(s)) return s;
      if (s.length >= 10 && /^\d{4}-\d{2}-\d{2}/.test(s)) return s.slice(0, 10);
    }
    try {
      const d = new Date(v);
      if (Number.isNaN(d.getTime())) return null;
      const yyyy = d.getUTCFullYear();
      const mm   = String(d.getUTCMonth() + 1).padStart(2, '0');
      const dd   = String(d.getUTCDate()).padStart(2, '0');
      return `${yyyy}-${mm}-${dd}`;
    } catch {
      return null;
    }
  };

  // Root stores
  window.__weeklyImportUi = window.__weeklyImportUi || {};
  window.__weeklyImportUi[T] = window.__weeklyImportUi[T] || {};

  // If already exists, normalize missing fields (DO NOT clobber existing object)
  let ui = window.__weeklyImportUi[T][impId];
  if (!ui || typeof ui !== 'object' || Array.isArray(ui)) {
    ui = {};
    window.__weeklyImportUi[T][impId] = ui;
  }

  // Helpers
  const ensureSet = (v) => (v instanceof Set ? v : new Set());
  const ensureMap = (v) => (v instanceof Map ? v : new Map());

  // Derive forced date range: file min/max first, then actions fallback (rare)
  const sum = (p.summary && typeof p.summary === 'object' && !Array.isArray(p.summary)) ? p.summary : {};
  const truth =
    (p.truth_meta && typeof p.truth_meta === 'object' && !Array.isArray(p.truth_meta)) ? p.truth_meta :
    (sum.truth_meta && typeof sum.truth_meta === 'object' && !Array.isArray(sum.truth_meta)) ? sum.truth_meta :
    null;

  const fileMin = asYmd(truth?.file_date_min ?? truth?.fileDateMin ?? null);
  const fileMax = asYmd(truth?.file_date_max ?? truth?.fileDateMax ?? null);

  const actions = Array.isArray(p.actions) ? p.actions : (Array.isArray(sum.actions) ? sum.actions : []);
  let actMin = null;
  let actMax = null;
  for (const a of actions) {
    const wd = asYmd(a?.work_date || a?.workDate || a?.date_local || a?.date || a?.week_ending_date || null);
    if (!wd) continue;
    if (!actMin || wd < actMin) actMin = wd;
    if (!actMax || wd > actMax) actMax = wd;
  }

  const forcedFrom = fileMin || actMin || null;
  const forcedTo   = fileMax || actMax || null;

  // Options (shared)
  if (!ui.options || typeof ui.options !== 'object' || Array.isArray(ui.options)) ui.options = {};

  // âœ… Forced behaviour for BOTH NHSP and HR_WEEKLY (no options modal anymore)
  ui.options.missingShiftsEnabled = true;

  // Only set forced dates when we actually have them (avoid wiping a previously seeded value)
  if (forcedFrom) ui.options.dateFrom = forcedFrom;
  if (forcedTo)   ui.options.dateTo = forcedTo;

  // Ensure keys exist even if null
  if (!('dateFrom' in ui.options)) ui.options.dateFrom = null;
  if (!('dateTo' in ui.options)) ui.options.dateTo = null;

  // Normalise / repair inverted ranges
  const df0 = asYmd(ui.options.dateFrom);
  const dt0 = asYmd(ui.options.dateTo);
  if (df0 && dt0 && df0 > dt0) {
    // Prefer forced range if available; otherwise swap
    if (forcedFrom && forcedTo) {
      ui.options.dateFrom = forcedFrom;
      ui.options.dateTo = forcedTo;
    } else {
      ui.options.dateFrom = dt0;
      ui.options.dateTo = df0;
    }
  } else {
    ui.options.dateFrom = df0 || ui.options.dateFrom;
    ui.options.dateTo = dt0 || ui.options.dateTo;
  }

  // Selections (shared)
  ui.actionSelection = ensureSet(ui.actionSelection);

  // emailSelection:
  // - HR_WEEKLY validation requires Map(key -> boolean) so explicit untick survives
  // - NHSP keeps legacy Set
  if (T === 'HR_WEEKLY') {
    if (ui.emailSelection instanceof Set) {
      const m = new Map();
      for (const k of Array.from(ui.emailSelection)) {
        const kk = String(k || '').trim();
        if (kk) m.set(kk, true);
      }
      ui.emailSelection = m;
    }
    if (!(ui.emailSelection instanceof Map)) ui.emailSelection = new Map();
  } else {
    if (!(ui.emailSelection instanceof Set)) ui.emailSelection = new Set();
  }

  // invalidationSelection: Map `${timesheet_id}|${comparison_key}` -> boolean
  ui.invalidationSelection = ensureMap(ui.invalidationSelection);

  // altEmailByKey: Map `${timesheet_id}|${issue_fingerprint}` -> string
  ui.altEmailByKey = ensureMap(ui.altEmailByKey);

  // Filters (shared)
  if (!ui.filters || typeof ui.filters !== 'object' || Array.isArray(ui.filters)) ui.filters = {};
  if (typeof ui.filters.showOnlyRed !== 'boolean') ui.filters.showOnlyRed = false;
  if (typeof ui.filters.showOnlyUnticked !== 'boolean') ui.filters.showOnlyUnticked = false;
  if (typeof ui.filters.showOnlyCancellations !== 'boolean') ui.filters.showOnlyCancellations = false;
  if (typeof ui.filters.search !== 'string') ui.filters.search = '';

  // Hydration flags (shared)
  if (!ui.hydratedFlags || typeof ui.hydratedFlags !== 'object' || Array.isArray(ui.hydratedFlags)) ui.hydratedFlags = {};
  if (typeof ui.hydratedFlags.didInitDefaultActionChecks !== 'boolean') ui.hydratedFlags.didInitDefaultActionChecks = false;
  if (typeof ui.hydratedFlags.didInitDefaultEmailChecks !== 'boolean') ui.hydratedFlags.didInitDefaultEmailChecks = false;
  if (typeof ui.hydratedFlags.didInitDefaultInvalidationChecks !== 'boolean') ui.hydratedFlags.didInitDefaultInvalidationChecks = false;

  // Optional lightweight preview meta (safe)
  try {
    ui.previewMeta = (ui.previewMeta && typeof ui.previewMeta === 'object' && !Array.isArray(ui.previewMeta)) ? ui.previewMeta : {};
    if (typeof ui.previewMeta.mode_summary !== 'string') {
      ui.previewMeta.mode_summary = String(p.mode_summary || p.modeSummary || sum.mode_summary || sum.modeSummary || '').trim();
    }
    if (typeof ui.previewMeta.client_id !== 'string') {
      ui.previewMeta.client_id = String(p.client_id || sum.client_id || truth?.client_id || '').trim();
    }
    if (!('file_date_min' in ui.previewMeta)) ui.previewMeta.file_date_min = truth?.file_date_min ?? truth?.fileDateMin ?? null;
    if (!('file_date_max' in ui.previewMeta)) ui.previewMeta.file_date_max = truth?.file_date_max ?? truth?.fileDateMax ?? null;
  } catch {
    // ignore
  }

  window.__weeklyImportUi[T][impId] = ui;
  return ui;
}

function wireHrWeeklyValidationSummaryActions(type, importId) {
  const T = String(type || '').toUpperCase();
  const impId = String(importId || '').trim();
  if (T !== 'HR_WEEKLY') return;
  if (!impId) return;

  setTimeout(() => {
    try {
      const root = document.getElementById('modalBody');
      if (!root) return;

      root.__hrWeeklyValSummaryWired = root.__hrWeeklyValSummaryWired || new Set();
      const wiredKey = `hr-weekly-val-summary:${impId}`;
      if (root.__hrWeeklyValSummaryWired.has(wiredKey)) return;
      root.__hrWeeklyValSummaryWired.add(wiredKey);

      const ensureUi = () => {
        window.__weeklyImportUi = window.__weeklyImportUi || {};
        window.__weeklyImportUi.HR_WEEKLY = window.__weeklyImportUi.HR_WEEKLY || {};

        let ui = window.__weeklyImportUi.HR_WEEKLY[impId] || null;

        if (!ui && typeof ensureWeeklyUiStore === 'function') {
          try {
            const p0 = (window.__importSummaryState && window.__importSummaryState.HR_WEEKLY)
              ? window.__importSummaryState.HR_WEEKLY
              : null;
            ensureWeeklyUiStore('HR_WEEKLY', impId, p0 || {});
          } catch {}
          ui = window.__weeklyImportUi.HR_WEEKLY[impId] || null;
        }

        if (!ui || typeof ui !== 'object') {
          ui = {
            options: { missingShiftsEnabled: true, dateFrom: null, dateTo: null },
            actionSelection: new Set(),

            // âœ… Map supports explicit untick (key -> boolean)
            emailSelection: new Map(),

            // existing
            invalidationSelection: new Map(), // key: `${timesheet_id}|${comparison_key}` -> boolean

            // âœ… Alternative Email per email key (`${timesheet_id}|${issue_fingerprint}`)
            altEmailByKey: new Map(),

            filters: { showOnlyRed: false, showOnlyUnticked: false, showOnlyCancellations: false, search: '' },
            hydratedFlags: { didInitDefaultActionChecks: true, didInitDefaultEmailChecks: false, didInitDefaultInvalidationChecks: false }
          };
          window.__weeklyImportUi.HR_WEEKLY[impId] = ui;
        }

        if (!(ui.actionSelection instanceof Set)) ui.actionSelection = new Set();

        // Back-compat: convert Set -> Map(true)
        if (ui.emailSelection instanceof Set) {
          const m = new Map();
          for (const k of Array.from(ui.emailSelection)) {
            const kk = String(k || '').trim();
            if (kk) m.set(kk, true);
          }
          ui.emailSelection = m;
        }
        if (!(ui.emailSelection instanceof Map)) ui.emailSelection = new Map();

        if (!(ui.invalidationSelection instanceof Map)) ui.invalidationSelection = new Map();
        if (!(ui.altEmailByKey instanceof Map)) ui.altEmailByKey = new Map();

        if (!ui.hydratedFlags || typeof ui.hydratedFlags !== 'object') ui.hydratedFlags = {};
        if (typeof ui.hydratedFlags.didInitDefaultEmailChecks !== 'boolean') ui.hydratedFlags.didInitDefaultEmailChecks = false;
        if (typeof ui.hydratedFlags.didInitDefaultInvalidationChecks !== 'boolean') ui.hydratedFlags.didInitDefaultInvalidationChecks = false;

        if (!ui.options || typeof ui.options !== 'object') ui.options = {};
        // âœ… Forced behaviour (no options modal)
        ui.options.missingShiftsEnabled = true;

        window.__weeklyImportUi.HR_WEEKLY[impId] = ui;
        return ui;
      };

      const getPreview = () => {
        const p0 = (window.__importSummaryState && window.__importSummaryState.HR_WEEKLY)
          ? window.__importSummaryState.HR_WEEKLY
          : null;
        return (p0 && typeof p0 === 'object') ? p0 : {};
      };

      const getMode = (p0) => {
        const sum0 = (p0 && p0.summary && typeof p0.summary === 'object') ? p0.summary : {};
        const raw = (p0 && (p0.mode_summary || p0.modeSummary)) || sum0.mode_summary || sum0.modeSummary || '';
        const ms = String(raw || '').trim().toUpperCase();
        if (ms === 'MODE_A_ONLY' || ms === 'MODE_B_ONLY' || ms === 'MIXED') return ms;

        const vgN = Array.isArray(p0?.validation_groups) ? p0.validation_groups.length : 0;
        const agN = Array.isArray(p0?.action_groups) ? p0.action_groups.length : 0;
        const aN  = Array.isArray(p0?.actions) ? p0.actions.length : 0;
        if (vgN > 0 && (agN > 0 || aN > 0)) return 'MIXED';
        if (vgN > 0) return 'MODE_A_ONLY';
        if (agN > 0 || aN > 0) return 'MODE_B_ONLY';
        return 'MODE_A_ONLY';
      };

      const parseEmailKey = (k) => {
        const s = String(k || '');
        const i = s.indexOf('|');
        if (i <= 0) return null;
        const ts = s.slice(0, i).trim();
        const fp = s.slice(i + 1).trim();
        if (!ts || !fp) return null;
        return { ts, fp };
      };

      const buildDefaultRecipientByKey = (p0) => {
        const out = new Map();
        const vg0 = Array.isArray(p0?.validation_groups) ? p0.validation_groups : [];
        for (const g of vg0) {
          const tsid = g?.timesheet_id || g?.timesheetId || null;
          const fp = String(g?.issue_fingerprint || g?.issueFingerprint || '').trim();
          if (!tsid || !fp) continue;
          const k = `${String(tsid).trim()}|${fp}`;
          const recip = String(g?.recipient_email || g?.recipientEmail || '').trim();
          const canEmail = (g?.can_email === true) || (g?.canEmail === true);
          out.set(k, { recipient_email: recip, can_email: !!canEmail });
        }
        return out;
      };

      const buildEmailActions = () => {
        const ui = ensureUi();
        const selMap = (ui && ui.emailSelection instanceof Map) ? ui.emailSelection : new Map();
        const altMap = (ui && ui.altEmailByKey instanceof Map) ? ui.altEmailByKey : new Map();

        const out = [];
        for (const [k, v] of selMap.entries()) {
          if (v !== true) continue;
          const it = parseEmailKey(k);
          if (!it) continue;

          const alt = String(altMap.get(k) || '').trim();
          out.push({
            timesheet_id: it.ts,
            issue_fingerprint: it.fp,
            alt_email: alt || null
          });
        }
        return out;
      };

      const buildInvalidationActions = () => {
        const ui = ensureUi();
        const m = (ui && ui.invalidationSelection instanceof Map) ? ui.invalidationSelection : new Map();
        const out = [];
        for (const [k, v] of m.entries()) {
          const s = String(k || '');
          const i = s.indexOf('|');
          if (i <= 0) continue;
          const tsid = s.slice(0, i).trim();
          const ckey = s.slice(i + 1).trim();
          if (!tsid || !ckey) continue;
          out.push({ timesheet_id: tsid, comparison_key: ckey, invalidate: (v === true) });
        }
        return out;
      };

      const hydrateDefaultsOnce = () => {
        const ui = ensureUi();
        const p0 = getPreview();
        const vg0 = Array.isArray(p0?.validation_groups) ? p0.validation_groups : [];

        if (ui.hydratedFlags.didInitDefaultEmailChecks !== true) {
          for (const g of vg0) {
            const hasMismatch = (g?.has_mismatch === true) || (g?.hasMismatch === true);
            const tsid = g?.timesheet_id || g?.timesheetId || null;
            const fp = String(g?.issue_fingerprint || g?.issueFingerprint || '').trim();
            if (!hasMismatch) continue;
            if (!tsid || !fp) continue;

            const k = `${String(tsid).trim()}|${fp}`;
            if (ui.emailSelection instanceof Map && ui.emailSelection.has(k)) continue;

            const emailedAlready = (g?.emailed_already === true) || (g?.emailedAlready === true);
            ui.emailSelection.set(k, emailedAlready ? false : true);
          }
          ui.hydratedFlags.didInitDefaultEmailChecks = true;
        }

        if (ui.hydratedFlags.didInitDefaultInvalidationChecks !== true) {
          for (const g of vg0) {
            const tsid = g?.timesheet_id || g?.timesheetId || null;
            if (!tsid) continue;

            const comps = Array.isArray(g?.comparisons) ? g.comparisons
              : (Array.isArray(g?.comparison_rows) ? g.comparison_rows : []);
            for (const c of comps) {
              const isDestr =
                (c?.is_destructive_invalidation === true) ||
                (c?.isDestructiveInvalidation === true) ||
                (c?.is_destructive_invalidation === 'true');
              if (!isDestr) continue;

              const invoiceLocked =
                (c?.invoice_locked === true) ||
                (c?.invoiceLocked === true) ||
                (String(c?.invoice_locked_invoice_id || c?.invoiceLockedInvoiceId || '').trim().length > 0);
              if (invoiceLocked) continue;

              const ck = String(c?.comparison_key || c?.comparisonKey || '').trim();
              if (!ck) continue;

              const key = `${String(tsid).trim()}|${ck}`;
              if (!ui.invalidationSelection.has(key)) {
                ui.invalidationSelection.set(key, true);
              }
            }
          }
          ui.hydratedFlags.didInitDefaultInvalidationChecks = true;
        }

        window.__weeklyImportUi.HR_WEEKLY[impId] = ui;
      };

      hydrateDefaultsOnce();

      root.addEventListener('input', (ev) => {
        const container = ev.target && ev.target.closest ? ev.target.closest('#hrWeeklyValidationSummary') : null;
        if (!container) return;

        const containerImp = String(container.getAttribute('data-import-id') || '').trim();
        if (containerImp && containerImp !== impId) return;

        const altIn = ev.target && ev.target.closest
          ? ev.target.closest('input[data-act="hr-weekly-val-alt-email"]')
          : null;

        if (!altIn) return;

        const tsid = String(altIn.getAttribute('data-timesheet-id') || '').trim();
        const fp   = String(altIn.getAttribute('data-issue-fingerprint') || '').trim();
        if (!tsid || !fp) return;

        const key = `${tsid}|${fp}`;
        const ui = ensureUi();

        const v = String(altIn.value || '').trim();
        if (v) ui.altEmailByKey.set(key, v);
        else ui.altEmailByKey.delete(key);

        window.__weeklyImportUi.HR_WEEKLY[impId] = ui;
      }, true);

      root.addEventListener('change', (ev) => {
        const container = ev.target && ev.target.closest ? ev.target.closest('#hrWeeklyValidationSummary') : null;
        if (!container) return;

        const containerImp = String(container.getAttribute('data-import-id') || '').trim();
        if (containerImp && containerImp !== impId) return;

        const cbEmail = ev.target && ev.target.closest
          ? ev.target.closest('input[data-act="hr-weekly-val-email-toggle"]')
          : null;
        if (cbEmail) {
          const tsid = String(cbEmail.getAttribute('data-timesheet-id') || '').trim();
          const fp   = String(cbEmail.getAttribute('data-issue-fingerprint') || '').trim();
          if (!tsid || !fp) return;

          const ui = ensureUi();
          const key = `${tsid}|${fp}`;
          ui.emailSelection.set(key, !!cbEmail.checked);

          window.__weeklyImportUi.HR_WEEKLY[impId] = ui;
          return;
        }

        const cbInv = ev.target && ev.target.closest
          ? ev.target.closest('input[data-act="hr-weekly-val-invalidate-toggle"]')
          : null;
        if (cbInv) {
          const tsid = String(cbInv.getAttribute('data-timesheet-id') || '').trim();
          const ck   = String(cbInv.getAttribute('data-comparison-key') || '').trim();
          if (!tsid || !ck) return;

          const ui = ensureUi();
          const key = `${tsid}|${ck}`;
          ui.invalidationSelection.set(key, !!cbInv.checked);

          window.__weeklyImportUi.HR_WEEKLY[impId] = ui;
          return;
        }
      }, true);

      root.addEventListener('click', async (ev) => {
        const container = ev.target && ev.target.closest ? ev.target.closest('#hrWeeklyValidationSummary') : null;
        if (!container) return;

        const containerImp = String(container.getAttribute('data-import-id') || '').trim();
        if (containerImp && containerImp !== impId) return;

        const btn = ev.target && ev.target.closest ? ev.target.closest('button[data-act]') : null;
        if (!btn) return;

        const act = String(btn.getAttribute('data-act') || '').trim();

        if (act === 'hr-weekly-val-resolve-candidate') {
          try {
            const idxRaw = btn.getAttribute('data-row-idx');
            const idx = Number(idxRaw);
            if (!Number.isFinite(idx) || idx < 0) throw new Error('Invalid row index for Assign candidate.');
            if (typeof openWeeklyCandidateResolveModal !== 'function') throw new Error('openWeeklyCandidateResolveModal is not defined.');
            await openWeeklyCandidateResolveModal('HR_WEEKLY', impId, idx);
          } catch (e) {
            console.error('[IMPORTS][HR_WEEKLY][VAL] resolve-candidate failed', e);
            alert(e?.message || 'Assign candidate failed.');
          }
          return;
        }

        if (act === 'hr-weekly-val-fix-band') {
          try {
            const incoming_code = String(btn.getAttribute('data-incoming-code') || '').trim();
            const client_id_raw = String(btn.getAttribute('data-client-id') || '').trim();
            const cand_id_raw   = String(btn.getAttribute('data-candidate-id') || '').trim();
            const work_date_raw = String(btn.getAttribute('data-work-date') || '').trim();
            const we_raw        = String(btn.getAttribute('data-week-ending-date') || '').trim();

            if (!incoming_code) throw new Error('Missing incoming code for band resolver.');
            if (!client_id_raw) throw new Error('Missing client_id for band resolver.');

            if (typeof openHrWeeklyBandResolveModal !== 'function') {
              throw new Error('openHrWeeklyBandResolveModal is not defined.');
            }

            await openHrWeeklyBandResolveModal({
              import_id: impId,
              client_id: client_id_raw || null,
              candidate_id: cand_id_raw || null,
              incoming_code: incoming_code,
              work_date: work_date_raw || null,
              week_ending_date: we_raw || null
            });
          } catch (e) {
            console.error('[IMPORTS][HR_WEEKLY][VAL] fix-band failed', e);
            alert(e?.message || 'Fix band mapping failed.');
          }
          return;
        }

        if (act === 'hr-weekly-val-reclassify') {
          try {
            if (typeof refreshWeeklyImportSummary !== 'function') {
              throw new Error('refreshWeeklyImportSummary is not defined.');
            }
            await refreshWeeklyImportSummary('HR_WEEKLY', impId);
            hydrateDefaultsOnce();
          } catch (e) {
            console.error('[IMPORTS][HR_WEEKLY][VAL] reclassify failed', e);
            alert(e?.message || 'Reclassify failed.');
          }
          return;
        }

        if (act === 'hr-weekly-val-finalise') {
          try {
            const ok = window.confirm('Are you sure you want to finalise now?');
            if (!ok) return;

            if (typeof applyWeeklyImportTransactional !== 'function') {
              throw new Error('applyWeeklyImportTransactional is not defined.');
            }

            const ui = ensureUi();
            const p0 = getPreview();
            const mode0 = getMode(p0);

            const auto_apply_action_ids =
              Array.isArray(p0?.auto_apply_action_ids) ? p0.auto_apply_action_ids :
              Array.isArray(p0?.autoApplyActionIds) ? p0.autoApplyActionIds :
              (p0?.summary && Array.isArray(p0.summary.auto_apply_action_ids)) ? p0.summary.auto_apply_action_ids :
              [];

            const email_actions = buildEmailActions();
            const invalidation_actions = buildInvalidationActions();

            // âœ… Client-side enforcement for missing default recipient:
            {
              const byKey = buildDefaultRecipientByKey(p0);
              const bad = [];

              for (const a of (email_actions || [])) {
                const ts = String(a?.timesheet_id || '').trim();
                const fp = String(a?.issue_fingerprint || '').trim();
                if (!ts || !fp) continue;

                const k = `${ts}|${fp}`;
                const meta = byKey.get(k) || { recipient_email: '', can_email: false };

                const alt = String(a?.alt_email || '').trim();
                const recip = String(meta.recipient_email || '').trim();
                const canEmail = (meta.can_email === true);

                if (!canEmail) {
                  if (!alt) bad.push(k);
                  continue;
                }
                if (!recip && !alt) bad.push(k);
              }

              if (bad.length) {
                alert(
                  'Alternative Email is required for one or more selected emails (default recipient is unavailable).\n\n' +
                  'Please enter an Alternative Email for the selected group(s) before finalising.'
                );
                return;
              }
            }

            let selected_action_ids = [];
            let decisions = {};

            if (mode0 === 'MIXED') {
              const seen = new Set();
              const out = [];

              for (const v of Array.from(ui.actionSelection || [])) {
                const s = String(v || '').trim();
                if (!s || seen.has(s)) continue;
                seen.add(s);
                out.push(s);
              }
              for (const v of (auto_apply_action_ids || [])) {
                const s = String(v || '').trim();
                if (!s || seen.has(s)) continue;
                seen.add(s);
                out.push(s);
              }
              selected_action_ids = out;

              if (typeof getOrInitWeeklyImportDecisionsStore === 'function') {
                try {
                  const ds = getOrInitWeeklyImportDecisionsStore('HR_WEEKLY', impId, p0);
                  if (ds && typeof ds.serialize === 'function') {
                    decisions = ds.serialize(p0) || {};
                  }
                } catch {
                  decisions = {};
                }
              }
            } else {
              selected_action_ids = [];
              decisions = {};
            }

            // âœ… always pass file_date_min/max from canonical preview truth_meta
            const tm =
              (p0 && typeof p0.truth_meta === 'object' && p0.truth_meta) ? p0.truth_meta :
              (p0 && p0.summary && typeof p0.summary.truth_meta === 'object' && p0.summary.truth_meta) ? p0.summary.truth_meta :
              null;

            const file_date_min =
              tm ? (tm.file_date_min ?? tm.fileDateMin ?? null) : null;
            const file_date_max =
              tm ? (tm.file_date_max ?? tm.fileDateMax ?? null) : null;

            const payload = {
              selected_action_ids,
              decisions,
              email_actions,
              invalidation_actions,
              include_missing_shifts: true
            };
            if (file_date_min) payload.file_date_min = String(file_date_min);
            if (file_date_max) payload.file_date_max = String(file_date_max);

            const result = await applyWeeklyImportTransactional('HR_WEEKLY', impId, payload) || {};

            // âœ… Finalised message (keep your existing behaviour)
            alert(`Import ${result.import_id || impId} has been finalised.`);

            // âœ… NEW: Optional QR reissue modal (post-apply)
            try {
              const candArr = Array.isArray(result?.qr_reissue_candidates) ? result.qr_reissue_candidates : [];

              if (candArr.length && typeof openHrWeeklyQrReissueSelectionModal === 'function') {
                const modalRes = await openHrWeeklyQrReissueSelectionModal(impId, candArr);

                if (modalRes && modalRes.confirmed === true) {
                  const ids = Array.isArray(modalRes.selected_timesheet_ids) ? modalRes.selected_timesheet_ids : [];

                  if (ids.length) {
                    if (typeof postHrWeeklyQrReissueBatch !== 'function') {
                      throw new Error('postHrWeeklyQrReissueBatch is not defined.');
                    }

                    const reissueRes = await postHrWeeklyQrReissueBatch(ids);

                    const okN = Number(reissueRes?.ok_count ?? 0) || 0;
                    const failN = Number(reissueRes?.fail_count ?? 0) || 0;

                    const msg =
                      failN > 0
                        ? `QR reissue complete: ${okN} succeeded, ${failN} failed.`
                        : `QR reissue complete: ${okN} succeeded.`;

                    if (window.__toast) window.__toast(msg);
                    else alert(msg);
                  }
                }
              }
            } catch (e) {
              console.warn('[IMPORTS][HR_WEEKLY][VAL] QR reissue flow failed (non-fatal)', e);
              if (window.__toast) window.__toast('QR reissue flow failed (non-fatal).');
            }

            // Refresh summary after finalise + optional reissue
            if (typeof refreshWeeklyImportSummary === 'function') {
              await refreshWeeklyImportSummary('HR_WEEKLY', impId);
            }
          } catch (e) {
            console.error('[IMPORTS][HR_WEEKLY][VAL] finalise failed', e);
            alert(e?.message || 'Finalise failed.');
          }
        }
      }, true);
    } catch (e) {
      console.warn('[IMPORTS][HR_WEEKLY][VAL] wiring failed (non-fatal)', e);
    }
  }, 0);
}


async function openHrWeeklyQrReissueSelectionModal(importId, qr_reissue_candidates) {
  const impId = String(importId || '').trim();
  const rowsIn = Array.isArray(qr_reissue_candidates) ? qr_reissue_candidates : [];
  const rows = rowsIn
    .map(r => (r && typeof r === 'object' ? r : null))
    .filter(Boolean);

  if (!impId) {
    return { confirmed: false, selected_timesheet_ids: [] };
  }

  if (!rows.length) {
    return { confirmed: false, selected_timesheet_ids: [] };
  }

  if (typeof showModal !== 'function') {
    // Hard fallback without modal stack (should never happen in your UI)
    const ids = rows.map(r => String(r.timesheet_id || '').trim()).filter(Boolean);
    return { confirmed: false, selected_timesheet_ids: ids };
  }

  const enc = (typeof escapeHtml === 'function')
    ? escapeHtml
    : (s) => String(s ?? '').replace(/[&<>"']/g, (c) => ({
        '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
      }[c]));

  const uniq = (arr) => {
    const out = [];
    const seen = new Set();
    for (const x of (Array.isArray(arr) ? arr : [])) {
      const s = String(x || '').trim();
      if (!s) continue;
      if (seen.has(s)) continue;
      seen.add(s);
      out.push(s);
    }
    return out;
  };

  const niceName = (r) => {
    const a = String(r?.candidate_name || r?.candidate || r?.candidate_display_name || '').trim();
    if (a) return a;
    return String(r?.candidate_id || '').trim() || 'Unknown';
  };

  const niceClient = (r) => {
    const a = String(r?.client_name || r?.client || '').trim();
    if (a) return a;
    return String(r?.client_id || '').trim() || 'â€”';
  };

  const we = (r) => {
    const s = String(r?.week_ending_date || r?.weekEndingDate || '').trim();
    return s ? s.slice(0, 10) : '';
  };

  const shortId = (id) => {
    const s = String(id || '').trim();
    if (!s) return '';
    return s.length > 10 ? `${s.slice(0, 8)}â€¦` : s;
  };

  // Default-ticked selection
  const allIds = uniq(rows.map(r => r?.timesheet_id));
  const selected = new Set(allIds);

  const kind = 'import-summary-hr-weekly-qr-reissue';

  const render = () => {
    const listHtml = rows.map((r) => {
      const tsid = String(r?.timesheet_id || '').trim();
      if (!tsid) return '';

      const checked = selected.has(tsid);
      return `
        <tr>
          <td class="mini" style="text-align:center;">
            <input type="checkbox" data-act="qr-reissue-toggle" data-timesheet-id="${enc(tsid)}" ${checked ? 'checked' : ''}/>
          </td>
          <td class="mini">${enc(niceName(r))}</td>
          <td class="mini">${enc(niceClient(r))}</td>
          <td class="mini" style="white-space:nowrap;">${enc(we(r) || 'â€”')}</td>
          <td class="mini mono" title="${enc(tsid)}" style="white-space:nowrap;">${enc(shortId(tsid))}</td>
        </tr>
      `;
    }).join('');

    const selectedCount = selected.size;

    return `
      <div id="hrWeeklyQrReissueModal" data-import-id="${enc(impId)}">
        <div class="card">
          <div class="row">
            <label>QR reissue</label>
            <div class="controls">
              <div class="mini" style="margin-bottom:8px;">
                Some QR timesheets were issued before booking reference numbers changed.
                You can optionally reissue new QR emails so candidates sign the updated copy.
              </div>

              <div class="mini" style="margin-bottom:8px;">
                Selected: <span class="mono" id="qrReissueSelectedCount">${enc(String(selectedCount))}</span> / ${enc(String(rows.length))}
              </div>

              <div style="overflow:auto; border:1px solid var(--line); border-radius:10px;">
                <table class="grid" style="table-layout:auto; width:100%; min-width:760px;">
                  <thead>
                    <tr>
                      <th style="width:44px;"></th>
                      <th>Candidate</th>
                      <th>Client</th>
                      <th style="width:130px;">W/E</th>
                      <th style="width:140px;">Timesheet</th>
                    </tr>
                  </thead>
                  <tbody>
                    ${listHtml || `<tr><td colspan="5"><span class="mini">No candidates to show.</span></td></tr>`}
                  </tbody>
                </table>
              </div>

              <div class="hint" style="margin-top:10px;">
                Only â€œissued but unsignedâ€ QR timesheets are shown here. Signed items are excluded.
              </div>

              <div style="display:flex; gap:10px; margin-top:12px; align-items:center;">
                <button type="button" class="btn" id="btnQrReissueSkip">Skip</button>
                <button type="button" class="btn btn-primary" id="btnQrReissueConfirm">Reissue selected</button>
                <span class="mini" id="qrReissueHint" style="margin-left:auto; opacity:.85;"></span>
              </div>
            </div>
          </div>
        </div>
      </div>
    `;
  };

  const closeTop = () => {
    try {
      const btn = document.getElementById('btnCloseModal');
      if (btn && typeof btn.click === 'function') { btn.click(); return; }
    } catch {}
    try { if (typeof closeModal === 'function') closeModal(); } catch {}
  };

  return await new Promise((resolve) => {
    let done = false;
    const finish = (res) => {
      if (done) return;
      done = true;
      resolve(res);
    };

    const onDismiss = () => finish({ confirmed: false, selected_timesheet_ids: [] });

    const renderTab = (key) => {
      if (key !== 'main') return '';
      return render();
    };

    showModal(
      'QR reissue (optional)',
      [{ key: 'main', label: 'Reissue' }],
      renderTab,
      null,
      true,
      null,
      {
        kind,
        noParentGate: true,
        showSave: false,
        showApply: false,
        stayOpenOnSave: false,
        onDismiss
      }
    );

    const wire = () => {
      const body = document.getElementById('modalBody');
      if (!body) return;

      const modalRoot = body.querySelector('#hrWeeklyQrReissueModal');
      if (!modalRoot) return;

      // Avoid double wiring
      if (modalRoot.__qrReissueWired) return;
      modalRoot.__qrReissueWired = true;

      const updateUi = () => {
        const cntEl = document.getElementById('qrReissueSelectedCount');
        if (cntEl) cntEl.textContent = String(selected.size);

        const hintEl = document.getElementById('qrReissueHint');
        if (hintEl) {
          hintEl.textContent = selected.size ? '' : 'Select at least one timesheet to reissue.';
        }

        const btnConfirm = document.getElementById('btnQrReissueConfirm');
        if (btnConfirm) btnConfirm.disabled = (selected.size === 0);
      };

      body.addEventListener('change', (ev) => {
        const cb = ev.target && ev.target.closest ? ev.target.closest('input[data-act="qr-reissue-toggle"]') : null;
        if (!cb) return;

        const tsid = String(cb.getAttribute('data-timesheet-id') || '').trim();
        if (!tsid) return;

        if (cb.checked) selected.add(tsid);
        else selected.delete(tsid);

        updateUi();
      }, true);

      const btnSkip = body.querySelector('#btnQrReissueSkip');
      if (btnSkip && !btnSkip.__wired) {
        btnSkip.__wired = true;
        btnSkip.onclick = () => {
          closeTop();
          finish({ confirmed: false, selected_timesheet_ids: [] });
        };
      }

      const btnConfirm = body.querySelector('#btnQrReissueConfirm');
      if (btnConfirm && !btnConfirm.__wired) {
        btnConfirm.__wired = true;
        btnConfirm.onclick = () => {
          const ids = uniq(Array.from(selected));
          closeTop();
          finish({ confirmed: true, selected_timesheet_ids: ids });
        };
      }

      updateUi();
    };

    try { requestAnimationFrame(() => requestAnimationFrame(wire)); }
    catch { setTimeout(wire, 0); }
  });
}


async function postHrWeeklyQrReissueBatch(timesheetIds) {
  if (typeof authFetch !== 'function' || typeof API !== 'function') {
    throw new Error('authFetch/API helper missing in postHrWeeklyQrReissueBatch.');
  }

  const uniqStrings = (arr) => {
    const out = [];
    const seen = new Set();
    for (const x of (Array.isArray(arr) ? arr : [])) {
      const s = String(x || '').trim();
      if (!s) continue;
      if (seen.has(s)) continue;
      seen.add(s);
      out.push(s);
    }
    return out;
  };

  const ids = uniqStrings(timesheetIds);
  if (!ids.length) {
    return { ok: true, requested_count: 0, ok_count: 0, fail_count: 0, results: [] };
  }

  const res = await authFetch(API('/api/healthroster/weekly/qr-reissue-batch'), {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify({ timesheet_ids: ids })
  });

  const text = await res.text().catch(() => '');

  if (!res.ok) {
    let msg = text || `QR reissue batch failed (${res.status})`;
    try {
      const j = text ? JSON.parse(text) : null;
      if (j && typeof j === 'object') {
        if (typeof j.message === 'string' && j.message.trim()) msg = j.message.trim();
        else if (typeof j.error === 'string' && j.error.trim()) msg = j.error.trim();
      }
    } catch {}
    throw new Error(msg);
  }

  try { return text ? JSON.parse(text) : {}; } catch { return {}; }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// NEW: ensurePickerDatasetPrimed(entity)  entity in {'candidates','clients'}
// - Ensures dataset snapshot is loaded, then applies pending deltas.
// - Safe to call before opening a picker.
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function ensurePickerDatasetPrimed(entity){
  const LOGC = (typeof window.__LOG_CONTRACTS === 'boolean') ? window.__LOG_CONTRACTS : false;
  window.__pickerData = window.__pickerData || { candidates:{ since:null, itemsById:{} }, clients:{ since:null, itemsById:{} } };
  const ds = window.__pickerData[entity] ||= { since:null, itemsById:{} };

  if (!ds._initStarted) {
    ds._initStarted = true;
    try {
      const url  = API(`/api/pickers/${entity}/snapshot`);
      const resp = await authFetch(url);
      const json = await resp.json();
      ds.itemsById = ds.itemsById || {};
      const arr = Array.isArray(json?.items) ? json.items : [];
      for (const it of arr) ds.itemsById[String(it.id)] = it;
      ds.since = json?.since ?? ds.since ?? null;
      if (LOGC) console.log('[PICKER][dataset snapshot]', { entity, count: arr.length, since: ds.since });
    } catch (e) {
      if (LOGC) console.warn('[PICKER][dataset snapshot] failed', e);
    }
  }

  try {
    if (ds.since != null) {
      const url  = API(`/api/pickers/${entity}/delta?since=${encodeURIComponent(ds.since)}`);
      const resp = await authFetch(url);
      if (resp && resp.ok) {
        const json = await resp.json();
        applyDatasetDelta(entity, json);
        if (LOGC) console.log('[PICKER][dataset delta]', { entity, added: json?.added?.length||0, updated: json?.updated?.length||0, removed: json?.removed?.length||0, since: json?.since });
      }
    }
  } catch (e) {
    if (LOGC) console.warn('[PICKER][dataset delta] failed', e);
  }
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// NEW: applyDatasetDelta(entity, delta)  // { added:[], updated:[], removed:[], since }
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function applyDatasetDelta(entity, delta){
  window.__pickerData = window.__pickerData || { candidates:{ since:null, itemsById:{} }, clients:{ since:null, itemsById:{} } };
  const ds = window.__pickerData[entity] ||= { since:null, itemsById:{} };
  ds.itemsById = ds.itemsById || {};

  // merge in additions
  for (const it of (delta?.added || [])) {
    ds.itemsById[String(it.id)] = it;
  }

  // shallow-merge updates into existing (preserve any fields not present in payload)
  for (const it of (delta?.updated || [])) {
    const k = String(it.id);
    ds.itemsById[k] = { ...(ds.itemsById[k] || {}), ...it };
  }

  // remove deleted ids
  for (const id of (delta?.removed || [])) {
    delete ds.itemsById[String(id)];
  }

  // advance since watermark
  if (delta?.since != null) ds.since = delta.since;
}
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// NEW: pickersLocalFilterAndSort(entity, ids, query, sortKey, sortDir)
// Uses dataset cache rows restricted to {ids}, filters locally and sorts.
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function pickersLocalFilterAndSort(entity, ids, query, sortKey, sortDir){
  window.__pickerData = window.__pickerData || { candidates:{ itemsById:{} }, clients:{ itemsById:{} } };
  const itemsById = (window.__pickerData[entity]||{}).itemsById || {};
  const norm = (s)=> (s||'').toString().toLowerCase();
  const toks = norm(query||'').split(/\s+/).filter(Boolean);

  // Accept either an array of IDs or an array of row objects
  const rows = (ids && ids.length && typeof ids[0] === 'object')
    ? ids.slice()
    : (ids || []).map(id => itemsById[String(id)]).filter(Boolean);

  if (typeof window.__LOG_CONTRACTS === 'boolean' ? window.__LOG_CONTRACTS : true) {
    console.log('[PLFS:entry]', { entity, q: query, toks, in: rows.length, sortKey, sortDir });
  }

  const scoreRow = (r) => {
    if (!toks.length) return 0;
    let nameScore = 0, extraScore = 0;
    let allNameTokensMatch = true;
    if (entity === 'candidates') {
      const first = norm(r.first_name), last = norm(r.last_name);
      const disp  = norm(r.display_name || `${r.first_name||''} ${r.last_name||''}`);
      const role  = norm(r.roles_display);
      const email = norm(r.email);
      toks.forEach(t=>{
        let matched=false;
        if (first.startsWith(t)) { nameScore+=6; matched=true; }
        if (last.startsWith(t))  { nameScore+=6; matched=true; }
        if (disp.includes(t))    { nameScore+=5; matched=true; }
        if (first===t||last===t) { nameScore+=8; matched=true; }
        if (!matched) allNameTokensMatch=false;
        if (role.includes(t))    extraScore+=2;
        if (email.includes(t))   extraScore+=1;
      });
    } else {
      const name  = norm(r.name);
      const email = norm(r.primary_invoice_email);
      toks.forEach(t=>{
        let matched=false;
        if (name.includes(t))    { nameScore+=6; matched=true; }
        if (!matched) allNameTokensMatch=false;
        if (email.includes(t))   extraScore+=1;
      });
    }
    if (!allNameTokensMatch) return 0;
    if (nameScore <= 0) return 0;
    return nameScore + extraScore;
  };

  if (!toks.length) {
    const cmpAlpha = (a,b) => {
      const av = (a?.[sortKey] ?? '').toString().toLowerCase();
      const bv = (b?.[sortKey] ?? '').toString().toLowerCase();
      if (av < bv) return (sortDir==='asc'? -1 : 1);
      if (av > bv) return (sortDir==='asc'? 1 : -1);
      return 0;
    };
    const out = rows.slice().sort(cmpAlpha);
    if (typeof window.__LOG_CONTRACTS === 'boolean' ? window.__LOG_CONTRACTS : true) {
      console.log('[PLFS:noquery]', { entity, out: out.length, sample: out.slice(0,6).map(r=> r.display_name||r.name) });
    }
    return out;
  }

  const withScore = rows.map(r => ({ r, s: scoreRow(r) })).filter(x => x.s > 0);
  withScore.sort((A,B) => {
    if (A.s !== B.s) return B.s - A.s;
    const av = (A.r?.[sortKey] ?? '').toString().toLowerCase();
    const bv = (B.r?.[sortKey] ?? '').toString().toLowerCase();
    if (av < bv) return (sortDir==='asc'? -1 : 1);
    if (av > bv) return (sortDir==='asc'? 1 : -1);
    return 0;
  });
  const out = withScore.map(x => x.r);
  if (typeof window.__LOG_CONTRACTS === 'boolean' ? window.__LOG_CONTRACTS : true) {
    console.log('[PLFS:out]', { entity, q: query, out: out.length, sample: out.slice(0,6).map(r=> r.display_name||r.name) });
  }
  return out;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// NEW: revalidateCandidateOnPick(id) / revalidateClientOnPick(id)
// Fetches current detail and refreshes dataset cache before accept
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function revalidateCandidateOnPick(id){
  const url  = API(`/api/candidates/${encodeURIComponent(id)}`);
  const resp = await authFetch(url);
  if (!resp || !resp.ok) throw new Error('Could not fetch candidate.');
  const r = await resp.json();
  window.__pickerData = window.__pickerData || { candidates:{ itemsById:{} } };
  const ds = window.__pickerData.candidates ||= { itemsById:{} };
  const proj = {
    id: r.id,
    display_name: r.display_name || `${r.first_name||''} ${r.last_name||''}`.trim(),
    first_name: r.first_name || '',
    last_name: r.last_name || '',
    email: r.email || '',
    roles_display: Array.isArray(r.roles)? formatRolesSummary(r.roles) : (r.role||''),
    active: r.active !== false
  };
  ds.itemsById[String(r.id)] = proj;
}

async function revalidateClientOnPick(id){
  const url  = API(`/api/clients/${encodeURIComponent(id)}`);
  const resp = await authFetch(url);
  if (!resp || !resp.ok) throw new Error('Could not fetch client.');
  const r = await resp.json();

  window.__pickerData = window.__pickerData || { clients:{ itemsById:{} } };
  const ds = (window.__pickerData.clients ||= { itemsById:{} });

  const cs = r.client_settings || {};

  const proj = {
    id:   r.id,
    name: r.name || '',
    primary_invoice_email: r.primary_invoice_email || '',
    active: r.active !== false,
    // Preserve flags used by the NHSP-only / HR-autoprocess filters
    is_nhsp:       !!(r.is_nhsp ?? cs.is_nhsp),
    autoprocess_hr: !!(r.autoprocess_hr ?? cs.autoprocess_hr)
  };

  ds.itemsById[String(r.id)] = proj;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// NEW: contractWeekCreateAdditional â€” POST /api/contract-weeks/:id/additional
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function contractWeekCreateAdditional(week_id) {
  const r = await authFetch(API(`/api/contract-weeks/${encodeURIComponent(String(week_id))}/additional`), {
    method: 'POST'
  });
  if (!r?.ok) throw new Error('Create additional sheet failed');
  return r.json();
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// (Optional UX) NEW: openCandidatePicker / openClientPicker
// Lightweight pickers that call onPick({id,label}) and close
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UPDATED: openCandidatePicker â€” delegated clicks + debounced live search with ranking
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UPDATED: openCandidatePicker(onPick)
// - Uses summary-membership cache (ids) âˆ© dataset cache (minimal rows)
// - Type-to-filter + header sort (Surname/First/Role/Email) locally
// - Revalidates on pick
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€









  // â”€â”€ Timesheets quick filters: Stage / Route / Scope / Flags â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (currentSection === 'timesheets') {
    const stFilters = window.__listState[currentSection].filters || {};
    window.__listState[currentSection].filters = stFilters;

    // Stage dropdown
    const stageLabel = document.createElement('span');
    stageLabel.className = 'mini';
    stageLabel.textContent = 'Stage:';
    const stageSel = document.createElement('select');

    const stageOpts = [
      ['ALL',              'All'],
      ['PAID',             'Paid'],
      ['INVOICED',         'Invoiced'],
      ['READY_FOR_INVOICE','Ready for invoice'],
      ['READY_FOR_HR',     'Ready for HR'],
      ['PENDING_AUTH',     'Awaiting auth'],
      ['NEEDS_ATTENTION',  'Needs attention']
    ];
    const stageCur = (stFilters.summary_stage || 'ALL').toUpperCase();
    stageOpts.forEach(([v, label]) => {
      const o = document.createElement('option');
      o.value = v;
      o.textContent = label;
      if (stageCur === v) o.selected = true;
      stageSel.appendChild(o);
    });
    stageSel.addEventListener('change', async () => {
      const val = stageSel.value;
      const curFilters = { ...(window.__listState[currentSection].filters || {}) };
      curFilters.summary_stage = val;
      window.__listState[currentSection].filters = curFilters;
      window.__listState[currentSection].page = 1;
      const data = await loadSection();
      renderSummary(data);
    });
    topControls.appendChild(stageLabel);
    topControls.appendChild(stageSel);

    // Route dropdown
    const routeLabel = document.createElement('span');
    routeLabel.className = 'mini';
    routeLabel.textContent = 'Route:';
    const routeSel = document.createElement('select');
    const routeOpts = [
      ['ALL',              'All'],
      ['DAILY_ELECTRONIC', 'Daily â€“ electronic'],
      ['DAILY_MANUAL',     'Daily â€“ manual'],
      ['WEEKLY_ELECTRONIC','Weekly â€“ electronic'],
      ['WEEKLY_MANUAL',    'Weekly â€“ manual'],
      ['WEEKLY_NHSP',      'Weekly â€“ NHSP'],
      ['WEEKLY_NHSP_ADJUSTMENT','Weekly â€“ NHSP adj']
    ];
    const routeCur = (stFilters.route_type || 'ALL').toUpperCase();
    routeOpts.forEach(([v, label]) => {
      const o = document.createElement('option');
      o.value = v;
      o.textContent = label;
      if (routeCur === v) o.selected = true;
      routeSel.appendChild(o);
    });
    routeSel.addEventListener('change', async () => {
      const val = routeSel.value;
      const curFilters = { ...(window.__listState[currentSection].filters || {}) };
      curFilters.route_type = val;
      window.__listState[currentSection].filters = curFilters;
      window.__listState[currentSection].page = 1;
      const data = await loadSection();
      renderSummary(data);
    });
    topControls.appendChild(routeLabel);
    topControls.appendChild(routeSel);

    // Scope dropdown (Both / Weekly / Daily)
    const scopeLabel = document.createElement('span');
    scopeLabel.className = 'mini';
    scopeLabel.textContent = 'Type:';
    const scopeSel = document.createElement('select');
    const scopeOpts = [
      ['ALL',    'Both'],
      ['WEEKLY', 'Weekly only'],
      ['DAILY',  'Daily only']
    ];
    const scopeCur = (stFilters.sheet_scope || 'ALL').toUpperCase();
    scopeOpts.forEach(([v, label]) => {
      const o = document.createElement('option');
      o.value = v;
      o.textContent = label;
      if (scopeCur === v) o.selected = true;
      scopeSel.appendChild(o);
    });
    scopeSel.addEventListener('change', async () => {
      const val = scopeSel.value;
      const curFilters = { ...(window.__listState[currentSection].filters || {}) };
      curFilters.sheet_scope = val;
      window.__listState[currentSection].filters = curFilters;
      window.__listState[currentSection].page = 1;
      const data = await loadSection();
      renderSummary(data);
    });
    topControls.appendChild(scopeLabel);
    topControls.appendChild(scopeSel);

    // Flags: adjusted / QR / needs attention
    const mkFlag = (name, label) => {
      const wrap = document.createElement('label');
      wrap.className = 'mini';
      wrap.style.display = 'flex';
      wrap.style.alignItems = 'center';
      wrap.style.gap = '4px';
      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.checked = !!stFilters[name];
      cb.addEventListener('change', async () => {
        const curFilters = { ...(window.__listState[currentSection].filters || {}) };
        curFilters[name] = cb.checked ? true : false;
        window.__listState[currentSection].filters = curFilters;
        window.__listState[currentSection].page = 1;
        const data = await loadSection();
        renderSummary(data);
      });
      wrap.appendChild(cb);
      wrap.appendChild(document.createTextNode(label));
      return wrap;
    };

    topControls.appendChild(mkFlag('is_adjusted', 'Adjusted only'));
    topControls.appendChild(mkFlag('is_qr', 'QR only'));
    topControls.appendChild(mkFlag('needs_attention', 'Needs attention'));
  }








async function openCandidatePicker(onPick, options) {
  const LOGC = (typeof window.__LOG_CONTRACTS === 'boolean') ? window.__LOG_CONTRACTS : true; // default ON
  const ctx  = options && options.context ? options.context : null;

  // âœ… NEW options
  const ignoreMembership = !!(options && options.ignoreMembership);
  const seedHintRaw      = (options && options.seed_hint && typeof options.seed_hint === 'object' && !Array.isArray(options.seed_hint))
    ? options.seed_hint
    : null;

  if (LOGC) console.log('[PICKER][candidates] ensure dataset primed â†’ start');
  await ensurePickerDatasetPrimed('candidates').catch(e => {
    if (LOGC) console.warn('[PICKER][candidates] priming failed', e);
  });

  let fp  = getSummaryFingerprint('candidates');
  let mem = getSummaryMembership('candidates', fp);

  // Keep existing behaviour by default; allow caller to ignore membership (timesheet resolve)
  if (!ignoreMembership) {
    if (!mem?.ids?.length || mem?.stale) {
      if (LOGC) console.log('[PICKER][candidates] membership empty/stale â†’ priming', { fp, mem });
      await primeSummaryMembership('candidates', fp);
      fp  = getSummaryFingerprint('candidates');
      mem = getSummaryMembership('candidates', fp);
    }
  }

  const ds    = (window.__pickerData ||= {}).candidates || { since: null, itemsById: {} };
  const items = ds.itemsById || {};

  // âœ… NEW: ignore membership if requested
  const baseIds  = (!ignoreMembership && (mem?.ids && mem.ids.length)) ? mem.ids : Object.keys(items);
  const baseRows = baseIds.map(id => items[id]).filter(Boolean);

  // âœ… NEW: suggested rows based on hint (best matches shown immediately)
  const norm = (s) => String(s || '').trim().toLowerCase();
  const alnum = (s) => norm(s).replace(/[^a-z0-9]+/g, '');

  const hint = (() => {
    if (!seedHintRaw) return null;
    return {
      email: norm(seedHintRaw.email || ''),
      first: norm(seedHintRaw.first_name || seedHintRaw.firstname || ''),
      sur:   norm(seedHintRaw.surname || seedHintRaw.last_name || seedHintRaw.lastname || ''),
      disp:  norm(seedHintRaw.display_name || ''),
      disp2: alnum(seedHintRaw.display_name || '')
    };
  })();

  const scoreCandidate = (r) => {
    if (!hint) return 0;

    const cEmail = norm(r.email || '');
    const cFirst = norm(r.first_name || '');
    const cLast  = norm(r.last_name || '');
    const cDisp  = norm(r.display_name || `${r.first_name || ''} ${r.last_name || ''}`);
    const cDisp2 = alnum(r.display_name || `${r.first_name || ''} ${r.last_name || ''}`);

    let score = 0;

    // Email is the strongest signal
    if (hint.email && cEmail) {
      if (cEmail === hint.email) score += 120;
      else if (cEmail.includes(hint.email)) score += 60;
    }

    // Surname
    if (hint.sur && cLast) {
      if (cLast === hint.sur) score += 50;
      else if (cLast.startsWith(hint.sur)) score += 30;
      else if (cLast.includes(hint.sur)) score += 15;
    }

    // First name
    if (hint.first && cFirst) {
      if (cFirst === hint.first) score += 25;
      else if (cFirst.startsWith(hint.first)) score += 15;
      else if (cFirst.includes(hint.first)) score += 8;
    }

    // Display name / combined
    if (hint.disp && cDisp.includes(hint.disp)) score += 12;
    if (hint.disp2 && cDisp2 && cDisp2 === hint.disp2) score += 25;

    // Bonus if both first+surname appear in display
    if (hint.first && hint.sur && cDisp) {
      if (cDisp.includes(hint.first) && cDisp.includes(hint.sur)) score += 18;
    }

    return score;
  };

  const suggestedRows = (() => {
    if (!hint) return [];
    const scored = baseRows
      .map(r => ({ r, s: scoreCandidate(r) }))
      .filter(x => x.s > 0)
      .sort((a, b) =>
        (b.s - a.s) ||
        String(a.r.last_name||'').localeCompare(String(b.r.last_name||'')) ||
        String(a.r.first_name||'').localeCompare(String(b.r.first_name||''))
      );
    return scored.slice(0, 20).map(x => x.r);
  })();

  const initialRows = (suggestedRows && suggestedRows.length) ? suggestedRows : baseRows;

  if (LOGC) console.log('[PICKER][candidates] dataset snapshot', {
    fingerprint: fp,
    total: mem?.total,
    ids: baseIds.length,
    stale: !!mem?.stale,
    since: ds?.since,
    rowsBase: baseRows.length,
    missingItems: baseIds.length - baseRows.length,
    ignoreMembership,
    suggestedCount: suggestedRows.length
  });

  const renderRows = (rows) => rows.map(r => {
    const first = r.first_name || '';
    const last  = r.last_name || '';
    const label = (r.display_name || `${first} ${last}`).trim() || (r.tms_ref || r.id || '');
    return `
      <tr data-id="${r.id||''}" data-label="${(label||'').replace(/"/g,'&quot;')}" class="pick-row">
        <td data-k="last_name">${(last)}</td>
        <td data-k="first_name">${(first)}</td>
        <td data-k="roles_display" class="mini">${(r.roles_display||'')}</td>
        <td data-k="email" class="mini">${(r.email||'')}</td>
      </tr>`;
  }).join('');

  // Context block above the search (which shift weâ€™re resolving)
  let ctxHtml = '';
  if (ctx) {
    const staff    = ctx.staffName || '';
    const unit     = ctx.unit || ctx.hospital || '';
    const ymd      = ctx.dateYmd || '';
    const nice     = ctx.dateNice || (typeof formatYmdToNiceDate === 'function' ? formatYmdToNiceDate(ymd) : ymd);
    const importId = ctx.importId || '';

    ctxHtml = `
      <div class="row">
        <label>Resolving</label>
        <div class="controls">
          <div class="mini">
            Candidate: <span class="mono">${escapeHtml ? escapeHtml(staff) : staff}</span><br/>
            Unit / Site: <span class="mono">${escapeHtml ? escapeHtml(unit) : unit}</span><br/>
            Date: <span class="mono">${escapeHtml ? escapeHtml(nice || 'â€”') : (nice || 'â€”')}</span><br/>
            Import ID: <span class="mono">${escapeHtml ? escapeHtml(importId || 'â€”') : (importId || 'â€”')}</span>
          </div>
        </div>
      </div>`;
  }

  const hintLine = (() => {
    if (ignoreMembership) return `Showing candidates from the full dataset${baseRows.length ? ` (${baseRows.length})` : ''}.`;
    return `Showing candidates from the current summary list${mem?.total ? ` (${mem.total} total)` : ''}.`;
  })();

  const hintLine2 = (suggestedRows && suggestedRows.length)
    ? `<div class="hint mini" style="margin-top:6px;">Suggested matches shown (top ${suggestedRows.length}). Type to search all candidates.</div>`
    : '';

  const html = `
    <div class="tabc">
      ${ctxHtml}
      <div class="row">
        <label>Search</label>
        <div class="controls">
          <input class="input" type="text" id="pickerSearch"
                 placeholder="${mem?.stale ? 'Priming listâ€¦ type to narrow' : 'Type a first name, surname, role or emailâ€¦'}"/>
        </div>
      </div>
      <div class="hint">
        ${hintLine}
      </div>
      ${hintLine2}
      <div class="picker-table-wrap">
        <table class="grid" id="pickerTable">
          <thead>
            <tr>
              <th data-sort="last_name">Surname</th>
              <th data-sort="first_name">First name</th>
              <th data-sort="roles_display">Role</th>
              <th data-sort="email">Email</th>
            </tr>
          </thead>
          <tbody id="pickerTBody">${renderRows(initialRows)}</tbody>
        </table>
      </div>
    </div>`;

  let selectedId     = null;
  let selectedLabel  = '';
  let applySelection = null;

  const renderTab = () => html;

  const onSave = async () => {
    if (typeof applySelection !== 'function') {
      if (LOGC) console.warn('[PICKER][candidates] onSave called before wiring');
      return false;
    }
    return await applySelection(true);
  };

  if (LOGC) console.log('[PICKER][candidates] opening modal');
  showModal(
    'Pick Candidate',
    [{ key: 'p', title: 'Candidates' }],
    renderTab,
    onSave,
    false,
    () => {
      const tbody  = document.getElementById('pickerTBody');
      const search = document.getElementById('pickerSearch');
      const table  = document.getElementById('pickerTable');
      if (LOGC) console.log('[PICKER][candidates] onReturn', { hasTBody: !!tbody, hasSearch: !!search, hasTable: !!table });
      if (!tbody || !search || !table) return;

      let sortKey     = 'last_name';
      let sortDir     = 'asc';
      let currentRows = initialRows.slice();

      const frame = window.__getModalFrame?.();
      if (frame && frame.kind === 'candidate-picker') {
        frame._pickerHasSelection = false;
        frame._updateButtons && frame._updateButtons();
      }

      const applyRows = (rows) => {
        tbody.innerHTML = renderRows(rows);
        if (selectedId) {
          const match = tbody.querySelector(`tr[data-id="${selectedId}"]`);
          if (match) match.classList.add('active');
        }
        if (LOGC) console.log('[PICKER][candidates] render()', {
          count: rows.length,
          sample: rows.slice(0, 6).map(r => r.display_name || `${r.first_name} ${r.last_name}`)
        });
      };

      // Always filter from the full baseRows (NOT initialRows)
      const doFilter = (q) => {
        const fn  = (window.pickersLocalFilterAndSort || pickersLocalFilterAndSort);
        const out = fn('candidates', baseRows, q, sortKey, sortDir);
        if (LOGC) console.log('[PICKER][candidates] doFilter()', {
          q,
          in: baseRows.length,
          out: out.length
        });
        currentRows = out;
        return out;
      };

      const setActiveRow = (tr) => {
        const all = tbody.querySelectorAll('tr[data-id]');
        all.forEach(r => r.classList.remove('active'));
        if (!tr) {
          selectedId = null;
          selectedLabel = '';
        } else {
          tr.classList.add('active');
          selectedId    = tr.getAttribute('data-id');
          selectedLabel = tr.getAttribute('data-label') || tr.textContent.trim();
        }

        const fr = window.__getModalFrame?.();
        if (fr && fr.kind === 'candidate-picker') {
          fr._pickerHasSelection = !!selectedId;
          fr._updateButtons && fr._updateButtons();
        }
      };

      applySelection = async (_triggerClose) => {
        if (!selectedId) {
          alert('Please select a candidate first.');
          return false;
        }
        if (LOGC) console.log('[PICKER][candidates] applySelection()', { selectedId, selectedLabel });
        try {
          await revalidateCandidateOnPick(selectedId);
          if (typeof onPick === 'function') {
            await onPick({ id: selectedId, label: selectedLabel });
          }
        } catch (err) {
          console.warn('[PICKER][candidates] selection validation failed', err);
          alert(err?.message || 'Selection could not be validated.');
          return false;
        }
        return true;
      };

      if (!tbody.__wiredClick) {
        tbody.__wiredClick = true;
        tbody.addEventListener('click', (e) => {
          const tr = e.target && e.target.closest('tr[data-id]');
          if (!tr) return;
          setActiveRow(tr);
        });
        tbody.addEventListener('dblclick', async (e) => {
          const tr = e.target && e.target.closest('tr[data-id]');
          if (!tr) return;
          setActiveRow(tr);
          const btnSave = document.getElementById('btnSave');
          if (btnSave && !btnSave.disabled) btnSave.click();
        });
        if (LOGC) console.log('[PICKER][candidates] wired click + dblclick handler');
      }

      // âœ… FIX #1: sort should work even when search box is empty (sort currentRows = suggestions)
      if (!table.__wiredSort) {
        table.__wiredSort = true;
        table.querySelector('thead').addEventListener('click', (e) => {
          const th = e.target && e.target.closest('th[data-sort]');
          if (!th) return;

          const key = th.getAttribute('data-sort');
          sortDir = (sortKey === key && sortDir === 'asc') ? 'desc' : 'asc';
          sortKey = key;

          const q = search.value.trim();

          if (q) {
            // Normal: filter+sort full set
            currentRows = doFilter(q);
            applyRows(currentRows);
            if (LOGC) console.log('[PICKER][candidates] sort (filtered)', { sortKey, sortDir, count: currentRows.length });
            return;
          }

          // Search empty: re-sort current visible set (suggestions / initial list)
          const dir = (sortDir === 'desc') ? -1 : 1;
          currentRows = (currentRows || []).slice().sort((a, b) => {
            const av = String((a && a[sortKey]) ?? '').toLowerCase();
            const bv = String((b && b[sortKey]) ?? '').toLowerCase();
            if (av < bv) return -1 * dir;
            if (av > bv) return  1 * dir;
            return 0;
          });
          applyRows(currentRows);

          if (LOGC) console.log('[PICKER][candidates] sort (currentRows)', { sortKey, sortDir, count: currentRows.length });
        });
        if (LOGC) console.log('[PICKER][candidates] wired sort header');
      }

      let t = 0;
      if (!search.__wiredInput) {
        search.__wiredInput = true;
        search.addEventListener('input', () => {
          const q = search.value.trim();
          if (LOGC) console.log('[PICKER][candidates] search input', { q });
          if (t) clearTimeout(t);
          t = setTimeout(() => {
            // If cleared, show suggested rows again (if any)
            currentRows = q ? doFilter(q) : initialRows.slice();
            applyRows(currentRows);
            setActiveRow(null);
          }, 150);
        });
        if (LOGC) console.log('[PICKER][candidates] wired search input');
      }

      if (!search.__wiredKey) {
        search.__wiredKey = true;
        search.addEventListener('keydown', (e) => {
          const itemsEls = Array.from(tbody.querySelectorAll('tr[data-id]'));
          if (!itemsEls.length) {
            if (e.key === 'Escape') {
              const closeBtn = document.getElementById('btnCloseModal');
              if (closeBtn) closeBtn.click();
            }
            return;
          }
          const idx = itemsEls.findIndex(tr => tr.classList.contains('active'));
          const setActiveIdx = (i) => {
            const safe = Math.max(0, Math.min(i, itemsEls.length - 1));
            setActiveRow(itemsEls[safe]);
            itemsEls[safe].scrollIntoView({ block: 'nearest' });
          };

          if (e.key === 'ArrowDown') {
            e.preventDefault();
            setActiveIdx(idx < 0 ? 0 : idx + 1);
          }
          if (e.key === 'ArrowUp') {
            e.preventDefault();
            setActiveIdx(idx < 0 ? 0 : idx - 1);
          }
          if (e.key === 'Enter') {
            e.preventDefault();
            const target = itemsEls[Math.max(idx, 0)];
            if (target) {
              setActiveRow(target);
              const btnSave = document.getElementById('btnSave');
              if (btnSave && !btnSave.disabled) btnSave.click();
            }
          }
          if (e.key === 'Escape') {
            e.preventDefault();
            const closeBtn = document.getElementById('btnCloseModal');
            if (closeBtn) closeBtn.click();
          }
        });
        if (LOGC) console.log('[PICKER][candidates] wired search keydown');
      }

      // If weâ€™re in seed mode, ensure the suggested rows are applied once after wiring
      try {
        if (suggestedRows && suggestedRows.length) {
          applyRows(currentRows);
        }
      } catch {}

      setTimeout(() => {
        try {
          search.focus();
          if (LOGC) console.log('[PICKER][candidates] search focused');
        } catch {}
      }, 0);
    },
    { kind: 'candidate-picker', noParentGate: true }
  );

  // Post-render kick: ensure the picker's onReturn wiring runs once on first open
  setTimeout(() => {
    try {
      const fr = window.__getModalFrame?.();
      const willCall = !!(fr && fr.kind === 'candidate-picker' && typeof fr.onReturn === 'function' && !fr.__pickerInit);
      if (LOGC) console.log('[PICKER][candidates] post-render kick', {
        hasFrame: !!fr,
        kind: fr?.kind,
        hasOnReturn: typeof fr?.onReturn === 'function',
        already: !!fr?.__pickerInit,
        willCall
      });
      if (willCall) {
        fr.__pickerInit = true;
        fr.onReturn();
        if (LOGC) console.log('[PICKER][candidates] initial onReturn() executed');
      }
    } catch (e) {
      if (LOGC) console.warn('[PICKER][candidates] post-render kick failed', e);
    }
  }, 0);
}

async function openClientPicker(onPick, opts) {
  const LOGC       = (typeof window.__LOG_CONTRACTS === 'boolean') ? window.__LOG_CONTRACTS : true; // default ON
  const nhspOnly   = !!(opts && opts.nhspOnly);
  const hrAutoOnly = !!(opts && opts.hrAutoOnly);
  const ctx        = opts && opts.context ? opts.context : null;

  // âœ… NEW options
  const ignoreMembership = !!(opts && opts.ignoreMembership);
  const seedQueryRaw     = (opts && typeof opts.seed_query === 'string') ? String(opts.seed_query).trim() : '';
  const seedQuery        = seedQueryRaw;

  if (LOGC) console.log('[PICKER][clients] ensure dataset primed â†’ start');
  await ensurePickerDatasetPrimed('clients').catch(e => {
    if (LOGC) console.warn('[PICKER][clients] priming failed', e);
  });

  let fp  = getSummaryFingerprint('clients');
  let mem = getSummaryMembership('clients', fp);

  if (!ignoreMembership) {
    if (!mem?.ids?.length || mem?.stale) {
      if (LOGC) console.log('[PICKER][clients] membership empty/stale â†’ priming', { fp, mem });
      await primeSummaryMembership('clients', fp);
      fp  = getSummaryFingerprint('clients');
      mem = getSummaryMembership('clients', fp);
    }
  }

  const ds    = (window.__pickerData ||= {}).clients || { since: null, itemsById: {} };
  const items = ds.itemsById || {};

  // âœ… NEW: ignore membership if requested
  const baseIds     = (!ignoreMembership && (mem?.ids && mem.ids.length)) ? mem.ids : Object.keys(items);
  const baseRowsAll = baseIds.map(id => items[id]).filter(Boolean);

  let baseRows = baseRowsAll;
  if (nhspOnly) {
    baseRows = baseRows.filter(r => r && (r.is_nhsp === true || r.is_nhsp === 'true'));
  }
  if (hrAutoOnly) {
    baseRows = baseRows.filter(r => r && (r.autoprocess_hr === true || r.autoprocess_hr === 'true'));
  }

  if (LOGC) console.log('[PICKER][clients] dataset snapshot', {
    fingerprint: fp,
    total: mem?.total,
    ids: baseIds.length,
    stale: !!mem?.stale,
    since: ds?.since,
    rowsBase: baseRows.length,
    missingItems: baseIds.length - baseRows.length,
    nhspOnly,
    hrAutoOnly,
    ignoreMembership,
    seedQuery
  });

  const renderRows = (rows) => rows.map(r => {
    const label = (r.name || '').trim();
    const sub   = (r.primary_invoice_email || '').trim();
    return `
      <tr data-id="${r.id||''}" data-label="${(label||'').replace(/"/g,'&quot;')}" class="pick-row">
        <td data-k="name">${label}</td>
        <td data-k="primary_invoice_email" class="mini">${sub}</td>
      </tr>`;
  }).join('');

  let ctxHtml = '';
  if (ctx) {
    const staff   = ctx.staffName || '';
    const unit    = ctx.unit || ctx.hospital || '';
    const ymd     = ctx.dateYmd || '';
    const nice    = ctx.dateNice || (typeof formatYmdToNiceDate === 'function' ? formatYmdToNiceDate(ymd) : ymd);
    const importId= ctx.importId || '';

    ctxHtml = `
      <div class="row">
        <label>Resolving</label>
        <div class="controls">
          <div class="mini">
            Candidate: <span class="mono">${escapeHtml ? escapeHtml(staff) : staff}</span><br/>
            Unit / Site: <span class="mono">${escapeHtml ? escapeHtml(unit) : unit}</span><br/>
            Date: <span class="mono">${escapeHtml ? escapeHtml(nice || 'â€”') : (nice || 'â€”')}</span><br/>
            Import ID: <span class="mono">${escapeHtml ? escapeHtml(importId || 'â€”') : (importId || 'â€”')}</span>
          </div>
        </div>
      </div>`;
  }

  const hintLine = (() => {
    if (ignoreMembership) return `Showing clients from the full dataset${baseRows.length ? ` (${baseRows.length})` : ''}.`;
    return `Showing clients from the current summary list${mem?.total ? ` (${mem.total} total)` : ''}.`;
  })();

  // âœ… FIX #2: seed_query must be HTML-escaped (attribute-safe)
  const seedEsc = seedQuery
    ? ((typeof escapeHtml === 'function')
        ? String(escapeHtml(seedQuery)).replace(/"/g, '&quot;')
        : String(seedQuery)
            .replace(/&/g,'&amp;')
            .replace(/</g,'&lt;')
            .replace(/>/g,'&gt;')
            .replace(/"/g,'&quot;'))
    : '';

  const html = `
    <div class="tabc">
      ${ctxHtml}
      <div class="row">
        <label>Search</label>
        <div class="controls">
          <input class="input" type="text" id="pickerSearch"
                 value="${seedEsc}"
                 placeholder="${mem?.stale ? 'Priming listâ€¦ type to narrow' : 'Type a client name or emailâ€¦'}"/>
        </div>
      </div>
      <div class="hint">
        ${hintLine}
        ${nhspOnly ? ' (NHSP-only filter)' : ''}${hrAutoOnly ? ' (Auto-process HR only)' : ''}
        ${seedQuery ? `<span class="mini" style="margin-left:8px;">(prefilled)</span>` : ''}
      </div>
      <div class="picker-table-wrap">
        <table class="grid" id="pickerTable">
          <thead>
            <tr>
              <th data-sort="name">Name</th>
              <th data-sort="primary_invoice_email">Email</th>
            </tr>
          </thead>
          <tbody id="pickerTBody">${renderRows(baseRows)}</tbody>
        </table>
      </div>
    </div>`;

  let selectedId     = null;
  let selectedLabel  = '';
  let applySelection = null;

  const renderTab = () => html;

  const onSave = async () => {
    if (typeof applySelection !== 'function') {
      if (LOGC) console.warn('[PICKER][clients] onSave called before wiring');
      return false;
    }
    return await applySelection(true);
  };

  if (LOGC) console.log('[PICKER][clients] opening modal');
  showModal(
    'Pick Client',
    [{ key: 'p', title: 'Clients' }],
    renderTab,
    onSave,
    false,
    () => {
      const tbody  = document.getElementById('pickerTBody');
      const search = document.getElementById('pickerSearch');
      const table  = document.getElementById('pickerTable');
      if (LOGC) console.log('[PICKER][clients] onReturn', { hasTBody: !!tbody, hasSearch: !!search, hasTable: !!table });
      if (!tbody || !search || !table) return;

      let sortKey     = 'name';
      let sortDir     = 'asc';
      let currentRows = baseRows.slice();

      const frame = window.__getModalFrame?.();
      if (frame && frame.kind === 'client-picker') {
        frame._pickerHasSelection = false;
        frame._updateButtons && frame._updateButtons();
      }

      const applyRows = (rows) => {
        tbody.innerHTML = renderRows(rows);
        if (selectedId) {
          const match = tbody.querySelector(`tr[data-id="${selectedId}"]`);
          if (match) match.classList.add('active');
        }
        if (LOGC) console.log('[PICKER][clients] render()', {
          count: rows.length,
          sample: rows.slice(0, 6).map(r => r.name)
        });
      };

      // Always filter from full baseRows
      const doFilter = (q) => {
        const fn  = (window.pickersLocalFilterAndSort || pickersLocalFilterAndSort);
        const out = fn('clients', baseRows, q, sortKey, sortDir);
        if (LOGC) console.log('[PICKER][clients] doFilter()', {
          q,
          in: baseRows.length,
          out: out.length
        });
        currentRows = out;
        return out;
      };

      // âœ… apply seed query immediately (prefill + filtered list on open)
      if (seedQuery && !search.__seedApplied) {
        search.__seedApplied = true;
        try {
          search.value = seedQuery;
          currentRows = doFilter(seedQuery);
          applyRows(currentRows);
        } catch {}
      }

      const setActiveRow = (tr) => {
        const all = tbody.querySelectorAll('tr[data-id]');
        all.forEach(r => r.classList.remove('active'));
        if (!tr) {
          selectedId = null;
          selectedLabel = '';
        } else {
          tr.classList.add('active');
          selectedId    = tr.getAttribute('data-id');
          selectedLabel = tr.getAttribute('data-label') || tr.textContent.trim();
        }

        const fr = window.__getModalFrame?.();
        if (fr && fr.kind === 'client-picker') {
          fr._pickerHasSelection = !!selectedId;
          fr._updateButtons && fr._updateButtons();
        }
      };

      applySelection = async (_triggerClose) => {
        if (!selectedId) {
          alert('Please select a client first.');
          return false;
        }
        if (LOGC) console.log('[PICKER][clients] applySelection()', { selectedId, selectedLabel });
        try {
          await revalidateClientOnPick(selectedId);
          if (typeof onPick === 'function') {
            await onPick({ id: selectedId, label: selectedLabel });
          }
        } catch (err) {
          console.warn('[PICKER][clients] selection validation failed', err);
          alert(err?.message || 'Selection could not be validated.');
          return false;
        }
        return true;
      };

      if (!tbody.__wiredClick) {
        tbody.__wiredClick = true;
        tbody.addEventListener('click', (e) => {
          const tr = e.target && e.target.closest('tr[data-id]');
          if (!tr) return;
          setActiveRow(tr);
        });
        tbody.addEventListener('dblclick', (e) => {
          const tr = e.target && e.target.closest('tr[data-id]');
          if (!tr) return;
          setActiveRow(tr);
          const btnSave = document.getElementById('btnSave');
          if (btnSave && !btnSave.disabled) btnSave.click();
        });
        if (LOGC) console.log('[PICKER][clients] wired click + dblclick handler');
      }

      if (!table.__wiredSort) {
        table.__wiredSort = true;
        table.querySelector('thead').addEventListener('click', (e) => {
          const th = e.target && e.target.closest('th[data-sort]');
          if (!th) return;
          const key = th.getAttribute('data-sort');
          sortDir = (sortKey === key && sortDir === 'asc') ? 'desc' : 'asc';
          sortKey = key;
          currentRows = doFilter(search.value.trim());
          applyRows(currentRows);
          if (LOGC) console.log('[PICKER][clients] sort', { sortKey, sortDir, count: currentRows.length });
        });
        if (LOGC) console.log('[PICKER][clients] wired sort header');
      }

      let t = 0;
      if (!search.__wiredInput) {
        search.__wiredInput = true;
        search.addEventListener('input', () => {
          const q = search.value.trim();
          if (LOGC) console.log('[PICKER][clients] search input', { q });
          if (t) clearTimeout(t);
          t = setTimeout(() => {
            currentRows = doFilter(q);
            applyRows(currentRows);
            setActiveRow(null);
          }, 150);
        });
        if (LOGC) console.log('[PICKER][clients] wired search input');
      }

      if (!search.__wiredKey) {
        search.__wiredKey = true;
        search.addEventListener('keydown', (e) => {
          const itemsEls = Array.from(tbody.querySelectorAll('tr[data-id]'));
          if (!itemsEls.length) {
            if (e.key === 'Escape') {
              const closeBtn = document.getElementById('btnCloseModal');
              if (closeBtn) closeBtn.click();
            }
            return;
          }

          const idx = itemsEls.findIndex(tr => tr.classList.contains('active'));
          const setActiveIdx = (i) => {
            const safe = Math.max(0, Math.min(i, itemsEls.length - 1));
            setActiveRow(itemsEls[safe]);
            itemsEls[safe].scrollIntoView({ block: 'nearest' });
          };

          if (e.key === 'ArrowDown') {
            e.preventDefault();
            setActiveIdx(idx < 0 ? 0 : idx + 1);
          }
          if (e.key === 'ArrowUp') {
            e.preventDefault();
            setActiveIdx(idx < 0 ? 0 : idx - 1);
          }
          if (e.key === 'Enter') {
            e.preventDefault();
            const target = itemsEls[Math.max(idx, 0)];
            if (target) {
              setActiveRow(target);
              const btnSave = document.getElementById('btnSave');
              if (btnSave && !btnSave.disabled) btnSave.click();
            }
          }
          if (e.key === 'Escape') {
            e.preventDefault();
            const closeBtn = document.getElementById('btnCloseModal');
            if (closeBtn) closeBtn.click();
          }
        });
        if (LOGC) console.log('[PICKER][clients] wired search keydown');
      }

      setTimeout(() => {
        try {
          search.focus();
          if (LOGC) console.log('[PICKER][clients] search focused');
        } catch {}
      }, 0);
    },
    { kind: 'client-picker', noParentGate: true }
  );

  // Post-render kick: ensure the picker's onReturn wiring runs once on first open
  setTimeout(() => {
    try {
      const fr = window.__getModalFrame?.();
      const willCall = !!(fr && fr.kind === 'client-picker' && typeof fr.onReturn === 'function' && !fr.__pickerInit);
      if (LOGC) console.log('[PICKER][clients] post-render kick', {
        hasFrame: !!fr,
        kind: fr?.kind,
        hasOnReturn: typeof fr?.onReturn === 'function',
        already: !!fr?.__pickerInit,
        willCall
      });
      if (willCall) {
        fr.__pickerInit = true;
        fr.onReturn();
        if (LOGC) console.log('[PICKER][clients] initial onReturn() executed');
      }
    } catch (e) {
      if (LOGC) console.warn('[PICKER][clients] post-render kick failed', e);
    }
  }, 0);
}



async function getCandidate(candidate_id) {
  if (!candidate_id) throw new Error('candidate_id required');
  const r = await authFetch(API(`/api/candidates/${encodeURIComponent(String(candidate_id))}`));
  if (!r?.ok) throw new Error('Failed to load candidate');
  return r.json();
}




// Fetch one client by id (adjust endpoint to your API if needed)
async function getClient(client_id) {
  if (!client_id) throw new Error('client_id required');
  const r = await authFetch(API(`/api/clients/${encodeURIComponent(String(client_id))}`));
  if (!r?.ok) throw new Error('Failed to load client');
  return r.json();
}

// Set/update the non-blocking hint text in the contract modal footer
function showModalHint(text, tone /* 'ok' | 'warn' | 'fail' */) {
  const el = byId('modalHint'); if (!el) return;
  el.textContent = text || '';
  el.classList.remove('tag-ok','tag-warn','tag-fail');
  if (tone === 'ok')   el.classList.add('tag-ok');
  if (tone === 'warn') el.classList.add('tag-warn');
  if (tone === 'fail') el.classList.add('tag-fail');
}

// Generic live-filter helper for picker tables
function wirePickerLiveFilter(inputEl, tableEl) {
  const rows = Array.from(tableEl.querySelectorAll('tbody tr'));
  const norm = (s) => (s||'').toLowerCase();
  inputEl.addEventListener('input', () => {
    const q = norm(inputEl.value);
    rows.forEach(tr => {
      const show = !q || norm(tr.textContent).includes(q);
      tr.style.display = show ? '' : 'none';
    });
  });
}

// Convenience: set a form field inside the contract modal
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UPDATED: setContractFormValue (adds logging)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function setContractFormValue(name, value) {
  const LOGC = (typeof window.__LOG_CONTRACTS === 'boolean') ? window.__LOG_CONTRACTS : false;

  // Do not stage ward_hint at all (deprecated)
  if (name === 'ward_hint') {
    if (LOGC) console.log('[CONTRACTS] setContractFormValue ignored (ward_hint deprecated)');
    return;
  }

  let targetName = (name === 'default_pay_method_snapshot') ? 'pay_method_snapshot' : name;

  try {
    const locked = !!(window.modalCtx?.formState?.main?.__pay_locked);
    if ((targetName === 'pay_method_snapshot' || name === 'default_pay_method_snapshot') && locked) {
      if (LOGC) console.log('[CONTRACTS] setContractFormValue ignored (pay method locked)', { name, value });
      return;
    }
  } catch {}

  const form =
    document.querySelector('#modalBody #contractForm') ||
    document.querySelector('#contractForm') ||
    null;
  const ratesRoot =
    document.getElementById('contractRatesTab') ||
    document.querySelector('#contractRatesTab') ||
    null;

  let el = null;
  if (ratesRoot) {
    el =
      ratesRoot.querySelector(`*[name="${CSS.escape(targetName)}"]`) ||
      ratesRoot.querySelector(`*[name="${CSS.escape(name)}"]`);
  }
  if (!el && form) {
    el =
      form.querySelector(`*[name="${CSS.escape(targetName)}"]`) ||
      form.querySelector(`*[name="${CSS.escape(name)}"]`);
  }

  // Validate & normalise *_start/*_end (empty allowed) **without** wiping partial input
  if (/^(mon|tue|wed|thu|fri|sat|sun)_(start|end)$/.test(targetName)) {
    const raw = (value == null ? '' : String(value).trim());

    const isValidHHMM = (s) => {
      if (!s) return true; // empty is allowed
      if (!/^(\d{1,2}:\d{1,2}|\d{3,4})$/.test(s)) return false;
      let h, m;
      if (/^\d{3,4}$/.test(s)) {
        const p = s.padStart(4, '0');
        h = +p.slice(0, 2);
        m = +p.slice(2, 4);
      } else {
        const a = s.split(':');
        h = +a[0];
        m = +a[1];
      }
      return (h >= 0 && h <= 23 && m >= 0 && m <= 59);
    };

    if (!raw) {
      // Empty: clear error markers and treat as blank
      if (el) {
        el.removeAttribute('data-invalid');
        el.removeAttribute('title');
      }
      value = '';
    } else if (isValidHHMM(raw)) {
      // Normalise to HH:MM (supports 3/4 digits or H:MM / HH:MM)
      let h, m;
      if (/^\d{3,4}$/.test(raw)) {
        const p = raw.padStart(4, '0');
        h = +p.slice(0, 2);
        m = +p.slice(2, 4);
      } else {
        const a = raw.split(':');
        h = +a[0];
        m = +a[1];
      }
      value = String(h).padStart(2, '0') + ':' + String(m).padStart(2, '0');
      if (el) {
        el.value = value;
        el.removeAttribute('data-invalid');
        el.removeAttribute('title');
      }
    } else {
      // Partially typed or invalid: keep what the user has typed, just mark it
      if (el) {
        el.setAttribute('data-invalid', '1');
        el.setAttribute('title', 'Enter HH:MM (00:00â€“23:59)');
      }
      value = raw; // keep raw so typing is not wiped
    }
  }

  window.modalCtx = window.modalCtx || {};
  const fs = (window.modalCtx.formState ||= {
    __forId: (window.modalCtx.data?.id ?? window.modalCtx.openToken ?? null),
    main:{},
    pay:{}
  });

  const isRate = /^(paye_|umb_|charge_)/.test(targetName);
  const prev = isRate ? fs.pay[targetName] : fs.main[targetName];

  let stored;
  if (el && el.type === 'checkbox') {
    el.checked = !!value && value !== 'false' && value !== '0';
    stored = el.checked ? 'on' : '';
  } else if (el && el.type === 'radio') {
    stored = String(value ?? '');
    const group = form ? Array.from(form.querySelectorAll(`input[type="radio"][name="${CSS.escape(el.name)}"]`)) : [];
    for (const r of group) r.checked = (String(r.value) === stored);
  } else {
    stored = (value == null ? '' : String(value));
    if (el) el.value = stored;
  }

  if (prev === stored) {
    if (LOGC) {
      console.log('[CONTRACTS] setContractFormValue no-op (unchanged)', {
        name: targetName,
        stored,
        prev,
        isRate
      });
    }
    return;
  }

  if (isRate) fs.pay[targetName] = stored;
  else        fs.main[targetName] = stored;

  if (LOGC) {
    let scope = 'none';
    try {
      if (el && ratesRoot && ratesRoot.contains(el)) scope = 'rates';
      else if (el && form && form.contains(el))      scope = 'form';
    } catch {}
    console.log('[CONTRACTS] setContractFormValue APPLY', {
      name: targetName,
      prev,
      stored,
      isRate,
      scope
    });
  }

  if (isRate || targetName === 'pay_method_snapshot') {
    try { computeContractMargins(); } catch {}
  }

  try { window.dispatchEvent(new CustomEvent('modal-dirty')); } catch {}
}


function applyRatePresetToContractForm(preset, payMethod /* 'PAYE'|'UMBRELLA' */) {
  if (!preset) return;

  const LOGC = (typeof window.__LOG_CONTRACTS === 'boolean') ? window.__LOG_CONTRACTS : false;

  // Helper: resolve the nearest/open Contracts frame (parent or higher)
  const getContractsFrame = () => {
    const s = window.__modalStack || [];
    for (let i = s.length - 1; i >= 0; i--) {
      const f = s[i];
      if (f && (f.kind === 'contracts' || f.entity === 'contracts')) return f;
    }
    return null;
  };

  const form =
    document.querySelector('#modalBody #contractForm') ||
    document.querySelector('#contractForm') ||
    null;
  const ratesRoot =
    document.getElementById('contractRatesTab') ||
    document.querySelector('#contractRatesTab') ||
    null;
  const canTouchDom = !!(form || ratesRoot);

  const mc = window.modalCtx || (window.modalCtx = {});
  if (!mc.formState) {
    const baseId = (mc.data && mc.data.id) || mc.openToken || null;
    mc.formState = { __forId: baseId, main: {}, pay: {} };
  }
  const fs = mc.formState;
  fs.main = fs.main || {};
  fs.pay  = fs.pay  || {};

  const effectivePayMethod = String(
    payMethod ||
    fs.main.pay_method_snapshot ||
    (mc.data && mc.data.pay_method_snapshot) ||
    'PAYE'
  ).toUpperCase();

  if (LOGC) {
    console.log('[CONTRACTS] applyRatePresetToContractForm ENTER', {
      presetId: preset.id,
      payMethodParam: payMethod,
      effectivePayMethod
    });
  }

  // Format helper: 2 decimal places if numeric, otherwise leave as-is
  const as2dpRate = (raw) => {
    if (raw == null || raw === '') return '';
    const n = Number(raw);
    return Number.isFinite(n) ? n.toFixed(2) : String(raw);
  };

  const write = (name, raw) => {
    const isRate = /^(paye_|umb_|charge_)/.test(name) || /^mileage_(pay|charge)_rate$/.test(name);
    const v = (raw == null || raw === '')
      ? ''
      : (isRate ? as2dpRate(raw) : String(raw));

    const prev = /^(paye_|umb_|charge_)/.test(name) ? fs.pay[name] : fs.main[name];

    let el = null;
    let hit = 'none';
    if (ratesRoot) {
      el = ratesRoot.querySelector(`[name="${CSS.escape(name)}"]`);
      if (el) hit = 'rates';
    }
    if (!el && form) {
      el = form.querySelector(`[name="${CSS.escape(name)}"]`);
      if (el) hit = 'form';
    }

    if (LOGC) {
      console.log('[CONTRACTS] preset write BEFORE', { name, prev, next: v, hit });
    }

    if (el && canTouchDom) {
      el.value = v;
      try {
        el.dispatchEvent(new Event('input',  { bubbles:true }));
        el.dispatchEvent(new Event('change', { bubbles:true }));
      } catch {}
    }

    // single source of truth: let setContractFormValue stage + fire margins/dirty
    if (typeof setContractFormValue === 'function') {
      try { setContractFormValue(name, v); }
      catch (e) {
        if (LOGC) console.warn('[CONTRACTS] setContractFormValue from preset failed', { name, v, err: e && e.message });
      }
    }
  };

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Identity fields: always overwrite from preset
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  [['role','role'], ['band','band'], ['display_site','display_site']].forEach(([field, key]) => {
    const next = preset[key] != null ? String(preset[key]).trim() : '';
    write(field, next);
  });

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Rates: copy all families the preset actually defines
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const BUCKETS  = ['day','night','sat','sun','bh'];
  const prefixes = ['paye','umb','charge'];

  BUCKETS.forEach(b => {
    prefixes.forEach(p => {
      const fieldName = `${p}_${b}`;
      if (!Object.prototype.hasOwnProperty.call(preset, fieldName)) return;
      const raw = preset[fieldName];
      const finalVal = as2dpRate(raw);
      write(fieldName, finalVal);
    });
  });

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Mileage â€” copy if present on the preset; leave untouched if absent
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const as2dpMileage = as2dpRate; // same behaviour

  if (Object.prototype.hasOwnProperty.call(preset, 'mileage_pay_rate')) {
    write('mileage_pay_rate', as2dpMileage(preset.mileage_pay_rate));
  }
  if (Object.prototype.hasOwnProperty.call(preset, 'mileage_charge_rate')) {
    write('mileage_charge_rate', as2dpMileage(preset.mileage_charge_rate));
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Bucket labels: if any labels present, overwrite for those keys;
  // even blank values wipe existing labels.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (preset.bucket_labels_json) {
    const BL = preset.bucket_labels_json || {};
    const hasAnyLabel = BUCKETS.some(k => Object.prototype.hasOwnProperty.call(BL, k));

    if (hasAnyLabel) {
      fs.main.__bucket_labels = fs.main.__bucket_labels || {};
      BUCKETS.forEach(k => {
        if (!Object.prototype.hasOwnProperty.call(BL, k)) return; // leave others as-is
        const raw  = BL[k];
        const next = raw == null ? '' : String(raw).trim();
        write(`bucket_label_${k}`, next);
        write(`bucket_${k}`,       next);
        fs.main.__bucket_labels[k] = next;
      });
    }
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Standard schedule:
  // - If NO days at all in std_schedule_json â†’ do nothing
  // - If ANY day present â†’ overwrite ALL 7 days (blanks where absent)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const days = ['mon','tue','wed','thu','fri','sat','sun'];

  if (preset.std_schedule_json) {
    const sched = preset.std_schedule_json || {};
    const hasAnyDay = days.some(d => Object.prototype.hasOwnProperty.call(sched, d));

    if (hasAnyDay) {
      const template = {};
      const toStr = (v) => (v == null ? '' : String(v).trim());

      days.forEach(d => {
        const hasThisDay = Object.prototype.hasOwnProperty.call(sched, d);
        const src        = hasThisDay ? (sched[d] || {}) : {};
        const start      = toStr(src.start);
        const end        = toStr(src.end);

        let brStr = '';
        let brNum = 0;
        if (src.break_minutes != null && start && end) {
          brNum = Number(src.break_minutes) || 0;
          brStr = String(brNum);
        }

        // Always overwrite all 7 days (even to blanks)
        write(`${d}_start`, start);
        write(`${d}_end`,   end);
        write(`${d}_break`, brStr);

        if (start && end) {
          template[d] = { start, end, break_minutes: brNum };
        }
      });

      fs.main.__template = template;
    }
  }

  // Hours snapshot from preset or derived from template
  if (preset.std_hours_json) {
    fs.main.__hours = preset.std_hours_json;
  } else if (fs.main.__template) {
    const hours = {};
    const toMinutes = (hhmm) => {
      const m = String(hhmm || '').match(/^(\d{1,2}):(\d{2})$/);
      return m ? (+m[1] * 60 + +m[2]) : null;
    };

    days.forEach(d => {
      const slot = fs.main.__template[d];
      if (!slot || !slot.start || !slot.end) return;

      const startMin = toMinutes(slot.start);
      const endMin   = toMinutes(slot.end);
      if (startMin == null || endMin == null) return;

      let mins = endMin < startMin ? (endMin + 1440 - startMin) : (endMin - startMin);
      mins -= Number(slot.break_minutes || 0);
      if (mins <= 0) return;

      hours[d] = +(mins / 60).toFixed(2);
    });

    fs.main.__hours = Object.keys(hours).length ? hours : null;
  }

  // Non-blocking warnings for pay-method / family mismatches
  const hasFamily = (fam) => BUCKETS.some(k => {
    const v = preset[`${fam}_${k}`];
    return v !== undefined && v !== null && String(v).trim() !== '';
  });

  try {
    if (effectivePayMethod === 'UMBRELLA' && !hasFamily('umb')) {
      if (typeof showModalHint === 'function') {
        showModalHint(
          'No Umbrella rates are set for this preset rate card. Please enter the Umbrella pay rates manually',
          'warn'
        );
      } else if (window.__toast) {
        window.__toast('No Umbrella rates are set for this preset rate card. Please enter the Umbrella pay rates manually');
      }
    } else if (effectivePayMethod === 'PAYE' && !hasFamily('paye')) {
      if (typeof showModalHint === 'function') {
        showModalHint(
          'No PAYE rates are set for this preset rate card. Please enter the PAYE pay rates manually',
          'warn'
        );
      } else if (window.__toast) {
        window.__toast('No PAYE rates are set for this preset rate card. Please enter the PAYE pay rates manually');
      }
    }
  } catch {}

  // Recompute margins + mark modal dirty
  try { if (typeof computeContractMargins === 'function') computeContractMargins(); } catch {}

  try {
    const fr = getContractsFrame();
    if (fr) {
      fr.isDirty = true;
      if (typeof fr._updateButtons === 'function') fr._updateButtons();
    }
    window.dispatchEvent(new Event('modal-dirty'));
  } catch {}

  if (LOGC) {
    console.log('[CONTRACTS] applyRatePresetToContractForm EXIT', {
      presetId: preset.id,
      effectivePayMethod
    });
  }
}

function mergeContractStateIntoRow(row, formState) {
  const base = { ...(row || {}) };

  // Allow explicit formState injection (for testability), but keep backward compatibility.
  const fs =
    formState ||
    ((window.modalCtx && window.modalCtx.formState) ? window.modalCtx.formState : null);

  const toBool = (v) => {
    return v === 'on' || v === true || v === 'true' || v === 1 || v === '1';
  };

  const boolKeys = new Set([
    // contract flags
    'auto_invoice',
    'require_reference_to_pay',
    'require_reference_to_invoice',
    'self_bill',

    // contract route + invoice calc flags
    'is_nhsp',
    'autoprocess_hr',
    'requires_hr',
    'no_timesheet_required',
    'daily_calc_of_invoices',
    'group_nightsat_sunbh',

    // âœ… NEW: attachments at contract level
    'hr_attach_to_invoice',
    'ts_attach_to_invoice'
  ]);

  // Merge MAIN staged fields
  if (fs && fs.main) {
    for (const [k, v] of Object.entries(fs.main)) {
      if (boolKeys.has(k)) {
        base[k] = toBool(v);
      } else if (k === 'start_date' || k === 'end_date') {
        base[k] = v; // Keep as DD/MM/YYYY in the UI; conversion happens on save
      } else if (k === 'week_ending_weekday_snapshot') {
        base[k] = v;
      } else {
        base[k] = v;
      }
    }
  }

  // Merge PAY staged fields into rates_json without forcing number conversion (UI shows strings)
  const stagedRates = (fs && fs.pay) ? fs.pay : null;
  if (stagedRates) {
    const r = { ...(base.rates_json || {}) };
    for (const [k, v] of Object.entries(stagedRates)) r[k] = v;
    base.rates_json = r;
  }

  return base;
}

function openContractSettingsModal() {
  const LOGC = (typeof window.__LOG_CONTRACTS === 'boolean') ? window.__LOG_CONTRACTS : true;

  if (!window.modalCtx || window.modalCtx.entity !== 'contracts') {
    alert('Contract settings can only be opened from an active Contract modal.');
    return;
  }

  const base = window.modalCtx?.data || {};
  const contractId = base?.id || null;

  // âœ… Parent contract modal mode gating:
  // - VIEW mode: cannot tick or edit anything in this child modal
  // - EDIT/CREATE mode: allow interactions per override rules
  let parentEditable = true;
  try {
    const frParent = (typeof window.__getModalFrame === 'function') ? window.__getModalFrame() : null;
    if (frParent && (frParent.kind === 'contracts' || frParent.entity === 'contracts')) {
      parentEditable = (frParent.mode === 'edit' || frParent.mode === 'create');
    }
  } catch {}
  const parentViewOnly = !parentEditable;

  // âœ… View-only gating: if real timesheets exist, OPEN view-only (do NOT block opening)
  const hasRealTimesheets = (() => {
    const d = base || {};
    const n = Number(d.real_timesheets_count ?? d.real_timesheet_count ?? d.timesheets_count ?? d.timesheet_count ?? NaN);
    if (Number.isFinite(n) && n > 0) return true;
    if (d.has_real_timesheets === true) return true;
    if (d.has_timesheets === true) return true;
    return false;
  })();

  // âœ… Final viewOnly: either parent is view-only OR real timesheets exist (existing rule)
  const viewOnly = !!(parentViewOnly || (contractId && hasRealTimesheets));

  const fs = (window.modalCtx.formState ||= {
    __forId: (window.modalCtx.data?.id ?? window.modalCtx.openToken ?? null),
    main: {},
    pay: {}
  });
  fs.main ||= {};

  const boolish = (v) => (v === 'on' || v === true || v === 'true' || v === 1 || v === '1');

  // --- Contract/client snapshot helpers ---
  const getClientSettingsSnapshot = () => {
    // Preferred: stored by openContract on open + on client change
    const cs1 = window.modalCtx?.client_settings_snapshot;
    if (cs1 && typeof cs1 === 'object') return cs1;

    // Secondary: tolerate alternative property names
    const cs2 = window.modalCtx?.clientSettingsSnapshot;
    if (cs2 && typeof cs2 === 'object') return cs2;

    return null;
  };

  const getClientSettingsClientId = () => {
    const id1 = window.modalCtx?.client_settings_snapshot_client_id;
    if (id1) return String(id1);
    return null;
  };

  // Staged value getter (fs.main wins), preserving nulls
  const getMainRaw = (k) => {
    if (Object.prototype.hasOwnProperty.call(fs.main, k)) return fs.main[k];
    if (Object.prototype.hasOwnProperty.call(base, k)) return base[k];
    return undefined;
  };

  // Tri-normalise: null/undefined => null, otherwise boolean coercion
  const triBool = (v) => {
    if (v === null || v === undefined) return null;
    return !!boolish(v);
  };

  const triString = (v) => {
    if (v === null || v === undefined) return null;
    return String(v);
  };

  const triUpperOrNull = (v) => {
    if (v === null || v === undefined) return null;
    const s = String(v).trim();
    if (!s) return null;
    return s.toUpperCase();
  };

  const setMainTriBool = (k, bOrNull) => {
    const prev = Object.prototype.hasOwnProperty.call(fs.main, k) ? fs.main[k] : undefined;
    const next = (bOrNull === null) ? null : (bOrNull ? 'on' : '');
    if (prev === next) return false;
    fs.main[k] = next;
    return true;
  };

  const setMainTriString = (k, sOrNull) => {
    const prev = Object.prototype.hasOwnProperty.call(fs.main, k) ? fs.main[k] : undefined;
    const next = (sOrNull === null) ? null : String(sOrNull);
    if (prev === next) return false;
    fs.main[k] = next;
    return true;
  };

  const setMainTriUpper = (k, sOrNull) => {
    const prev = Object.prototype.hasOwnProperty.call(fs.main, k) ? fs.main[k] : undefined;
    const next = (sOrNull === null) ? null : String(sOrNull).trim().toUpperCase();
    if (prev === next) return false;
    fs.main[k] = next;
    return true;
  };

  const setContractDirtyIfChanged = (changed) => {
    if (!changed) return;

    // Mark non-calendar dirty so calendar-only saves never skip the upsert.
    try {
      window.modalCtx.__nonCalendarDirty = true;
      window.modalCtx.__calendarOnly = false;
    } catch {}

    // Mark parent contract frame dirty (so Save becomes available after Apply closes)
    try {
      const fr = (typeof window.__getModalFrame === 'function') ? window.__getModalFrame() : null;
      if (fr && fr.kind === 'contracts') {
        fr.isDirty = true;
        fr._updateButtons && fr._updateButtons();
      }
    } catch {}

    try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
  };

  // --- Override stash mechanics ---
  // Stored on parent modalCtx so toggling survives re-render while modal is open
  const STASH_KEY = '__overrideClientSettingsStash';

  const BOOL_FIELDS = [
    'is_nhsp',
    'autoprocess_hr',
    'requires_hr',
    'no_timesheet_required',
    'daily_calc_of_invoices',
    'group_nightsat_sunbh',
    'self_bill',
    'hr_attach_to_invoice',
    'ts_attach_to_invoice',
    'auto_invoice',
    'require_reference_to_pay',
    'require_reference_to_invoice',
    'reference_number_required_to_issue_invoice',
    'send_manual_invoices_to_different_email'
  ];

  const STR_FIELDS = [
    'manual_invoices_alt_email_address'
  ];

  const ENUM_FIELDS = [
    'default_submission_mode'
  ];

  const captureOverrideValuesAsStaged = () => {
    const out = {};

    for (const k of BOOL_FIELDS) {
      const raw = getMainRaw(k);
      out[k] = (raw === null || raw === undefined) ? null : (boolish(raw) ? 'on' : '');
    }
    for (const k of STR_FIELDS) {
      const raw = getMainRaw(k);
      out[k] = (raw === null || raw === undefined) ? null : String(raw);
    }
    for (const k of ENUM_FIELDS) {
      const raw = getMainRaw(k);
      out[k] = (raw === null || raw === undefined) ? null : triUpperOrNull(raw);
    }

    return out;
  };

  const applyOverrideValuesStaged = (stashObj) => {
    if (!stashObj || typeof stashObj !== 'object') return false;
    let changed = false;

    for (const k of BOOL_FIELDS) {
      if (Object.prototype.hasOwnProperty.call(stashObj, k)) {
        const v = stashObj[k];
        if (v === null) changed = setMainTriBool(k, null) || changed;
        else changed = setMainTriBool(k, !!boolish(v)) || changed;
      }
    }
    for (const k of STR_FIELDS) {
      if (Object.prototype.hasOwnProperty.call(stashObj, k)) {
        const v = stashObj[k];
        changed = setMainTriString(k, (v === null ? null : String(v))) || changed;
      }
    }
    for (const k of ENUM_FIELDS) {
      if (Object.prototype.hasOwnProperty.call(stashObj, k)) {
        const v = stashObj[k];
        changed = setMainTriUpper(k, (v === null ? null : String(v))) || changed;
      }
    }

    return changed;
  };

  const clearOverrideValuesToNull = () => {
    let changed = false;
    for (const k of BOOL_FIELDS) changed = setMainTriBool(k, null) || changed;
    for (const k of STR_FIELDS)  changed = setMainTriString(k, null) || changed;
    for (const k of ENUM_FIELDS) changed = setMainTriUpper(k, null) || changed;
    return changed;
  };

  // --- Seed from client_settings snapshot (when override toggled ON from OFF, and no stash restore) ---
  const seedFromClientSettingsSnapshot = (cs) => {
    if (!cs || typeof cs !== 'object') return false;

    // booleans from client settings
    const csBool = (k, def = false) => {
      if (!cs || typeof cs !== 'object') return !!def;
      if (!Object.prototype.hasOwnProperty.call(cs, k)) return !!def;
      return !!cs[k];
    };

    const csStr = (k) => {
      if (!cs || typeof cs !== 'object') return '';
      const v = cs[k];
      return (v == null) ? '' : String(v).trim();
    };

    const csMode = (k) => {
      const v = cs[k];
      const s = (v == null) ? '' : String(v).trim().toUpperCase();
      return s || '';
    };

    // Map: client_settings â†’ contract fields
    // NOTE: this is staging-only; parent Save persists it.
    let changed = false;

    changed = setMainTriBool('is_nhsp',               csBool('is_nhsp', false)) || changed;
    changed = setMainTriBool('autoprocess_hr',        csBool('autoprocess_hr', false)) || changed;
    changed = setMainTriBool('requires_hr',           csBool('requires_hr', false)) || changed;
    changed = setMainTriBool('no_timesheet_required', csBool('no_timesheet_required', false)) || changed;

    changed = setMainTriBool('daily_calc_of_invoices', csBool('daily_calc_of_invoices', false)) || changed;
    changed = setMainTriBool('group_nightsat_sunbh',   csBool('group_nightsat_sunbh', false)) || changed;

    // client setting name: self_bill_no_invoices_sent
    changed = setMainTriBool('self_bill', csBool('self_bill_no_invoices_sent', false)) || changed;

    // references (client settings names)
    changed = setMainTriBool('require_reference_to_pay',     csBool('pay_reference_required', false)) || changed;
    changed = setMainTriBool('require_reference_to_invoice', csBool('invoice_reference_required', false)) || changed;

    // attachments
    changed = setMainTriBool('hr_attach_to_invoice', csBool('hr_attach_to_invoice', true)) || changed;
    changed = setMainTriBool('ts_attach_to_invoice', csBool('ts_attach_to_invoice', true)) || changed;

    // auto-invoice default (client-level default)
    changed = setMainTriBool('auto_invoice', csBool('auto_invoice_default', false)) || changed;

    // NEW: ref required to ISSUE invoice (client-level value exists; contract will override)
    changed = setMainTriBool('reference_number_required_to_issue_invoice', csBool('reference_number_required_to_issue_invoice', false)) || changed;

    // NEW: manual invoice email routing (contract-level)
    changed = setMainTriBool('send_manual_invoices_to_different_email', csBool('send_manual_invoices_to_different_email', false)) || changed;
    const altEmail = csStr('manual_invoices_alt_email_address');
    changed = setMainTriString('manual_invoices_alt_email_address', altEmail ? altEmail : null) || changed;

    // NEW: default submission mode (nullable, â€œinheritâ€ option)
    const dsm = csMode('default_submission_mode');
    changed = setMainTriUpper('default_submission_mode', dsm ? dsm : null) || changed;

    // Canonicalise route flags exactly as per existing contract settings rules
    const isNhsp = !!boolish(fs.main.is_nhsp);
    const isHr   = !!boolish(fs.main.autoprocess_hr);
    const noTs   = !!boolish(fs.main.no_timesheet_required);

    if (isNhsp) {
      changed = setMainTriBool('autoprocess_hr', false) || changed;
      changed = setMainTriBool('no_timesheet_required', false) || changed;
      changed = setMainTriBool('requires_hr', false) || changed;
    } else if (isHr) {
      changed = setMainTriBool('is_nhsp', false) || changed;
      if (noTs) {
        changed = setMainTriBool('requires_hr', false) || changed;
      } else {
        changed = setMainTriBool('requires_hr', true) || changed;
        changed = setMainTriBool('no_timesheet_required', false) || changed;
      }
    } else {
      changed = setMainTriBool('is_nhsp', false) || changed;
      changed = setMainTriBool('no_timesheet_required', false) || changed;
      changed = setMainTriBool('requires_hr', false) || changed;
    }

    return changed;
  };

  // --- Effective value computation (for rendering) ---
  const computeEffective = () => {
    const cs = getClientSettingsSnapshot();
    const contractClientId = String(base.client_id || '') || null;

    const overrideOn = !!boolish(getMainRaw('overrideclientsettings'));

    const csBool = (k, def = false) => {
      if (!cs || typeof cs !== 'object') return !!def;
      if (!Object.prototype.hasOwnProperty.call(cs, k)) return !!def;
      return !!cs[k];
    };

    const csStr = (k) => {
      if (!cs || typeof cs !== 'object') return '';
      const v = cs[k];
      return (v == null) ? '' : String(v).trim();
    };

    const csUpper = (k) => {
      const v = cs ? cs[k] : null;
      const s = (v == null) ? '' : String(v).trim().toUpperCase();
      return s || '';
    };

    // Resolve effective flags
    const eff = {};

    // Route flags
    if (overrideOn) {
      eff.is_nhsp               = (triBool(getMainRaw('is_nhsp'))               ?? false);
      eff.autoprocess_hr        = (triBool(getMainRaw('autoprocess_hr'))        ?? false);
      eff.no_timesheet_required = (triBool(getMainRaw('no_timesheet_required')) ?? false);
      eff.requires_hr           = (triBool(getMainRaw('requires_hr'))           ?? false);
    } else {
      eff.is_nhsp               = csBool('is_nhsp', false);
      eff.autoprocess_hr        = csBool('autoprocess_hr', false);
      eff.no_timesheet_required = csBool('no_timesheet_required', false);
      eff.requires_hr           = csBool('requires_hr', false);
    }

    // Non-route flags
    if (overrideOn) {
      eff.require_reference_to_pay     = (triBool(getMainRaw('require_reference_to_pay'))     ?? false);
      eff.require_reference_to_invoice = (triBool(getMainRaw('require_reference_to_invoice')) ?? false);

      eff.self_bill              = (triBool(getMainRaw('self_bill'))              ?? false);
      eff.daily_calc_of_invoices = (triBool(getMainRaw('daily_calc_of_invoices')) ?? false);
      eff.group_nightsat_sunbh   = (triBool(getMainRaw('group_nightsat_sunbh'))   ?? false);

      eff.auto_invoice           = (triBool(getMainRaw('auto_invoice'))           ?? false);

      eff.hr_attach_to_invoice   = (triBool(getMainRaw('hr_attach_to_invoice'))   ?? false);
      eff.ts_attach_to_invoice   = (triBool(getMainRaw('ts_attach_to_invoice'))   ?? false);

      // NEW fields
      eff.reference_number_required_to_issue_invoice =
        (triBool(getMainRaw('reference_number_required_to_issue_invoice')) ?? false);

      eff.send_manual_invoices_to_different_email =
        (triBool(getMainRaw('send_manual_invoices_to_different_email')) ?? false);

      eff.manual_invoices_alt_email_address =
        (triString(getMainRaw('manual_invoices_alt_email_address')) ?? '');

      eff.default_submission_mode =
        (triUpperOrNull(getMainRaw('default_submission_mode')) ?? null);

    } else {
      // inherited from client settings snapshot
      eff.require_reference_to_pay     = csBool('pay_reference_required', false);
      eff.require_reference_to_invoice = csBool('invoice_reference_required', false);

      eff.self_bill              = csBool('self_bill_no_invoices_sent', false);
      eff.daily_calc_of_invoices = csBool('daily_calc_of_invoices', false);
      eff.group_nightsat_sunbh   = csBool('group_nightsat_sunbh', false);

      eff.auto_invoice           = csBool('auto_invoice_default', false);

      eff.hr_attach_to_invoice   = csBool('hr_attach_to_invoice', true);
      eff.ts_attach_to_invoice   = csBool('ts_attach_to_invoice', true);

      // NEW inherited fields
      eff.reference_number_required_to_issue_invoice =
        csBool('reference_number_required_to_issue_invoice', false);

      eff.send_manual_invoices_to_different_email =
        csBool('send_manual_invoices_to_different_email', false);

      eff.manual_invoices_alt_email_address =
        csStr('manual_invoices_alt_email_address');

      eff.default_submission_mode =
        (csUpper('default_submission_mode') || null);
    }

    const weeklyMode =
      eff.is_nhsp ? 'NHSP' : (eff.autoprocess_hr ? 'HEALTHROSTER' : 'NONE');

    const hrMode =
      (eff.autoprocess_hr && eff.no_timesheet_required) ? 'NO_TS' : 'REQUIRE_TS';

    return {
      cs,
      contractClientId,
      snapshotClientId: getClientSettingsClientId(),
      hasSnapshot: !!(cs && typeof cs === 'object'),
      overrideOn,
      weeklyMode,
      hrMode,
      isHrCreate: (weeklyMode === 'HEALTHROSTER' && hrMode === 'NO_TS'),
      eff
    };
  };

  // --- Render HTML (self-contained; does not rely on renderContractSettingsModal) ---
  const renderHtml = () => {
    const st = computeEffective();
    const { hasSnapshot, overrideOn, weeklyMode, hrMode, isHrCreate, eff } = st;

    // âœ… Critical gating:
    // - viewOnly => everything disabled
    // - override OFF (in edit mode) => only override checkbox enabled, everything else disabled
    const disabledAll = viewOnly ? 'disabled' : '';
    const disabledIfInherit = (!overrideOn || viewOnly) ? 'disabled' : '';

    const hint = viewOnly
      ? `View-only. You cannot change contract settings here.`
      : (!hasSnapshot
          ? `Client settings snapshot is not available. Pick a client (or reopen the contract) to enable seeding when overriding.`
          : (overrideOn
              ? `Override is ON. Changes here are staged and applied when you Save the contract.`
              : `Override is OFF. Only the override checkbox is editable. Tick â€œOverride client settingsâ€ to stage contract-specific values.`));

    const radioPill = (name, value, text, checked, disabledAttr) => `
      <label class="inline chk-tight"
        style="display:inline-flex;align-items:center;gap:6px;margin-right:10px;white-space:nowrap;opacity:${disabledAttr ? '0.7' : '1'};">
        <input type="radio" name="${name}" value="${value}" ${checked ? 'checked' : ''} ${disabledAttr}/>
        <span style="white-space:nowrap;">${text}</span>
      </label>
    `;

    const radioChoice = (name, value, title, desc, checked, disabledAttr) => `
      <label style="
        display:grid;
        grid-template-columns: 18px 1fr;
        column-gap:8px;
        row-gap:4px;
        align-items:start;
        cursor:pointer;
        margin:0;
        opacity:${disabledAttr ? '0.7' : '1'};
      ">
        <input type="radio" name="${name}" value="${value}" ${checked ? 'checked' : ''} ${disabledAttr} style="margin-top:2px;" />
        <div style="min-width:0;">
          <div style="line-height:1.2;white-space:normal;word-break:normal;overflow-wrap:break-word;">${title}</div>
          ${desc ? `<div class="mini" style="opacity:0.9;line-height:1.25;white-space:normal;word-break:normal;overflow-wrap:break-word;">${desc}</div>` : ``}
        </div>
      </label>
    `;

    const checkChoice = (name, title, checked, disabledAttr) => `
      <label style="
        display:grid;
        grid-template-columns: 18px 1fr;
        column-gap:8px;
        align-items:start;
        cursor:pointer;
        margin:0;
        opacity:${disabledAttr ? '0.7' : '1'};
      ">
        <input type="checkbox" name="${name}" ${checked ? 'checked' : ''} ${disabledAttr} style="margin-top:2px;" />
        <div style="line-height:1.2;white-space:normal;word-break:normal;overflow-wrap:break-word;min-width:0;">${title}</div>
      </label>
    `;

    const showNhsp   = (weeklyMode === 'NHSP');
    const showManual = (weeklyMode === 'NONE');
    const showHr     = (weeklyMode === 'HEALTHROSTER');
    const showHrTsAttach = showHr && !isHrCreate;

    // default_submission_mode: allow â€œinheritâ€ (NULL) option
    const dsmVal = eff.default_submission_mode ? String(eff.default_submission_mode).toUpperCase() : '';

    // manual invoices alt email input enable
    const manualEmailEnabled = !!eff.send_manual_invoices_to_different_email;
    const altEmailVal = String(eff.manual_invoices_alt_email_address || '');

    return `
      <form id="contractSettingsForm" class="tabc form">

        ${hint ? `
          <div class="alert alert-warning py-2 px-2 small" style="margin-bottom:12px;">
            ${escapeHtml(hint)}
          </div>
        ` : ''}

        <div class="row" style="margin:0;">
          <label style="white-space:normal">Override client settings</label>
          <div class="controls" style="display:flex;flex-direction:column;gap:8px;min-width:0;">
            <div style="display:flex;align-items:center;gap:10px;flex-wrap:wrap;">
              <label class="inline chk-tight" style="display:inline-flex;align-items:center;gap:6px;white-space:nowrap;">
                <input type="checkbox" name="overrideclientsettings" ${overrideOn ? 'checked' : ''} ${disabledAll}/>
                <span>Override client settings for this contract</span>
              </label>
              <span class="mini" style="opacity:0.8;">(Staged only until you Save the contract)</span>
            </div>
          </div>
        </div>

        <div class="row" style="margin-top:12px;">
          <label style="white-space:normal">Weekly timesheet source</label>
          <div class="controls" style="display:flex;flex-direction:column;gap:8px;min-width:0;">
            <div style="display:flex;flex-wrap:wrap;gap:10px;align-items:center;">
              ${radioPill('weekly_mode', 'NONE', 'None (manual)', weeklyMode === 'NONE', disabledIfInherit)}
              ${radioPill('weekly_mode', 'NHSP', 'NHSP', weeklyMode === 'NHSP', disabledIfInherit)}
              ${radioPill('weekly_mode', 'HEALTHROSTER', 'HealthRoster', weeklyMode === 'HEALTHROSTER', disabledIfInherit)}
            </div>

            <div id="contractWeeklyMsg" class="mini" style="opacity:0.9;line-height:1.25;white-space:normal;overflow-wrap:break-word;">
              ${
                weeklyMode === 'NONE'
                  ? 'Weekly timesheets are managed manually (no external weekly import source). Candidates will submit timesheets electronically or using a QR Timesheet.'
                  : weeklyMode === 'NHSP'
                  ? 'NHSP weekly imports will be used for this contract. Candidates will not submit any timesheets.'
                  : 'HealthRoster weekly imports will be used for this contract.'
              }
            </div>
          </div>
        </div>

        <div id="contractHrModeWrap" style="display:${showHr ? '' : 'none'};">
          <div class="row" style="margin-top:12px;">
            <label style="white-space:normal">Weekly HealthRoster behaviour</label>
            <div class="controls" style="display:flex;flex-direction:column;gap:12px;min-width:0;">
              ${radioChoice(
                'hr_timesheet_mode',
                'REQUIRE_TS',
                'Worker will provide timesheets; the agency will also import healthroster data to verify workers hours',
                'Import will validate that HealthRoster hours match the workerâ€™s weekly timesheet. Mismatches fail validation and healthroster or timesheet will need amending before it can be paid.',
                hrMode === 'REQUIRE_TS',
                disabledIfInherit
              )}
              ${radioChoice(
                'hr_timesheet_mode',
                'NO_TS',
                'Worker will not provide timesheets; imports create them if a contract exists',
                'Import will create/update weekly timesheets from HealthRoster hours when a contract exists. Healthroster hours will not require any seperate checks.',
                hrMode === 'NO_TS',
                disabledIfInherit
              )}
            </div>
          </div>
        </div>

        <div class="row" style="margin-top:12px;">
          <label style="white-space:normal">References & flags</label>
          <div class="controls" style="display:flex;flex-direction:column;gap:12px;min-width:0;">

            <!-- default submission mode (nullable / inherit) -->
            <div id="contractDefaultSubmissionModeRow" style="margin-bottom:6px; display:${(showNhsp || isHrCreate) ? 'none' : ''};">
              <div class="mini" style="opacity:0.85;margin-bottom:6px;">Default submission mode</div>
              <select name="default_submission_mode" class="form-select form-select-sm" ${disabledIfInherit}>
                <option value="" ${dsmVal === '' ? 'selected' : ''}>Inherit (client default)</option>
                <option value="ELECTRONIC" ${dsmVal === 'ELECTRONIC' ? 'selected' : ''}>Electronic</option>
                <option value="MANUAL" ${dsmVal === 'MANUAL' ? 'selected' : ''}>Manual</option>
              </select>
            </div>

            <!-- ref required to ISSUE invoice -->
            <div style="display:grid;grid-template-columns:1fr;gap:8px;">
              ${checkChoice(
                'reference_number_required_to_issue_invoice',
                'Ref No. required to ISSUE invoice',
                !!eff.reference_number_required_to_issue_invoice,
                disabledIfInherit
              )}
            </div>

            <!-- manual invoice email routing -->
            <div style="display:grid;grid-template-columns:1fr;gap:8px;margin-top:6px;">
              ${checkChoice(
                'send_manual_invoices_to_different_email',
                'Send manual/QR adjustment invoices to a different email address',
                !!eff.send_manual_invoices_to_different_email,
                disabledIfInherit
              )}
              <div style="margin-left:24px;opacity:${(!manualEmailEnabled || disabledIfInherit) ? '0.65' : '1'};">
                <div class="mini" style="opacity:0.85;margin-bottom:6px;">Alternate email</div>
                <input type="text"
                  name="manual_invoices_alt_email_address"
                  class="form-control form-control-sm"
                  value="${escapeHtml(altEmailVal)}"
                  placeholder="e.g. accounts@client.nhs.uk"
                  ${(!manualEmailEnabled || disabledIfInherit) ? 'disabled' : ''}
                />
              </div>
            </div>

            <!-- NHSP -->
            <div id="contractFlagsNHSP" style="display:${showNhsp ? '' : 'none'};">
              <div class="mini" style="opacity:0.9;line-height:1.25;white-space:normal;overflow-wrap:break-word;">
                NHSP mode controls references, invoicing behaviour and attachments automatically.
              </div>
              <div style="display:grid;grid-template-columns:1fr;gap:8px;margin-top:10px;">
                ${checkChoice('auto_invoice', 'Auto-invoice (this contract)', !!eff.auto_invoice, disabledIfInherit)}
              </div>
            </div>

            <!-- MANUAL -->
            <div id="contractFlagsManual" style="display:${showManual ? '' : 'none'};">
              <div style="display:grid;grid-template-columns:1fr;gap:8px;">
                ${checkChoice('require_reference_to_pay', 'Ref No. required to PAY', !!eff.require_reference_to_pay, disabledIfInherit)}
                ${checkChoice('require_reference_to_invoice', 'Ref No. required to INVOICE', !!eff.require_reference_to_invoice, disabledIfInherit)}
              </div>

              <div style="display:grid;grid-template-columns:1fr;gap:8px;margin-top:10px;">
                ${checkChoice('self_bill', 'Self-bill (no invoices sent)', !!eff.self_bill, disabledIfInherit)}
                ${checkChoice('daily_calc_of_invoices', 'Daily invoice calculation', !!eff.daily_calc_of_invoices, disabledIfInherit)}
                ${checkChoice('group_nightsat_sunbh', 'Group Night/Sat/Sun/BH', !!eff.group_nightsat_sunbh, disabledIfInherit)}
                ${checkChoice('auto_invoice', 'Auto-invoice (this contract)', !!eff.auto_invoice, disabledIfInherit)}
              </div>

              <div class="mini" style="opacity:0.9;line-height:1.25;white-space:normal;overflow-wrap:break-word;margin-top:10px;">
                Timesheets will always be attached to invoices for manual clients.
              </div>
            </div>

            <!-- HEALTHROSTER -->
            <div id="contractFlagsHR" style="display:${showHr ? '' : 'none'};">
              <div style="display:grid;grid-template-columns:1fr;gap:8px;">
                ${checkChoice('self_bill', 'Self-bill (no invoices sent)', !!eff.self_bill, disabledIfInherit)}
                ${checkChoice('daily_calc_of_invoices', 'Daily invoice calculation', !!eff.daily_calc_of_invoices, disabledIfInherit)}
                ${checkChoice('group_nightsat_sunbh', 'Group Night/Sat/Sun/BH', !!eff.group_nightsat_sunbh, disabledIfInherit)}
                ${checkChoice('auto_invoice', 'Auto-invoice (this contract)', !!eff.auto_invoice, disabledIfInherit)}
              </div>

              <div style="display:grid;grid-template-columns:1fr;gap:8px;margin-top:10px;">
                ${checkChoice('hr_attach_to_invoice', 'Attach HealthRoster to invoice', !!eff.hr_attach_to_invoice, disabledIfInherit)}
                <div id="contractTsAttachRow" style="display:${showHrTsAttach ? '' : 'none'};">
                  ${checkChoice('ts_attach_to_invoice', 'Attach timesheets to invoice', !!eff.ts_attach_to_invoice, disabledIfInherit)}
                </div>
              </div>
            </div>

            <div class="mini" style="opacity:0.8;line-height:1.25;white-space:normal;overflow-wrap:break-word;">
              Day/night boundary time settings remain client-level and are not shown here.
            </div>

          </div>
        </div>

      </form>
    `;
  };

  // --- Apply staging from DOM ---
  const applyFromDOM = (root, opts = {}) => {
    if (!root) return false;
    const initial = !!opts.initial;

    // âœ… If view-only, never stage changes.
    if (viewOnly) return false;

    const beforeOverride = !!boolish(getMainRaw('overrideclientsettings'));
    const overrideChecked = !!root.querySelector('input[type="checkbox"][name="overrideclientsettings"]')?.checked;

    let changed = false;

    // Toggle override: OFF â†’ ON seeds from snapshot (unless stash restore), ON â†’ OFF clears to NULL (stash saved)
    if (overrideChecked !== beforeOverride) {
      if (overrideChecked) {
        // turning ON
        changed = setMainTriBool('overrideclientsettings', true) || changed;

        const stash = window.modalCtx?.[STASH_KEY];
        if (stash && typeof stash === 'object') {
          // Restore prior override values
          changed = applyOverrideValuesStaged(stash) || changed;
        } else {
          // Seed from client settings snapshot
          const cs = getClientSettingsSnapshot();
          if (!cs) {
            alert('Cannot enable override: client settings snapshot is missing. Pick a client (or reopen this contract) first.');
            try { root.querySelector('input[name="overrideclientsettings"]').checked = false; } catch {}
            changed = setMainTriBool('overrideclientsettings', false) || changed;
            return false;
          }
          changed = seedFromClientSettingsSnapshot(cs) || changed;
        }
      } else {
        // turning OFF
        try {
          window.modalCtx[STASH_KEY] = captureOverrideValuesAsStaged();
        } catch {}

        changed = setMainTriBool('overrideclientsettings', false) || changed;
        changed = clearOverrideValuesToNull() || changed;
      }
    }

    const overrideOnNow = !!boolish(getMainRaw('overrideclientsettings'));

    // If override is OFF, nothing else is staged (inherit). Do not mark dirty on initial paint.
    if (!overrideOnNow) {
      if (!initial && changed) setContractDirtyIfChanged(true);
      return !!changed;
    }

    // Read UI selection (enabled only when overrideOnNow)
    const weekly = String(root.querySelector('input[type="radio"][name="weekly_mode"]:checked')?.value || 'NONE').toUpperCase();
    const hrMode = String(root.querySelector('input[type="radio"][name="hr_timesheet_mode"]:checked')?.value || 'REQUIRE_TS').toUpperCase();
    const isHrCreate = (weekly === 'HEALTHROSTER' && hrMode === 'NO_TS');

    // Route canonicalisation
    if (weekly === 'NHSP') {
      changed = setMainTriBool('is_nhsp', true) || changed;
      changed = setMainTriBool('autoprocess_hr', false) || changed;
      changed = setMainTriBool('no_timesheet_required', false) || changed;
      changed = setMainTriBool('requires_hr', false) || changed;
    } else if (weekly === 'HEALTHROSTER') {
      changed = setMainTriBool('is_nhsp', false) || changed;
      changed = setMainTriBool('autoprocess_hr', true) || changed;
      if (isHrCreate) {
        changed = setMainTriBool('no_timesheet_required', true) || changed;
        changed = setMainTriBool('requires_hr', false) || changed;
      } else {
        changed = setMainTriBool('no_timesheet_required', false) || changed;
        changed = setMainTriBool('requires_hr', true) || changed;
      }
    } else {
      changed = setMainTriBool('is_nhsp', false) || changed;
      changed = setMainTriBool('autoprocess_hr', false) || changed;
      changed = setMainTriBool('no_timesheet_required', false) || changed;
      changed = setMainTriBool('requires_hr', false) || changed;
    }

    // Auto-invoice (user-controlled)
    changed = setMainTriBool('auto_invoice', !!root.querySelector('input[type="checkbox"][name="auto_invoice"]')?.checked) || changed;

    // Default submission mode (nullable / inherit)
    const dsmSel = root.querySelector('select[name="default_submission_mode"]');
    if (weekly === 'NHSP' || (weekly === 'HEALTHROSTER' && isHrCreate) || !dsmSel) {
      changed = setMainTriUpper('default_submission_mode', null) || changed;
    } else {
      const v = String(dsmSel.value || '').trim().toUpperCase();
      changed = setMainTriUpper('default_submission_mode', v ? v : null) || changed;
    }

    // Ref required to ISSUE invoice
    changed = setMainTriBool(
      'reference_number_required_to_issue_invoice',
      !!root.querySelector('input[type="checkbox"][name="reference_number_required_to_issue_invoice"]')?.checked
    ) || changed;

    // Manual invoice email routing
    const sendManual = !!root.querySelector('input[type="checkbox"][name="send_manual_invoices_to_different_email"]')?.checked;
    changed = setMainTriBool('send_manual_invoices_to_different_email', sendManual) || changed;

    const altEmailEl = root.querySelector('input[name="manual_invoices_alt_email_address"]');
    const altEmail = altEmailEl ? String(altEmailEl.value || '').trim() : '';
    changed = setMainTriString('manual_invoices_alt_email_address', sendManual ? (altEmail || '') : null) || changed;

    // Route-specific forced flags
    if (weekly === 'NHSP') {
      changed = setMainTriBool('require_reference_to_pay', false) || changed;
      changed = setMainTriBool('require_reference_to_invoice', false) || changed;

      changed = setMainTriBool('self_bill', true) || changed;
      changed = setMainTriBool('daily_calc_of_invoices', true) || changed;
      changed = setMainTriBool('group_nightsat_sunbh', false) || changed;

      changed = setMainTriBool('hr_attach_to_invoice', false) || changed;
      changed = setMainTriBool('ts_attach_to_invoice', false) || changed;
    }

    if (weekly === 'NONE') {
      changed = setMainTriBool('require_reference_to_pay', !!root.querySelector('input[type="checkbox"][name="require_reference_to_pay"]')?.checked) || changed;
      changed = setMainTriBool('require_reference_to_invoice', !!root.querySelector('input[type="checkbox"][name="require_reference_to_invoice"]')?.checked) || changed;

      changed = setMainTriBool('self_bill', !!root.querySelector('input[type="checkbox"][name="self_bill"]')?.checked) || changed;
      changed = setMainTriBool('daily_calc_of_invoices', !!root.querySelector('input[type="checkbox"][name="daily_calc_of_invoices"]')?.checked) || changed;
      changed = setMainTriBool('group_nightsat_sunbh', !!root.querySelector('input[type="checkbox"][name="group_nightsat_sunbh"]')?.checked) || changed;

      // forced attachments
      changed = setMainTriBool('hr_attach_to_invoice', false) || changed;
      changed = setMainTriBool('ts_attach_to_invoice', true) || changed;
    }

    if (weekly === 'HEALTHROSTER') {
      changed = setMainTriBool('require_reference_to_pay', false) || changed;
      changed = setMainTriBool('require_reference_to_invoice', false) || changed;

      changed = setMainTriBool('self_bill', !!root.querySelector('input[type="checkbox"][name="self_bill"]')?.checked) || changed;
      changed = setMainTriBool('daily_calc_of_invoices', !!root.querySelector('input[type="checkbox"][name="daily_calc_of_invoices"]')?.checked) || changed;
      changed = setMainTriBool('group_nightsat_sunbh', !!root.querySelector('input[type="checkbox"][name="group_nightsat_sunbh"]')?.checked) || changed;

      changed = setMainTriBool('hr_attach_to_invoice', !!root.querySelector('input[type="checkbox"][name="hr_attach_to_invoice"]')?.checked) || changed;

      if (isHrCreate) {
        changed = setMainTriBool('ts_attach_to_invoice', false) || changed;
      } else {
        changed = setMainTriBool('ts_attach_to_invoice', !!root.querySelector('input[type="checkbox"][name="ts_attach_to_invoice"]')?.checked) || changed;
      }
    }

    if (!initial && changed) setContractDirtyIfChanged(true);
    return !!changed;
  };

  const wire = () => {
    const root = document.getElementById('contractSettingsForm');
    if (!root || root.__wired) return;
    root.__wired = true;

    const rerenderSelf = () => {
      try {
        const fr = (typeof window.__getModalFrame === 'function') ? window.__getModalFrame() : null;
        if (fr && fr.kind === 'contract_settings') {
          fr._suppressDirty = true;
          fr.setTab(fr.currentTabKey || 'settings');
          fr._suppressDirty = false;
          fr._updateButtons && fr._updateButtons();
        }
      } catch {}
    };

    const onAnyChange = () => {
      // âœ… View-only means nothing in the form should stage.
      if (viewOnly) return;

      const did = applyFromDOM(root, { initial: false });
      if (did) rerenderSelf();
    };

    root.addEventListener('change', onAnyChange, true);
    root.addEventListener('input',  onAnyChange, true);

    // Initial canonicalise WITHOUT dirty
    try { applyFromDOM(root, { initial: true }); } catch {}
  };

  showModal(
    'Contract settings',
    [{ key: 'settings', title: 'Settings' }],
    (key) => {
      if (key !== 'settings') return `<div class="tabc">Unknown tab.</div>`;
      return renderHtml();
    },
    viewOnly ? null : async () => {
      // Apply once more on Apply, then close (staging only; parent Save persists)
      const root = document.getElementById('contractSettingsForm');
      applyFromDOM(root, { initial: false });

      // If override is OFF at Apply time, forget the old override values (per brief)
      try {
        const overrideOn = !!boolish(getMainRaw('overrideclientsettings'));
        if (!overrideOn && window.modalCtx && window.modalCtx[STASH_KEY]) {
          delete window.modalCtx[STASH_KEY];
        }
      } catch {}

      return { ok: true, saved: null };
    },
    viewOnly ? true : false,
    null,
    {
      kind: 'contract_settings',
      noParentGate: !!viewOnly,
      showSave: viewOnly ? false : undefined,
      _trace: (LOGC && { tag: 'contract-settings', contract_id: window.modalCtx?.data?.id || null })
    }
  );

  setTimeout(() => {
    try { wire(); } catch (e) { if (LOGC) console.warn('[CONTRACT_SETTINGS] wire failed', e); }
  }, 0);
}


function renderContractSettingsModal(ctx) {
  const LOGC = (typeof window.__LOG_CONTRACTS === 'boolean') ? window.__LOG_CONTRACTS : true;

  const d = (typeof mergeContractStateIntoRow === 'function')
    ? mergeContractStateIntoRow(ctx?.data || {})
    : (ctx?.data || {});

  const isNhsp = !!d.is_nhsp;
  const isHr   = !!d.autoprocess_hr;
  const noTs   = !!d.no_timesheet_required;

  const weeklyMode = isNhsp ? 'NHSP' : (isHr ? 'HEALTHROSTER' : 'NONE');
  const hrMode     = (isHr && noTs) ? 'NO_TS' : 'REQUIRE_TS';

  const radioPill = (name, value, text, checked) => `
    <label class="inline chk-tight"
      style="display:inline-flex;align-items:center;gap:6px;margin-right:10px;white-space:nowrap;">
      <input type="radio" name="${name}" value="${value}" ${checked ? 'checked' : ''}/>
      <span style="white-space:nowrap;">${text}</span>
    </label>
  `;

  const radioChoice = (name, value, title, desc, checked) => `
    <label style="
      display:grid;
      grid-template-columns: 18px 1fr;
      column-gap:8px;
      row-gap:4px;
      align-items:start;
      cursor:pointer;
      margin:0;
    ">
      <input type="radio" name="${name}" value="${value}" ${checked ? 'checked' : ''} style="margin-top:2px;" />
      <div style="min-width:0;">
        <div style="line-height:1.2;white-space:normal;word-break:normal;overflow-wrap:break-word;">${title}</div>
        ${desc ? `<div class="mini" style="opacity:0.9;line-height:1.25;white-space:normal;word-break:normal;overflow-wrap:break-word;">${desc}</div>` : ``}
      </div>
    </label>
  `;

  const checkChoice = (name, title, checked) => `
    <label style="
      display:grid;
      grid-template-columns: 18px 1fr;
      column-gap:8px;
      align-items:start;
      cursor:pointer;
      margin:0;
    ">
      <input type="checkbox" name="${name}" ${checked ? 'checked' : ''} style="margin-top:2px;" />
      <div style="line-height:1.2;white-space:normal;word-break:normal;overflow-wrap:break-word;min-width:0;">${title}</div>
    </label>
  `;

  if (LOGC) console.log('[CONTRACT_SETTINGS] render snapshot', {
    weeklyMode, hrMode,
    flags: {
      require_reference_to_pay: !!d.require_reference_to_pay,
      require_reference_to_invoice: !!d.require_reference_to_invoice,
      self_bill: !!d.self_bill,
      daily_calc_of_invoices: !!d.daily_calc_of_invoices,
      group_nightsat_sunbh: !!d.group_nightsat_sunbh,
      auto_invoice: !!d.auto_invoice,
      hr_attach_to_invoice: !!d.hr_attach_to_invoice,
      ts_attach_to_invoice: !!d.ts_attach_to_invoice
    }
  });

  const showNhsp   = (weeklyMode === 'NHSP');
  const showManual = (weeklyMode === 'NONE');
  const showHr     = (weeklyMode === 'HEALTHROSTER');
  const showHrTsAttach = showHr && (hrMode !== 'NO_TS');

  return `
    <form id="contractSettingsForm" class="tabc form">

      <div class="row" style="margin:0;">
        <label style="white-space:normal">Weekly timesheet source</label>
        <div class="controls" style="display:flex;flex-direction:column;gap:8px;min-width:0;">
          <div style="display:flex;flex-wrap:wrap;gap:10px;align-items:center;">
            ${radioPill('weekly_mode', 'NONE', 'None (manual)', weeklyMode === 'NONE')}
            ${radioPill('weekly_mode', 'NHSP', 'NHSP', weeklyMode === 'NHSP')}
            ${radioPill('weekly_mode', 'HEALTHROSTER', 'HealthRoster', weeklyMode === 'HEALTHROSTER')}
          </div>
          <div id="contractWeeklyMsg" class="mini" style="opacity:0.9;line-height:1.25;white-space:normal;overflow-wrap:break-word;">
            ${
              weeklyMode === 'NONE'
                ? 'Weekly timesheets are managed manually (no external weekly import source). Candidates will submit timesheets electronically or using a QR Timesheet.'
                : weeklyMode === 'NHSP'
                ? 'NHSP weekly imports will be used for this contract. Candidates will not submit any timesheets.'
                : 'HealthRoster weekly imports will be used for this contract.'
            }
          </div>
        </div>
      </div>

      <div id="contractHrModeWrap" style="display:${showHr ? '' : 'none'};">
        <div class="row" style="margin-top:12px;">
          <label style="white-space:normal">Weekly HealthRoster behaviour</label>
          <div class="controls" style="display:flex;flex-direction:column;gap:12px;min-width:0;">
            ${radioChoice(
              'hr_timesheet_mode',
              'REQUIRE_TS',
              'Worker will provide timesheets; the agency will also import healthroster data to verify workers hours',
              'Import will validate that HealthRoster hours match the workerâ€™s weekly timesheet. Mismatches fail validation and healthroster or timesheet will need amending before it can be paid.',
              hrMode === 'REQUIRE_TS'
            )}
            ${radioChoice(
              'hr_timesheet_mode',
              'NO_TS',
              'Worker will not provide timesheets; imports create them if a contract exists',
              'Import will create/update weekly timesheets from HealthRoster hours when a contract exists. Healthroster hours will not require any seperate checks.',
              hrMode === 'NO_TS'
            )}
          </div>
        </div>
      </div>

      <div class="row" style="margin-top:12px;">
        <label style="white-space:normal">References & flags</label>
        <div class="controls" style="display:flex;flex-direction:column;gap:12px;min-width:0;">

          <!-- NHSP -->
          <div id="contractFlagsNHSP" style="display:${showNhsp ? '' : 'none'};">
            <div class="mini" style="opacity:0.9;line-height:1.25;white-space:normal;overflow-wrap:break-word;">
              NHSP mode controls references, invoicing behaviour and attachments automatically.
            </div>
            <div style="display:grid;grid-template-columns:1fr;gap:8px;margin-top:10px;">
              ${checkChoice('auto_invoice', 'Auto-invoice (this contract)', !!d.auto_invoice)}
            </div>
          </div>

          <!-- MANUAL -->
          <div id="contractFlagsManual" style="display:${showManual ? '' : 'none'};">
            <div style="display:grid;grid-template-columns:1fr;gap:8px;">
              ${checkChoice('require_reference_to_pay', 'Ref No. required to PAY', !!d.require_reference_to_pay)}
              ${checkChoice('require_reference_to_invoice', 'Ref No. required to INVOICE', !!d.require_reference_to_invoice)}
            </div>

            <div style="display:grid;grid-template-columns:1fr;gap:8px;margin-top:10px;">
              ${checkChoice('self_bill', 'Self-bill (no invoices sent)', !!d.self_bill)}
              ${checkChoice('daily_calc_of_invoices', 'Daily invoice calculation', !!d.daily_calc_of_invoices)}
              ${checkChoice('group_nightsat_sunbh', 'Group Night/Sat/Sun/BH', !!d.group_nightsat_sunbh)}
              ${checkChoice('auto_invoice', 'Auto-invoice (this contract)', !!d.auto_invoice)}
            </div>

            <div class="mini" style="opacity:0.9;line-height:1.25;white-space:normal;overflow-wrap:break-word;margin-top:10px;">
              Timesheets will always be attached to invoices for manual clients.
            </div>
          </div>

          <!-- HEALTHROSTER -->
          <div id="contractFlagsHR" style="display:${showHr ? '' : 'none'};">
            <div style="display:grid;grid-template-columns:1fr;gap:8px;">
              ${checkChoice('self_bill', 'Self-bill (no invoices sent)', !!d.self_bill)}
              ${checkChoice('daily_calc_of_invoices', 'Daily invoice calculation', !!d.daily_calc_of_invoices)}
              ${checkChoice('group_nightsat_sunbh', 'Group Night/Sat/Sun/BH', !!d.group_nightsat_sunbh)}
              ${checkChoice('auto_invoice', 'Auto-invoice (this contract)', !!d.auto_invoice)}
            </div>

            <div style="display:grid;grid-template-columns:1fr;gap:8px;margin-top:10px;">
              ${checkChoice('hr_attach_to_invoice', 'Attach HealthRoster to invoice', !!d.hr_attach_to_invoice)}
              <div id="contractTsAttachRow" style="display:${showHrTsAttach ? '' : 'none'};">
                ${checkChoice('ts_attach_to_invoice', 'Attach timesheets to invoice', !!d.ts_attach_to_invoice)}
              </div>
            </div>
          </div>

          <div class="mini" style="opacity:0.8;line-height:1.25;white-space:normal;overflow-wrap:break-word;">
            Day/night boundary time settings remain client-level and are not shown here.
          </div>
        </div>
      </div>

    </form>
  `;
}


function snapshotContractForm() {
  const fs = (window.modalCtx.formState ||= { __forId: (window.modalCtx.data?.id ?? window.modalCtx.openToken ?? null), main:{}, pay:{} });

  const form = document.querySelector('#contractForm');
  const fromMain  = form ? Array.from(form.querySelectorAll('input, select, textarea')) : [];

  const ratesTab  = document.querySelector('#contractRatesTab');
  const fromRates = ratesTab ? Array.from(ratesTab.querySelectorAll('input, select, textarea')) : [];

  const all = [...fromMain, ...fromRates];

  for (const el of all) {
    const name = el && el.name;
    if (!name) continue;
    if (el.disabled || el.readOnly || el.dataset.noCollect === 'true') continue;
    if (name === 'ward_hint') continue; // do not stage ward_hint

    let v;
    if (el.type === 'checkbox') {
      v = el.checked ? 'on' : '';
    } else if (el.type === 'radio') {
      if (!el.checked) continue;
      v = el.value;
    } else {
      v = el.value;
    }

    if (name === 'default_pay_method_snapshot') {
      fs.main.pay_method_snapshot = v;
      continue;
    }

    if (/^(paye_|umb_|charge_)/.test(name)) {
      fs.pay[name] = v;
    } else {
      fs.main[name] = v;
    }
  }
}


// Optional helper: align pay_method_snapshot to candidate; return hint if mismatch
function prefillPayMethodFromCandidate(candidate) {
  if (!candidate) return '';
  const method = (candidate.pay_method || candidate.pay_method_snapshot || '').toString().toUpperCase();
  if (!method || (method !== 'PAYE' && method !== 'UMBRELLA')) return '';

  const form = document.querySelector('#contractForm'); if (!form) return '';
  const sel = form.querySelector('select[name="pay_method_snapshot"]');
  if (!sel) return '';

  const current = (sel.value || '').toUpperCase();
  if (current === method) return '';

  // Preselect to match candidate to reduce mistakes (still editable)
  sel.value = method;
  const evt = new Event('change', { bubbles: true });
  sel.dispatchEvent(evt);

  return `Candidate pay method is ${method}; snapshot updated from ${current || 'N/A'}.`;
}

// Optional helper: return a friendly hint if client has no primary invoice email
function checkClientInvoiceEmailPresence(client) {
  if (!client) return '';
  const has = !!(client.primary_invoice_email && String(client.primary_invoice_email).trim());
  return has ? '' : 'Client has no primary invoice email set â€” auto-invoicing may be blocked.';
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// FIX 5: Guide hours UI (std_hours_json) added to Main tab
// (Monâ€“Sun numeric hours; optional, display-only helper)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UPDATED: renderContractMainTab (layout + logs; site under Client, Ward hint to right;
// Role with Band to the right; uses .form to pick up input styling)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function renderContractMainTab(ctx) {
  const LOGC = (typeof window.__LOG_CONTRACTS === 'boolean') ? window.__LOG_CONTRACTS : true;

  const d = mergeContractStateIntoRow(ctx?.data || {});
  const labelsBlock = renderBucketLabelsEditor({ data: d });

  const candVal   = d.candidate_id || '';
  const clientVal = d.client_id || '';

  const candLabel   = (d.candidate_display || '').trim();
  const clientLabel = (d.client_name || '').trim();

  // ---- Route / visibility derived from CONTRACT OVERRIDES first (formState), fallback to loaded row ----
  const fsMain = window.modalCtx?.formState?.main || {};
  const hasOwn = (o, k) => Object.prototype.hasOwnProperty.call(o || {}, k);
  const triVal = (k) => (hasOwn(fsMain, k) && fsMain[k] !== null && fsMain[k] !== undefined) ? fsMain[k] : d[k];

  const isNhsp = !!triVal('is_nhsp');
  const isHr   = !!triVal('autoprocess_hr');
  const noTs   = !!triVal('no_timesheet_required');

  const hideDSM = isNhsp || (isHr && noTs);

  const routeLabel =
    isNhsp ? 'NHSP' :
    (isHr && noTs) ? 'HealthRoster (no timesheets)' :
    (isHr) ? 'HealthRoster (timesheets required)' :
    'Manual';

  // Derive labels from picker cache if missing but ids exist (and store into formState for persistence)
  let derivedCand = '';
  let derivedClient = '';
  try {
    const pickData = (window.__pickerData ||= {});
    if (!candLabel && candVal && pickData.candidates && pickData.candidates.itemsById) {
      const r = pickData.candidates.itemsById[candVal];
      if (r) {
        const first = (r.first_name||'').trim();
        const last  = (r.last_name||'').trim();
        const role  = ((r.roles_display||'').split(/[â€¢;,]/)[0]||'').trim();
        derivedCand = `${last}${last?', ':''}${first}${role?` ${role}`:''}`.trim();
        const fs = (window.modalCtx.formState ||= { __forId:(window.modalCtx.data?.id ?? window.modalCtx.openToken ?? null), main:{}, pay:{} });
        (fs.main ||= {}).candidate_display = derivedCand;
      }
    }
    if (!clientLabel && clientVal && pickData.clients && pickData.clients.itemsById) {
      const r = pickData.clients.itemsById[clientVal];
      if (r) {
        derivedClient = (r.name||'').trim();
        const fs = (window.modalCtx.formState ||= { __forId:(window.modalCtx.data?.id ?? window.modalCtx.openToken ?? null), main:{}, pay:{} });
        (fs.main ||= {}).client_name = derivedClient;
      }
    }
  } catch {}

  const _candLabel   = candLabel   || derivedCand;
  const _clientLabel = clientLabel || derivedClient;

  const toUk = (iso) => {
    try { return (typeof formatIsoToUk === 'function') ? (formatIsoToUk(iso) || '') : (iso || ''); }
    catch { return iso || ''; }
  };
  const startUk = (d.start_date && /^\d{2}\/\d{2}\/\d{4}$/.test(d.start_date)) ? d.start_date : toUk(d.start_date);
  const endUk   = (d.end_date && /^\d{2}\/\d{2}\/\d{4}$/.test(d.end_date)) ? d.end_date : toUk(d.end_date);

  const SS = d.std_schedule_json || {};

  const pick = (day, part) => {
    const staged = d[`${day}_${part}`];
    if (staged !== undefined && staged !== null && String(staged).trim() !== '') return String(staged).trim();
    if (part === 'break') {
      const v = SS?.[day]?.break_minutes;
      return (v === 0 || v) ? String(v) : '';
    }
    return (SS?.[day]?.[part] || '');
  };

  const DAYS = [
    ['mon','Mon'],['tue','Tue'],['wed','Wed'],['thu','Thu'],
    ['fri','Fri'],['sat','Sat'],['sun','Sun']
  ];

  // disable Pay Method snapshot whenever a candidate is present or __pay_locked is set
  const payLocked = !!(d.__pay_locked || d.candidate_id);

  // Inline time normaliser/validator wired on blur + Tab (keydown)
  const timeEvents = () => `
    onblur="(function(el){
      var v=(el.value||'').trim(); v=v.replace(/[^0-9:]/g,'');
      if(!v){ try{ if(typeof setContractFormValue==='function') setContractFormValue(el.name,''); }catch(e){}; return; }
      if(v.indexOf(':')<0){
        if(v.length===3){ v='0'+v; }
        if(v.length!==4){ el.value=''; try{ if(typeof setContractFormValue==='function') setContractFormValue(el.name,''); }catch(e){}; try{ el.dispatchEvent(new Event('input',{bubbles:true})); el.dispatchEvent(new Event('change',{bubbles:true})); }catch(e){}; return; }
        v=v.slice(0,2)+':'+v.slice(2,4);
      }
      var p=v.split(':'), h=parseInt(p[0],10), m=parseInt(p[1],10);
      if(isNaN(h)||isNaN(m)||h<0||h>23||m<0||m>59){ el.value=''; }
      else { el.value=(h<10?'0'+h:h)+':' + (m<10?'0'+m:m); }
      try{ if(typeof setContractFormValue==='function') setContractFormValue(el.name, el.value);}catch(e){}
      try{ el.dispatchEvent(new Event('input',{bubbles:true})); el.dispatchEvent(new Event('change',{bubbles:true})); }catch(e){}
    })(this)"
    onkeydown="if(event.key==='Tab'){ (function(el){
      var v=(el.value||'').trim(); v=v.replace(/[^0-9:]/g,'');
      if(!v){ try{ if(typeof setContractFormValue==='function') setContractFormValue(el.name,''); }catch(e){}; return; }
      if(v.indexOf(':')<0){
        if(v.length===3){ v='0'+v; }
        if(v.length!==4){ el.value=''; try{ if(typeof setContractFormValue==='function') setContractFormValue(el.name,''); }catch(e){}; try{ el.dispatchEvent(new Event('input',{bubbles:true})); el.dispatchEvent(new Event('change',{bubbles:true})); }catch(e){}; return; }
        v=v.slice(0,2)+':'+v.slice(2,4);
      }
      var p=v.split(':'), h=parseInt(p[0],10), m=parseInt(p[1],10);
      if(isNaN(h)||isNaN(m)||h<0||h>23||m<0||m>59){ el.value=''; }
      else { el.value=(h<10?'0'+h:h)+':' + (m<10?'0'+m:m); }
      try{ if(typeof setContractFormValue==='function') setContractFormValue(el.name, el.value);}catch(e){}
      try{ el.dispatchEvent(new Event('input',{bubbles:true})); el.dispatchEvent(new Event('change',{bubbles:true})); }catch(e){}
    })(this) }"
  `;

  const dayRow = (k, label) => {
    const s  = pick(k,'start');
    const e  = pick(k,'end');
    const br = pick(k,'break');
    const num = (v) => (v == null ? '' : String(v));
    return `
      <div class="row sched" data-day="${k}">
        <label>${label}</label>
        <div class="controls" style="display:flex;align-items:flex-end;gap:8px;flex-wrap:wrap">
          <div class="grid-3" style="min-width:420px">
            <div class="split">
              <span class="mini">Start</span>
              <input class="input" name="${k}_start" value="${s}" placeholder="HH:MM" ${timeEvents()} />
            </div>
            <div class="split">
              <span class="mini">End</span>
              <input class="input" name="${k}_end" value="${e}" placeholder="HH:MM" ${timeEvents()} />
            </div>
            <div class="split">
              <span class="mini">Break (min)</span>
              <input class="input" type="number" min="0" step="1" name="${k}_break" value="${num(br)}" placeholder="0"
                oninput="try{ if(typeof setContractFormValue==='function') setContractFormValue(this.name, this.value); }catch(e){}" />
            </div>
          </div>
          <div class="row-actions" style="display:flex;gap:6px">
            <button type="button" class="btn mini"
              title="Copy this rowâ€™s Start/End/Break"
              onclick="(function(){
                try{
                  const f=document.querySelector('#contractForm'); if(!f) return;
                  const s=f['${k}_start']?.value||''; const e=f['${k}_end']?.value||''; const b=f['${k}_break']?.value||'';
                  window.__schedClipboard = { s, e, b };
                  try {
                    var day='${label}';
                    var range=(s||'â€”') + ((s||e)?'â€“':'') + (e||'');
                    var br=(b && String(b).trim()?(' + '+b+'m'):'');
                    if (window.__toast) window.__toast('Copied ' + day + ' ' + range + br);
                  } catch {}
                }catch(e){ console.warn('sched copy failed', e); }
              })()">Copy</button>
            <button type="button" class="btn mini"
              title="Paste to this row"
              onclick="(function(){
                try{
                  const clip = window.__schedClipboard || {};
                  const f=document.querySelector('#contractForm'); if(!f) return;
                  const S=f['${k}_start'], E=f['${k}_end'], B=f['${k}_break'];
                  if(S && clip.s!=null){ S.value = clip.s; S.dispatchEvent(new Event('blur', {bubbles:true})); }
                  if(E && clip.e!=null){ E.value = clip.e; E.dispatchEvent(new Event('blur', {bubbles:true})); }
                  if(B && clip.b!=null){
                    B.value = clip.b;
                    try{ if(typeof setContractFormValue==='function') setContractFormValue(B.name, B.value); }catch(e){}
                    B.dispatchEvent(new Event('input',{bubbles:true})); B.dispatchEvent(new Event('change',{bubbles:true}));
                  }
                }catch(e){ console.warn('sched paste failed', e); }
              })()">Paste</button>
          </div>
        </div>
      </div>`;
  };

  if (LOGC) console.log('[CONTRACTS] renderContractMainTab â†’ Start/End/Breaks enabled + per-row Copy/Paste, auto-normalise on blur/Tab');

  const weekNames = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];
  const weVal = Number(d.week_ending_weekday_snapshot ?? 0);
  const weLabel = weekNames[isNaN(weVal) ? 0 : weVal];

  const schedGrid = `
    <div class="row"><label class="section">Proposed schedule (Monâ€“Sun)</label></div>
    <div class="sched-grid" style="min-width:0;flex:1">
      ${DAYS.map(([k,l]) => dayRow(k,l)).join('')}
    </div>
  `;

  if (LOGC) console.log('[CONTRACTS] renderContractMainTab snapshot', {
    candidate_id: candVal, client_id: clientVal,
    candidate_label: _candLabel, client_label: _clientLabel,
    week_ending_weekday_snapshot: d.week_ending_weekday_snapshot,
    route: { is_nhsp: isNhsp, autoprocess_hr: isHr, no_timesheet_required: noTs, routeLabel, hideDSM },
    mode: window.__getModalFrame?.()?.mode
  });

  // Inline, non-blocking overlap + timesheet-boundary checks on date changes
  const overlapChangeAttr = `
    onchange="(function(el){
      try{
        var form = document.querySelector('#contractForm');
        var cid  = form ? (form.querySelector('[name=\\'candidate_id\\']')?.value||'') : '';
        var sd   = form ? (form.querySelector('[name=\\'start_date\\']')?.value||'') : '';
        var ed   = form ? (form.querySelector('[name=\\'end_date\\']')?.value||'')  : '';
        var sIso = (window.parseUkDateToIso ? parseUkDateToIso(sd) : sd);
        var eIso = (window.parseUkDateToIso ? parseUkDateToIso(ed) : ed);
        var excl = (window.modalCtx && window.modalCtx.data && window.modalCtx.data.id) || null;

        // Overlap (non-blocking)
        if (cid && sIso && eIso && window.callCheckContractWindowOverlap) {
          callCheckContractWindowOverlap(cid, sIso, eIso, excl).then(function(res){
            if (res && res.has_overlap) {
              var msg = (res.overlaps||[]).map(function(o){
                var nm = o.client_name || o.client || 'Client';
                var a = o.overlap_from || '';
                var b = o.overlap_to   || '';
                return nm + ' ' + a + 'â†’' + b;
              }).join(' â€¢ ');
              if (window.showModalHint) { showModalHint('Overlap with: ' + msg, 'warn'); }
              else if (window.__toast)  { __toast('Overlap with: ' + msg); }
            }
          });
        }

        // Timesheet boundary (non-blocking hint + cache for save eligibility). Skip in create (no contract id yet)
        if (excl && sIso && eIso && window.callCheckTimesheetBoundary) {
          callCheckTimesheetBoundary(excl, sIso, eIso).then(function(bres){
            window.__tsBoundaryResult = bres || null;
            if (bres && bres.ok === false) {
              var txt = 'Dates exclude existing timesheets.';
              try {
                var v = bres.violations || [];
                if (v.length) {
                  var sample = v.slice(0,3).map(function(x){
                    var nm = x.client_name || 'Client';
                    var dt = x.date || '';
                    var st = x.status || '';
                    return nm + ' ' + dt + (st?(' ('+st+')'):'');
                  }).join(' â€¢ ');
                  txt = 'Dates exclude existing timesheets: ' + sample + (v.length>3?'â€¦':'');
                } else if (bres.min_ts_date || bres.max_ts_date) {
                  txt = 'Dates exclude timesheets in range ' + (bres.min_ts_date||'') + ' â†’ ' + (bres.max_ts_date||'') + '.';
                }
              } catch {}
              if (window.showModalHint) { showModalHint(txt, 'warn'); } else if (window.__toast) { __toast(txt); }
            }
          });
        } else {
          if (!excl) window.__tsBoundaryResult = null;
        }
      }catch(e){}
    })(this)"`;

  return `
    <form id="contractForm" class="tabc form">
      <input type="hidden" name="candidate_id" value="${candVal}">
      <input type="hidden" name="client_id"    value="${clientVal}">
      <input type="hidden" name="week_ending_weekday_snapshot" value="${String(d.week_ending_weekday_snapshot ?? '')}">

      <div class="row">
        <label>Candidate</label>
        <div class="controls">
          <div class="split">
            <input class="input" type="text" id="candidate_name_display" value="${_candLabel}" placeholder="Type 3+ letters to searchâ€¦" />
            <span>
              <button type="button" class="btn mini" id="btnPickCandidate">Pickâ€¦</button>
              <button type="button" class="btn mini" id="btnClearCandidate">Clear</button>
            </span>
          </div>
          <div class="mini" id="candidatePickLabel">${_candLabel ? `Chosen: ${_candLabel}` : ''}</div>
        </div>
      </div>

      <div class="row">
        <label>Client</label>
        <div class="controls">
          <div class="split">
            <input class="input" type="text" id="client_name_display" value="${_clientLabel}" placeholder="Type 3+ letters to searchâ€¦" />
            <span>
              <button type="button" class="btn mini" id="btnPickClient">Pickâ€¦</button>
              <button type="button" class="btn mini" id="btnClearClient">Clear</button>
            </span>
          </div>
          <div class="mini" id="clientPickLabel">${_clientLabel ? `Chosen: ${_clientLabel}` : ''}</div>
        </div>
      </div>

      <div class="row">
        <label>Route</label>
        <div class="controls" style="display:flex;flex-wrap:wrap;gap:10px;align-items:center">
          <div class="mini" id="contractRouteLabel"><strong>${routeLabel}</strong></div>
          <button type="button" class="btn mini" id="btnContractSettings"
            onclick="(function(){
              try{
                if (typeof openContractSettingsModal === 'function') { openContractSettingsModal(); return; }
                if (window.__toast) __toast('Contract settings modal is not wired yet.');
              }catch(e){}
            })()"
          >Contract settings</button>
        </div>
      </div>

      <div class="grid-2">
        <div class="row"><label>Display site</label><div class="controls"><input class="input" name="display_site" value="${d.display_site || ''}" /></div></div>
        <div class="row"><label>Week-ending day</label><div class="controls"><div class="mini" id="weLabel">${weLabel}</div></div></div>
      </div>

      <div class="grid-2">
        <div class="row"><label>Role</label><div class="controls"><input class="input" name="role" value="${d.role || ''}" /></div></div>
        <div class="row"><label>Band</label><div class="controls"><input class="input" name="band" value="${d.band || ''}" /></div></div>
      </div>

      <div class="grid-2">
        <div class="row"><label>Start date</label><div class="controls"><input class="input" name="start_date" value="${startUk}" placeholder="DD/MM/YYYY" required ${overlapChangeAttr} /></div></div>
        <div class="row"><label>End date</label><div class="controls"><input class="input" name="end_date" value="${endUk}" placeholder="DD/MM/YYYY" required ${overlapChangeAttr} /></div></div>
      </div>

      <div class="grid-2">
        <div class="row"><label>Pay method snapshot</label>
          <div class="controls">
            <select name="pay_method_snapshot" ${payLocked ? 'disabled' : ''}>
              <option value="PAYE" ${String(d.pay_method_snapshot||'PAYE').toUpperCase()==='PAYE'?'selected':''}>PAYE</option>
              <option value="UMBRELLA" ${String(d.pay_method_snapshot||'PAYE').toUpperCase()==='UMBRELLA'?'selected':''}>Umbrella</option>
            </select>
          </div>
        </div>

        ${
          hideDSM
            ? `<div class="row"><label>Default submission mode</label><div class="controls"><div class="mini">Hidden for <strong>${routeLabel}</strong> route.</div></div></div>`
            : `<div class="row"><label>Default submission mode</label>
                <div class="controls">
                  <select name="default_submission_mode">
                    <option value="ELECTRONIC" ${String(d.default_submission_mode||'ELECTRONIC').toUpperCase()==='ELECTRONIC'?'selected':''}>Electronic</option>
                    <option value="MANUAL" ${String(d.default_submission_mode||'ELECTRONIC').toUpperCase()==='MANUAL'?'selected':''}>Manual</option>
                  </select>
                </div>
              </div>`
        }
      </div>

      ${schedGrid}

      ${labelsBlock}
    </form>`;
}



// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UPDATED: renderContractRatesTab (adds logging only)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function renderContractRatesTab(ctx) {
  const LOGC = (typeof window.__LOG_CONTRACTS === 'boolean') ? window.__LOG_CONTRACTS : false;

  const merged = mergeContractStateIntoRow(ctx?.data || {});
  const R = (merged?.rates_json) || {};
  const payMethod = String(merged?.pay_method_snapshot || 'PAYE').toUpperCase();
  const showPAYE = (payMethod === 'PAYE');
  const num = (v) => (v == null ? '' : String(v));
  const LBL = merged?.bucket_labels_json || {};
  const labelOf = (k) => {
    if (k==='day') return (LBL.day||'Day');
    if (k==='night') return (LBL.night||'Night');
    if (k==='sat') return (LBL.sat||'Sat');
    if (k==='sun') return (LBL.sun||'Sun');
    if (k==='bh') return (LBL.bh||'BH');
    return k;
  };

  // âœ… Prefer finance payload from backend (fresh) over any cached globals
  const fin = (window.modalCtx && window.modalCtx.finance && typeof window.modalCtx.finance === 'object')
    ? window.modalCtx.finance
    : null;

  const erniMult = (fin && typeof fin.erni_multiplier === 'number' && fin.erni_multiplier > 0)
    ? fin.erni_multiplier
    : (typeof window.__ERNI_MULT__ === 'number' && window.__ERNI_MULT__ > 0)
      ? window.__ERNI_MULT__
      : 1;

  const erniApplies = (fin && typeof fin.erni_applies === 'boolean')
    ? fin.erni_applies
    : (payMethod === 'PAYE');

  // âœ… NEW: server-computed margins (from GET /api/contracts/:id)
  // merged.margins.bucket_margins is the preferred source when present.
  const serverBucketMargins = (merged && merged.margins && merged.margins.bucket_margins && typeof merged.margins.bucket_margins === 'object')
    ? merged.margins.bucket_margins
    : null;

  const toNum = (v) => {
    if (v === '' || v === null || v === undefined) return null;
    const n = Number(v);
    return Number.isFinite(n) ? n : null;
  };

  const fmt = (n) => (Number.isFinite(Number(n)) ? `Â£${Number(n).toFixed(2)}` : '');

  const payRate = {
    day:   toNum(showPAYE ? R.paye_day   : R.umb_day),
    night: toNum(showPAYE ? R.paye_night : R.umb_night),
    sat:   toNum(showPAYE ? R.paye_sat   : R.umb_sat),
    sun:   toNum(showPAYE ? R.paye_sun   : R.umb_sun),
    bh:    toNum(showPAYE ? R.paye_bh    : R.umb_bh)
  };

  const chgRate = {
    day:   toNum(R.charge_day),
    night: toNum(R.charge_night),
    sat:   toNum(R.charge_sat),
    sun:   toNum(R.charge_sun),
    bh:    toNum(R.charge_bh)
  };

  // âœ… Local compute fallback (used only when server margin not present)
  const marginRateLocal = {
    day:   (payRate.day   != null && chgRate.day   != null) ? (chgRate.day   - (payMethod === 'PAYE' && erniApplies ? payRate.day   * erniMult : payRate.day))   : null,
    night: (payRate.night != null && chgRate.night != null) ? (chgRate.night - (payMethod === 'PAYE' && erniApplies ? payRate.night * erniMult : payRate.night)) : null,
    sat:   (payRate.sat   != null && chgRate.sat   != null) ? (chgRate.sat   - (payMethod === 'PAYE' && erniApplies ? payRate.sat   * erniMult : payRate.sat))   : null,
    sun:   (payRate.sun   != null && chgRate.sun   != null) ? (chgRate.sun   - (payMethod === 'PAYE' && erniApplies ? payRate.sun   * erniMult : payRate.sun))   : null,
    bh:    (payRate.bh    != null && chgRate.bh    != null) ? (chgRate.bh    - (payMethod === 'PAYE' && erniApplies ? payRate.bh    * erniMult : payRate.bh))    : null
  };

  // âœ… Prefer server margins when present; fallback to local compute.
  // FE recompute on edits still works because your input handlers call computeContractMargins().
  const marginRate = {
    day:   (serverBucketMargins && toNum(serverBucketMargins.day)   != null) ? toNum(serverBucketMargins.day)   : marginRateLocal.day,
    night: (serverBucketMargins && toNum(serverBucketMargins.night) != null) ? toNum(serverBucketMargins.night) : marginRateLocal.night,
    sat:   (serverBucketMargins && toNum(serverBucketMargins.sat)   != null) ? toNum(serverBucketMargins.sat)   : marginRateLocal.sat,
    sun:   (serverBucketMargins && toNum(serverBucketMargins.sun)   != null) ? toNum(serverBucketMargins.sun)   : marginRateLocal.sun,
    bh:    (serverBucketMargins && toNum(serverBucketMargins.bh)    != null) ? toNum(serverBucketMargins.bh)    : marginRateLocal.bh
  };

  if (LOGC) console.log('[CONTRACTS] renderContractRatesTab', { payMethod, hasRates: !!merged?.rates_json });

  const html = `
    <div class="tabc" id="contractRatesTab" data-pay-method="${payMethod}">
      <div class="row" style="display:flex;justify-content:space-between;align-items:center">
        <label class="section">Rates</label>
        <div class="actions" style="gap:8px">
          <span class="pill" id="presetChip" style="display:none"></span>
          <button type="button" id="btnChoosePreset">Choose presetâ€¦</button>
          <button type="button" id="btnResetPreset">Reset preset</button>
        </div>
      </div>

      <div class="grid-3" id="ratesCards">
        <div class="card" id="cardPAYE" style="${showPAYE?'':'display:none'}">
          <div class="row"><label class="section">PAYE pay (visible if PAYE)</label></div>
          <div class="grid-5">
            <div class="row"><label>${labelOf('day')}</label><div class="controls"><input class="input" name="paye_day"  value="${num(R.paye_day)}" /></div></div>
            <div class="row"><label>${labelOf('night')}</label><div class="controls"><input class="input" name="paye_night" value="${num(R.paye_night)}" /></div></div>
            <div class="row"><label>${labelOf('sat')}</label><div class="controls"><input class="input" name="paye_sat"  value="${num(R.paye_sat)}" /></div></div>
            <div class="row"><label>${labelOf('sun')}</label><div class="controls"><input class="input" name="paye_sun"  value="${num(R.paye_sun)}" /></div></div>
            <div class="row"><label>${labelOf('bh')}</label><div class="controls"><input class="input" name="paye_bh"   value="${num(R.paye_bh)}" /></div></div>
          </div>
        </div>

        <div class="card" id="cardUMB" style="${showPAYE?'display:none':''}">
          <div class="row"><label class="section">Umbrella pay (visible if Umbrella)</label></div>
          <div class="grid-5">
            <div class="row"><label>${labelOf('day')}</label><div class="controls"><input class="input" name="umb_day"  value="${num(R.umb_day)}" /></div></div>
            <div class="row"><label>${labelOf('night')}</label><div class="controls"><input class="input" name="umb_night" value="${num(R.umb_night)}" /></div></div>
            <div class="row"><label>${labelOf('sat')}</label><div class="controls"><input class="input" name="umb_sat"  value="${num(R.umb_sat)}" /></div></div>
            <div class="row"><label>${labelOf('sun')}</label><div class="controls"><input class="input" name="umb_sun"  value="${num(R.umb_sun)}" /></div></div>
            <div class="row"><label>${labelOf('bh')}</label><div class="controls"><input class="input" name="umb_bh"   value="${num(R.umb_bh)}" /></div></div>
          </div>
        </div>

        <div class="card" id="cardCHG">
          <div class="row"><label class="section">Charge-out</label></div>
          <div class="grid-5">
            <div class="row"><label>${labelOf('day')}</label><div class="controls"><input class="input" name="charge_day"   value="${num(R.charge_day)}" /></div></div>
            <div class="row"><label>${labelOf('night')}</label><div class="controls"><input class="input" name="charge_night" value="${num(R.charge_night)}" /></div></div>
            <div class="row"><label>${labelOf('sat')}</label><div class="controls"><input class="input" name="charge_sat"   value="${num(R.charge_sat)}" /></div></div>
            <div class="row"><label>${labelOf('sun')}</label><div class="controls"><input class="input" name="charge_sun"   value="${num(R.charge_sun)}" /></div></div>
            <div class="row"><label>${labelOf('bh')}</label><div class="controls"><input class="input" name="charge_bh"    value="${num(R.charge_bh)}" /></div></div>
          </div>

          <!-- Mileage row -->
          <div class="grid-2" style="margin-top:10px">
            <div class="row"><label>Mileage charge</label><div class="controls"><input class="input" name="mileage_charge_rate" value="${num(merged?.mileage_charge_rate)}" /></div></div>
            <div class="row"><label>Mileage pay</label><div class="controls"><input class="input" name="mileage_pay_rate" value="${num(merged?.mileage_pay_rate)}" /></div></div>
          </div>
        </div>
      </div>

      <div class="row" style="margin-top:12px"><label class="section">Margins</label></div>
      <table class="grid" id="marginsTable">
        <thead><tr><th>Bucket</th><th>Pay</th><th>Charge</th><th>Margin</th></tr></thead>
        <tbody>
          <tr data-b="day"><td>${labelOf('day')}</td><td class="py">${payRate.day != null ? fmt(payRate.day) : ''}</td><td class="ch">${chgRate.day != null ? fmt(chgRate.day) : ''}</td><td class="mg">${marginRate.day != null ? fmt(marginRate.day) : ''}</td></tr>
          <tr data-b="night"><td>${labelOf('night')}</td><td class="py">${payRate.night != null ? fmt(payRate.night) : ''}</td><td class="ch">${chgRate.night != null ? fmt(chgRate.night) : ''}</td><td class="mg">${marginRate.night != null ? fmt(marginRate.night) : ''}</td></tr>
          <tr data-b="sat"><td>${labelOf('sat')}</td><td class="py">${payRate.sat != null ? fmt(payRate.sat) : ''}</td><td class="ch">${chgRate.sat != null ? fmt(chgRate.sat) : ''}</td><td class="mg">${marginRate.sat != null ? fmt(marginRate.sat) : ''}</td></tr>
          <tr data-b="sun"><td>${labelOf('sun')}</td><td class="py">${payRate.sun != null ? fmt(payRate.sun) : ''}</td><td class="ch">${chgRate.sun != null ? fmt(chgRate.sun) : ''}</td><td class="mg">${marginRate.sun != null ? fmt(marginRate.sun) : ''}</td></tr>
          <tr data-b="bh"><td>${labelOf('bh')}</td><td class="py">${payRate.bh != null ? fmt(payRate.bh) : ''}</td><td class="ch">${chgRate.bh != null ? fmt(chgRate.bh) : ''}</td><td class="mg">${marginRate.bh != null ? fmt(marginRate.bh) : ''}</td></tr>
        </tbody>
      </table>
    </div>`;

  setTimeout(() => {
    try {WRA
      const root = document.getElementById('contractRatesTab');
      if (!root) return;
      const ev = new CustomEvent('contracts-rates-rendered', {
        detail: { payMethod }
      });
      if (LOGC) console.log('[CONTRACTS] dispatch contracts-rates-rendered', { payMethod });
      window.dispatchEvent(ev);
    } catch (e) {
      if (LOGC) console.warn('[CONTRACTS] contracts-rates-rendered dispatch failed', e);
    }
  }, 0);

  return html;
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Week actions (drawer modals)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€-

function openManualWeekEditor(week_id, contract_id /* optional but recommended */) {
  const LOG = (typeof window.__LOG_CONTRACTS === 'boolean') ? window.__LOG_CONTRACTS : true;

  // Extra-rate config + week dates live in this closure so onSave can see them
  let extrasConfig = [];
  let weekDates = []; // [{ ymd, label }...]

  const main = `
    <div class="tabc">
      <div id="hoursGrid" class="grid-5 tight">
        ${['day','night','sat','sun','bh'].map(k => `
          <div data-bucket="${k}">
            <div class="lbl mini" style="margin-bottom:4px">${k.toUpperCase()}</div>
            <input class="input" type="number" step="0.01" min="0" name="h_${k}" placeholder="0.00" />
          </div>`).join('')}
      </div>

      <div class="row" style="margin-top:16px">
        <label class="section">Additional Rates</label>
        <div class="controls">
          <div id="additionalRatesSection">
            <div class="hint">No additional rates configured for this contract.</div>
          </div>
        </div>
      </div>

      <div class="row" style="margin-top:10px">
        <label>Reference (optional)</label>
        <div class="controls"><input class="input" name="reference_number" placeholder="PO / Ref" /></div>
      </div>
      <div class="row"><div class="hint">Tip: attach or replace a manual PDF in â€œActionsâ€¦â€.</div></div>
    </div>
  `;

  showModal(
    `Manual Week â€” ${week_id}`,
    [{ key:'edit', title:'Edit hours' }],
    () => main,
    async () => {
      // Collect & post
      const root = document.querySelector('#modalRoot') || document;
      const v = (n) => Number(root.querySelector(`input[name="${n}"]`)?.value || 0);
      const ref = root.querySelector('input[name="reference_number"]')?.value?.trim() || '';

      const payload = {
        hours: {
          day:  v('h_day'),
          night:v('h_night'),
          sat:  v('h_sat'),
          sun:  v('h_sun'),
          bh:   v('h_bh')
        }
      };
      if (ref) payload.reference_number = ref;

      // Additional weekly buckets â€“ derive weekly totals (and optional per-day map)
      if (extrasConfig && extrasConfig.length) {
        const addWeek = {};
        const addPerDay = {};

        extrasConfig.forEach((cfg, idx) => {
          const code = cfg.code || `EX${idx + 1}`;
          const freq = String(cfg.frequency || 'ONE_PER_WEEK').toUpperCase();

          if (freq === 'ONE_PER_WEEK') {
            const inp = root.querySelector(`input[name="extra_week_${code}"]`);
            const val = inp ? Number(inp.value || 0) : 0;
            if (val && Number.isFinite(val)) {
              addWeek[code] = val;
            }
          } else {
            // Per-day modes (ONE_PER_DAY, WEEKENDS_AND_BH_ONLY, WEEKDAYS_EXCL_BH_ONLY)
            // We collect units per displayed day and let the backend apply the BH/weekend rules.
            const perDay = {};
            let total = 0;
            if (weekDates && weekDates.length === 7) {
              for (let i = 0; i < 7; i++) {
                const meta = weekDates[i];
                const inp = root.querySelector(`input[name="extra_${code}_d${i}"]`);
                if (!inp) continue;
                const numVal = Number(inp.value || 0);
                if (!numVal || !Number.isFinite(numVal)) continue;
                perDay[meta.ymd] = numVal;
                total += numVal;
              }
            }
            if (total > 0) {
              addWeek[code] = total;
              if (Object.keys(perDay).length) addPerDay[code] = perDay;
            }
          }
        });

        if (Object.keys(addWeek).length) {
          payload.additional_units_week = addWeek;
        }
        if (Object.keys(addPerDay).length) {
          payload.additional_units_per_day = addPerDay;
        }
      }

      await contractWeekManualUpsert(week_id, payload);
      alert('Saved.');
      return true;
    },
    false,
    async () => {
      // Post-render: apply bucket labels and render Additional Rates if we have a contract
      try {
        // First resolve the contract + week-ending date
        let cw = null;
        try {
          const r = await authFetch(API(`/api/contract-weeks?id=eq.${_enc(week_id)}&select=contract_id,week_ending_date`));
          if (r && r.ok) {
            const rows = await r.json();
            if (Array.isArray(rows) && rows.length) cw = rows[0];
          }
        } catch (e) {
          if (LOG) console.warn('[MANUAL-WEEK] failed to load contract_week', e);
        }

        let cid = contract_id || (cw && cw.contract_id) || null;
        if (!cid) return;

        let cr;
        try {
          cr = await getContract(cid);
        } catch (e) {
          if (LOG) console.warn('[MANUAL-WEEK] getContract failed', e);
          return;
        }
        const contract = cr?.contract || cr;
        if (!contract) return;

        // Apply bucket labels for the 5 standard hours buckets
        try {
          const L = getBucketLabelsForContract(contract);
          applyBucketLabelsToHoursGrid(document.querySelector('#hoursGrid'), L);
        } catch (e) {
          if (LOG) console.warn('[MANUAL-WEEK] applyBucketLabels failed', e);
        }

        // Compute the 7 dates for this contract week (WE-6 .. WE)
        weekDates = [];
        if (cw && cw.week_ending_date) {
          const weIso = String(cw.week_ending_date);
          const baseDate = new Date(weIso + 'T00:00:00');
          if (!isNaN(baseDate.getTime())) {
            const dowNames = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
            for (let offset = 6; offset >= 0; offset--) {
              const d = new Date(baseDate);
              d.setDate(baseDate.getDate() - offset);
              const yyyy = d.getFullYear();
              const mm = String(d.getMonth() + 1).padStart(2, '0');
              const dd = String(d.getDate()).padStart(2, '0');
              const ymd = `${yyyy}-${mm}-${dd}`;
              const label = `${dowNames[d.getDay()]} ${dd}/${mm}`;
              weekDates.push({ ymd, label });
            }
          }
        }

        const host = document.getElementById('additionalRatesSection');
        if (!host) return;

        const extras = Array.isArray(contract.additional_rates_json)
          ? contract.additional_rates_json
          : [];

        extrasConfig = (extras || []).filter(e => e && (e.bucket_name || e.unit_name || e.code));

        if (!extrasConfig.length) {
          host.innerHTML = '<div class="hint">No additional rates configured for this contract.</div>';
          return;
        }

        const freqLabel = (f) => {
          const s = String(f || '').toUpperCase();
          if (s === 'ONE_PER_WEEK') return 'One per week';
          if (s === 'ONE_PER_DAY') return 'One per day';
          if (s === 'WEEKENDS_AND_BH_ONLY') return 'Weekends & BH only';
          if (s === 'WEEKDAYS_EXCL_BH_ONLY') return 'Weekdays (excl BH) only';
          return s || 'One per week';
        };

        const esc = (x) => String(x == null ? '' : x)
          .replace(/&/g,'&amp;')
          .replace(/</g,'&lt;')
          .replace(/>/g,'&gt;')
          .replace(/"/g,'&quot;')
          .replace(/'/g,'&#39;');

        let html = '';
        extrasConfig.forEach((cfg, idx) => {
          const code = cfg.code || `EX${idx + 1}`;
          const name = esc(cfg.bucket_name || code);
          const unitName = esc(cfg.unit_name || 'Units');
          const freq = String(cfg.frequency || 'ONE_PER_WEEK').toUpperCase();
          const pay = (cfg.pay_rate != null && Number.isFinite(Number(cfg.pay_rate))) ? Number(cfg.pay_rate) : null;
          const chg = (cfg.charge_rate != null && Number.isFinite(Number(cfg.charge_rate))) ? Number(cfg.charge_rate) : null;
          const payStr = pay != null ? pay.toFixed(2) : '0.00';
          const chgStr = chg != null ? chg.toFixed(2) : '0.00';

          if (freq === 'ONE_PER_WEEK') {
            html += `
              <div class="row extra-row" data-code="${esc(code)}">
                <label>${name}</label>
                <div class="controls">
                  <div class="split">
                    <span class="mini">${unitName} (${freqLabel(freq)})</span>
                    <input class="input" type="number" min="0" step="0.01"
                      name="extra_week_${esc(code)}" placeholder="0" />
                  </div>
                  <div class="mini" style="margin-top:4px;">
                    Pay per unit Â£${payStr}, Charge per unit Â£${chgStr}
                  </div>
                </div>
              </div>`;
          } else {
            const perDayInputs = (weekDates && weekDates.length === 7)
              ? weekDates.map((d, i) => `
                  <div class="split">
                    <span class="mini">${esc(d.label)}</span>
                    <input class="input" type="number" min="0" step="0.01"
                      name="extra_${esc(code)}_d${i}" placeholder="0" />
                  </div>
                `).join('')
              : '';

            html += `
              <div class="row extra-row" data-code="${esc(code)}">
                <label>${name}</label>
                <div class="controls" style="flex-direction:column;gap:4px;align-items:flex-start">
                  <div class="mini">${unitName} (${freqLabel(freq)})</div>
                  <div class="grid-7 tight" style="min-width:0;flex-wrap:wrap;gap:6px">
                    ${perDayInputs}
                  </div>
                  <div class="mini" style="margin-top:4px;">
                    Pay per unit Â£${payStr}, Charge per unit Â£${chgStr}
                  </div>
                </div>
              </div>`;
          }
        });

        host.innerHTML = `
          <div class="card" id="manualExtrasCard" style="margin-top:4px">
            <div class="row"><label class="section">Additional Rates â€” weekly units</label></div>
            <div class="extras-body" style="display:flex;flex-direction:column;gap:8px">
              ${html}
            </div>
          </div>
        `;
      } catch (e) {
        if (LOG) console.warn('[MANUAL-WEEK] post-render wiring failed', e);
      }
    },
    { kind:'manual-week' }
  );
}
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// openContractWeekActions (amended) â€” â€œAdd additional sheetâ€ now calls additional;
// add separate â€œCreate expense sheetâ€ button wired to expense-sheet endpoint
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€




// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// FIX 2: Clone & Extend endpoint name mismatch (â€¦/clone-and-extend)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function openContractCloneAndExtend(contract_id) {
  const LOGM = !!window.__LOG_MODAL;
  const old = (window.modalCtx && window.modalCtx.data) ? window.modalCtx.data : {};
  if (LOGM) console.log('[CLONE] entry', { contract_id, hasOld: !!old?.id, oldPreview: old?.id ? { id: old.id, start: old.start_date, end: old.end_date } : null });

  const iso = (d)=> (typeof d === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(d)) ? d : toYmd(new Date());
  const oldStart = iso(old?.start_date);
  const oldEnd   = iso(old?.end_date);

  // Defaults for the wizard
  const defaultStart = (() => { const d=new Date((oldEnd||toYmd(new Date()))+'T00:00:00Z'); d.setUTCDate(d.getUTCDate()+1); return toYmd(d); })();
  const defaultEnd   = (() => { const d=new Date(defaultStart+'T00:00:00Z'); d.setUTCDate(d.getUTCDate()+84); return toYmd(d); })();
  const defaultEndOld= (() => { const d=new Date(defaultStart+'T00:00:00Z'); d.setUTCDate(d.getUTCDate()-1); return toYmd(d); })();

  const content = `
    <div class="tabc" id="cloneExtendForm">
      <div class="row"><label>New start</label>
        <div class="controls"><input class="input" type="text" name="new_start_date" placeholder="DD/MM/YYYY" value="${formatIsoToUk(defaultStart)}" /></div>
      </div>
      <div class="row"><label>New end</label>
        <div class="controls"><input class="input" type="text" name="new_end_date" placeholder="DD/MM/YYYY" value="${formatIsoToUk(defaultEnd)}" /></div>
      </div>

      <div class="row" style="margin-top:6px">
        <label style="display:flex;align-items:center;gap:6px">
          <input type="checkbox" name="end_existing_checked" checked />
          End existing contract on
        </label>
        <div class="controls" style="margin-top:6px">
          <input class="input" type="text" name="end_existing_on" placeholder="DD/MM/YYYY" value="${formatIsoToUk(defaultEndOld)}" />
          <div class="mini" style="margin-top:4px">Default is New start âˆ’ 1 day. Untick to keep the existing contract running.</div>
        </div>
      </div>

      <div class="mini" style="margin-top:10px">
        After this, the successor opens in the normal contract modal (Create mode). You can edit Main / Rates / Calendar before saving.
      </div>
    </div>
  `;

  showModal(
    'Clone & Extend',
    [{ key:'c', title:'Successor window' }],
    () => content,
    async () => {
      const LOGM = !!window.__LOG_MODAL;
      const root = document.getElementById('cloneExtendForm') || document;

      const newStartUk  = root.querySelector('input[name="new_start_date"]')?.value?.trim() || '';
      const newEndUk    = root.querySelector('input[name="new_end_date"]')?.value?.trim()   || '';
      const endChk      = !!root.querySelector('input[name="end_existing_checked"]')?.checked;
      const endOldUk    = root.querySelector('input[name="end_existing_on"]')?.value?.trim() || '';

      const new_start_date = parseUkDateToIso(newStartUk);
      const new_end_date   = parseUkDateToIso(newEndUk);
      const end_existing_on= endChk ? parseUkDateToIso(endOldUk) : null;

      if (!new_start_date || !new_end_date) { alert('Enter both new start and new end.'); return false; }
      if (new_start_date > new_end_date)   { alert('New end must be on or after new start.'); return false; }

      try {
        const oldStartIso = (window.modalCtx?.data?.start_date) || '';
        if (endChk) {
          if (!end_existing_on) { alert('Pick a valid end date for the existing contract.'); return false; }
          if (oldStartIso && end_existing_on < oldStartIso) { alert('Existing contract cannot end before its original start.'); return false; }
          if (end_existing_on >= new_start_date) { alert('Existing contract end must be before the new start.'); return false; }
        }
      } catch {}

      // === NEW: pre-truncate the existing contract (blocking) BEFORE opening successor ===
      let effectiveOldEnd = end_existing_on;
      if (endChk) {
        const oldId = String(window.modalCtx?.data?.id || '');
        if (!oldId) { alert('Source contract id missing.'); return false; }

        try {
          console.groupCollapsed('[CLONE][pre-trim gate]');
          const url  = API(`/api/contracts/${encodeURIComponent(oldId)}/truncate-tail`);
          const init = {
            method: 'POST',
            headers: { 'content-type': 'application/json' },
            body: JSON.stringify({ id: oldId, desired_end: end_existing_on })
          };
          console.log('request', { url, init, new_start_date, new_end_date });
          try { window.__LOG_API = true; } catch {}

          const res = await (typeof authFetch === 'function' ? authFetch(url, init) : fetch(url, init));
          let obj = null;
          try { obj = await res.clone().json(); } catch { obj = null; }

          const okField =
            (typeof obj?.ok === 'boolean' ? obj.ok :
             typeof obj?.success === 'boolean' ? obj.success :
             (typeof res?.ok === 'boolean' ? res.ok : undefined));

          const clamped  = !!obj?.clamped;
          const safe_end = obj?.safe_end || null;
          const status   = (typeof res?.status === 'number') ? res.status : (typeof obj?.status === 'number' ? obj.status : undefined);

          console.log('response', { status, ok: !!okField, clamped, safe_end, obj });

          if (!okField) {
            alert((obj && (obj.message || obj.error)) || res.statusText || 'Failed to end the existing contract.');
            console.groupEnd?.();
            return false;
          }

          if (clamped && typeof showTailClampWarning === 'function') {
            try { showTailClampWarning(safe_end, end_existing_on); } catch {}
          }

          effectiveOldEnd = safe_end || end_existing_on;

          if (effectiveOldEnd >= new_start_date) {
            alert(`Existing contract now ends on ${effectiveOldEnd}, which overlaps the new start (${new_start_date}). Adjust dates and try again.`);
            console.groupEnd?.();
            return false;
          }

          if (typeof refreshOldContractAfterTruncate === 'function') {
            try { await refreshOldContractAfterTruncate(oldId); } catch (e) { if (LOGM) console.warn('[CLONE] refresh after truncate failed', e); }
          }
          console.groupEnd?.();
        } catch (e) {
          console.warn('[CLONE][pre-trim gate] exception', e);
          alert(`Could not end the existing contract: ${e?.message || e}`);
          return false;
        }
      }

      // Build staged successor row from current contract (no staging of end_existing intent anymore)
      const old = window.modalCtx?.data || {};
      const newToken = `contract:new:${Date.now()}:${Math.random().toString(36).slice(2)}`;
      const stagedRow = {
        id: null,
        candidate_id: old.candidate_id || '',
        client_id:    old.client_id    || '',
        role:         old.role         || '',
        band:         (old.band ?? null),
        display_site: old.display_site || '',
        start_date:   new_start_date,
        end_date:     new_end_date,
        pay_method_snapshot: old.pay_method_snapshot || 'PAYE',
        default_submission_mode: old.default_submission_mode || 'ELECTRONIC',
        week_ending_weekday_snapshot: Number(old.week_ending_weekday_snapshot ?? 0),
        std_schedule_json: old.std_schedule_json || null,
        std_hours_json:    old.std_hours_json    || null,
        bucket_labels_json: old.bucket_labels_json || null,
        rates_json: (old.rates_json && typeof old.rates_json === 'object') ? old.rates_json : {}
      };

      // Open successor ONLY AFTER the pre-trim has finished successfully â€” as a ROOT modal
      try {
        if (LOGM) console.log('[CLONE] will open staged successor in Create mode (root, deferred)', { token: newToken, stagedRow, effectiveOldEnd });
        window.__preOpenToken = newToken;
        setTimeout(() => {
          try {
            // Tear down entire stack so successor opens as root (no parent to resurface)
            try { discardAllModalsAndState(); } catch {}
            openContract(stagedRow);
            // After the modal builds its own formState, force-align __forId with our token
            setTimeout(() => {
              try {
                if (window.modalCtx) {
                  window.modalCtx.openToken = newToken;
                  const fs2 = (window.modalCtx.formState ||= { __forId: newToken, main:{}, pay:{} });
                  fs2.__forId = newToken;
                  if (LOGM) console.log('[CLONE] bound token to create modal', { openToken: window.modalCtx.openToken, forId: fs2.__forId });
                }
              } catch (e) { console.warn('[CLONE] bind token failed', e); }
            }, 0);
          } catch (e) {
            console.error('[CLONE] openContract failed', e);
            try { renderAll(); } catch {}
          }
        }, 0);
      } catch (e) {
        console.error('[CLONE] schedule open failed', e);
      }

      return true;
    },
    false,
    () => {
      try { window.dispatchEvent(new Event('contracts-main-rendered')); } catch {}
    },
    { kind:'contract-clone-extend', forceEdit:true, noParentGate:true }
  );

  // Wire pickers & auto-sync after mount
  setTimeout(() => {
    const root = document.getElementById('cloneExtendForm');
    if (!root) return;

    const startEl = root.querySelector('input[name="new_start_date"]');
    const endEl   = root.querySelector('input[name="new_end_date"]');
    const endChk  = root.querySelector('input[name="end_existing_checked"]');
    const endOld  = root.querySelector('input[name="end_existing_on"]');

    attachUkDatePicker(startEl, { minDate: formatIsoToUk(oldStart) });
    attachUkDatePicker(endEl,   { minDate: startEl.value, maxDate: null });
    attachUkDatePicker(endOld,  { minDate: formatIsoToUk(oldStart), maxDate: startEl.value });

    const isoMinusOne = (isoStr) => { try { const d=new Date(isoStr+'T00:00:00Z'); d.setUTCDate(d.getUTCDate()-1); return toYmd(d); } catch { return null; } };

    const onStartChange = () => {
      const startIso = parseUkDateToIso(startEl.value || '') || defaultStart;
      const maxOldEndIso = isoMinusOne(startIso);
      const maxOldEndUk  = formatIsoToUk(maxOldEndIso);
      if (typeof endOld.setMinDate === 'function') endOld.setMinDate(formatIsoToUk(oldStart));
      endOld._maxIso = maxOldEndIso;
      if (typeof endOld.__ukdpRepaint === 'function') endOld.__ukdpRepaint();
      if (endChk.checked) endOld.value = maxOldEndUk;
      if (LOGM) console.log('[CLONE] onStartChange', { startIso, endOldUk: endOld.value, maxOldEndIso });
    };

    const onChkToggle = () => {
      const checked = !!endChk.checked;
      endOld.disabled = !checked;
      if (checked) {
        const sIso = parseUkDateToIso(startEl.value || '') || oldEnd;
        const maxIso = isoMinusOne(sIso);
        const maxUk  = formatIsoToUk(maxIso);
        const eIso   = parseUkDateToIso(endOld.value || '') || '';
        if (!eIso || eIso >= sIso || eIso < oldStart) endOld.value = maxUk;
      }
      if (LOGM) console.log('[CLONE] onChkToggle', { checked, endOldUk: endOld.value });
    };

    startEl.addEventListener('change', onStartChange, true);
    startEl.addEventListener('blur',   onStartChange, true);
    endChk.addEventListener('change',  onChkToggle,   true);

    onChkToggle();
    onStartChange();
  }, 0);
}




function openContractSkipWeeks(contract_id) {
  const content = `
    <div class="tabc">
      <div class="row"><label>From (W/E)</label><div class="controls"><input class="input" name="from" placeholder="YYYY-MM-DD" /></div></div>
      <div class="row"><label>To (W/E)</label><div class="controls"><input class="input" name="to" placeholder="YYYY-MM-DD" /></div></div>
      <div class="hint">Only OPEN/PLANNED weeks without timesheets will be cancelled.</div>
    </div>
  `;
  showModal(
    'Skip Weeks',
    [{ key:'s', title:'Cancel range'}],
    () => content,
    async () => {
      const root = document;
      const from = root.querySelector('input[name="from"]')?.value?.trim() || null;
      const to   = root.querySelector('input[name="to"]')?.value?.trim() || null;
      const r = await authFetch(API(`/api/contracts/${_enc(contract_id)}/skip-weeks`), {
        method:'POST', headers:{'content-type':'application/json'}, body:_json({ from, to })
      });
      if (!r?.ok) { alert('Skip weeks failed.'); return false; }
      alert('Weeks cancelled (where eligible).');
      return true;
    },
    false,
    null,
    { kind:'skip-weeks' }
  );
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Helper â€” presign & upload a manual PDF to the week
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€-

async function presignAndAttachManualWeekPdf(week_id) {
  try {
    const { upload_url } = await contractWeekPresignPdf(week_id);

    // Spawn a file input + PUT the first file
    const inp = document.createElement('input');
    inp.type = 'file';
    inp.accept = '.pdf,.jpg,.jpeg,.png,.heic,.heif,application/pdf,image/*';
    inp.style.display = 'none';
    document.body.appendChild(inp);
    inp.onchange = async () => {
      const f = inp.files && inp.files[0];
      document.body.removeChild(inp);
      if (!f) return;

      const put = await fetch(upload_url, { method:'PUT', headers:{ 'content-type': f.type || 'application/octet-stream' }, body: f });
      if (!put.ok) throw new Error(`Upload failed (${put.status})`);
      alert('File uploaded and attached to the week.');
    };
    inp.click();
  } catch (e) {
    alert(e?.message || e);
  }
}














































// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// NEW: Quick wrapper to focus current ticked selection
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// NEW: Render the tiny Selection toolbar under the grid
// Buttons: ðŸ” Focus | ðŸ” Save | ðŸ” Load
// Call from renderSummary() after the pager, or anywhere you want.
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderSelectionToolbar(section, mountAfterEl) {
  // Locate a mount point
  const content = document.getElementById('content');
  const host = mountAfterEl || content;
  if (!host) return null;

  // Read selection
  window.__selection = window.__selection || {};
  const sel = (window.__selection[section] ||= { fingerprint: '', ids: new Set() });
  const hasSelection = sel.ids && sel.ids.size > 0;

  // Create bar
  const bar = document.createElement('div');
  bar.className = 'selection-toolbar';
  bar.style.cssText = 'display:flex;justify-content:flex-end;gap:8px;padding:6px 10px;border-top:1px dashed var(--line)';

  // Button factory
  const mkBtn = (title, text) => {
    const b = document.createElement('button');
    b.title = title;
    b.textContent = text;
    b.style.cssText = 'border:1px solid var(--line);background:#0b152a;color:var(--text);padding:4px 8px;border-radius:8px;cursor:pointer';
    return b;
  };

  const btnFocus = mkBtn('Focus on records', 'ðŸ” Focus');
  const btnSave  = mkBtn('Save selection',   'ðŸ” Save');
  const btnLoad  = mkBtn('Load selection',   'ðŸ” Load');

  btnFocus.disabled = !hasSelection;
  btnSave.disabled  = !hasSelection;

  btnFocus.addEventListener('click', async () => {
    try { await focusCurrentSelection(section); } catch (e) { console.error('Focus failed', e); }
  });

  btnSave.addEventListener('click', async () => {
    try { await openSaveSelectionModal(section); } catch (e) { console.error('Save selection failed', e); }
  });

  btnLoad.addEventListener('click', async () => {
    try { await openLoadSelectionModal(section); } catch (e) { console.error('Load selection failed', e); }
  });

  bar.appendChild(btnFocus);
  bar.appendChild(btnSave);
  bar.appendChild(btnLoad);

  // NEW: Resolve button for timesheets selection only
  if (section === 'timesheets') {
    const btnResolve = mkBtn('Resolve selected timesheets (candidate/client mapping)', 'Resolveâ€¦');
    btnResolve.disabled = !hasSelection;

    btnResolve.addEventListener('click', async () => {
      try {
        if (!hasSelection) return;
        if (typeof getSelectedSummaryRows !== 'function') {
          console.warn('getSelectedSummaryRows() is not defined; cannot resolve selection');
          return;
        }
        const rows = getSelectedSummaryRows('timesheets') || [];
        if (!rows.length) return;
        await openTimesheetsResolveModal(rows);
      } catch (e) {
        console.error('Resolve selection failed', e);
      }
    });

    bar.appendChild(btnResolve);
  }

  host.appendChild(bar);
  return bar;
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// NEW: Save the current ticked selection (IDs-only)
// Modes: Save as new, Append to existing (selection kind only)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function openSaveSelectionModal(section) {
  const sanitize = (typeof window !== 'undefined' && typeof window.sanitize === 'function')
    ? window.sanitize
    : (s => String(s ?? '').replace(/&/g,'&amp;').replace(/</g,'&lt;')
                           .replace(/>/g,'&gt;').replace(/"/g,'&quot;')
                           .replace(/'/g,'&#39;'));

  window.__selection = window.__selection || {};
  const curSel = window.__selection[section] || { fingerprint:'', ids:new Set() };
  const idsNow = Array.from(new Set((Array.from(curSel.ids || []).map(String).filter(Boolean)))); // dedupe

  if (!idsNow.length) {
    alert('No records selected to save.');
    return;
  }

  // Load owned selection presets for Append
  const myId = currentUserId();
  const mine = await listReportPresets({ section, kind: 'selection', include_shared: false }).catch(() => []);
  const owned = (mine || []).filter(p => String(p.user_id) === String(myId));
  const optionsHtml = owned.map(p => `<option value="${p.id}">${sanitize(p.name || '(unnamed)')}</option>`).join('');

  const body = html(`
    <div class="form" id="saveSelectionForm" style="max-width:720px">
      <div class="row">
        <label for="selPresetName">Preset name</label>
        <div class="controls">
          <input id="selPresetName" class="input" placeholder="e.g. â€˜Shortlist â€” RMNsâ€™" />
        </div>
      </div>

      <div class="row">
        <label>Mode</label>
        <div class="controls" style="display:flex;flex-direction:column;gap:8px;min-width:0">
          <div style="display:flex;gap:12px;align-items:center;flex-wrap:wrap">
            <label class="inline">
              <input type="radio" name="mode" value="new" checked>
              <span>Save as new selection</span>
            </label>
            <label class="inline">
              <input type="radio" name="mode" value="append" ${owned.length ? '' : 'disabled'}>
              <span>Append to existing selection</span>
            </label>
          </div>
          <div id="selAppendWrap" style="display:none; width:100%; max-width:100%">
            <div class="hint" style="margin:2px 0 4px">
              ${owned.length ? 'Choose selection to append to' : 'You donâ€™t own any selections to append'}
            </div>
            <select id="selAppendPresetId" class="input" style="width:100%; max-width:100%">
              ${optionsHtml}
            </select>
          </div>
        </div>
      </div>

      <div class="row">
        <label for="selPresetShared">Visibility</label>
        <div class="controls">
          <label class="inline">
            <input id="selPresetShared" type="checkbox">
            <span>Visible to all users</span>
          </label>
        </div>
      </div>
    </div>
  `);

  showModal(
    'Save selection',
    [{ key: 'form', label: 'Details' }],
    () => body,
    async () => {
      const name  = String(document.getElementById('selPresetName')?.value || '').trim();
      const share = !!document.getElementById('selPresetShared')?.checked;

      // Re-read & dedupe IDs at submit time
      const ids = Array.from(new Set((Array.from((window.__selection?.[section]?.ids) || []))
        .map(String).filter(Boolean)));

      if (!ids.length) { alert('No records selected.'); return false; }

      const mode = (document.querySelector('#saveSelectionForm input[name="mode"]:checked')?.value || 'new').toLowerCase();
      if (mode === 'append') {
        if (!owned.length) { alert('You donâ€™t own any selections to append.'); return false; }
        const targetId = (document.getElementById('selAppendPresetId')?.value) || '';
        if (!targetId) { alert('Select a selection to append to.'); return false; }

        // Fetch target â†’ dedupe-union â†’ PATCH kind: 'selection'
        const targetList = await listReportPresets({ section, kind: 'selection', include_shared: false }).catch(()=>[]);
        const target = (targetList || []).find(p => String(p.id) === String(targetId));
        const targetIds = Array.isArray(target?.selection_json?.ids) ? target.selection_json.ids.map(String).filter(Boolean) : [];
        const targetSet = new Set(targetIds);

        // Only add what isn't there already
        const toAdd = ids.filter(id => !targetSet.has(id));
        if (toAdd.length === 0) {
          alert('Those records are already in that selection. Nothing to append.');
          return false;
        }

        const merged = Array.from(new Set([...targetIds, ...toAdd]));

        await updateReportPreset({
          id: targetId,
          kind: 'selection',
          selection: { ids: merged }
          // keep name/visibility as-is
        });
      } else {
        if (!name) { alert('Please enter a name'); return false; }
        await createReportPreset({
          section,
          kind: 'selection',
          name,
          is_shared: share,
          filters: {},                         // not used for selections
          selection: { ids }                   // already deduped
        });
      }

      try { invalidatePresetCache(section, 'selection'); } catch {}
      return true;  // â† tells saveForFrame to treat as success and close the modal
    },
    false,
    undefined,
    { noParentGate: true, forceEdit: true, kind: 'selection-save' }
  );

  // Wire append toggling + name field enable/disable
  setTimeout(() => {
    const formEl = document.getElementById('saveSelectionForm');
    if (!formEl || formEl.dataset.wired === '1') return;
    formEl.dataset.wired = '1';

    const appendWrap = document.getElementById('selAppendWrap');
    const nameInput  = document.getElementById('selPresetName');

    const syncModeUI = () => {
      const modeEl = formEl.querySelector('input[name="mode"]:checked');
      const isAppend = !!(modeEl && modeEl.value === 'append');

      if (appendWrap) appendWrap.style.display = isAppend ? 'block' : 'none';

      if (nameInput) {
        nameInput.disabled = isAppend;
        nameInput.readOnly = isAppend;
      }
    };

    formEl.querySelectorAll('input[name="mode"]').forEach(r => {
      r.addEventListener('change', () => {
        syncModeUI();
      });
    });

    // Initialise UI (default is "new" so name should be editable)
    syncModeUI();
  }, 0);
}



async function openLoadSelectionModal(section) {
  const sanitize = (typeof window !== 'undefined' && typeof window.sanitize === 'function')
    ? window.sanitize
    : (s => String(s ?? '').replace(/&/g,'&amp;').replace(/</g,'&lt;')
                           .replace(/>/g,'&gt;').replace(/"/g,'&quot;')
                           .replace(/'/g,'&#39;'));

  let list = await listReportPresets({ section, kind: 'selection', include_shared: true }).catch(()=>[]);
  let selectedId = null;

  const renderList = () => {
    const myId = currentUserId();
    const mine   = (list || []).filter(r => String(r.user_id) === String(myId))
                     .sort((a,b)=>String(a.name||'').localeCompare(String(b.name||''), undefined, {sensitivity:'base'}));
    const shared = (list || []).filter(r => String(r.user_id) !== String(myId))
                     .sort((a,b)=>String(a.name||'').localeCompare(String(b.name||''), undefined, {sensitivity:'base'}));
    const rows = mine.concat(shared);

    const rowsHtml = rows.map(p => {
      const owned    = String(p.user_id) === String(myId);
      const nameHtml = `<span class="name">${sanitize(p.name || '(unnamed)')}</span>`;
      const creator  = (p.user && (p.user.display_name || p.user.email)) ? ` <span class="hint">â€¢ by ${sanitize(p.user.display_name || p.user.email)}</span>` : '';
      const badge    = p.is_shared ? `<span class="badge">shared</span>${creator}` : '';
      const trashBtn = owned ? `<button class="btn mini bin" title="Delete" data-act="delete">ðŸ—‘</button>` : '';
      return `
        <tr data-id="${p.id}">
          <td class="pick">${nameHtml} ${badge}</td>
          <td>${new Date(p.updated_at || p.created_at).toLocaleString()}</td>
          <td class="actions" style="text-align:right">${trashBtn}</td>
        </tr>`;
    }).join('') || `<tr><td colspan="3" class="hint">No saved selections</td></tr>`;

    return html(`
      <div class="form">
        <div class="row" style="justify-content:space-between;align-items:center">
          <strong>Saved selections</strong>
          <span class="hint">Section: <code>${sanitize(section)}</code></span>
        </div>
        <div class="row">
          <table class="grid compact" id="selPresetTable">
            <thead>
              <tr>
                <th>Name</th>
                <th>Updated</th>
                <th style="text-align:right">Delete</th>
              </tr>
            </thead>
            <tbody>${rowsHtml}</tbody>
          </table>
        </div>
      </div>
    `);
  };

  function wireTable() {
    const tbl = document.getElementById('selPresetTable');
    if (!tbl || tbl.__wired) return;
    tbl.__wired = true;

    const frame = window.__getModalFrame?.();
    const updateButtons = () => {
      try {
        const fr = window.__getModalFrame?.();
        if (!fr) return;
        fr.isDirty = !!selectedId; // just to enable Save/Load
        fr._updateButtons?.();
      } catch {}
    };

    // click â†’ select & enable Load
    tbl.addEventListener('click', (e) => {
      const tr = e.target && e.target.closest('tr[data-id]');
      const bin = e.target && e.target.closest('button[data-act="delete"]');
      if (bin) {
        // deletion handled in separate listener below
      }
      if (!tr) return;
      selectedId = tr.getAttribute('data-id');
      Array.from(tbl.querySelectorAll('tbody tr')).forEach(r => r.classList.toggle('selected', r === tr));
      updateButtons();
    });

    // dblclick â†’ apply immediately
    tbl.addEventListener('dblclick', async (e) => {
      const tr = e.target && e.target.closest('tr[data-id]');
      if (!tr) return;
      const id = tr.getAttribute('data-id');
      const chosen = (list || []).find(p => p.id === id);
      if (!chosen) return;

      const ids = Array.isArray(chosen?.selection_json?.ids) ? chosen.selection_json.ids : [];
      await applySelectionAsFilter(section, { ids });
      const closeBtn = document.getElementById('btnCloseModal');
      if (closeBtn) closeBtn.click();
    });

    // delete owned selection
    tbl.addEventListener('click', async (e) => {
      const bin = e.target && e.target.closest('button[data-act="delete"]');
      if (!bin) return;
      const tr = e.target && e.target.closest('tr[data-id]');
      const id = tr && tr.getAttribute('data-id');
      const row = (list || []).find(p => p.id === id);
      if (!row) return;
      const myIdNow = currentUserId();
      if (String(row.user_id) !== String(myIdNow)) return;
      if (!confirm(`Delete saved selection â€œ${row.name || '(unnamed)'}â€?`)) return;

      try { await deleteReportPreset(id); } catch (err) { alert(String(err?.message || err || 'Failed to delete preset')); return; }
      try { invalidatePresetCache(section, 'selection'); } catch {}
      list = await listReportPresets({ section, kind:'selection', include_shared:true }).catch(()=>[]);
      selectedId = null;
      updateButtons();

      const body = document.getElementById('modalBody');
      if (body) {
        const markup = renderList();
        if (typeof markup === 'string') body.innerHTML = markup;
        else if (markup && typeof markup.nodeType === 'number') body.replaceChildren(markup);
        else body.innerHTML = String(markup ?? '');
        wireTable();
      }
    });

    updateButtons();
  }

  showModal(
    'Load selection',
    [{ key: 'list', label: 'Saved' }],
    renderList,
    async () => {
      if (!selectedId) { alert('Pick a selection to load'); return false; }
      const chosen = (list || []).find(p => p.id === selectedId);
      if (!chosen) { alert('Selection not found'); return false; }
      const ids = Array.isArray(chosen?.selection_json?.ids) ? chosen.selection_json.ids : [];
      await applySelectionAsFilter(section, { ids });
      return true;
    },
    false,
    undefined,
    { noParentGate: true, forceEdit: true, kind: 'selection-load' }
  );

  setTimeout(wireTable, 0);
}


// ======================================
// FRONTEND â€” buildSearchQS (UPDATED: support ids[] â†’ id=in.(...))
// ======================================


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// buildSearchQS (amended) â€” map submission_mode â†’ default_submission_mode;
// keep original too for safety; pass has_custom_labels through
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function buildSearchQS(section, filters = {}) {
  window.__listState = window.__listState || {};
  const st = (window.__listState[section] ||= {
    page: 1,
    pageSize: 50,
    total: null,
    hasMore: false,
    filters: null,
    sort: { key: null, dir: 'asc' }
  });

  // Ensure we always have a sort object
  if (!st.sort || typeof st.sort !== 'object') {
    st.sort = { key: null, dir: 'asc' };
  }

  const qs = new URLSearchParams();
  const add = (key, val) => {
    if (val == null || val === '') return;
    qs.append(key, String(val));
  };
  const addArr = (key, arr) => {
    if (!Array.isArray(arr)) return;
    arr.forEach(v => {
      if (v != null && v !== '') qs.append(key, String(v));
    });
  };

  // paging
  if (st.pageSize !== 'ALL') {
    add('page', st.page || 1);
    add('page_size', st.pageSize || 50);
    add('include_count', 'true');
  } else {
    // âœ… ALL is normally handled by loadSection() paging. If someone calls search() directly while ALL,
    // request a safe high cap; backends can clamp.
    add('page', 1);
    add('page_size', 10000);
    add('include_count', 'true');
  }

  // IDs filter (show only these records)
  if (Array.isArray(filters.ids) && filters.ids.length > 0) {
    qs.append('id', `in.(${filters.ids.map(String).join(',')})`);
  }

  switch (section) {
    case 'candidates': {
      const {
        first_name,
        last_name,
        email,
        phone,
        pay_method,
        roles_any,
        active,
        created_from,
        created_to,

        // extra filters
        primary_job_title_contains,
        job_title_contains,
        prof_reg_number,
        prof_reg_type,
        dob,
        gender,
        town_city,
        postcode,
        updated_from,
        updated_to,
        sort_code,
        account_number,
        umbrella_name,
        tms_ref
      } = filters || {};

      add('first_name', first_name);
      add('last_name', last_name);
      add('email', email);
      add('phone', phone);
      add('pay_method', pay_method); // PAYE / UMBRELLA / BLANK

      addArr('roles_any', roles_any);

      if (typeof active === 'boolean') add('active', active);

      add('created_from', created_from);
      add('created_to', created_to);

      add('primary_job_title_contains', primary_job_title_contains);
      add('job_title_contains', job_title_contains);

      add('prof_reg_number', prof_reg_number);
      add('prof_reg_type', prof_reg_type);

      add('dob', dob);

      add('gender', gender);
      add('town_city', town_city);
      add('postcode', postcode);

      add('updated_from', updated_from);
      add('updated_to', updated_to);

      add('sort_code', sort_code);
      add('account_number', account_number);
      add('umbrella_name', umbrella_name);
      add('tms_ref', tms_ref);

      break;
    }

    case 'clients': {
      const {
        name,
        cli_ref,
        primary_invoice_email,
        invoice_address,
        postcode,
        ap_phone,
        vat_chargeable,
        payment_terms_days,
        mileage_charge_rate,
        ts_queries_email,
        created_from,
        created_to,
        updated_from,
        updated_to
      } = filters || {};

      if (name) add('q', name);
      add('cli_ref', cli_ref);
      add('primary_invoice_email', primary_invoice_email);
      add('invoice_address', invoice_address);
      add('postcode', postcode);
      add('ap_phone', ap_phone);
      if (typeof vat_chargeable === 'boolean') add('vat_chargeable', vat_chargeable);
      add('payment_terms_days', payment_terms_days);
      add('mileage_charge_rate', mileage_charge_rate);
      add('ts_queries_email', ts_queries_email);
      add('created_from', created_from);
      add('created_to', created_to);
      add('updated_from', updated_from);
      add('updated_to', updated_to);
      break;
    }

    case 'umbrellas': {
      const {
        name,
        bank_name,
        sort_code,
        account_number,
        vat_chargeable,
        enabled,
        created_from,
        created_to
      } = filters || {};
      if (name) add('q', name);
      add('bank_name', bank_name);
      add('sort_code', sort_code);
      add('account_number', account_number);
      if (typeof vat_chargeable === 'boolean') add('vat_chargeable', vat_chargeable);
      if (typeof enabled === 'boolean') add('enabled', enabled);
      add('created_from', created_from);
      add('created_to', created_to);
      break;
    }

    case 'timesheets': {
      const {
        booking_id,
        occupant_key_norm,
        hospital_norm,
        worked_from,
        worked_to,
        week_ending_from,
        week_ending_to,
        status,
        created_from,
        created_to
      } = filters || {};
      add('booking_id', booking_id);
      add('occupant_key_norm', occupant_key_norm);
      add('hospital_norm', hospital_norm);
      add('worked_from', worked_from);
      add('worked_to', worked_to);
      add('week_ending_from', week_ending_from);
      add('week_ending_to', week_ending_to);
      addArr('status', status);
      add('created_from', created_from);
      add('created_to', created_to);
      break;
    }

    case 'invoices': {
      const {
        // Support both: invoice_no (legacy) and q (preferred for /api/invoices)
        q,
        invoice_no,

        client_id,
        status,

        issued_from,
        issued_to,
        due_from,
        due_to,

        // âœ… requested (FE-ready)
        week_ending_from,
        week_ending_to,

        created_from,
        created_to
      } = filters || {};

      const qText =
        (q != null && String(q).trim() !== '')
          ? String(q).trim()
          : (invoice_no != null ? String(invoice_no).trim() : '');

      if (qText) add('q', qText);

      add('client_id', client_id);

      // status can be array or comma list string
      let statusArr = status;
      if (typeof statusArr === 'string' && statusArr.trim()) {
        statusArr = statusArr.split(',').map(s => s.trim()).filter(Boolean);
      }
      addArr('status', statusArr);

      add('issued_from', issued_from);
      add('issued_to', issued_to);
      add('due_from', due_from);
      add('due_to', due_to);

      add('week_ending_from', week_ending_from);
      add('week_ending_to', week_ending_to);

      add('created_from', created_from);
      add('created_to', created_to);
      break;
    }

    case 'contracts': {
      const weekdayCodeMap = {
        MON: 1, TUE: 2, WED: 3, THU: 4, FRI: 5, SAT: 6, SUN: 0
      };

      const {
        q: qText,
        candidate_name,
        client_name,
        candidate_id,
        client_id,
        role,
        band,
        pay_method_snapshot,
        submission_mode,
        week_ending_weekday_snapshot,
        require_reference_to_pay,
        require_reference_to_invoice,
        has_custom_labels,
        active_on,
        start_date_from,
        start_date_to,
        end_date_from,
        end_date_to,
        created_from,
        created_to,
        updated_from,
        updated_to,
        auto_invoice,
        mileage_pay_rate,
        mileage_charge_rate,
        status
      } = filters || {};

      add('q', qText);
      add('candidate_name', candidate_name);
      add('client_name', client_name);
      add('candidate_id', candidate_id);
      add('client_id', client_id);
      add('role', role);
      add('band', band);
      add('pay_method_snapshot', pay_method_snapshot);

      if (submission_mode) {
        add('default_submission_mode', submission_mode);
        add('submission_mode', submission_mode);
      }

      if (week_ending_weekday_snapshot) {
        const codeUpper = String(week_ending_weekday_snapshot).toUpperCase();
        const mapped = weekdayCodeMap[codeUpper];
        add('week_ending_weekday_snapshot', mapped != null ? mapped : week_ending_weekday_snapshot);
      }

      if (typeof auto_invoice === 'boolean') add('auto_invoice', auto_invoice);
      if (typeof require_reference_to_pay === 'boolean') add('require_reference_to_pay', require_reference_to_pay);
      if (typeof require_reference_to_invoice === 'boolean') add('require_reference_to_invoice', require_reference_to_invoice);
      if (typeof has_custom_labels === 'boolean') add('has_custom_labels', has_custom_labels);
      add('active_on', active_on);

      add('start_date_from', start_date_from);
      add('start_date_to',   start_date_to);
      add('end_date_from',   end_date_from);
      add('end_date_to',     end_date_to);
      add('created_from',    created_from);
      add('created_to',      created_to);
      add('updated_from',    updated_from);
      add('updated_to',      updated_to);

      add('mileage_pay_rate',    mileage_pay_rate);
      add('mileage_charge_rate', mileage_charge_rate);

      if (status) add('status', status);

      break;
    }
  }

  // Sorting (shared for all sections that support it)
  const sort = st.sort && typeof st.sort === 'object' ? st.sort : null;
  if (sort && sort.key) {
    qs.set('order_by', String(sort.key));
    qs.set('order_dir', sort.dir === 'desc' ? 'desc' : 'asc');
  }

  return qs.toString();
}


// -----------------------------
// NEW: Save search modal (new / overwrite / shared)
// -----------------------------

// === REPLACE: openSaveSearchModal (no currentWorked; built-in sanitize) ===
// === REPLACE: openSaveSearchModal (radio-safe + stable layout + full-width dropdown)
// ======================================
// FRONTEND â€” openSaveSearchModal (UPDATED)
// Behaviour:
// - If there IS a selection: show â€œSave Selectionâ€ UI only (Save new / Append).
// - If there is NO selection: show â€œSave Filtersâ€ UI only.
// ======================================
// Save selection/search modal â€” simplified choices per your spec
async function openSaveSearchModal(section, filters){
  const sanitize = (typeof window !== 'undefined' && typeof window.sanitize === 'function')
    ? window.sanitize
    : (s => String(s ?? '').replace(/&/g,'&amp;').replace(/</g,'&lt;')
                           .replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;'));

  // Selection present?
  window.__selection = window.__selection || {};
  const sel = window.__selection[section];
  const hasSelection = !!sel && sel.ids && sel.ids.size > 0;

  // If weâ€™re going to append, we need the userâ€™s presets list
  const mineServer = await listReportPresets({ section, kind: 'search', include_shared: false }).catch(()=>[]);
  const myId = currentUserId();
  const mine = (mineServer || []).filter(m => String(m.user_id) === String(myId));
  const hasOwned = Array.isArray(mine) && mine.length > 0;
  const optionsHtml = hasOwned
    ? mine.map(m => `<option value="${m.id}">${sanitize(m.name)}</option>`).join('')
    : '';

  let body;
  if (hasSelection) {
    body = html(`
      <div class="form" id="saveSearchForm" style="max-width:720px">
        <div class="row">
          <label for="presetName">Preset name</label>
          <div class="controls">
            <input id="presetName" name="preset_name" class="input" placeholder="e.g. â€˜Shortlist â€” RMNsâ€™" />
          </div>
        </div>

        <div class="row">
          <label>Mode</label>
          <div class="controls" style="display:flex;flex-direction:column;gap:8px;min-width:0">
            <div style="display:flex;gap:12px;align-items:center;flex-wrap:wrap">
              <label class="inline"><input type="radio" name="mode" value="new" checked> <span>Save selection as new</span></label>
              <label class="inline">
                <input type="radio" name="mode" value="append" ${hasOwned ? '' : 'disabled'}>
                <span>Append to existing selection</span>
              </label>
            </div>
            <div id="appendWrap" style="display:none; width:100%; max-width:100%">
              <div class="hint" style="margin:2px 0 4px">${hasOwned ? 'Choose selection to append to' : 'You donâ€™t own any selections to append'}</div>
              <select id="appendPresetId" class="select" style="width:100%; max-width:100%">${optionsHtml}</select>
            </div>
          </div>
        </div>

        <div class="row">
          <label for="presetShared">Visibility</label>
          <div class="controls">
            <label class="inline"><input id="presetShared" type="checkbox"> <span>Visible to all users</span></label>
          </div>
        </div>
      </div>
    `);
  } else {
    body = html(`
      <div class="form" id="saveSearchForm" style="max-width:720px">
        <div class="row">
          <label for="presetName">Preset name</label>
          <div class="controls">
            <input id="presetName" name="preset_name" class="input" placeholder="e.g. â€˜PAYE RMNsâ€™" />
          </div>
        </div>

        <div class="row">
          <label>Visibility</label>
          <div class="controls">
            <label class="inline"><input id="presetShared" type="checkbox"> <span>Visible to all users</span></label>
          </div>
        </div>
      </div>
    `);
  }

  showModal(
    hasSelection ? 'Save selection' : 'Save search',
    [{ key: 'form', label: 'Details' }],
    () => body,
    async () => {
      const name  = String(document.getElementById('presetName')?.value || '').trim();
      const share = !!document.getElementById('presetShared')?.checked;
      if (!name && !hasSelection) { alert('Please enter a name'); return false; }

      // Recompute selection now
      const curSel = window.__selection[section];
      const hasSelectionNow = !!curSel && curSel.ids && curSel.ids.size>0;

      if (hasSelectionNow) {
        const modeInput = document.querySelector('#saveSearchForm input[name="mode"]:checked');
        const mode = (modeInput?.value || 'new').toLowerCase();
        if (mode === 'append') {
          if (!hasOwned) { alert('You donâ€™t own any selections to append'); return false; }
          const targetId = (document.getElementById('appendPresetId')?.value) || '';
          if (!targetId) { alert('Select a selection to append to'); return false; }

          const target = (await listReportPresets({ section, kind:'search', include_shared:false }).catch(()=>[])).find(p => String(p.id) === String(targetId));
          const targetSel = target?.selection || target?.selection_json || null;
          const merged = mergeSelectionSnapshots(section,
            { section, fingerprint: targetSel?.fingerprint || '', ids: Array.from(new Set((targetSel?.ids||[]).map(String))) },
            { section, fingerprint: curSel.fingerprint || '',  ids: Array.from(curSel.ids || []) }
          );
          await updateReportPreset({ id: targetId, name: target?.name, section, kind:'search', selection: merged, is_shared: target?.is_shared });
        } else {
          const payload = {
            section, kind:'search', name, is_shared: share,
            selection: {
              fingerprint: curSel.fingerprint || '',
              ids: Array.from(curSel.ids || [])
            }
          };
          await createReportPreset(payload);
        }
      } else {
        const payload = { section, kind:'search', name, is_shared: share, filters: filters || {} };
        await createReportPreset(payload);
      }

      invalidatePresetCache(section, 'search');
      try { window.dispatchEvent(new Event('search-preset-updated')); } catch(_) {}
      return true;
    },
    false,
    undefined,
    { noParentGate: true, forceEdit: true, kind: hasSelection ? 'selection-save' : 'search-save' }
  );

  // Wire append toggling (only in selection mode)
  if (hasSelection) {
    setTimeout(() => {
      const formEl = document.getElementById('saveSearchForm');
      if (!formEl || formEl.dataset.wired === '1') return;
      formEl.dataset.wired = '1';
      const appendWrap = document.getElementById('appendWrap');
      formEl.querySelectorAll('input[name="mode"]').forEach(r =>
        r.addEventListener('change', () => {
          const isAppend = r.value === 'append' && r.checked;
          if (appendWrap) appendWrap.style.display = isAppend ? 'block' : 'none';
        })
      );
    }, 0);
  }
}

// === REPLACE: openLoadSearchModal (built-in sanitize; no globals required) ===
// FRONTEND â€” UPDATED
// openLoadSearchModal: emit event with filters (so parent re-applies after repaint),
// stage-delete UI kept; shows shared badge and (when present) creator.


// ======================================
// FRONTEND â€” openLoadSearchModal (UPDATED)
// Behaviour: list saved presets; double-click applies immediately & closes.
// - If preset has selection with explicit ids â†’ show only those (applySelectionAsFilter).
// - If selection has allMatching=true â†’ apply its filters instead.
// - If preset is a filters-only search â†’ apply filters.
// ======================================

async function openLoadSearchModal(section){
  const sanitize = (typeof window !== 'undefined' && typeof window.sanitize === 'function')
    ? window.sanitize
    : (s => String(s ?? '').replace(/&/g,'&amp;').replace(/</g,'&lt;')
                           .replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;'));

  // Filters-only presets
  let list = await listReportPresets({ section, kind: 'search', include_shared: true }).catch(()=>[]);
  let selectedId = null;

  function sortMineThenShared(rows, myId) {
    const mine   = (rows || []).filter(r => String(r.user_id) === String(myId))
                     .sort((a,b)=>String(a.name||'').localeCompare(String(b.name||''), undefined, {sensitivity:'base'}));
    const shared = (rows || []).filter(r => String(r.user_id) !== String(myId))
                     .sort((a,b)=>String(a.name||'').localeCompare(String(b.name||''), undefined, {sensitivity:'base'}));
    return mine.concat(shared);
  }

  const renderList = () => {
    const myId = currentUserId();
    const rows = sortMineThenShared(list || [], myId);

    const rowsHtml = rows.map(p => {
      const owned    = String(p.user_id) === String(myId);
      const nameHtml = `<span class="name">${sanitize(p.name)}</span>`;
      const creator  = (p.user && (p.user.display_name || p.user.email)) ? ` <span class="hint">â€¢ by ${sanitize(p.user.display_name || p.user.email)}</span>` : '';
      const badge    = p.is_shared ? `<span class="badge">shared</span>${creator}` : '';
      const trashBtn = owned ? `<button class="bin btn btn-ghost btn-sm" title="Delete">ðŸ—‘</button>` : '';
      return `
        <tr data-id="${p.id}">
          <td class="pick">${nameHtml} ${badge}</td>
          <td>${new Date(p.updated_at || p.created_at).toLocaleString()}</td>
          <td class="actions">${trashBtn}</td>
        </tr>`;
    }).join('') || `<tr><td colspan="3" class="hint">No saved searches</td></tr>`;

    return html(`
      <div class="form">
        <div class="row" style="justify-content:space-between;align-items:center">
          <strong>Saved searches</strong>
          <span class="hint">Section: <code>${sanitize(section)}</code></span>
        </div>
        <div class="row">
          <table class="grid compact" id="presetTable">
            <thead><tr><th>Name</th><th>Updated</th><th></th></tr></thead>
            <tbody>${rowsHtml}</tbody>
          </table>
        </div>
      </div>
    `);
  };

  function wirePresetTable() {
    const tbl = document.getElementById('presetTable');
    if (!tbl || tbl.__wired) return;
    tbl.__wired = true;

    // Select row on click
    tbl.addEventListener('click', (e) => {
      const tr = e.target && e.target.closest('tr[data-id]');
      if (!tr) return;
      selectedId = tr.getAttribute('data-id');
      Array.from(tbl.querySelectorAll('tbody tr')).forEach(r => r.classList.toggle('selected', r === tr));
    });

    // Double-click: apply filters immediately and close + notify parent
    tbl.addEventListener('dblclick', async (e) => {
      const tr = e.target && e.target.closest('tr[data-id]');
      if (!tr) return;
      const id = tr.getAttribute('data-id');
      const chosen = (list || []).find(p => p.id === id);
      if (!chosen) return;

      const filters = chosen.filters || chosen.filters_json || chosen.filtersJson || {};

      window.__listState = window.__listState || {};
      const st = (window.__listState[section] ||= { page:1, pageSize:50, total:null, hasMore:false, filters:null });
      st.page = 1; st.filters = filters || {};
      const rows = await search(section, st.filters);
      renderSummary(rows);

      // notify parent advanced-search to re-populate its form
      try { window.__PENDING_ADV_PRESET = { section, filters: st.filters || {} }; } catch {}

      const closeBtn = document.getElementById('btnCloseModal');
      if (closeBtn) closeBtn.click();
    });

    // Delete handler
    tbl.addEventListener('click', async (e) => {
      const bin = e.target && e.target.closest('button.bin');
      if (!bin) return;
      const tr = e.target && e.target.closest('tr[data-id]');
      const id = tr && tr.getAttribute('data-id');
      const row = (list || []).find(p => p.id === id);
      if (!row) return;
      const myIdNow = currentUserId();
      if (String(row.user_id) !== String(myIdNow)) return;
      if (!confirm(`Delete saved preset â€œ${row.name}â€? This cannot be undone.`)) return;

      try { await deleteReportPreset(id); } catch (err) { alert(String(err?.message || err || 'Failed to delete preset')); return; }
      try { invalidatePresetCache(section, 'search'); } catch {}
      list = await listReportPresets({ section, kind:'search', include_shared:true }).catch(()=>[]);

      const body = document.getElementById('modalBody');
      if (body) {
        const markup = renderList();
        if (typeof markup === 'string') body.innerHTML = markup;
        else if (markup && typeof markup.nodeType === 'number') body.replaceChildren(markup);
        else body.innerHTML = String(markup ?? '');
        wirePresetTable();
      }
    });
  }

  showModal(
    'Load saved search',
    [{ key: 'list', label: 'Saved' }],
    renderList,
    async () => {
      if (!selectedId) { alert('Pick a preset to load'); return false; }
      const chosen = (list || []).find(p => p.id === selectedId);
      if (!chosen) { alert('Preset not found'); return false; }

      const filters = chosen.filters || chosen.filters_json || chosen.filtersJson || {};
      window.__listState = window.__listState || {};
      const st = (window.__listState[section] ||= { page:1, pageSize:50, total:null, hasMore:false, filters:null });
      st.page = 1; st.filters = filters || {};
      const rows = await search(section, st.filters);
      renderSummary(rows);

      // notify parent advanced-search to re-populate its form
      try { window.__PENDING_ADV_PRESET = { section, filters: st.filters || {} }; } catch {}
      return true; // child closes; parent will onReturn and re-populate form
    },
    false,
    undefined,
    { noParentGate: true, forceEdit: true, kind: 'search-load' }
  );

  setTimeout(wirePresetTable, 0);
}



// ============================================================================
// Selection presets â€” wrappers to save/list/load selection presets via backend
// ============================================================================

/**
 * Save a selection preset.
 * By default uses kind: 'selection' to keep it distinct from pure filter presets,
 * but your backend can also store it under kind: 'search' with a `selection` block.
 */

/** List selection presets for a section (owned + shared if requested). */
async function listSelectionPresets(section, { include_shared = true } = {}) {
  if (typeof listReportPresets === 'function') {
    return await listReportPresets({ section, kind: 'selection', include_shared });
  }
  // Fallback, if needed:
  const qs = new URLSearchParams({ section, kind: 'selection', include_shared: include_shared ? 'true' : 'false' });
  const res = await authFetch(API(`/api/report-presets?${qs}`));
  return res?.ok ? res.json().catch(()=>[]) : [];
}

/**
 * Load a selection preset by ID or name. Returns the preset object (or null).
 * Note: this does not apply it â€” use applySelectionSnapshot() or mergeSelectionSnapshots().
 */
async function loadSelectionPreset(section, idOrName) {
  const all = await listSelectionPresets(section, { include_shared: true }) || [];
  if (!idOrName) return null;
  const match = all.find(p => String(p.id) === String(idOrName)) ||
                all.find(p => String(p.name || '').toLowerCase() === String(idOrName).toLowerCase());
  return match || null;
}
















// -----------------------------
// UPDATED: openSearchModal()
// - Fix search submit path (object filters, not JSON string)
// - Provide inline Save/Load buttons that open child modals
// -----------------------------
// -----------------------------
// FIXED: openSearchModal()
// - No undefined variables
// - Uses attachUkDatePicker + extractFiltersFromForm
// - Section-aware fields that match buildSearchQS()
// -----------------------------
// === REPLACE: openSearchModal (icons + robust wiring + fallback for old text buttons) ===
// === FORCE-HIDE legacy buttons (one-time CSS) ===
// Run once: force-hide any legacy white buttons, and add compact button styles
(function ensureAdvancedSearchCSS(){
  if (document.getElementById('advSearchCSS')) return;
  const s = document.createElement('style');
  s.id = 'advSearchCSS';
  s.textContent = `
    /* never show legacy white buttons */
    #btnLoadSavedSearch, #btnSaveSearch { display: none !important; visibility: hidden !important; }

    /* compact, not-white text buttons */
    .adv-btn {
      height: 26px;
      padding: 0 10px;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      background: #f3f4f6;          /* not white */
      color: #111827;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
    }
    .adv-btn:hover { background: #e5e7eb; }
  `;
  document.head.appendChild(s);
})();

async function openSearchModal(opts = {}) {
  // âœ… UPDATED: Timesheets advanced search aligns to summary filters (tools_stage + issues_filter)
  // Keep invoices status list as-is
  const INVOICE_STATUS = ['DRAFT','ISSUED','ON_HOLD','PAID'];

  const row = (label, inner) => `
    <div class="row">
      <label>${label}</label>
      <div class="controls">${inner}</div>
    </div>`;

  const inputText = (name, placeholder='') =>
    `<input class="input" type="text" name="${name}" placeholder="${placeholder}" />`;

  const boolSelect = (name) => `
    <select name="${name}">
      <option value="">Any</option>
      <option value="true">Yes</option>
      <option value="false">No</option>
    </select>`;

  const datePair = (fromName, fromLabel, toName, toLabel) => `
    ${row(fromLabel, `<input class="input" type="text" name="${fromName}" placeholder="DD/MM/YYYY" />`)}
    ${row(toLabel,   `<input class="input" type="text" name="${toName}"   placeholder="DD/MM/YYYY" />`)}`;

  // Inline date range (From / To on one row)
  const dateRangeRow = (fromName, toName, label) => row(label, `
    <div class="split">
      <input class="input" type="text" name="${fromName}" placeholder="From DD/MM/YYYY" />
      <input class="input" type="text" name="${toName}"   placeholder="To DD/MM/YYYY" />
    </div>`);

  const multi = (name, values) =>
    `<select name="${name}" multiple size="6">${values.map(v=>`<option value="${v}">${v}</option>`).join('')}</select>`;

  const friendly = (section, key, fallback) => {
    try {
      if (typeof getFriendlyHeaderLabel === 'function') {
        const lbl = getFriendlyHeaderLabel(section, key);
        if (lbl && typeof lbl === 'string') return lbl;
      }
    } catch {}
    return fallback || key;
  };

  // Section-specific filters
  let inner = '';
  if (currentSection === 'candidates') {
    let roleOptions = [];
    try { roleOptions = await loadGlobalRoleOptions(); } catch { roleOptions = []; }

    inner = [
      // Basic identity / contact
      row('First name',           inputText('first_name')),
      row('Last name',            inputText('last_name')),
      row('Email',                `<input class="input" type="email" name="email" placeholder="name@domain" />`),
      row('Telephone',            inputText('phone')),

      // Pay type (including blank)
      row('Pay type', `
        <select name="pay_method">
          <option value="">Any</option>
          <option value="PAYE">PAYE</option>
          <option value="UMBRELLA">UMBRELLA</option>
          <option value="BLANK">Blank</option>
        </select>`),

      // Care Package Role (rota roles)
      row('Care Package Role (any)', `
        <select name="roles_any" multiple size="6">
          ${roleOptions.map(r => `<option value="${r}">${r}</option>`).join('')}
        </select>`),

      // Job titles
      row('Primary Job Title contains', inputText('primary_job_title_contains', 'e.g. CPN')),
      row('Any Job Title contains',     inputText('job_title_contains', 'includes primary and secondary')),

      // Professional registration
      row('Professional Reg Number', inputText('prof_reg_number')),
      row('Professional Reg Type', `
        <select name="prof_reg_type">
          <option value="">Any</option>
          <option value="NMC">NMC</option>
          <option value="GMC">GMC</option>
          <option value="HCPC">HCPC</option>
        </select>`),

      // DOB exact
      row('Date of birth', `<input class="input" type="text" name="dob" placeholder="DD/MM/YYYY" />`),

      // Gender / location
      row('Gender', `
        <select name="gender">
          <option value="">Any</option>
          <option value="Male">Male</option>
          <option value="Female">Female</option>
          <option value="Other">Other</option>
        </select>`),
      row('City',     inputText('town_city', 'Town / City')),
      row('Postcode', inputText('postcode', 'e.g. W7 3EE')),

      // Status + created range (inline)
      row('Active', boolSelect('active')),
      dateRangeRow('created_from','created_to','Created date (from / to)'),

      // Last updated range (inline)
      dateRangeRow('updated_from','updated_to','Last updated (from / to)'),

      // Banking / umbrella / ref
      row('Sort Code',       inputText('sort_code', '12-34-56')),
      row('Account Number',  inputText('account_number')),
      row('Umbrella Name',   inputText('umbrella_name')),
      row('TMS Ref',         inputText('tms_ref'))
    ].join('');

  } else if (currentSection === 'clients') {
    const lblName     = friendly('clients','name','Client name');
    const lblCliRef   = friendly('clients','cli_ref','Client ref');
    const lblEmail    = friendly('clients','primary_invoice_email','Invoice email');
    const lblInvAddr  = friendly('clients','invoice_address','Invoice address');
    const lblPost     = friendly('clients','postcode','Postcode');
    const lblApPhone  = friendly('clients','ap_phone','A/P phone');

    inner = [
      row(lblName,          inputText('name', 'partial match')),
      row(lblCliRef,        inputText('cli_ref')),
      row(lblEmail,         `<input class="input" type="email" name="primary_invoice_email" placeholder="ap@client" />`),
      row(lblInvAddr,       inputText('invoice_address')),
      row(lblPost,          inputText('postcode')),
      row(lblApPhone,       inputText('ap_phone')),
      row('VAT chargeable (Yes/No)', boolSelect('vat_chargeable')),
      row('Payment terms (days)', `<input class="input" type="number" name="payment_terms_days" min="0" />`),
      row('Mileage charge rate',  `<input class="input" type="number" step="0.01" name="mileage_charge_rate" />`),
      row('Timesheet queries email', `<input class="input" type="email" name="ts_queries_email" placeholder="ts@client" />`),
      dateRangeRow('created_from','created_to','Created date (from / to)'),
      dateRangeRow('updated_from','updated_to','Last updated (from / to)')
    ].join('');

  } else if (currentSection === 'umbrellas') {
    inner = [
      row('Name',                 inputText('name')),
      row('Bank',                 inputText('bank_name')),
      row('Sort code',            inputText('sort_code', '12-34-56')),
      row('Account number',       inputText('account_number')),
      row('VAT chargeable',       boolSelect('vat_chargeable')),
      row('Enabled',              boolSelect('enabled')),
      datePair('created_from','Created from','created_to','Created to')
    ].join('');

  } else if (currentSection === 'timesheets') {
    // âœ… Updated to match the NEW canonical summary model:
    // tools_stage + issues_filter + route/scope + week-ending + checkboxes via boolSelect
    inner = [
      row('Tools stage', `
        <select name="tools_stage">
          <option value="">Any</option>
          <option value="UNPROCESSED">Unprocessed</option>
          <option value="PROCESSING_DELAYED">Processing Delayed</option>
          <option value="AWAITING_AUTHORISATION">Awaiting Authorisation</option>
          <option value="AUTHORISED_FOR_INVOICING">Authorised for Invoicing</option>
          <option value="INVOICED">Invoiced</option>
        </select>`),

      row('Issues', `
        <select name="issues_filter">
          <option value="">Any</option>
          <option value="NO_MATCH_ID">No match to Candidate/Client</option>
          <option value="RATE_MISSING">Rate missing</option>
          <option value="PAY_CHAN_MISS">Pay channel missing</option>
          <option value="AWAITING_HR_VALIDATION">Awaiting HR validation</option>
          <option value="HR_HOURS_MISMATCH">Hours mismatch (HealthRoster)</option>
          <option value="HR_HOURS_MISSING">HR hours missing</option>
          <option value="DUPLICATE_CONTRACTS">Duplicate contracts</option>
          <option value="TIMESHEET_EVIDENCE">Timesheet evidence missing</option>
          <option value="EXPENSES_EVIDENCE">Expenses evidence missing</option>
          <option value="MILEAGE_EVIDENCE">Mileage evidence missing</option>
          <option value="REFERENCE_MISSING">Reference missing</option>
          <option value="REFS_PDF_INVALID">Refs - Timesheet PDF invalid</option>
          <option value="VALIDATION">Validation</option>
          <option value="ON_HOLD">On hold</option>
          <option value="AUTHORISATION">Awaiting Authorisation</option>
          <option value="QR_NOT_ISSUED">QR not issued</option>
          <option value="QR_AWAITING_SIGNATURE">QR awaiting signature</option>
        </select>`),

      row('Route', `
        <select name="route_type">
          <option value="">Any</option>
          <option value="ALL">All</option>
          <option value="ELECTRONIC">Electronic</option>
          <option value="MANUAL">Manual</option>
          <option value="NHSP">NHSP</option>
          <option value="HEALTHROSTER">HealthRoster</option>
          <option value="QR">QR</option>
        </select>`),

      row('Type (scope)', `
        <select name="sheet_scope">
          <option value="">Any</option>
          <option value="ALL">Both</option>
          <option value="WEEKLY">Weekly</option>
          <option value="DAILY">Daily</option>
        </select>`),

      row('QR status', `
        <select name="qr_status">
          <option value="">Any</option>
          <option value="PENDING">PENDING</option>
          <option value="SIGNED">SIGNED</option>
          <option value="REFUSED">REFUSED</option>
          <option value="REISSUE_REQUIRED">REISSUE_REQUIRED</option>
        </select>`),

      dateRangeRow('week_ending_from','week_ending_to','Week ending (from / to)'),

      row('Candidate paid', boolSelect('candidate_paid')),
      row('Adjusted timesheets', boolSelect('is_adjusted'))
    ].join('');

  } else if (currentSection === 'invoices') {
    inner = [
      row('Invoice no',           inputText('invoice_no')),
      row('Client ID',            inputText('client_id', 'UUID')),
      row('Status',               multi('status', INVOICE_STATUS)),
      datePair('issued_from','Issued from','issued_to','Issued to'),
      datePair('due_from','Due from','due_to','Due to'),
      datePair('created_from','Created from','created_to','Created to')
    ].join('');

  } else if (currentSection === 'contracts') {
    const weekdayOptions = [
      { value: '',    label: 'Any'    },
      { value: 'MON', label: 'Monday' },
      { value: 'TUE', label: 'Tuesday' },
      { value: 'WED', label: 'Wednesday' },
      { value: 'THU', label: 'Thursday' },
      { value: 'FRI', label: 'Friday' },
      { value: 'SAT', label: 'Saturday' },
      { value: 'SUN', label: 'Sunday' }
    ];

    const lblCandName  = friendly('contracts','candidate_display','Candidate name');
    const lblClient    = friendly('contracts','client_name','Client name');
    const lblBand      = friendly('contracts','band','Band');
    const lblRole      = friendly('contracts','role','Role');
    const lblPaySnap   = friendly('contracts','pay_method_snapshot','Pay method snapshot');
    const lblSubMode   = friendly('contracts','default_submission_mode','Submission mode');

    inner = [
      row('Free text',            inputText('q', 'client / candidate / role')),

      // Explicit name filters
      row(`${lblCandName} contains`, inputText('candidate_name', 'partial name match')),
      row(`${lblClient} contains`,   inputText('client_name', 'partial name match')),

      row('Candidate ID',         inputText('candidate_id', 'UUID')),
      row('Client ID',            inputText('client_id', 'UUID')),
      row(lblRole,                inputText('role', 'e.g. RMN')),
      row(lblBand,                inputText('band', 'e.g. 5 / 6 / 7')),
      row(lblPaySnap,  `
        <select name="pay_method_snapshot">
          <option value="">Any</option>
          <option value="PAYE">PAYE</option>
          <option value="UMBRELLA">UMBRELLA</option>
        </select>`),
      row(lblSubMode,      `
        <select name="submission_mode">
          <option value="">Any</option>
          <option value="MANUAL">Manual</option>
          <option value="ELECTRONIC">Electronic</option>
        </select>`),

      row('Start date (from / to)',
        `<div class="split">
           <input class="input" type="text" name="start_date_from" placeholder="From DD/MM/YYYY" />
           <input class="input" type="text" name="start_date_to"   placeholder="To DD/MM/YYYY" />
         </div>`),

      row('End date (from / to)',
        `<div class="split">
           <input class="input" type="text" name="end_date_from" placeholder="From DD/MM/YYYY" />
           <input class="input" type="text" name="end_date_to"   placeholder="To DD/MM/YYYY" />
         </div>`),

      row('Week-ending weekday',  `
        <select name="week_ending_weekday_snapshot">
          ${weekdayOptions.map(o=>`<option value="${o.value}">${o.label}</option>`).join('')}
        </select>`),

      row('Auto invoice',           boolSelect('auto_invoice')),
      row('Require ref to pay',     boolSelect('require_reference_to_pay')),
      row('Require ref to invoice', boolSelect('require_reference_to_invoice')),
      row('Has custom labels',      boolSelect('has_custom_labels')),
      row('Active on date',         `<input class="input" type="text" name="active_on" placeholder="DD/MM/YYYY" />`),

      dateRangeRow('created_from','created_to','Created date (from / to)'),
      dateRangeRow('updated_from','updated_to','Last updated (from / to)'),

      row('Mileage pay rate',    `<input class="input" type="number" step="0.01" name="mileage_pay_rate" />`),
      row('Mileage charge rate', `<input class="input" type="number" step="0.01" name="mileage_charge_rate" />`)
    ].join('');
  } else {
    inner = `<div class="tabc">No filters for this section.</div>`;
  }

  // Header: two small dark buttons, side by side, using .adv-btn styling
  const headerHtml = `
    <div class="row" id="searchHeaderRow" style="justify-content:flex-end;gap:6px;margin-bottom:.5rem">
      <div class="controls" style="display:flex;justify-content:flex-end;gap:6px">
        <button type="button" class="adv-btn" data-adv-act="load">Load saved search</button>
        <button type="button" class="adv-btn" data-adv-act="save">Save search</button>
      </div>
    </div>`;

  const formHtml = `
    <div class="form" id="searchForm">
      ${headerHtml}
      ${inner}
    </div>
  `;

  showModal(
    'Advanced Search',
    [{ key: 'filter', title: 'Filters' }],
    () => formHtml,
    async () => {
      window.__listState = window.__listState || {};
      const st = (window.__listState[currentSection] ||= {
        page: 1,
        pageSize: 50,
        total: null,
        hasMore: false,
        filters: null
      });
      st.page = 1;

      // Reset selection for the new dataset (IDs-only)
      window.__selection = window.__selection || {};
      const sel = (window.__selection[currentSection] ||= { fingerprint:'', ids:new Set() });

      const filters = extractFiltersFromForm('#searchForm');
      sel.fingerprint = JSON.stringify({ section: currentSection, filters });
      sel.ids.clear();

      // Persist filters into list state (so paging + re-open uses the same criteria)
      st.filters = { ...(filters || {}) };

      // âœ… Timesheets: run via the normal section list path (summary endpoint), not /api/search/timesheets
      // This keeps Tools Stage / Issues logic consistent with the main Timesheets Summary.
      let rows = null;
      if (currentSection === 'timesheets') {
        rows = await loadSection();
      } else {
        rows = await search(currentSection, filters);
      }

      if (rows) renderSummary(rows);
      return true; // saveForFrame will close this advanced-search frame on success
    },
    false,
    () => {
      // Apply pending preset (if a child "Load search" just set it)
      const pending = (typeof window !== 'undefined') ? window.__PENDING_ADV_PRESET : null;
      if (pending && pending.section) {
        try {
          window.dispatchEvent(new CustomEvent('adv-search-apply-preset', { detail: pending }));
        } catch {}
      }
      if (typeof window !== 'undefined') delete window.__PENDING_ADV_PRESET;

      try { wireAdvancedSearch(); } catch {}

      // Prefill from current filters immediately on mount
      try {
        window.__listState = window.__listState || {};
        const st = (window.__listState[currentSection] ||= {
          page:1,
          pageSize:50,
          total:null,
          hasMore:false,
          filters:null
        });
        populateSearchFormFromFilters(st.filters || {}, '#searchForm');
      } catch {}

      // Wire datepickers to *all* DD/MM/YYYY fields (including From/To ranges)
      try {
        if (typeof attachUkDatePicker === 'function') {
          const root = document.getElementById('searchForm');
          if (root) {
            root.querySelectorAll('input[type="text"]').forEach(el => {
              const ph = (el.getAttribute('placeholder') || '').toUpperCase();
              if (ph.includes('DD/MM/YYYY')) {
                // Avoid double-wiring, in case modal is reopened
                if (!el.__ukPickerWired) {
                  attachUkDatePicker(el);
                  el.__ukPickerWired = true;
                }
              }
            });
          }
        }
      } catch {}
    },
    { noParentGate: true, forceEdit: true, kind: 'advanced-search' }
  );

  // Extra wiring (eg. load/save presets actions)
  setTimeout(wireAdvancedSearch, 0);
}

function renderTimesheetIssuesTab(ctx) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][ISSUES]');
  const { row, details } = normaliseTimesheetCtx(ctx);

  GC('render');

  const tsfin  = details.tsfin || {};
  const ts     = details.timesheet || {};

  // âœ… Use the shared helper for requiresAuth/authorised/badge rule (per spec)
  let authInfo = { requires: false, authorised: false, showAwaitingBadge: false };
  if (typeof computeRequiresTimesheetAuthorisation === 'function') {
    try {
      authInfo = computeRequiresTimesheetAuthorisation(details, row) || authInfo;
    } catch (e) {
      if (LOGM) L('[ISSUES] computeRequiresTimesheetAuthorisation failed (non-fatal)', e);
    }
  }

  // âœ… Use the shared helper for the mutually-exclusive Processing State label (per spec)
  let ps = { key: '', label: 'Unprocessed' };
  if (typeof computeTimesheetProcessingState === 'function') {
    try {
      ps = computeTimesheetProcessingState(details, row) || ps;
    } catch (e) {
      if (LOGM) L('[ISSUES] computeTimesheetProcessingState failed (non-fatal)', e);
    }
  } else {
    // If helper is not yet implemented, do not invent alternate state logic here.
    // The tab must still render without crashing.
    ps = { key: 'UNPROCESSED', label: 'Unprocessed' };
  }

  const esc = (typeof escapeHtml === 'function')
    ? escapeHtml
    : (s) => String(s == null ? '' : s)
        .replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')
        .replace(/"/g,'&quot;').replace(/'/g,'&#39;');

  const fmtYmdToDmy = (ymd) => {
    const s = String(ymd || '').slice(0, 10);
    if (!/^\d{4}-\d{2}-\d{2}$/.test(s)) return s;
    const [y, m, d] = s.split('-');
    return `${d}/${m}/${y}`;
  };

  const fmtDow = (ymd) => {
    const s = String(ymd || '').slice(0, 10);
    if (!/^\d{4}-\d{2}-\d{2}$/.test(s)) return '';
    const d = new Date(`${s}T00:00:00Z`);
    if (Number.isNaN(d.getTime())) return '';
    return d.toLocaleDateString('en-GB', { weekday: 'short', timeZone: 'Europe/London' });
  };

  const addDaysYmd = (ymd, deltaDays) => {
    const s = String(ymd || '').slice(0, 10);
    if (!/^\d{4}-\d{2}-\d{2}$/.test(s)) return null;
    const [yy, mm, dd] = s.split('-').map(Number);
    const dt = new Date(Date.UTC(yy, mm - 1, dd));
    dt.setUTCDate(dt.getUTCDate() + Number(deltaDays || 0));
    return dt.toISOString().slice(0, 10);
  };

  // Monday start (matches Postgres date_trunc('week', ...) behaviour)
  const weekStartMondayYmd = (ymd) => {
    const s = String(ymd || '').slice(0, 10);
    if (!/^\d{4}-\d{2}-\d{2}$/.test(s)) return null;
    const [yy, mm, dd] = s.split('-').map(Number);
    const dt = new Date(Date.UTC(yy, mm - 1, dd));
    const jsDow = dt.getUTCDay();        // Sun=0..Sat=6
    const monIndex = (jsDow + 6) % 7;   // Mon=0..Sun=6
    dt.setUTCDate(dt.getUTCDate() - monIndex);
    return dt.toISOString().slice(0, 10);
  };

  const boolish = (v) => {
    if (v === true) return true;
    if (v === false) return false;
    if (v == null) return false;
    const s = String(v).trim().toLowerCase();
    return (s === 'true' || s === '1' || s === 'yes' || s === 'y' || s === 'on');
  };

  const normStr = (v) => (v == null ? '' : String(v).trim());

  const fmtHHMM = (isoLike) => {
    const s = String(isoLike || '');
    const m1 = s.match(/T(\d{2}:\d{2})/);
    if (m1 && m1[1]) return m1[1];
    const m2 = s.match(/(\d{2}:\d{2})/);
    if (m2 && m2[1]) return m2[1];
    return '';
  };

  // Facts used only for issues list (not for Processing State label)
  const procStatusRaw =
    tsfin.processing_status ||
    details.processing_status ||
    row.processing_status ||
    null;

  const procStatus = String(procStatusRaw || '').toUpperCase();

  if (LOGM) {
    L('snapshot', {
      procStatus,
      requiresAuth: !!authInfo.requires,
      authorised: !!authInfo.authorised,
      processingState: ps
    });
  }

  const issues = [];

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // âœ… NEW: Validation framework detection + coherent UX
  // When HR validation framework is active:
  //  - if validation ERROR => show it as primary issue
  //  - if validation OK => suppress stale/conflicting HR_HOURS_MISSING warnings
  // This is display-only; DB fields remain unchanged.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const hrValidationRequired =
    boolish(tsfin.client_hr_validation_required) ||
    boolish(tsfin.hr_validation_required_for_invoice) ||
    boolish(details.client_hr_validation_required) ||
    boolish(details.hr_validation_required_for_invoice) ||
    boolish(row.client_hr_validation_required) ||
    boolish(row.hr_validation_required_for_invoice) ||
    false;

  const validationStatusRaw =
    tsfin.validation_status ||
    details.validation_status ||
    row.validation_status ||
    details.timesheet_validation_status ||
    row.timesheet_validation_status ||
    null;

  const validationStatus = String(validationStatusRaw || '').trim().toUpperCase();

  const validationFrameworkInUse = !!hrValidationRequired;

  // Helper: decide whether a validation status is "OK" vs "ERROR"
  const validationIsOk =
    (validationStatus === 'VALIDATION_OK' || validationStatus === 'OK' || validationStatus === 'PASS' || validationStatus === 'OVERRIDDEN');

  const validationIsError =
    (validationStatus === 'VALIDATION_ERROR' || validationStatus === 'ERROR' || validationStatus === 'FAIL');

  if (validationFrameworkInUse) {
    if (validationIsError) {
      issues.push('Validation failed (HealthRoster): this timesheet is not consistent with HealthRoster and is blocked until corrected or overridden.');
    } else if (validationIsOk) {
      // We do not push an "OK" issue line; we just use this to suppress conflicting crosscheck warnings below.
      // (User sees the OK status in HealthRoster validation screens, not as an "issue".)
    } else if (validationStatus) {
      // Unknown but present; surface as neutral info.
      issues.push(`Validation status: ${validationStatus}.`);
    } else {
      // Validation required but no status present: treat as informational blocker.
      issues.push('Validation is required for this client, but no validation result is recorded yet.');
    }
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // âœ… NEW: Reference blocker issue + per-day/segment detail
  // Source of truth:
  //  - ref blocker codes live in issue_codes (Option A strings)
  //  - detail list lives in details.refs_missing_items_json / count (details view only)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  try {
    const rawCodes =
      Array.isArray(row?.issue_codes) ? row.issue_codes :
      (Array.isArray(details?.issue_codes) ? details.issue_codes : []);

    const codes = rawCodes.map(x => String(x || '').trim()).filter(Boolean);

    // âœ… Friendly mapping for "Refs - Timesheet PDF invalid"
    if (codes.includes('Refs - Timesheet PDF invalid')) {
      const smUpper = String(ts?.submission_mode || '').trim().toUpperCase();

      const qrIssued =
        (
          (ts?.qr_token && String(ts.qr_token).trim() && ts?.qr_generated_at)
          || (ts?.qr_last_sent_hash && String(ts.qr_last_sent_hash).trim())
        ) ? true : false;

      if (smUpper === 'ELECTRONIC') {
        issues.push('Refs changed since PDF generated â€” system will regenerate automatically.');
      } else if (qrIssued) {
        issues.push('Refs changed since QR PDF issued â€” signed/issued QR evidence may not match current refs.');
      } else {
        issues.push('Refs changed since timesheet PDF generated.');
      }
    }

    const REF_PRECEDENCE = [
      'Refs (Invoice and Issue Blocked)',
      'Refs (Invoicing Blocked)',
      'Refs (Issue Invoice Blocked)'
    ];

    let refChosen = '';
    for (const k of REF_PRECEDENCE) {
      if (codes.includes(k)) { refChosen = k; break; }
    }

    if (refChosen) {
      if (refChosen === 'Refs (Invoice and Issue Blocked)') {
        issues.push('Reference numbers are missing â€” invoicing and issuing invoices are both blocked until references are added.');
      } else if (refChosen === 'Refs (Invoicing Blocked)') {
        issues.push('Reference numbers are missing â€” invoicing is blocked until references are added.');
      } else if (refChosen === 'Refs (Issue Invoice Blocked)') {
        issues.push('Reference numbers are missing â€” invoices can be created, but cannot be issued until references are added.');
      }

      let items = details?.refs_missing_items_json ?? null;
      if (typeof items === 'string') {
        try { items = JSON.parse(items); } catch { items = null; }
      }
      if (!Array.isArray(items)) items = [];

      const countRaw = details?.refs_missing_items_count;
      const count = Number(countRaw);
      const countNum = Number.isFinite(count) ? count : null;

      if (items.length > 0) {
        issues.push(`Missing reference numbers on ${items.length} day(s)/segment(s):`);

        const sorted = items.slice().sort((a, b) => {
          const ad = normStr(a?.day_ymd || a?.day_date || a?.date);
          const bd = normStr(b?.day_ymd || b?.day_date || b?.date);
          if (ad !== bd) return ad.localeCompare(bd);
          const ak = normStr(a?.kind);
          const bk = normStr(b?.kind);
          if (ak !== bk) return ak.localeCompare(bk);
          const ai = Number(a?.segment_index);
          const bi = Number(b?.segment_index);
          const aok = Number.isFinite(ai);
          const bok = Number.isFinite(bi);
          if (aok && bok) return ai - bi;
          if (aok) return -1;
          if (bok) return 1;
          return 0;
        });

        for (const it of sorted) {
          const kind = String(it?.kind || '').trim().toUpperCase();
          let day = normStr(it?.day_ymd || it?.day_date || it?.date);

          // Fallback day extraction from start values
          if (!day) {
            const s1 = normStr(it?.start_utc || it?.start);
            const m = s1.match(/^(\d{4}-\d{2}-\d{2})/);
            if (m && m[1]) day = m[1];
          }

          const dmy = day ? fmtYmdToDmy(day) : '';
          const dow = day ? fmtDow(day) : '';

          if (kind === 'TIMESHEET') {
            const st = normStr(it?.start_utc || it?.start);
            const en = normStr(it?.end_utc || it?.end);
            const t1 = fmtHHMM(st);
            const t2 = fmtHHMM(en);
            const tr = (t1 && t2) ? `${t1}â€“${t2}` : '';
            issues.push(`Missing reference: ${dow ? dow + ' ' : ''}${dmy || day || 'Unknown date'}${tr ? ` (${tr})` : ''} (Daily timesheet).`);
          } else if (kind === 'FREEFORM') {
            issues.push(`Missing reference: ${dow ? dow + ' ' : ''}${dmy || day || 'Unknown date'} (Weekly day reference).`);
          } else if (kind === 'SEGMENT') {
            const idx0 = Number(it?.segment_index);
            const idx = Number.isFinite(idx0) ? (idx0 + 1) : null;

            const st = normStr(it?.start);
            const en = normStr(it?.end);
            const t1 = fmtHHMM(st);
            const t2 = fmtHHMM(en);
            const tr = (t1 && t2) ? `${t1}â€“${t2}` : '';

            const segLabel = idx != null ? `Segment ${idx}` : 'Segment';
            issues.push(`Missing reference: ${dow ? dow + ' ' : ''}${dmy || day || 'Unknown date'}${tr ? ` (${tr})` : ''} (${segLabel}).`);
          } else {
            issues.push(`Missing reference: ${dow ? dow + ' ' : ''}${dmy || day || 'Unknown date'}.`);
          }
        }
      } else if (countNum != null && countNum > 0) {
        issues.push(`Missing reference numbers on ${countNum} day(s)/segment(s).`);
      }
    }
  } catch (e) {
    if (LOGM) L('[ISSUES] reference missing detail mapping failed (non-fatal)', e);
  }

  // Processing-status based issues (keep concise)
  if (procStatus === 'RATE_MISSING') {
    issues.push('Rate missing: no pay/charge rates found for this client/role/band on this date.');
  }
  if (procStatus === 'PAY_CHANNEL_MISSING') {
    issues.push('Pay channel missing: candidate bank/umbrella details incomplete for this timesheet.');
  }
  if (procStatus === 'CLIENT_UNRESOLVED') {
    issues.push('Client unresolved: timesheet could not be linked to a client correctly.');
  }
  if (procStatus === 'UNASSIGNED') {
    issues.push('Unassigned: this timesheet has not been fully matched or processed yet.');
  }

  // Pay hold (sheet-level, from row or tsfin)
  const payOnHold = !!(tsfin.pay_on_hold ?? row.pay_on_hold);
  if (payOnHold) {
    issues.push('Pay is currently on hold for this timesheet. It will be excluded from pay runs until released.');
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // âœ… NEW: SEGMENTS-mode per-day delays (matches your SQL rules)
  //   - invoice delayed per day: invoice_locked_invoice_id empty AND invoice_target_week_start present AND target != baseline
  //   - pay delayed per day: exclude_from_pay === true
  // Only list dates that are actually delayed.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  try {
    const weYmd = (ts.week_ending_date || row.week_ending_date || null);
    const baselineWeekStart =
      (weYmd && /^\d{4}-\d{2}-\d{2}$/.test(String(weYmd).slice(0,10)))
        ? addDaysYmd(String(weYmd).slice(0,10), -6)
        : null;

    let inv = tsfin.invoice_breakdown_json ?? null;
    if (typeof inv === 'string') {
      try { inv = JSON.parse(inv); } catch { inv = null; }
    }

    const mode = String(inv?.mode || '').toUpperCase();
    const segs = Array.isArray(inv?.segments) ? inv.segments : [];

    if (mode === 'SEGMENTS' && segs.length) {
      const invoiceDelayed = [];
      const payDelayed     = [];

      for (const seg of segs) {
        if (!seg || typeof seg !== 'object') continue;

        const segDate = String(seg.date || '').slice(0, 10);
        if (!/^\d{4}-\d{2}-\d{2}$/.test(segDate)) continue;

        // --- pay delay (exclude_from_pay) ---
        if (boolish(seg.exclude_from_pay)) {
          const reason = (seg.held_back_reason != null && String(seg.held_back_reason).trim())
            ? String(seg.held_back_reason).trim()
            : '';
          payDelayed.push({ date: segDate, reason });
        }

        // --- invoice delay (exactly your SQL rule) ---
        const lockedRaw = seg.invoice_locked_invoice_id;
        const lockedId  = (lockedRaw == null) ? '' : String(lockedRaw).trim();

        const targetRaw = seg.invoice_target_week_start;
        const target    = (targetRaw == null) ? '' : String(targetRaw).slice(0, 10).trim();

        const baseStart = baselineWeekStart || weekStartMondayYmd(segDate);

        const hasLocked = !!lockedId;
        const hasTarget = !!target;

        const isDelayed = (!hasLocked) && hasTarget && baseStart && (target !== baseStart);

        if (isDelayed) {
          const isPermanent = (target === '2099-01-05') || (/^2099-/.test(target));
          invoiceDelayed.push({
            date: segDate,
            targetWeekStart: target,
            permanent: isPermanent
          });
        }
      }

      if (invoiceDelayed.length) {
        const allInvDelayed = (invoiceDelayed.length === segs.length);
        issues.push(allInvDelayed
          ? 'Whole invoice is delayed: all dated lines are being held back for invoicing.'
          : `Some invoice issuing delays: ${invoiceDelayed.length} dated line(s) are being held back for invoicing.`
        );

        for (const it of invoiceDelayed.sort((a,b)=>String(a.date).localeCompare(String(b.date)))) {
          const dmy = fmtYmdToDmy(it.date);
          const dow = fmtDow(it.date);
          if (it.permanent) {
            issues.push(`Invoice delayed: ${dow ? dow + ' ' : ''}${dmy} â€” permanently delayed.`);
          } else {
            issues.push(`Invoice delayed: ${dow ? dow + ' ' : ''}${dmy} â€” delayed until week starting ${fmtYmdToDmy(it.targetWeekStart)}.`);
          }
        }
      }

      if (payDelayed.length) {
        const allPayDelayed = (payDelayed.length === segs.length);
        issues.push(allPayDelayed
          ? 'All pay is on hold (line-level): all dated lines are excluded from pay.'
          : `Some pay is on hold (line-level): ${payDelayed.length} dated line(s) are excluded from pay.`
        );

        for (const it of payDelayed.sort((a,b)=>String(a.date).localeCompare(String(b.date)))) {
          const dmy = fmtYmdToDmy(it.date);
          const dow = fmtDow(it.date);
          const extra = it.reason ? ` (Reason: ${it.reason})` : '';
          issues.push(`Pay excluded: ${dow ? dow + ' ' : ''}${dmy}${extra}.`);
        }
      }
    }
  } catch (e) {
    if (LOGM) L('[ISSUES] SEGMENTS delay scan failed (non-fatal)', e);
  }

  // HR cross-check issues (from TSFIN)
  // âœ… UPDATED: If validation framework is in use and validation is OK, suppress HR_HOURS_MISSING to avoid contradictory UX.
  try {
    const hrIssuesArr = Array.isArray(tsfin.hr_crosscheck_issues) ? tsfin.hr_crosscheck_issues : [];
    const hrIssues = hrIssuesArr.map(c => String(c || '').toUpperCase()).filter(Boolean);

    const seen = new Set();
    for (const code of hrIssues) {
      if (seen.has(code)) continue;
      seen.add(code);

      if (code === 'HOURS_MISMATCH_HR') {
        issues.push('Timesheet hours mismatch with HealthRoster.');
      } else if (code === 'HR_HOURS_MISSING') {
        // Suppress when validation is in use and OK (stale TSFIN should clear after recompute).
        if (validationFrameworkInUse && validationIsOk) {
          // intentionally suppressed
        } else {
          issues.push('Timesheet has hours not yet on HealthRoster.');
        }
      } else if (code === 'DUPLICATE_CONTRACTS') {
        issues.push('Multiple contracts cover the same period for this client.');
      }
    }
  } catch (e) {
    if (LOGM) L('[ISSUES] hr_crosscheck_issues mapping failed (non-fatal)', e);
  }

  // Authorisation required but not yet authorised (issue line)
  if (authInfo.requires && !authInfo.authorised) {
    issues.push('Awaiting authorisation by team.');
  }

  const issuesHtml = issues.length
    ? `<ul class="mini">${issues.map(i => `<li>${esc(i)}</li>`).join('')}</ul>`
    : `<span class="mini">No issues detected.</span>`;

  GE();

  return `
    <div class="tabc">
      <div class="card">
        <div class="row">
          <label>Processing State</label>
          <div class="controls">
            <span class="mini">${esc(ps.label || 'Unprocessed')}</span>
          </div>
        </div>
      </div>

      <div class="card" style="margin-top:10px;">
        <div class="row">
          <label>Issues Flagged</label>
          <div class="controls">
            ${issuesHtml}
          </div>
        </div>
      </div>
    </div>
  `;
}


// === REPLACE: openSearchModal (icons only, legacy forced hidden, robust wiring) ===
// === REPLACE: openSearchModal (compact text buttons + robust delegated wiring) ===
// FRONTEND â€” UPDATED
// openSearchModal: compact text buttons + delegated wiring + listens for preset-apply event
// and re-applies filters AFTER parent repaint (onReturn hook).
// ======================================
// FRONTEND â€” openSearchModal (UPDATED)
// Branches: if there's a selection in the summary â†’ go straight to Save Selection.
// Otherwise, open the Advanced Search (filters) modal as usual.
// ======================================


// ======================================
// FRONTEND â€” wireAdvancedSearch (UPDATED only to call the updated save/load modals)
// ======================================


function wireAdvancedSearch() {
  const bodyEl = document.getElementById('modalBody');
  const formEl = document.getElementById('searchForm');
  if (!bodyEl || !formEl) return;

  formEl.querySelectorAll('input[placeholder="DD/MM/YYYY"]').forEach(el => {
    try { attachUkDatePicker(el); } catch {}
  });

  // hide any legacy buttons
  formEl.querySelectorAll('#btnLoadSavedSearch,#btnSaveSearch').forEach(el => {
    el.style.display = 'none'; el.hidden = true; el.disabled = true;
  });

  // delegated click (survives re-renders)
  if (bodyEl._advSearchHandler) bodyEl.removeEventListener('click', bodyEl._advSearchHandler, true);
  bodyEl._advSearchHandler = async (e) => {
    const btn = e.target && e.target.closest('button[data-adv-act]');
    if (!btn) return;
    const act = btn.dataset.advAct;
    if (act === 'load') {
      await openLoadSearchModal(currentSection);
    } else if (act === 'save') {
      // â†³ Recompute filters at click time so we pass the *current* criteria
      const filters = extractFiltersFromForm('#searchForm');
      await openSaveSearchModal(currentSection, filters);
    }
  };
  bodyEl.addEventListener('click', bodyEl._advSearchHandler, true);

  // listen once for preset apply events (filters only â€” selection is handled in the load modal)
  if (!window.__advPresetListener) {
    window.__advPresetListener = (ev) => {
      const det = ev && ev.detail;
      const here = String(currentSection || '').toLowerCase();
      const inc  = String(det && det.section || '').toLowerCase();
      if (!det || !inc || inc !== here) return;
      try { window.__squelchDirty = true; } catch {}
      try { populateSearchFormFromFilters(det.filters || {}, '#searchForm'); }
      finally {
        setTimeout(() => { try { window.__squelchDirty = false; } catch {} }, 0);
      }
    };
    window.addEventListener('adv-search-apply-preset', window.__advPresetListener);
  }

  // NEW: Immediately populate from current filters when the modal mounts/re-renders
  try {
    window.__listState = window.__listState || {};
    const st = (window.__listState[currentSection] ||= { page:1, pageSize:50, total:null, hasMore:false, filters:null });
    populateSearchFormFromFilters(st.filters || {}, '#searchForm');
  } catch {}
}

// -----------------------------
// UPDATED: renderTools()
// - Keep Searchâ€¦, add â€œSaved searchesâ€¦â€ shortcut that opens Search modal pre-focused on loading presets
// -----------------------------

function renderTools(){
  const el = byId('toolButtons');
  const canCreate = ['candidates','clients','umbrellas','contracts'].includes(currentSection); // added contracts

  el.innerHTML = '';
  const addBtn = (txt, cb) => {
    const b = document.createElement('button');
    b.textContent = txt;
    b.onclick = cb;
    el.appendChild(b);
    return b;
  };

  const btnCreate = addBtn('Create New Record', () => openCreate());
  addBtn('Show all records', () => showAllRecords(currentSection));
  addBtn('Searchâ€¦', () => openSearchModal()); // left toolbar search

  // âœ… NEW: Refresh button (forces reload of the current summary view using existing state/filters)
  addBtn('Refresh', async () => {
    try {
      const data = await loadSection();
      renderSummary(data);
    } catch (e) {
      console.error('[TOOLS][REFRESH] failed', e);
      alert(e?.message || 'Refresh failed');
    }
  });

  if (!canCreate) btnCreate.disabled = true;

  // â”€â”€ Timesheet filters box (only when in Timesheets summary) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (currentSection === 'timesheets') {
    window.__listState = window.__listState || {};
    const st = (window.__listState['timesheets'] ||= {
      page: 1,
      pageSize: 50,
      total: null,
      hasMore: false,
      filters: {},
      sort: { key: null, dir: 'asc' }
    });
    const filters = st.filters || {};
    window.__listState['timesheets'].filters = filters;

    // âœ… Drop legacy/stale keys that should no longer drive list mode
    // - ts_stage / summary_stage were legacy stage concepts
    // - client_invoiced / needs_attention are removed from Tools UI
    try {
      if (Object.prototype.hasOwnProperty.call(filters, 'client_invoiced')) delete filters.client_invoiced;
      if (Object.prototype.hasOwnProperty.call(filters, 'needs_attention')) delete filters.needs_attention;

      // If an old session stored a legacy stage, map only the safe values to tools_stage
      // (we intentionally do NOT guess mappings for READY_FOR_INVOICE/PROCESSED)
      if (!Object.prototype.hasOwnProperty.call(filters, 'tools_stage')) {
        const legacyTsStage = Object.prototype.hasOwnProperty.call(filters, 'ts_stage')
          ? String(filters.ts_stage || '').trim().toUpperCase()
          : '';
        const legacySumStage = Object.prototype.hasOwnProperty.call(filters, 'summary_stage')
          ? String(filters.summary_stage || '').trim().toUpperCase()
          : '';

        const legacy = legacyTsStage || legacySumStage;

        if (legacy === 'UNPROCESSED') filters.tools_stage = 'UNPROCESSED';
        else if (legacy === 'INVOICED') filters.tools_stage = 'INVOICED';
      }

      if (Object.prototype.hasOwnProperty.call(filters, 'ts_stage')) delete filters.ts_stage;
      if (Object.prototype.hasOwnProperty.call(filters, 'summary_stage')) delete filters.summary_stage;
      if (Object.prototype.hasOwnProperty.call(filters, 'processing_status')) delete filters.processing_status;

      window.__listState['timesheets'].filters = filters;
    } catch {}

    const box = document.createElement('div');
    box.style.cssText = 'margin-top:10px;padding:8px;border:1px solid var(--line);border-radius:6px;background:#0b152a;';
    const title = document.createElement('div');
    title.textContent = 'Timesheet Filters';
    title.className = 'mini';
    title.style.fontWeight = 'bold';
    title.style.marginBottom = '4px';
    box.appendChild(title);

    const mkToolFlag = (name, label) => {
      const wrap = document.createElement('label');
      wrap.className = 'mini';
      wrap.style.display = 'flex';
      wrap.style.alignItems = 'center';
      wrap.style.gap = '4px';
      wrap.style.marginTop = '4px';
      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.checked = !!filters[name];
      cb.addEventListener('change', async () => {
        const curFilters = { ...(window.__listState['timesheets'].filters || {}) };
        curFilters[name] = cb.checked ? true : false;
        window.__listState['timesheets'].filters = curFilters;
        window.__listState['timesheets'].page = 1;
        const data = await loadSection();
        renderSummary(data);
      });
      wrap.appendChild(cb);
      wrap.appendChild(document.createTextNode(label));
      return wrap;
    };

    // âœ… Candidate Paid (checkbox): filters by candidate-paid timestamp (paid_at_utc NOT NULL)
    box.appendChild(mkToolFlag('candidate_paid', 'Candidate paid'));

    // âœ… Adjusted timesheets (checkbox): moved from summary header
    box.appendChild(mkToolFlag('is_adjusted', 'Adjusted timesheets'));

    // â”€â”€ Tools Stage selector (canonical tools_stage) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const stageWrap = document.createElement('div');
    stageWrap.style.marginTop = '8px';
    stageWrap.className = 'mini';

    const stageLabel = document.createElement('div');

    stageLabel.textContent = 'Stage:';
    stageLabel.style.marginBottom = '2px';

    const stageSel = document.createElement('select');
    stageSel.style.width = '100%';
    stageSel.classList.add('dark-control');

    const stageOpts = [
      ['ALL',                    'All'],
      ['UNPROCESSED',            'Unprocessed'],
      ['PROCESSING_DELAYED',     'Processing Delayed'],
      ['AWAITING_AUTHORISATION', 'Awaiting Authorisation'],
      ['AUTHORISED_FOR_INVOICING','Authorised for Invoicing'],
      ['INVOICED',               'Invoiced']
    ];

    const allowedStages = new Set(stageOpts.map(x => x[0]));
    const curStage = String((filters.tools_stage || 'ALL')).toUpperCase();
    const curStageSafe = allowedStages.has(curStage) ? curStage : 'ALL';

    stageOpts.forEach(([v, label]) => {
      const o = document.createElement('option');
      o.value = v;
      o.textContent = label;
      if (curStageSafe === v) o.selected = true;
      stageSel.appendChild(o);
    });

    stageSel.addEventListener('change', async () => {
      const val = String(stageSel.value || '').toUpperCase();
      const curFilters = { ...(window.__listState['timesheets'].filters || {}) };

      // Canonical tools stage only
      curFilters.tools_stage = val;

      // Ensure legacy keys cannot affect list mode
      if ('ts_stage' in curFilters) delete curFilters.ts_stage;
      if ('summary_stage' in curFilters) delete curFilters.summary_stage;
      if ('processing_status' in curFilters) delete curFilters.processing_status;
      if ('client_invoiced' in curFilters) delete curFilters.client_invoiced;
      if ('needs_attention' in curFilters) delete curFilters.needs_attention;

      window.__listState['timesheets'].filters = curFilters;
      window.__listState['timesheets'].page = 1;

      const data = await loadSection();
      renderSummary(data);
    });

    stageWrap.appendChild(stageLabel);
    stageWrap.appendChild(stageSel);
    box.appendChild(stageWrap);

    el.appendChild(box);
  }
}



async function showAllRecords(section = currentSection){
  // Reset paging & clear all filters
  window.__listState = window.__listState || {};
  const st = (window.__listState[section] ||= {
    page: 1, pageSize: 50, total: null, hasMore: false, filters: null,
  });
  st.page = 1;
  st.filters = null;

  // Forget any focused shortlist (IDs selection)
  const sel = ensureSelection(section);
  sel.ids.clear();
  sel.fingerprint = ''; // optional: allow renderSummary to recompute

  // Reload full list for the section and render
  const rows = await loadSection();
  renderSummary(rows);
}
// Optional alias if other code calls clearFilters()
function clearFilters(section = currentSection){
  return showAllRecords(section);
}


// ===================== NEW HELPERS (UI + data) =====================

// Cache for global roles
// Cache for global roles
let __GLOBAL_ROLE_CODES_CACHE__ = null;
let __GLOBAL_ROLE_CODES_CACHE_TS__ = 0;
function invalidateGlobalRoleOptionsCache(){
  __GLOBAL_ROLE_CODES_CACHE__ = null;
  __GLOBAL_ROLE_CODES_CACHE_TS__ = 0;
}

// Load and dedupe all role codes from client defaults across all clients
// ðŸ”§ CHANGE: truly global roles list (de-duplicated across ALL clients), with a short TTL cache.
// Works even when there is no active client in context (e.g., Candidate create).
async function loadGlobalRoleOptions(){
  const now = Date.now();
  const TTL_MS = 60_000;

  // Prefer our global cache
  if (Array.isArray(window.__GLOBAL_ROLE_CODES_ALL__) &&
      (now - (window.__GLOBAL_ROLE_CODES_ALL_TS__ || 0) < TTL_MS)) {
    return window.__GLOBAL_ROLE_CODES_ALL__;
  }

  // Fallback to legacy '__fallback__' if itâ€™s fresh
  if (window.__GLOBAL_ROLE_CODES_CACHE__ &&
      window.__GLOBAL_ROLE_CODES_CACHE__['__fallback__'] &&
      (now - (window.__GLOBAL_ROLE_CODES_CACHE_TS__?.['__fallback__'] || 0) < TTL_MS)) {
    const arr = window.__GLOBAL_ROLE_CODES_CACHE__['__fallback__'];
    window.__GLOBAL_ROLE_CODES_ALL__ = arr.slice();
    window.__GLOBAL_ROLE_CODES_ALL_TS__ = now;
    return arr;
  }

  // Aggregate roles across all clients (enabled client-default windows only)
  const roles = new Set();
  try {
    const clients = await listClientsBasic();
    for (const c of (clients || [])) {
      try {
        const rows = await listClientRates(c.id, { only_enabled: true });
        for (const r of (rows || [])) {
          if (r && r.role) roles.add(String(r.role));
        }
      } catch { /* ignore per-client errors */ }
    }
  } catch { /* ignore listClientsBasic error */ }

  const arr = [...roles].sort((a,b)=> a.localeCompare(b));

  // Save to both the new global cache AND the legacy fallback keys so existing invalidation hooks still help
  window.__GLOBAL_ROLE_CODES_ALL__ = arr;
  window.__GLOBAL_ROLE_CODES_ALL_TS__ = now;

  window.__GLOBAL_ROLE_CODES_CACHE__    = window.__GLOBAL_ROLE_CODES_CACHE__    || Object.create(null);
  window.__GLOBAL_ROLE_CODES_CACHE_TS__ = window.__GLOBAL_ROLE_CODES_CACHE_TS__ || Object.create(null);
  window.__GLOBAL_ROLE_CODES_CACHE__['__fallback__']    = arr;
  window.__GLOBAL_ROLE_CODES_CACHE_TS__['__fallback__'] = now;

  return arr;
}


// Render roles editor into a container; updates modalCtx.rolesState
function renderRolesEditor(container, rolesState, allRoleOptions){
  // Detect read-only (view mode) from the active modal frame
  const fr = (window.__modalStack || [])[ (window.__modalStack || []).length - 1 ] || null;
  // âœ… Treat 'create' same as 'edit' (editable)
  const readOnly = !fr || !(fr.mode === 'edit' || fr.mode === 'create');

  // Local, mutable copy of available options so we can refresh after adds/removes
  let roleOptions = Array.isArray(allRoleOptions) ? allRoleOptions.slice() : [];

  function markDirty() {
    try {
      const stack = window.__modalStack || [];
      const top = stack[stack.length - 1];
      if (top) top.isDirty = true;
      try { window.dispatchEvent(new CustomEvent('modal-dirty')); }
      catch { try { window.dispatchEvent(new Event('modal-dirty')); } catch(_) {} }
    } catch (_) {}
  }

  container.innerHTML = `
    <div class="roles-editor">
      <div class="roles-add" ${readOnly ? 'style="display:none"' : ''}>
        <select id="rolesAddSelect">
          <option value="">Add roleâ€¦</option>
          ${roleOptions.map(code => `<option value="${code}">${code}</option>`).join('')}
        </select>
        <button id="rolesAddBtn" type="button">Add</button>
      </div>
      <ul id="rolesList" class="roles-list"></ul>
    </div>
  `;

  const sel = container.querySelector('#rolesAddSelect');
  const btn = container.querySelector('#rolesAddBtn');
  const ul  = container.querySelector('#rolesList');

  const byCode = (code) => (rolesState || []).find(r => String(r.code) === String(code));

  function availableOptions(){
    const picked = new Set((rolesState||[]).map(x => x.code));
    return roleOptions.filter(code => !picked.has(code));
  }

  function refreshAddSelect(){
    if (!sel) return;
    const opts = ['<option value="">Add roleâ€¦</option>']
      .concat(availableOptions().map(code => `<option value="${code}">${code}</option>`))
      .join('');
    sel.innerHTML = opts;
  }

  function renderList(){
    ul.innerHTML = '';
    const arr = (rolesState||[]).slice().sort((a,b)=> (a.rank||0) - (b.rank||0));

    arr.forEach((item, idx) => {
      const li = document.createElement('li');
      li.className = 'role-item';
      li.draggable = !readOnly;
      li.dataset.index = String(idx);

      li.innerHTML = `
        <span class="drag" title="Drag to reorder" style="cursor:${readOnly?'default':'grab'}">â‹®â‹®</span>
        <span class="rank">${idx+1}.</span>
        <span class="code">${item.code}</span>
        <input class="label" type="text" placeholder="Optional labelâ€¦" value="${item.label || ''}" ${readOnly?'disabled':''}/>
        <button class="remove" type="button" title="Remove" ${readOnly?'disabled style="display:none"':''}>âœ•</button>
      `;

      if (!readOnly) {
        li.querySelector('.remove').onclick = () => {
          rolesState = (rolesState || []).filter(r => r.code !== item.code);
          rolesState.forEach((r,i)=> r.rank = i+1);
          rolesState = normaliseRolesForSave(rolesState);
          window.modalCtx.rolesState = rolesState;
          markDirty();
          renderList(); refreshAddSelect();
        };

        li.querySelector('.label').oninput = (e) => {
          const rec = byCode(item.code);
          if (rec) rec.label = e.target.value;
          window.modalCtx.rolesState = rolesState;
          // dirty state handled by global tracker
        };

        // Drag payload
        li.addEventListener('dragstart', (e) => {
          const from = li.dataset.index || String(idx);
          try { e.dataTransfer.setData('text/x-role-index', from); } catch {}
          try { e.dataTransfer.setData('text/plain', from); } catch {}
          if (e.dataTransfer) e.dataTransfer.effectAllowed = 'move';
          li.classList.add('dragging');
        });
        li.addEventListener('dragend', () => {
          li.classList.remove('dragging');
          ul.querySelectorAll('.over').forEach(n => n.classList.remove('over'));
        });
      }

      ul.appendChild(li);
    });
  }

  // Delegate DnD only when editable
  if (!readOnly) {
    ul.addEventListener('dragover', (e) => {
      e.preventDefault();
      const overLi = e.target && e.target.closest('li.role-item');
      ul.querySelectorAll('.over').forEach(n => n.classList.remove('over'));
      if (overLi) overLi.classList.add('over');
      if (e.dataTransfer) e.dataTransfer.dropEffect = 'move';
    });

    ul.addEventListener('drop', (e) => {
      e.preventDefault();
      const toLi = e.target && e.target.closest('li.role-item');
      if (!toLi) return;

      let from = NaN;
      try { from = parseInt(e.dataTransfer.getData('text/x-role-index'), 10); } catch {}
      if (isNaN(from)) {
        try { from = parseInt(e.dataTransfer.getData('text/plain'), 10); } catch {}
      }
      const to = parseInt(toLi.dataset.index, 10);
      if (!Number.isInteger(from) || !Number.isInteger(to) || from === to) return;

      // Reorder against current rank-sorted view
      const view = (rolesState||[]).slice().sort((a,b)=> (a.rank||0) - (b.rank||0));
      const [moved] = view.splice(from, 1);
      view.splice(to, 0, moved);

      view.forEach((r,i)=> r.rank = i+1);
      rolesState = normaliseRolesForSave(view);
      window.modalCtx.rolesState = rolesState;

      markDirty();
      renderList();
      refreshAddSelect();
    });
  }

  // Add role (only in edit/create)
  if (!readOnly && btn) {
    btn.onclick = () => {
      const code = sel.value;
      if (!code) return;
      if ((rolesState||[]).some(r => r.code === code)) return; // no duplicates
      const nextRank = ((rolesState||[]).length || 0) + 1;
      rolesState = [...(rolesState||[]), { code, rank: nextRank }];
      rolesState = normaliseRolesForSave(rolesState);
      window.modalCtx.rolesState = rolesState;
      markDirty();
      renderList(); refreshAddSelect();
    };
  }

  // Expose a tiny API for refreshing options live
  container.__rolesEditor = {
    updateOptions(newOptions){
      roleOptions = Array.isArray(newOptions) ? newOptions.slice() : [];
      refreshAddSelect();
    }
  };

  // Initial paint
  refreshAddSelect();
  renderList();
}


// Drop dups (by code), sort by rank, rewrite rank 1..N
function normaliseRolesForSave(roles){
  const out = [];
  const seen = new Set();
  (Array.isArray(roles) ? roles : []).forEach(r => {
    const code = String(r.code || '').trim();
    if (!code) return;
    if (seen.has(code)) return;
    seen.add(code);
    out.push({ code, rank: Number(r.rank) || 0, label: r.label ? String(r.label) : undefined });
  });
  out.sort((a,b)=> a.rank - b.rank);
  out.forEach((r,i)=> r.rank = i+1);
  return out;
}

async function listClientHospitals(clientId){
  if (!clientId) return [];
  const url = API(`/api/clients/${clientId}/hospitals`);
  const APILOG = (typeof window !== 'undefined' && !!window.__LOG_API) || (typeof __LOG_API !== 'undefined' && !!__LOG_API);
  if (APILOG) console.log('[listClientHospitals] â†’ GET', url);
  const r = await authFetch(url);
  if (APILOG) console.log('[listClientHospitals] â†', r.status, r.ok);
  const list = await toList(r);
  if (APILOG) console.log('[listClientHospitals] parsed length', Array.isArray(list) ? list.length : -1);
  return list;
}

function formatYmdToNiceDate(ymd) {
  const s = String(ymd || '').trim();
  if (!s) return '';
  const parts = s.split('-');
  if (parts.length !== 3) return s;

  const [Y, M, D] = parts.map(Number);
  if (!Y || !M || !D) return s;

  // Use UTC so it doesn't shift with timezone
  const d = new Date(Date.UTC(Y, M - 1, D));
  const days   = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
  const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

  const dayName = days[d.getUTCDay()];
  const dayNum  = d.getUTCDate();       // 1..31
  const month   = months[d.getUTCMonth()];
  const year    = d.getUTCFullYear();

  return `${dayName} ${dayNum} ${month} ${year}`;
}


function formatRolesSummary(roles){
  if (!Array.isArray(roles) || !roles.length) return '';
  const sorted = roles.slice().sort((a,b)=> (a.rank||0)-(b.rank||0));
  return sorted.map(r => `${ordinal(r.rank)} ${r.code}`).join(', ');
}

function ordinal(n){
  const s = ["th","st","nd","rd"], v = n % 100;
  return n + (s[(v-20)%10] || s[v] || s[0]);
}

// Basic clients list for dropdowns (id + name)
async function listClientsBasic(){
  const r = await authFetch(API('/api/clients'));
  const rows = await r.json().catch(()=>({items:[]}));
  const list = Array.isArray(rows?.items) ? rows.items : (Array.isArray(rows) ? rows : []);
  return list.map(x => ({ id: x.id, name: x.name })).filter(x => x.id && x.name);
}

// ===== UK date helpers & lightweight picker =====

function formatIsoToUk(iso){ // 'YYYY-MM-DD' -> 'DD/MM/YYYY'
  if (!iso || typeof iso !== 'string') return '';
  const m = iso.match(/^(\d{4})-(\d{2})-(\d{2})/);
  if (!m) return '';
  return `${m[3]}/${m[2]}/${m[1]}`;
}

function parseUkDateToIso(ddmmyyyy){ // 'DD/MM/YYYY' -> 'YYYY-MM-DD' or null
  if (!ddmmyyyy || typeof ddmmyyyy !== 'string') return null;
  const m = ddmmyyyy.trim().match(/^(\d{2})\/(\d{2})\/(\d{4})$/);
  if (!m) return null;
  const d = parseInt(m[1],10), mo=parseInt(m[2],10), y=parseInt(m[3],10);
  if (mo<1||mo>12||d<1||d>31||y<1900||y>3000) return null;
  const dt = new Date(Date.UTC(y, mo-1, d));
  if (dt.getUTCFullYear()!==y || (dt.getUTCMonth()+1)!==mo || dt.getUTCDate()!==d) return null; // invalid date like 31/02
  const mm = String(mo).padStart(2,'0'), dd = String(d).padStart(2,'0');
  return `${y}-${mm}-${dd}`;
}

// Minimal calendar that sits above modals; ESC / outside closes; keyboard nav supported
function attachUkDatePicker(inputEl, opts) {
  if (!inputEl) return;
  inputEl.setAttribute('autocomplete','off');

  const setIso = (v) => {
    if (!v) return null;
    if (/^\d{2}\/\d{2}\/\d{4}$/.test(String(v))) {
      try { return parseUkDateToIso(v) || null; } catch { return null; }
    }
    return String(v);
  };

  // allow dynamic (re)configuration
  if (opts && typeof opts === 'object') {
    if ('minDate' in opts) inputEl._minIso = setIso(opts.minDate);
    if ('maxDate' in opts) inputEl._maxIso = setIso(opts.maxDate);
  }

  // if already wired, just update constraints and return
  if (inputEl.__ukdpBound) {
    if (inputEl.__ukdpPortal) {
      // refresh current view with new bounds
      try { inputEl.__ukdpRepaint && inputEl.__ukdpRepaint(); } catch {}
    }
    return;
  }

  // Bounds helpers (YYYY-MM-DD or null)
  const getMinIso = () => inputEl._minIso || null;
  const getMaxIso = () => inputEl._maxIso || null;

  let portal = null;
  let current = null;

  function openPicker(){
    closePicker();

    let today = new Date();
    if (inputEl.value) {
      const iso = parseUkDateToIso(inputEl.value);
      if (iso) {
        const [y,m,d] = iso.split('-').map(Number);
        today = new Date(Date.UTC(y, m-1, d));
      }
    }
    current = { year: today.getUTCFullYear(), month: today.getUTCMonth() }; // 0-based

    portal = document.createElement('div');
    inputEl.__ukdpPortal = portal;
    portal.className = 'uk-datepicker-portal';
    portal.style.position = 'fixed';
    portal.style.zIndex = '99999';
    portal.style.background = '#fff';
    portal.style.border = '1px solid #ccc';
    portal.style.borderRadius = '8px';
    portal.style.boxShadow = '0 8px 24px rgba(0,0,0,0.15)';
    portal.style.padding = '8px';

    positionPortal();

    portal.innerHTML = renderCalendarHtml(current.year, current.month, inputEl.value);
    document.body.appendChild(portal);

    portal.addEventListener('click', onPortalClick);
    window.addEventListener('resize', positionPortal);
    document.addEventListener('keydown', onKeyDown, true);
    setTimeout(()=> document.addEventListener('click', onOutside, true), 0);
  }

  function positionPortal(){
    if (!portal) return;
    const r = inputEl.getBoundingClientRect();
    portal.style.left = `${Math.max(8, r.left)}px`;
    portal.style.top  = `${Math.max(8, r.top + window.scrollY + r.height + 6)}px`;
  }

  function closePicker(){
    if (!portal) return;
    document.removeEventListener('click', onOutside, true);
    document.removeEventListener('keydown', onKeyDown, true);
    window.removeEventListener('resize', positionPortal);
    portal.removeEventListener('click', onPortalClick);
    portal.remove();
    portal = null;
    inputEl.__ukdpPortal = null;
  }

  function onOutside(e){
    if (portal && !portal.contains(e.target) && e.target !== inputEl) closePicker();
  }

  function onKeyDown(e){
    if (!portal) return;
    if (e.key === 'Escape') { e.preventDefault(); closePicker(); return; }
  }

  function onPortalClick(e){
    const t = e.target;
    if (t.matches('.nav-prev')) { e.preventDefault(); navMonth(-1); return; }
    if (t.matches('.nav-next')) { e.preventDefault(); navMonth(+1); return; }
    const dayBtn = t.closest('button.day');
    if (dayBtn && !dayBtn.disabled) {
      const y = Number(dayBtn.dataset.y), m = Number(dayBtn.dataset.m), d = Number(dayBtn.dataset.d);
      const iso = `${y}-${String(m+1).padStart(2,'0')}-${String(d).padStart(2,'0')}`;
      inputEl.value = formatIsoToUk(iso);
      closePicker();
      inputEl.dispatchEvent(new Event('change'));
    }
  }

  function dateAllowed(iso){
    const minIso = getMinIso(), maxIso = getMaxIso();
    if (minIso && iso < minIso) return false;
    if (maxIso && iso > maxIso) return false;
    return true;
  }

  function navMonth(delta){
    current.month += delta;
    if (current.month < 0) { current.month = 11; current.year--; }
    if (current.month > 11){ current.month = 0;  current.year++; }
    portal.innerHTML = renderCalendarHtml(current.year, current.month, inputEl.value);
  }

  function renderCalendarHtml(year, month0, selectedUk){
    const selectedIso = parseUkDateToIso(selectedUk || '') || '';
    const sel = selectedIso ? selectedIso.split('-').map(Number) : null;

    const first = new Date(Date.UTC(year, month0, 1));
    const startDow = first.getUTCDay(); // 0=Sun
    const daysInMonth = new Date(Date.UTC(year, month0+1, 0)).getUTCDate();
    const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];

    let grid = '<div class="cal-head" style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px;">' +
      `<a href="#" class="nav-prev" aria-label="Previous month">â€¹</a>` +
      `<div class="title" style="font-weight:600">${monthNames[month0]} ${year}</div>` +
      `<a href="#" class="nav-next" aria-label="Next month">â€º</a>` +
      '</div>';

    grid += `<div class="cal-grid" style="display:grid;grid-template-columns:repeat(7,2em);gap:2px;justify-items:center;align-items:center">`;
    ['Su','Mo','Tu','We','Th','Fr','Sa'].forEach(d => grid += `<div style="font-size:12px;color:#666">${d}</div>`);

    // leading blanks
    for (let i=0;i<startDow;i++) grid += `<div></div>`;
    for (let d=1; d<=daysInMonth; d++){
      const iso = `${year}-${String(month0+1).padStart(2,'0')}-${String(d).padStart(2,'0')}`;
      const isSel = sel && sel[0]===year && (sel[1]-1)===month0 && sel[2]===d;
      const allowed = dateAllowed(iso);
      grid += `<button type="button" class="day${isSel?' selected':''}" data-y="${year}" data-m="${month0}" data-d="${d}"` +
              ` style="width:2em;height:2em;border:1px solid #ddd;border-radius:4px;${allowed?'background:#fff':'background:#f4f4f4;color:#aaa'}" ${allowed?'':'disabled'}>${d}</button>`;
    }
    grid += `</div>`;
    return grid;
  }

   // public dynamic API for constraints refresh
  inputEl.setMinDate = (minDate) => {
    inputEl._minIso = setIso(minDate);
    if (inputEl.__ukdpPortal) { try { inputEl.__ukdpRepaint && inputEl.__ukdpRepaint(); } catch {} }
  };

  inputEl.setMaxDate = (maxDate) => {
    inputEl._maxIso = setIso(maxDate);
    if (inputEl.__ukdpPortal) { try { inputEl.__ukdpRepaint && inputEl.__ukdpRepaint(); } catch {} }
  };

  inputEl.addEventListener('focus', openPicker);

  inputEl.addEventListener('click', openPicker);

  inputEl.__ukdpBound = true;
  inputEl.__ukdpRepaint = ()=>{ if (portal && current) portal.innerHTML = renderCalendarHtml(current.year, current.month, inputEl.value); };
}


function headersFromRows(rows){
  if (!rows.length) return [];
  const keys = new Set(Object.keys(rows[0]));
  rows.forEach(r=> Object.keys(r).forEach(k=> keys.add(k)));
  return [...keys];
}



/* ===== UK date/time formatter helpers (display only) =====
   - Date-only 'YYYY-MM-DD' -> 'DD/MM/YYYY'
   - UTC timestamps -> 'DD/MM/YYYY HHMMhrs' (Europe/London, no seconds)
*/
function formatUkDate(isoDateStr){
  if (!isoDateStr || typeof isoDateStr !== 'string') return isoDateStr;
  const m = /^(\d{4})-(\d{2})-(\d{2})$/.exec(isoDateStr);
  if (!m) return isoDateStr;
  const [,y,mo,d] = m;
  return `${d}/${mo}/${y}`;
}

// ============================================================================
// NEW HELPERS
// ============================================================================

// Toggle enable/disable via backend endpoint
async function patchClientDefault(id, { disabled }) {
  const url = API(`/api/rates/client-defaults/${encodeURIComponent(id)}`);
  const res = await authFetch(url, {
    method: 'PATCH',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify({ disabled: !!disabled })
  });
  if (!res.ok) {
    const text = await res.text().catch(()=> '');
    throw new Error(text || `PATCH failed (${res.status})`);
  }
  const data = await res.json().catch(()=> ({}));
  // Endpoint returns { rate: {...} } or the row; support both
  const row = (data && (data.rate || data)) || null;
  return row;
}

// Format a user reference gracefully
function formatUserRef(u) {
  if (!u) return '';
  const s = String(u);
  if (s.includes('@')) return s;           // email
  if (s.length > 8) return s.slice(0,8)+'â€¦';
  return s;
}

// Trivial HTML escape
function escapeHtml(x) {
  return String(x || '')
    .replaceAll('&','&amp;')
    .replaceAll('<','&lt;')
    .replaceAll('>','&gt;')
    .replaceAll('"','&quot;')
    .replaceAll("'",'&#39;');
}
function formatUkTimestampFromUtc(isoLike){
  if (!isoLike) return isoLike;
  const dt = new Date(isoLike); // parse ISO / ISO-like (+00:00, with ms) to JS Date
  if (isNaN(dt.getTime())) return isoLike;
  const fmt = new Intl.DateTimeFormat('en-GB', {
    timeZone: 'Europe/London',
    year:'numeric', month:'2-digit', day:'2-digit',
    hour:'2-digit', minute:'2-digit', hour12:false
  });
  const parts = fmt.formatToParts(dt);
  const g = (type)=> (parts.find(p=>p.type===type)?.value || '');
  const dd = g('day'), mm = g('month'), yyyy = g('year');
  const hh = g('hour'), mi = g('minute');
  return `${dd}/${mm}/${yyyy} ${hh}${mi}hrs`;
}

function formatDisplayValue(key, val){
  if (val === null || val === undefined || val === '') return 'â€”';
  if (typeof val === 'boolean') return val ? 'Yes' : 'No';

  const normEnum = (s) => String(s || '').trim().replace(/-/g, '_').toUpperCase();

  const titleCaseEnum = (s) => {
    const raw = normEnum(s).replace(/_/g, ' ').toLowerCase();
    const tc = raw.replace(/\b\w/g, (c) => c.toUpperCase());

    // Preserve common acronyms
    return tc
      .replace(/\bNhsp\b/g, 'NHSP')
      .replace(/\bHr\b/g, 'HR')
      .replace(/\bNhs\b/g, 'NHS')
      .replace(/\bVat\b/g, 'VAT');
  };

  const friendlyProcessingStatus = (s) => {
    const up = normEnum(s);
    const map = {
      READY_FOR_INVOICE: 'Ready to Invoice',
      PENDING_AUTH: 'Awaiting Authorisation',
      UNASSIGNED: 'Unassigned',
      RATE_MISSING: 'Rate Missing'
    };
    return map[up] || titleCaseEnum(up);
  };

  const friendlyRouteType = (s) => {
    const up = normEnum(s);
    const map = {
      WEEKLY_NHSP: 'Weekly NHSP',
      WEEKLY_NHSP_ADJUSTMENT: 'Weekly NHSP Adjustment',
      WEEKLY_HEALTHROSTER: 'Weekly HealthRoster',
      WEEKLY_ELECTRONIC: 'Weekly Electronic',
      DAILY_ELECTRONIC: 'Daily Electronic',
      WEEKLY_MANUAL: 'Weekly Manual',
      DAILY_MANUAL: 'Daily Manual',
      UNKNOWN: 'Unknown'
    };
    return map[up] || titleCaseEnum(up);
  };

  const friendlySheetScope = (s) => {
    const up = normEnum(s);
    if (up === 'WEEKLY') return 'Weekly';
    if (up === 'DAILY') return 'Daily';
    return titleCaseEnum(up);
  };

  const friendlySubmissionMode = (s) => {
    const up = normEnum(s);
    if (up === 'MANUAL') return 'Manual';
    if (up === 'ELECTRONIC') return 'Electronic';
    return titleCaseEnum(up);
  };

  const friendlyInvoiceStatus = (s) => {
    const up = normEnum(s);
    if (up === 'DRAFT') return 'Draft';
    if (up === 'ON_HOLD') return 'On Hold';
    if (up === 'ISSUED') return 'Issued';
    if (up === 'PAID') return 'Paid';
    return titleCaseEnum(up);
  };

  // Friendly enum display (must happen before date heuristics)
  const k = String(key || '').toLowerCase();
  if (k === 'processing_status' || k === 'summary_stage') {
    return friendlyProcessingStatus(val);
  }
  if (k === 'route_type') {
    return friendlyRouteType(val);
  }
  if (k === 'sheet_scope') {
    return friendlySheetScope(val);
  }
  if (k === 'submission_mode') {
    return friendlySubmissionMode(val);
  }
  if (k === 'status') {
    return friendlyInvoiceStatus(val);
  }

  if (typeof val === 'string'){
    // date-only?
    if (/^\d{4}-\d{2}-\d{2}$/.test(val)) return formatUkDate(val);
    // ISO-ish timestamp?
    if (/\d{4}-\d{2}-\d{2}T/.test(val))  return formatUkTimestampFromUtc(val);
  }

  // Heuristic by column name
  if (typeof key === 'string' && (
      key.endsWith('_at_utc') ||
      key === 'created_at' || key === 'updated_at' ||
      key.endsWith('_timestamp') || key.endsWith('_utc')
    )){
    return formatUkTimestampFromUtc(val);
  }

  return String(val);
}


// === UPDATED: Summary renders role summary for candidates (computed from JSON) ===


function renderAuditTable(content, rows){
  const cols = defaultColumnsFor('audit');
  const tbl = document.createElement('table'); tbl.className='grid';
  const thead = document.createElement('thead'); const trh=document.createElement('tr');
  cols.forEach(c=>{ const th=document.createElement('th'); th.textContent=c; trh.appendChild(th); });
  thead.appendChild(trh); tbl.appendChild(thead);
  const tb = document.createElement('tbody');
  rows.forEach(r=>{
    const tr=document.createElement('tr'); tr.ondblclick=()=> openAuditItem(r);
    cols.forEach(c=>{
      const td=document.createElement('td');
      let v=r[c];
      if (c==='status') td.innerHTML = `<span class="pill ${v==='SENT'?'tag-ok':v==='FAILED'?'tag-fail':'tag-warn'}">${v}</span>`;
      else td.textContent = formatDisplayValue(c, v);
      tr.appendChild(td);
    }); tb.appendChild(tr);
  }); tbl.appendChild(tb); content.appendChild(tbl);
}

// Column manager
const globalColsBtn = byId('btnColumns');
if (globalColsBtn) {
  globalColsBtn.onclick = () => {
    if (!currentSection || !Array.isArray(currentRows)) return;
    openColumnsDialog(currentSection);
  };
}


// ===== Data fetchers =====
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UPDATED: listCandidates â€” supports { q, page, page_size } + best-effort server search
// Falls back to list+local filter if /api/search/candidates is unavailable.
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function listCandidates(opts = {}) {
  const LOGC = (typeof window.__LOG_CONTRACTS === 'boolean') ? window.__LOG_CONTRACTS : false;
  const q = (opts.q || '').trim();
  window.__listState = window.__listState || {};
  const st = (window.__listState['candidates'] ||= { page: 1, pageSize: 50, total: null, hasMore: false, filters: null });
  const page = Number(opts.page || st.page || 1);
  const ps   = String(opts.page_size || st.pageSize || 50);

  // Helper: choose a search strategy based on q
  const buildCandidateQS = (qText) => {
    const qs = new URLSearchParams();
    if (ps !== 'ALL') { qs.set('page', String(page)); qs.set('page_size', String(ps)); } else { qs.set('page','1'); }
    if (!qText) return qs;

    if (qText.includes('@'))        qs.set('email', qText);
    else if (qText.replace(/\D/g,'').length >= 7) qs.set('phone', qText);
    else if (qText.includes(' ')) {
      const parts = qText.split(/\s+/).filter(Boolean);
      const fn = parts.shift() || qText; const ln = parts.join(' ');
      qs.set('first_name', fn); if (ln) qs.set('last_name', ln);
    } else                          qs.set('first_name', qText);

    return qs;
  };

  // Try server-side search first when q is present
  if (q) {
    const qs = buildCandidateQS(q);
    const url = `/api/search/candidates?${qs.toString()}`;
    try {
      if (LOGC) console.log('[PICKER][candidates] server-search â†’', url);
      const r = await authFetch(API(url));
      if (r.ok) {
        const rows = await toList(r);
        if (LOGC) console.log('[PICKER][candidates] server-search OK', { count: rows.length });
        if (ps !== 'ALL') st.hasMore = Array.isArray(rows) && rows.length === Number(ps || 50);
        return rows;
      }
    } catch (e) {
      if (LOGC) console.warn('[PICKER][candidates] server-search failed, falling back', e);
    }
  }

  // Fallback: plain list, then optional local filter
  const qs = new URLSearchParams();
  if (ps !== 'ALL') { qs.set('page', String(page)); qs.set('page_size', String(ps)); } else { qs.set('page','1'); }
  const url = qs.toString() ? `/api/candidates?${qs}` : '/api/candidates';
  const r = await authFetch(API(url));
  const rows = await toList(r);
  if (ps !== 'ALL') st.hasMore = Array.isArray(rows) && rows.length === Number(ps || 50);

  if (!q) return rows;

  // Local best-match ranking when server search isnâ€™t available
  const norm = (s) => (s||'').toString().toLowerCase();
  const toks = q.toLowerCase().split(/\s+/).filter(Boolean);
  const score = (row) => {
    const first = norm(row.first_name), last = norm(row.last_name);
    const disp  = norm(row.display_name || `${row.first_name||''} ${row.last_name||''}`);
    const email = norm(row.email), ref = norm(row.tms_ref);
    let s = 0;
    toks.forEach(t => {
      if (first.startsWith(t)) s += 6;
      if (last.startsWith(t))  s += 6;
      if (disp.startsWith(t))  s += 4;
      if (first === t || last === t) s += 8;
      if (disp.includes(t))    s += 2;
      if (email.includes(t))   s += 1;
      if (ref.includes(t))     s += 1;
    });
    if (toks.length >= 2) {
      // bonus if tokens cover first+last in any order
      const set = new Set(toks);
      if (set.has(first) && set.has(last)) s += 4;
    }
    return s;
  };
  const ranked = rows
    .map(r => ({ r, s: score(r) }))
    .filter(x => x.s > 0)
    .sort((a,b)=> b.s - a.s || String(a.r.display_name||'').localeCompare(String(b.r.display_name||'')))
    .map(x => x.r);

  if (LOGC) console.log('[PICKER][candidates] local-filter', { q, in: rows.length, out: ranked.length });
  return ranked;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UPDATED: listClients â€” supports { q, page, page_size } with /api/search/clients?q=â€¦
// Falls back to list when q is empty.
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function listClients(opts = {}) {
  const LOGC = (typeof window.__LOG_CONTRACTS === 'boolean') ? window.__LOG_CONTRACTS : false;
  const q = (opts.q || '').trim();
  window.__listState = window.__listState || {};
  const st = (window.__listState['clients'] ||= { page: 1, pageSize: 50, total: null, hasMore: false, filters: null });
  const page = Number(opts.page || st.page || 1);
  const ps   = String(opts.page_size || st.pageSize || 50);

  if (q) {
    const qs = new URLSearchParams();
    if (ps !== 'ALL') { qs.set('page', String(page)); qs.set('page_size', String(ps)); } else { qs.set('page','1'); }
    qs.set('q', q);
    const url = `/api/search/clients?${qs.toString()}`;
    try {
      if (LOGC) console.log('[PICKER][clients] server-search â†’', url);
      const r = await authFetch(API(url));
      if (r.ok) {
        const rows = await toList(r);
        if (LOGC) console.log('[PICKER][clients] server-search OK', { count: rows.length });
        if (ps !== 'ALL') st.hasMore = Array.isArray(rows) && rows.length === Number(ps || 50);
        return rows;
      }
    } catch (e) {
      if (LOGC) console.warn('[PICKER][clients] server-search failed, falling back', e);
    }
  }

  const qs = new URLSearchParams();
  if (ps !== 'ALL') { qs.set('page', String(page)); qs.set('page_size', String(ps)); } else { qs.set('page','1'); }
  const url = qs.toString() ? `/api/clients?${qs}` : '/api/clients';
  const r = await authFetch(API(url));
  const rows = await toList(r);
  if (ps !== 'ALL') st.hasMore = Array.isArray(rows) && rows.length === Number(ps || 50);

  // local filter when q present but search route unavailable
  if (!q) return rows;
  const qn = q.toLowerCase();
  const filtered = rows.filter(x => (x.name || '').toLowerCase().includes(qn) || (x.primary_invoice_email||'').toLowerCase().includes(qn));
  if (LOGC) console.log('[PICKER][clients] local-filter', { q, in: rows.length, out: filtered.length });
  return filtered;
}


async function listUmbrellas(){
  window.__listState = window.__listState || {};
  const st = (window.__listState['umbrellas'] ||= { page: 1, pageSize: 50, total: null, hasMore: false, filters: null });
  const ps = st.pageSize, pg = st.page;
  const qs = new URLSearchParams();
  if (ps !== 'ALL') { qs.set('page', String(pg || 1)); qs.set('page_size', String(ps || 50)); }
  else { qs.set('page', '1'); }
  const url = qs.toString() ? `/api/umbrellas?${qs}` : '/api/umbrellas';
  const r = await authFetch(API(url));
  const rows = toList(r);
  if (ps !== 'ALL') st.hasMore = Array.isArray(rows) && rows.length === Number(ps || 50);
  return rows;
}

async function listOutbox(){    const r = await authFetch(API('/api/email/outbox')); return toList(r); }
// ===================== API WRAPPERS (UPDATED) =====================

// GET /api/rates/client-defaults with optional filters:
//   clientId (path param), opts: { rate_type, role, band, active_on }
// Note: charge is shared; rate_type filter is optional and used by UI lists.
// âœ… UPDATED â€” unified FE model; grouping raw per-type rows into unified windows
//    Returned shape: [{ client_id, role, band|null, date_from, date_to|null,
//                       charge_day..bh, paye_day..bh, umb_day..bh }]
// ============================================================================
// LIST CLIENT RATES (adds only_enabled support)
// ============================================================================

async function listClientRates(clientId, opts = {}) {
  const APILOG = (typeof window !== 'undefined' && !!window.__LOG_API) || (typeof __LOG_API !== 'undefined' && !!__LOG_API);

  // ðŸ”§ Guard: never fetch without a client_id (prevents global empty lists clobbering staged state)
  if (!clientId) {
    if (APILOG) console.warn('[listClientRates] called without clientId â€” returning [] to avoid clobbering state');
    return [];
  }

  const qp = new URLSearchParams();
  qp.set('client_id', clientId);
  if (opts.role) qp.set('role', String(opts.role));
  if (opts.band !== undefined && opts.band !== null && `${opts.band}` !== '') {
    qp.set('band', String(opts.band));
  }
  if (opts.active_on) qp.set('active_on', String(opts.active_on)); // YYYY-MM-DD
  if (opts.only_enabled) qp.set('only_enabled', 'true');

  const qs = `?${qp.toString()}`;
  const url = API(`/api/rates/client-defaults${qs}`);
  if (APILOG) console.log('[listClientRates] â†’ GET', url);

  const res = await authFetch(url);
  if (APILOG) console.log('[listClientRates] â†', res.status, res.ok);
  const rows = await toList(res);
  if (APILOG) console.log('[listClientRates] parsed length', Array.isArray(rows) ? rows.length : -1);
  return Array.isArray(rows) ? rows : [];
}

// POST /api/rates/client-defaults â€” requires rate_type = 'PAYE' | 'UMBRELLA'

// POST /api/rates/candidate-overrides â€” requires rate_type
async function addCandidateRate(payload) {
  const rt = String(payload?.rate_type || '').toUpperCase();
  if (rt !== 'PAYE' && rt !== 'UMBRELLA') throw new Error("rate_type must be 'PAYE' or 'UMBRELLA'");
  const r = await authFetch(API('/api/rates/candidate-overrides'), {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify({ ...payload, rate_type: rt })
  });
  return r.ok;
}
// âœ… UPDATED â€” FE accepts a unified window payload; bridges to current per-type backend
//    Posts TWO rows: PAYE (pay from paye_*), UMBRELLA (pay from umb_*), both with same charge set
async function upsertClientRate(payload) {
  if (!payload || !payload.client_id || !payload.role || !payload.date_from) {
    throw new Error('upsertClientRate: client_id, role and date_from are required');
  }
  const APILOG = (typeof window !== 'undefined' && !!window.__LOG_API) || (typeof __LOG_API !== 'undefined' && !!__LOG_API);

  const body = {
    client_id : String(payload.client_id),
    role      : String(payload.role),
    band      : payload.band ?? null,
    date_from : payload.date_from,
    date_to   : payload.date_to ?? null,

    charge_day   : payload.charge_day   ?? null,
    charge_night : payload.charge_night ?? null,
    charge_sat   : payload.charge_sat   ?? null,
    charge_sun   : payload.charge_sun   ?? null,
    charge_bh    : payload.charge_bh    ?? null,

    paye_day     : payload.paye_day     ?? null,
    paye_night   : payload.paye_night   ?? null,
    paye_sat     : payload.paye_sat     ?? null,
    paye_sun     : payload.paye_sun     ?? null,
    paye_bh      : payload.paye_bh      ?? null,

    umb_day      : payload.umb_day      ?? null,
    umb_night    : payload.umb_night    ?? null,
    umb_sat      : payload.umb_sat      ?? null,
    umb_sun      : payload.umb_sun      ?? null,
    umb_bh       : payload.umb_bh       ?? null
  };

  if (APILOG) console.log('[upsertClientRate] â†’ POST /api/rates/client-defaults', body);
  const res = await authFetch(
    API(`/api/rates/client-defaults`),
    { method: 'POST', headers: { 'content-type': 'application/json' }, body: JSON.stringify(body) }
  );
  if (APILOG) console.log('[upsertClientRate] â†', res.status, res.ok);
  if (!res.ok) {
    const msg = await res.text().catch(() => 'Failed to upsert client default window');
    if (APILOG) console.error('[upsertClientRate] error body', msg);
    throw new Error(msg);
  }
  const json = await res.json().catch(() => ({}));
  if (APILOG) console.log('[upsertClientRate] parsed', json);
  return json;
}


// Small helper: cached settings (for ERNI%)
// Falls back to 0 if missing; returns { erni_pct: number (e.g. 0.15), ... }



// Small helper: pick best shared charge row for {client_id, role, band, active_on}
// Uses backendâ€™s selection logic via filters; no rate_type filter here (shared).
// âœ… UPDATED â€” works against unified rows returned by listClientRates()
//    Picks exact band first, then band-null; newest start date wins
async function findBestChargeFor({ client_id, role, band, active_on }) {
  // Fetch ONLY enabled windows for this client/role/date
  const rows = await listClientRates(client_id, { role, band: undefined, active_on, only_enabled: true });
  if (!Array.isArray(rows) || !rows.length) return null;

  const ranked = rows
    // extra guard: ignore any disabled rows that might slip through
    .filter(r =>
      !r.disabled_at_utc &&
      r.role === role &&
      r.date_from &&
      r.date_from <= (active_on || '9999-12-31') &&
      (!r.date_to || r.date_to >= (active_on || '0000-01-01'))
    )
    .sort((a,b) => {
      const aExact = (String(a.band||'') === String(band||''));
      const bExact = (String(b.band||'') === String(band||''));
      if (aExact !== bExact) return aExact ? -1 : 1;          // exact band before band-null
      // newer start first
      return (a.date_from < b.date_from) ? 1 : (a.date_from > b.date_from ? -1 : 0);
    });

  const best = ranked[0];
  return best ? {
    charge_day  : best.charge_day  ?? null,
    charge_night: best.charge_night?? null,
    charge_sat  : best.charge_sat  ?? null,
    charge_sun  : best.charge_sun  ?? null,
    charge_bh   : best.charge_bh   ?? null
  } : null;
}


// Small helper: per-bucket margin
function calcMargin(charge, pay, rate_type, erni_pct = 0) {
  if (charge == null || pay == null) return null;
  const rt = String(rate_type || '').toUpperCase();
  if (rt === 'PAYE') {
    const factor = 1 + (Number.isFinite(erni_pct) ? erni_pct : 0);
    return +(charge - (pay * factor)).toFixed(2);
  }
  return +(charge - pay).toFixed(2);
}


// Helper: basic date overlap check for YYYY-MM-DD strings (null = open-ended)
function rangesOverlap(a_from, a_to, b_from, b_to) {
  const A0 = a_from || '0000-01-01';
  const A1 = a_to   || '9999-12-31';
  const B0 = b_from || '0000-01-01';
  const B1 = b_to   || '9999-12-31';
  return !(A1 < B0 || B1 < A0);
}

// ====================== listCandidateRates (unchanged API) ======================
async function listCandidateRates(candidate_id){
  const r = await authFetch(API(`/api/rates/candidate-overrides?candidate_id=${encodeURIComponent(candidate_id)}`));
  return toList(r);
}
// =========================== fetchRelated (unchanged API) ===========================
  async function fetchRelated(entity, id, type){
  const sp = new URLSearchParams();

  // âœ… NEW: when showing related timesheets, forward the current stage filter (if present)
  try {
    const t = String(type || '').toLowerCase();
    const stage =
      (typeof filters === 'object' && filters && filters.tools_stage != null)
        ? String(filters.tools_stage || '').trim()
        : '';

    if (t === 'timesheets' && stage) {
      sp.set('tools_stage', stage);
    }
  } catch {}

  const qs = sp.toString();
  const url = API(`/api/related/${entity}/${id}/${type}${qs ? `?${qs}` : ''}`);

  let res;
  try {
    res = await authFetch(url);
  } catch (err) {
    console.error('fetchRelated network error:', { url, error: err });
    throw err;
  }

  if (!res.ok) {
    const text = await res.text().catch(()=> '');
    console.error('fetchRelated failed:', { status: res.status, url, server: text });
    throw new Error(`Request failed: ${res.status}`);
  }
  return toList(res);
}




// Settings (singleton)

async function saveSettings(payload){
  // Save non-finance settings_defaults only (finance windows are saved separately)
  const r = await authFetch(API('/api/settings/defaults'), {
    method:'PUT',
    headers:{'content-type':'application/json'},
    body: JSON.stringify(payload)
  });
  if (!r.ok) throw new Error('Save failed');
  return true;
}

async function getSettings(){
  const r = await authFetch(API('/api/settings/defaults'));
  if (!r.ok) throw new Error('Fetch settings failed');
  const j = await r.json();

  // Updated shape: { settings: {...}, finance_windows: [...] }
  if (j && typeof j === 'object' && j.settings && typeof j.settings === 'object') {
    return {
      settings: j.settings || {},
      finance_windows: Array.isArray(j.finance_windows) ? j.finance_windows : []
    };
  }

  // Fallback for legacy responses
  return {
    settings: (j?.settings || j || {}),
    finance_windows: Array.isArray(j?.finance_windows) ? j.finance_windows : []
  };
}
let __SETTINGS_CACHE__ = null;
async function getSettingsCached() {
  if (__SETTINGS_CACHE__) return __SETTINGS_CACHE__;
  try {
    const s = await getSettings();
    __SETTINGS_CACHE__ = s || { settings:{}, finance_windows:[] };
  } catch {
    __SETTINGS_CACHE__ = { settings:{}, finance_windows:[] };
  }
  return __SETTINGS_CACHE__;
}




// Related counts (object map: {type: count, ...})
async function fetchRelatedCounts(entity, id){
  try {
    const r = await authFetch(API(`/api/related/${entity}/${id}/counts`));
    if (!r.ok) return {};

    const j = await r.json().catch(() => ({}));
    const out = (j && typeof j === 'object') ? { ...j } : {};

    // âœ… Treat invoice count as integer (segment splits can make this >1)
    if (Object.prototype.hasOwnProperty.call(out, 'invoices')) {
      const n = Number(out.invoices);
      out.invoices = Number.isFinite(n) ? Math.max(0, Math.trunc(n)) : 0;
    }
    if (Object.prototype.hasOwnProperty.call(out, 'invoice_count')) {
      const n = Number(out.invoice_count);
      out.invoice_count = Number.isFinite(n) ? Math.max(0, Math.trunc(n)) : 0;
    }

    // âœ… Treat series count as already "other timesheets in series" (no subtraction here)
    if (Object.prototype.hasOwnProperty.call(out, 'series')) {
      const n = Number(out.series);
      out.series = Number.isFinite(n) ? Math.max(0, Math.trunc(n)) : 0;
    }
    if (Object.prototype.hasOwnProperty.call(out, 'series_count')) {
      const n = Number(out.series_count);
      out.series_count = Number.isFinite(n) ? Math.max(0, Math.trunc(n)) : 0;
    }

    return out;
  } catch {
    // keep "return {} on error"
    return {};
  }
}

// ===== UPDATED: upsertCandidate â€” normalize server response so we always return the created/updated object with an id
async function upsertCandidate(payload, id){
  if ('tms_ref' in payload) delete payload.tms_ref; // safety

  const url = id ? `/api/candidates/${id}` : '/api/candidates';
  const method = id ? 'PUT' : 'POST';

  let res;
  try {
    res = await authFetch(API(url), {
      method,
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify(payload),
    });
  } catch (err) {
    console.error('Candidate save request/network error:', { url, method, payload, error: err });
    throw err;
  }

  const text = await res.text().catch(() => '');
  if (!res.ok) {
    console.error('Candidate save failed:', { status: res.status, url, method, payload, server: text });
    throw new Error(text || `Save failed (${res.status})`);
  }

  try {
    const data = text ? JSON.parse(text) : null;
    // normalize common shapes: [row], { candidate: {...} }, or { ...row }
    let obj = null;
    if (Array.isArray(data)) obj = data[0] || null;
    else if (data && data.candidate) obj = data.candidate;
    else if (data && typeof data === 'object') obj = data;

    return obj || (id ? { id, ...payload } : {});
  } catch (e) {
    console.warn('Candidate save: non-JSON response body', { body: text });
    return id ? { id, ...payload } : {};
  }
}

// ===== UPDATED: upsertClient â€” normalize server response so we always return the created/updated object with an id

// ================== FRONTEND: upsertUmbrella (UPDATED to return saved object) ==================
// ===== UPDATED: upsertUmbrella â€” normalize server response so we always return the created/updated object with an id
async function upsertUmbrella(payload, id){
  const url = id ? `/api/umbrellas/${id}` : '/api/umbrellas';
  const method = id ? 'PUT' : 'POST';
  const r = await authFetch(API(url), {method, headers:{'content-type':'application/json'}, body: JSON.stringify(payload)});
  if (!r.ok) { 
    const msg = await r.text().catch(()=> 'Save failed');
    throw new Error(msg || 'Save failed'); 
  }
  try {
    const data = await r.json();
    // normalize shapes: [row], { umbrella: {...} }, or { ...row }
    let obj = null;
    if (Array.isArray(data)) obj = data[0] || null;
    else if (data && data.umbrella) obj = data.umbrella;
    else if (data && typeof data === 'object') obj = data;

    return obj || (id ? { id, ...payload } : { ...payload });
  } catch (_) {
    return id ? { id, ...payload } : { ...payload };
  }
}


async function deleteCandidateRatesFor(candidate_id){
  const r = await authFetch(API(`/api/rates/candidate-overrides/${candidate_id}`), {method:'DELETE'}); return r.ok;
}



// ===== Details Modals =====
let modalCtx = { entity:null, data:null };


// âœ… CHANGED: make this async, always hydrate fresh from server before opening
async function openDetails(rowOrId) {
  if (!confirmDiscardChangesIfDirty()) return;

  const gl = beginGlobalLoading('Openingâ€¦');

  try {
    let row = rowOrId;
    let id  = null;

    if (!row || typeof row !== 'object') {
      id = String(rowOrId || '');
      row = currentRows.find(x => String(x.id) === id) || null;
    } else {
      id = String(row.id || '');
    }

    if (!id) { alert('Record id not provided'); return; }

    // Contracts: fetch fresh wrapper/row best-effort, then open
    if (currentSection === 'contracts') {
      let fresh = null;
      try {
        fresh = await getContract(id);
      } catch (e) {
        console.debug('[OPEN] getContract failed, falling back to cached row', e);
      }
      const effective = fresh || row;
      if (!effective) { alert('Record not found'); return; }
      currentSelection = effective;
      console.debug('[OPEN] openDetails', { section: currentSection, id: effective.id });
      openContract(effective);
      return;
    }

    if (!row) { alert('Record not found'); return; }

    currentSelection = row;
    console.debug('[OPEN] openDetails', { section: currentSection, id: row.id });

    if (currentSection === 'candidates')      await openCandidate(row);
    else if (currentSection === 'clients')    await openClient(row);
    else if (currentSection === 'umbrellas')  await openUmbrella(row);
    else if (currentSection === 'audit')      openAuditItem(row);
    else if (currentSection === 'contracts')  openContract(row);
    else if (currentSection === 'timesheets') await openTimesheet(row);
    else if (currentSection === 'invoices')   await openInvoiceModal(row); // âœ… NEW
  } catch (e) {
    console.warn('[OPEN] openDetails failed', e);
    alert(e?.message || 'Failed to open record.');
  } finally {
    endGlobalLoading();
  }
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Global loading overlay (rotating dots) â€” minimal + safe
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function ensureGlobalLoadingOverlay() {
  try {
    if (document.getElementById('globalLoadingOverlay')) return;

    // Inject CSS once
    if (!document.getElementById('__globalLoadingCss')) {
      const st = document.createElement('style');
      st.id = '__globalLoadingCss';
      st.textContent = `
#globalLoadingOverlay{
  position:fixed;
  inset:0;
  display:none;
  place-items:center;
  z-index:9999;
  background: rgba(2,6,23,0.35);
  backdrop-filter: blur(1px);
}
#globalLoadingOverlay[data-show="1"]{ display:grid; }
#globalLoadingOverlay .gload-card{
  display:flex;
  flex-direction:column;
  align-items:center;
  gap:10px;
  padding:14px 16px;
  border-radius:14px;
  border:1px solid var(--line, #334155);
  background: linear-gradient(180deg,#0e1428,#0b1221);
  box-shadow: var(--shadow, 0 6px 20px rgba(0,0,0,.25));
}
#globalLoadingOverlay .gload-spinner{
  position:relative;
  width:54px;
  height:54px;
  animation: gloadSpin 0.95s linear infinite;
}
#globalLoadingOverlay .gload-spinner span{
  position:absolute;
  top:50%;
  left:50%;
  width:8px;
  height:8px;
  margin:-4px;
  border-radius:50%;
  background:#e5e7eb;
  opacity:.25;
  transform: rotate(calc(var(--i) * 45deg)) translate(20px);
}
#globalLoadingOverlay .gload-spinner span:nth-child(1){opacity:.25}
#globalLoadingOverlay .gload-spinner span:nth-child(2){opacity:.30}
#globalLoadingOverlay .gload-spinner span:nth-child(3){opacity:.35}
#globalLoadingOverlay .gload-spinner span:nth-child(4){opacity:.45}
#globalLoadingOverlay .gload-spinner span:nth-child(5){opacity:.60}
#globalLoadingOverlay .gload-spinner span:nth-child(6){opacity:.75}
#globalLoadingOverlay .gload-spinner span:nth-child(7){opacity:.90}
#globalLoadingOverlay .gload-spinner span:nth-child(8){opacity:1.00}

@keyframes gloadSpin{ to { transform: rotate(360deg); } }
      `;
      document.head.appendChild(st);
    }

    // Create overlay
    const ov = document.createElement('div');
    ov.id = 'globalLoadingOverlay';
    ov.setAttribute('aria-hidden', 'true');

    ov.innerHTML = `
      <div class="gload-card" role="status" aria-live="polite">
        <div class="gload-spinner" aria-hidden="true">
          <span style="--i:0"></span><span style="--i:1"></span><span style="--i:2"></span><span style="--i:3"></span>
          <span style="--i:4"></span><span style="--i:5"></span><span style="--i:6"></span><span style="--i:7"></span>
        </div>
        <div class="mini" id="globalLoadingText">Loadingâ€¦</div>
      </div>
    `;

    document.body.appendChild(ov);
  } catch {}
}

function beginGlobalLoading(label) {
  try {
    ensureGlobalLoadingOverlay();

    const st = (window.__gload ||= {
      count: 0,
      visibleSince: 0,
      hideTimer: null
    });

    st.count += 1;
    if (st.count === 1) st.visibleSince = Date.now();

    if (st.hideTimer) { clearTimeout(st.hideTimer); st.hideTimer = null; }

    const ov = document.getElementById('globalLoadingOverlay');
    if (ov) {
      ov.dataset.show = '1';
      ov.setAttribute('aria-hidden', 'false');
      const txt = document.getElementById('globalLoadingText');
      if (txt) txt.textContent = (label ? `Loadingâ€¦ ${String(label)}` : 'Loadingâ€¦');
    }
  } catch {}

  return `gl:${Date.now()}:${Math.random().toString(36).slice(2)}`;
}

function endGlobalLoading() {
  try {
    const st = window.__gload;
    if (!st || !Number.isFinite(st.count)) return;

    st.count = Math.max(0, st.count - 1);
    if (st.count > 0) return;

    const ov = document.getElementById('globalLoadingOverlay');
    if (!ov) return;

    // Ensure it stays visible a tiny minimum time (prevents â€œflashâ€)
    const minMs = 250;
    const elapsed = Date.now() - (st.visibleSince || 0);
    const wait = Math.max(0, minMs - elapsed);

    st.hideTimer = setTimeout(() => {
      try {
        ov.dataset.show = '';
        ov.setAttribute('aria-hidden', 'true');
      } catch {}
      st.hideTimer = null;
    }, wait);
  } catch {}
}



async function unauthoriseTimesheet(ctxOrId, expectedTimesheetId) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][UNAUTH]');
  GC('unauthoriseTimesheet');

  const mc  = window.modalCtx || {};
  const row = (mc.data && mc.data.timesheet_id) ? mc.data :
              (ctxOrId && ctxOrId.row ? ctxOrId.row : {});
  const tsId = (typeof ctxOrId === 'string')
    ? ctxOrId
    : (row.timesheet_id || row.id || mc.data?.id || null);

  if (!tsId) {
    L('ERROR: missing timesheetId');
    GE();
    throw new Error('unauthoriseTimesheet: timesheetId is required');
  }

  const expected =
    (expectedTimesheetId != null ? String(expectedTimesheetId) : '') ||
    (mc.timesheetMeta && mc.timesheetMeta.expected_timesheet_id) ||
    String(tsId);

  const encId   = encodeURIComponent(tsId);
  const urlPath = `/api/timesheets/${encId}/unauthorise`;

  const payload = { expected_timesheet_id: expected };

  L('REQUEST', { url: API(urlPath), tsId, payload });

  // âœ… Use apiPostJson so 409 errors preserve err.status + err.json for TIMESHEET_MOVED handling
  const json = await apiPostJson(urlPath, payload);

  L('unauthorise result', json);

  const newId =
    (json && (json.current_timesheet_id || json.new_timesheet_id || json.timesheet_id))
      ? (json.current_timesheet_id || json.new_timesheet_id || json.timesheet_id)
      : null;

  const resolvedId = (newId && String(newId).trim()) ? String(newId) : String(tsId);

  let newDetails = mc.timesheetDetails;
  try {
    newDetails = await fetchTimesheetDetails(resolvedId);
    window.modalCtx.timesheetDetails = newDetails;
  } catch (err) {
    L('refresh details failed (non-fatal)', err);
  }

  const tsfin = newDetails?.tsfin || {};
  const updatedRow = {
    ...(mc.data || row),
    summary_stage: json.summary_stage || mc.data?.summary_stage || 'PENDING_AUTH',
    processing_status: tsfin.processing_status || mc.data?.processing_status,
    total_pay_ex_vat: tsfin.total_pay_ex_vat ?? mc.data?.total_pay_ex_vat,
    total_charge_ex_vat: tsfin.total_charge_ex_vat ?? mc.data?.total_charge_ex_vat,
    margin_ex_vat: tsfin.margin_ex_vat ?? mc.data?.margin_ex_vat,
    timesheet_id: resolvedId,
    id: resolvedId
  };

  window.modalCtx.data = updatedRow;

  // âœ… keep guarded-write expected id aligned
  if (window.modalCtx?.timesheetMeta && typeof window.modalCtx.timesheetMeta === 'object') {
    window.modalCtx.timesheetMeta.expected_timesheet_id = resolvedId;
  }

  try {
    window.__pendingFocus = {
      section: 'timesheets',
      ids: [String(resolvedId)],
      primaryIds: [String(resolvedId)]
    };
  } catch {}

  // âœ… Keep the summary grid consistent
  try {
    if (typeof refreshTimesheetsSummaryAfterRotation === 'function') {
      await refreshTimesheetsSummaryAfterRotation(resolvedId);
    }
  } catch (e) {
    L('summary refresh failed (non-fatal)', e);
  }

  L('UPDATED ROW', updatedRow);
  GE();
  return { ok: true, updatedRow, details: newDetails, json };
}



function openCreate(){
  if (!confirmDiscardChangesIfDirty()) return;
  if (currentSection==='candidates') openCandidate({});
  else if (currentSection==='clients') openClient({});
  else if (currentSection==='umbrellas') openUmbrella({});
  else if (currentSection==='contracts') openContract({}); // new route
  else alert('Create not supported for this section yet.');
}

function openEdit(){
  if (!confirmDiscardChangesIfDirty()) return;
  if (!currentSelection) return alert('Select by double-clicking a row first.');
  openDetails(currentSelection);
}

async function openDelete(){
  const inModal = (window.__modalStack?.length || 0) > 0;
  const row = inModal ? (modalCtx?.data || null) : currentSelection;

  if (!row) return alert('Select a record (or open it) first.');
  if (!confirm('Delete (or disable) this record?')) return;

  console.debug('[DELETE] request', {
    section: inModal ? modalCtx?.entity : currentSection,
    inModal, id: row.id
  });

  const section = inModal ? modalCtx?.entity : currentSection;

  if (section === 'candidates'){
    await upsertCandidate({ ...row, active:false }, row.id);
  } else if (section === 'umbrellas'){
    await upsertUmbrella({ ...row, enabled:false }, row.id);
  } else if (section === 'contracts'){
    alert('Delete is not available for Contracts here. Open the contract and use the dedicated action if supported.'); // guarded, non-breaking
    return;
  } else {
    alert('Delete is not available for this section.');
    return;
  }

  if (inModal) {
    // Ensure no lingering state after delete
    discardAllModalsAndState();
  }
  await renderAll();
}

// ---- Candidate modal
// === UPDATED: Candidate open modal (mount roles editor; include roles on save) ===
// === UPDATED: openCandidate â€” save uses full persisted state + current tab values ===

// ========================= openCandidate (FIXED) =========================

// =================== CANDIDATE MODAL (unchanged save; ensures pay_method present) ===================
// âœ… UPDATED â€” staged candidate overrides model (apply vs save)
//    Parent Save commits staged deletes â†’ edits â†’ creates

// FRONTEND â€” UPDATED
// openCandidate: default Account holder from umbrella name if pay_method is UMBRELLA and empty.
// ================== FRONTEND: openCandidate (UPDATED) ==================
// ================== FIXED: openCandidate (hydrate before showModal) ==================
// ================== FIXED: openCandidate (hydrate before showModal) ==================
// ================== FIXED: openCandidate (hydrate before showModal) ==================





















// NEW: dedicated Advances / Loans manager modal for a candidate
async function openCandidateAdvancesModal(candidateRow) {
  const deep = (o) => JSON.parse(JSON.stringify(o || {}));
  const row = deep(candidateRow || {});
  const candId = row.id;
  if (!candId) {
    alert('Candidate id is missing; save the candidate record first.');
    return;
  }

  window.appState = window.appState || {};
  window.appState.candidateAdvances = window.appState.candidateAdvances || {};

  // Ensure advances are fetched before opening
  try {
    if (!window.appState.candidateAdvances[candId]) {
      await fetchCandidateAdvances(candId);
    } else {
      // refresh in background, but don't block the modal opening
      fetchCandidateAdvances(candId).catch(() => {});
    }
  } catch (e) {
    console.warn('[ADVANCES][MGR] prefetch failed', e);
  }

  // Seed modal context as its own entity
  window.modalCtx = {
    entity: 'candidate-advances',
    data: row,
    formState: { __forId: candId, main: {} },
    openToken: `cand-adv:${candId}:${Date.now()}`
  };

  const titleName =
    row.display_name ||
    `${row.first_name || ''} ${row.last_name || ''}`.trim() ||
    row.tms_ref ||
    'Candidate';

  const renderAdvancesTab = () => {
    const S = (window.appState && window.appState.candidateAdvances) || {};
    const entry   = S[candId] || { list: [], summary: {} };
    const list    = Array.isArray(entry.list) ? entry.list : [];
    const summary = entry.summary || {};

    const missing = list.filter(a => (a.reason || '').toUpperCase() === 'MISSING_SHIFT');
    const general = list.filter(a => (a.reason || '').toUpperCase() !== 'MISSING_SHIFT');

    return html(`
      <div class="form" id="candidateAdvancesManager" data-candidate-id="${candId}">
        <div class="row">
          <label>Candidate</label>
          <div class="controls">
            <span class="mini">${escapeHtml(titleName)}</span>
          </div>
        </div>

        <div class="row">
          <label>Summary</label>
          <div class="controls" id="candidateAdvancesSummary">
            ${renderAdvancesSummary(summary)}
          </div>
        </div>

        <div class="row">
          <label>Missing-shift advances</label>
          <div class="controls">
            <div id="candidateMissingShiftAdvances">
              ${renderMissingShiftAdvancesList(missing)}
            </div>
            <button type="button"
                    class="btn mini"
                    data-act="adv-missing-new">
              New missing-shift advanceâ€¦
            </button>
          </div>
        </div>

        <div class="row">
          <label>Advances / loans</label>
          <div class="controls">
            <div id="candidateGeneralAdvances">
              ${renderGeneralAdvancesList(general)}
            </div>
            <button type="button"
                    class="btn mini"
                    data-act="adv-manual-new">
              New advance / loanâ€¦
            </button>
          </div>
        </div>
      </div>
    `);
  };

  const onSave = async () => {
    // All actions are applied immediately by their own dialogs/routes.
    // Parent Save just closes the manager.
    return { ok: true };
  };

  const onReturn = () => {
    try {
      const root = document.getElementById('candidateAdvancesManager');
      if (!root) return;
      const candIdLocal =
        root.getAttribute('data-candidate-id') ||
        window.modalCtx?.data?.id ||
        candId;

      if (!candIdLocal) return;

      // Wire "New missing-shift advance" & "New advance / loan"
      if (!root.__advNewWired) {
        root.__advNewWired = true;
        root.addEventListener('click', (ev) => {
          const btn = ev.target.closest('button[data-act]');
          if (!btn) return;
          const act = btn.getAttribute('data-act') || '';

          if (act === 'adv-missing-new') {
            const cand = window.modalCtx?.data || row;
            if (typeof openMissingShiftAdvanceModal === 'function') {
              openMissingShiftAdvanceModal(cand);
            }
          } else if (act === 'adv-manual-new') {
            const cand = window.modalCtx?.data || row;
            if (typeof openManualAdvanceModal === 'function') {
              openManualAdvanceModal(cand);
            }
          }
        });
      }

      // Wire general advances actions (Edit schedule / Pause/Resume / Mark paid off)
      const generalContainer = root.querySelector('#candidateGeneralAdvances');
      if (generalContainer && !generalContainer.__advWired) {
        generalContainer.__advWired = true;
        generalContainer.addEventListener('click', async (ev) => {
          const btn = ev.target.closest('button[data-act][data-advance-id]');
          if (!btn) return;

          const act   = btn.getAttribute('data-act') || '';
          const advId = btn.getAttribute('data-advance-id') || '';
          if (!advId) return;

          const S = (window.appState && window.appState.candidateAdvances) || {};
          const entry = S[candIdLocal] || {};
          const list  = Array.isArray(entry.list) ? entry.list : [];
          const advance = list.find(a => String(a.id) === String(advId));
          if (!advance) return;

          if (act === 'adv-edit-schedule') {
            if (typeof openEditAdvanceScheduleModal === 'function') {
              openEditAdvanceScheduleModal(advance);
            }
          } else if (act === 'adv-toggle-pause') {
            if (typeof toggleAdvancePause === 'function') {
              await toggleAdvancePause(advance);
            }
          } else if (act === 'adv-mark-paid-off') {
            if (typeof markAdvancePaidOff === 'function') {
              await markAdvancePaidOff(advance);
            }
          }
        });
      }
    } catch (e) {
      console.warn('[ADVANCES][MGR] wiring failed', e);
    }
  };

  showModal(
    `Advances / loans â€” ${escapeHtml(titleName)}`,
    [{ key: 'main', label: 'Advances' }],
    renderAdvancesTab,
    onSave,
    true,
    onReturn,
    { kind: 'candidate-advances', noParentGate: true }
  );

  // Ensure the advances manager is wired immediately on first open
  try {
    onReturn();
  } catch (e) {
    console.warn('[ADVANCES][MGR] initial wiring failed', e);
  }
}

function renderCandidateTab(key, row = {}) {
  if (key === 'main') {
    const enc = escapeHtml || ((s) => String(s || ''));

    return html(`
      <div class="form" id="tab-main">
        ${input('first_name','First name', row.first_name)}
        ${input('last_name','Last name', row.last_name)}
        ${input('email','Email', row.email, 'email')}
        ${input('phone','Telephone', row.phone)}

        ${select(
          'pay_method',
          'Pay method',
          (row.pay_method && row.pay_method !== 'Unknown' && row.pay_method !== 'UNKNOWN')
            ? row.pay_method
            : 'Unknown',
          ['Unknown','PAYE','UMBRELLA'],
          { id:'pay-method' }
        )}

     <!-- Global Candidate Key (GCK): editable (so we can correct/clear mappings) -->
<div class="row">
  <label>Global Candidate Key (GCK)</label>
  <div class="controls">
    <input
      class="input"
      name="key_norm"
      value="${enc(row.key_norm || '')}"
      placeholder=""
    />
    <div class="hint">
      Links this candidate to the rota identity (GCK). You can correct or clear this if it was mapped incorrectly.
    </div>
  </div>
</div>


        <!-- NHSP / HealthRoster aliases (from hr_name_mappings) -->
        <div class="row">
          <label>Also known as in NHSP / HealthRoster</label>
          <div class="controls">
            <div class="split" id="cand-alias-select-row" style="display:none;">
              <select id="cand-alias-select" class="input"></select>
              <button type="button"
                      class="btn mini"
                      data-act="delete-cand-alias"
                      title="Remove this mapping">
                ðŸ—‘ Remove mapping
              </button>
            </div>
            <div id="cand-alias-empty" class="mini">
              No aliases configured yet.
            </div>
            <div class="hint">
              Aliases come from previous NHSP / HealthRoster imports where this staff name
              was resolved to this candidate. Removing a mapping will prevent future rotas
              using that name from auto-linking to this candidate.
            </div>
          </div>
        </div>

        <!-- CCR: display-only, never posted -->
        <div class="row">
          <label>CloudTMS Candidate Reference (CCR)</label>
          <input id="tms_ref_display"
                 value="${row.tms_ref ? String(row.tms_ref) : 'Awaiting CCR number from server'}"
                 disabled
                 readonly
                 style="opacity:.7" />
        </div>

        ${input('display_name','Display name', row.display_name)}

        <!-- New: NI / DOB / Gender -->
        ${input('ni_number','National Insurance Number', row.ni_number)}
        ${input('date_of_birth','Date of birth', row.date_of_birth)}
        ${select('gender','Gender', row.gender || '', ['', 'Male', 'Female', 'Other'])}

        <!-- New: Job Titles (multi, with bins) -->
        <div class="row">
          <label>Job Titles</label>
          <div class="controls">
            <div id="jobTitlesList"
                 style="display:flex;flex-wrap:wrap;gap:4px;min-height:24px;align-items:flex-start;"></div>
            <button type="button"
                    class="btn mini"
                    data-act="pick-job-title">
              Add Job Titleâ€¦
            </button>
            <div class="hint">
              Right click a Job Title in Edit mode to select a Primary Job Role.
            </div>
          </div>
        </div>

        <!-- Professional registration number (NMC/GMC/HCPC) -->
        <div class="row"
             data-block="prof_reg"
             style="${row.prof_reg_type ? '' : 'display:none'}">
          <label data-field="prof_reg_label">
            ${row.prof_reg_type
              ? escapeHtml(`${row.prof_reg_type} Number`)
              : 'Registration Number'}
          </label>
          <div class="controls">
            <input class="input"
                   name="prof_reg_number"
                   value="${escapeHtml(row.prof_reg_number || '')}">
          </div>
        </div>

        <!-- Home address + postcode lookup -->
        <div class="row">
          <label>Home address</label>
          <div class="controls">
            <div class="grid-2">
              <input class="input"
                     name="address_line1"
                     placeholder="Address line 1"
                     value="${escapeHtml(row.address_line1 || '')}">
              <input class="input"
                     name="address_line2"
                     placeholder="Address line 2"
                     value="${escapeHtml(row.address_line2 || '')}">
              <input class="input"
                     name="address_line3"
                     placeholder="Address line 3"
                     value="${escapeHtml(row.address_line3 || '')}">
              <input class="input"
                     name="town_city"
                     placeholder="City / Town"
                     value="${escapeHtml(row.town_city || '')}">
              <input class="input"
                     name="county"
                     placeholder="County"
                     value="${escapeHtml(row.county || '')}">
              <div class="split">
                <input class="input"
                       name="postcode"
                       placeholder="Postcode"
                       value="${escapeHtml(row.postcode || '')}">
                <button type="button"
                        class="btn mini"
                        data-act="postcode-lookup"
                        title="Lookup by postcode">
                  Lookup
                </button>
              </div>
            </div>
          </div>
        </div>

        <div class="row">
          <label>Notes</label>
          <textarea name="notes" placeholder="Free textâ€¦">${row.notes || ''}</textarea>
        </div>
      </div>
    `);
  }

  // Care Packages tab (was "Rates")
 if (key === 'rates') return html(`
  <div class="form" id="tab-rates" style="grid-template-columns:minmax(0,1fr);">
    <!-- Rota Roles editor -->
    <div class="row" style="grid-column:1/-1;">
      <label>Rota Roles</label>
      <div class="controls">
        <div id="rolesEditor" data-init="1"></div>
        <div class="hint">
          This links the candidate job role to a Care Package rota only.
          If this candidate is not working on Care Packages, you can ignore this.
        </div>
      </div>
    </div>

    <!-- Candidate rate overrides table -->
    <div class="row" style="grid-column:1/-1;">
      <label>Care Package Rates</label>
      <div class="controls">
        <div id="ratesTable" class="rates-table-wrap"></div>
      </div>
    </div>
  </div>
`);


  if (key === 'pay') return html(`
    <div class="form" id="tab-pay" data-candidate-id="${row.id || ''}">
      <div class="row">
        <label class="hint">
          PAYE bank fields are editable. If UMBRELLA is selected, bank details are taken from the umbrella and locked.
        </label>
      </div>

      ${input('account_holder','Account holder', row.account_holder)}
      ${input('bank_name','Bank name', row.bank_name)}
      ${input('sort_code','Sort code', row.sort_code)}
      ${input('account_number','Account number', row.account_number)}

      <!-- Umbrella chooser: text input + datalist + hidden canonical id -->
      <div class="row" id="umbRow">
        <label>Umbrella company</label>
        <input id="umbrella_name"
               list="umbList"
               placeholder="Type to search umbrellasâ€¦"
               value=""
               autocomplete="off"
               onclick="if (this.value) { this.dataset.prev=this.value; this.value=''; this.dispatchEvent(new Event('input',{bubbles:true})); }"
               onfocus="if (this.value) { this.dataset.prev=this.value; this.value=''; this.dispatchEvent(new Event('input',{bubbles:true})); }" />
        <datalist id="umbList"></datalist>
        <input type="hidden" name="umbrella_id" id="umbrella_id" value="${row.umbrella_id || ''}"/>
      </div>

      <!-- Advances summary (read-only) -->
      <div class="row">
        <label>Advances summary</label>
        <div class="controls" id="candidateAdvancesSummary">
          <span class="mini">No advances loaded yet.</span>
        </div>
      </div>

      <!-- Missing-shift advances (read-only) -->
      <div class="row">
        <label>Missing-shift advances</label>
        <div class="controls">
          <div id="candidateMissingShiftAdvances">
            <span class="mini">No missing-shift advances.</span>
          </div>
          <div class="hint mini">
            To add or edit missing-shift advances, right-click this candidate in the summary list and choose â€œAdvances / loansâ€¦â€.
          </div>
        </div>
      </div>

      <!-- General advances / loans (read-only) -->
      <div class="row">
        <label>Advances / loans</label>
        <div class="controls">
          <div id="candidateGeneralAdvances">
            <span class="mini">No advances or loans.</span>
          </div>
          <div class="hint mini">
            To manage advances or loans, right-click this candidate in the summary list and choose â€œAdvances / loansâ€¦â€.
          </div>
        </div>
      </div>
    </div>
  `);

  // Candidate Calendar tab container
  if (key === 'bookings') return html(`
    <div id="candidateCalendarHolder" class="tabc">
      <div class="hint">Loading calendarâ€¦</div>
    </div>
  `);
}


async function fetchCandidateAdvances(candidateId) {
  if (!candidateId) return;

  window.appState = window.appState || {};
  const S = (window.appState.candidateAdvances ||= {});

  const advancesUrl = API(`/api/candidates/${encodeURIComponent(candidateId)}/advances`);
  const summaryUrl  = API(`/api/candidates/${encodeURIComponent(candidateId)}/advances/summary`);

  let advances = [];
  let summary  = { total_owed_by_candidate: 0, total_advances_not_offset: 0 };

  try {
    const [resList, resSummary] = await Promise.all([
      authFetch(advancesUrl),
      authFetch(summaryUrl)
    ]);

    if (resList.ok) {
      const j = await resList.json().catch(() => ({}));
      advances = Array.isArray(j.advances) ? j.advances : (Array.isArray(j) ? j : []);
    }

    if (resSummary.ok) {
      const s = await resSummary.json().catch(() => ({}));
      if (typeof s.total_owed_by_candidate === 'number') {
        summary.total_owed_by_candidate = s.total_owed_by_candidate;
      }
      if (typeof s.total_advances_not_offset === 'number') {
        summary.total_advances_not_offset = s.total_advances_not_offset;
      }
    }
  } catch (e) {
    console.warn('[ADVANCES] fetchCandidateAdvances failed', e);
  }

  S[candidateId] = {
    list: advances,
    summary,
    fetched_at: new Date().toISOString()
  };

  try {
    updateCandidateAdvancesUI(candidateId);
  } catch (e) {
    console.warn('[ADVANCES] updateCandidateAdvancesUI failed', e);
  }
}


function renderMissingShiftAdvancesList(list) {
  const rows = Array.isArray(list) ? list : [];
  if (!rows.length) {
    return '<span class="mini">No missing-shift advances.</span>';
  }

  const body = rows.map(a => {
    const client = escapeHtml(a.client_name || a.client_label || a.client_id || '');
    const date   = escapeHtml(a.linked_shift_date || '');
    const orig   = (Number(a.original_amount || 0)).toFixed(2);
    const out    = (Number(a.outstanding_amount || 0)).toFixed(2);
    const notes  = escapeHtml(a.notes || '');

    return `
      <tr data-advance-id="${a.id}">
        <td>${client || '<span class="mini">â€”</span>'}</td>
        <td>${date   || '<span class="mini">â€”</span>'}</td>
        <td>Â£${orig}</td>
        <td>Â£${out}</td>
        <td>${notes || '<span class="mini">â€”</span>'}</td>
      </tr>
    `;
  }).join('');

  return `
    <div class="adv-table-wrap">
      <table class="grid mini adv-table" style="table-layout:auto;width:100%;">
        <thead>
          <tr>
            <th>Client</th>
            <th>Shift date</th>
            <th>Original</th>
            <th>Outstanding</th>
            <th>Notes</th>
          </tr>
        </thead>
        <tbody>${body}</tbody>
      </table>
    </div>
  `;
}

function renderGeneralAdvancesList(list, opts = {}) {
  const rows = Array.isArray(list) ? list : [];
  const context = String(opts.context || 'manager').toLowerCase();
  const showActions = (context === 'manager');

  if (!rows.length) {
    return '<span class="mini">No advances or loans.</span>';
  }

  const body = rows.map(a => {
    const client = escapeHtml(a.client_name || a.client_label || a.client_id || '');
    const reason = escapeHtml(a.reason || '');
    const origNum = Number(a.original_amount || 0);
    const outNum  = Number(a.outstanding_amount || 0);
    const orig    = origNum.toFixed(2);
    const out     = outNum.toFixed(2);
    const next    = escapeHtml(a.next_due_week_start || '');

    const rawStatus = String(a.status || '');
    const status    = escapeHtml(rawStatus);

    const schedule = Array.isArray(a.schedule_json) ? a.schedule_json : [];
    const notes    = escapeHtml(a.notes || '');

    const schedSummary = schedule.length
      ? schedule
          .map(e => {
            const ws  = escapeHtml(e.week_start || '');
            const amt = (Number(e.amount || 0)).toFixed(2);
            return `${ws}: Â£${amt}`;
          })
          .join('<br>')
      : '<span class="mini">No schedule</span>';

    const paused     = rawStatus === 'PAUSED';
    const pauseLabel = paused ? 'Resume' : 'Pause';
    const showMarkPaidOff = (outNum > 0 && rawStatus !== 'PAID_OFF');

    const actionsHtml = showActions ? `
      <div class="adv-sched-actions">
        <button type="button"
                class="btn mini"
                data-act="adv-edit-schedule"
                data-advance-id="${a.id}">
          Edit schedule
        </button>
        <button type="button"
                class="btn mini"
                data-act="adv-toggle-pause"
                data-advance-id="${a.id}">
          ${pauseLabel}
        </button>
        ${
          showMarkPaidOff
            ? `<button type="button"
                       class="btn mini"
                       data-act="adv-mark-paid-off"
                       data-advance-id="${a.id}">
                 Mark paid off
               </button>`
            : ''
        }
      </div>
    ` : '';

    return `
      <tr data-advance-id="${a.id}">
        <td>${client || '<span class="mini">â€”</span>'}</td>
        <td>${reason || '<span class="mini">â€”</span>'}</td>
        <td>Â£${orig}</td>
        <td>Â£${out}</td>
        <td>${next || '<span class="mini">â€”</span>'}</td>
        <td>${status}</td>
        <td>${notes || '<span class="mini">â€”</span>'}</td>
        <td style="min-width:260px;">
          <div class="adv-sched">
            <div class="adv-sched-lines">${schedSummary}</div>
            ${actionsHtml}
          </div>
        </td>
      </tr>
    `;
  }).join('');

  return `
    <div class="adv-table-wrap">
      <table class="grid mini adv-table" style="table-layout:auto;width:100%;">
        <thead>
          <tr>
            <th>Client</th>
            <th>Reason</th>
            <th>Original</th>
            <th>Outstanding</th>
            <th>Next due week</th>
            <th>Status</th>
            <th>Notes</th>
            <th>Schedule${showActions ? ' / Actions' : ''}</th>
          </tr>
        </thead>
        <tbody>${body}</tbody>
      </table>
    </div>
  `;
}


async function markAdvancePaidOff(advance) {
  if (!advance || !advance.id) {
    alert('Advance record missing id.');
    return;
  }

  const id     = advance.id;
  const candId = advance.candidate_id || window.modalCtx?.data?.id || null;
  const orig   = Number(advance.original_amount || 0);
  const out    = Number(advance.outstanding_amount || 0);

  const msg = [
    `Mark this advance as fully paid off?`,
    ``,
    `Original amount: Â£${orig.toFixed(2)}`,
    `Outstanding now: Â£${out.toFixed(2)}`,
    ``,
    `No further repayments will be taken in pay runs.`
  ].join('\n');

  const ok = window.confirm(msg);
  if (!ok) return;

  try {
    const payload = {
      status: 'PAID_OFF',
      outstanding_amount: 0
      // Backend can recompute next_due_week_start as needed
    };

    const res = await authFetch(
      API(`/api/advances/${encodeURIComponent(id)}`),
      {
        method: 'PATCH',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify(payload)
      }
    );

    if (!res.ok) {
      const text = await res.text().catch(() => '');
      alert(text || 'Failed to mark advance as paid off.');
      return;
    }

    if (candId) {
      await fetchCandidateAdvances(candId);
    }

    window.__toast && window.__toast('Advance marked as paid off.');
  } catch (e) {
    console.warn('[ADVANCES] markAdvancePaidOff failed', e);
    alert(e?.message || 'Failed to mark advance as paid off.');
  }
}

function renderAdvancesSummary(summary) {
  const totalOwed     = Number(summary?.total_owed_by_candidate || 0).toFixed(2);
  const totalMissing  = Number(summary?.total_advances_not_offset || 0).toFixed(2);

  return `
    <div class="mini">
      <div>Total owed by candidate (all advances): <strong>Â£${totalOwed}</strong></div>
      <div>Total advances owed to candidate (not yet offset by shifts): <strong>Â£${totalMissing}</strong></div>
    </div>
  `;
}
function updateCandidateAdvancesUI(candidateId) {
  const S = (window.appState && window.appState.candidateAdvances) || {};
  const entry = S[candidateId] || { list: [], summary: {} };
  const list  = Array.isArray(entry.list) ? entry.list : [];
  const summary = entry.summary || {};

  const missing = list.filter(a => (a.reason || '').toUpperCase() === 'MISSING_SHIFT');
  const general = list.filter(a => (a.reason || '').toUpperCase() !== 'MISSING_SHIFT');

  const sumEl  = document.getElementById('candidateAdvancesSummary');
  const missEl = document.getElementById('candidateMissingShiftAdvances');
  const genEl  = document.getElementById('candidateGeneralAdvances');

  if (sumEl)  sumEl.innerHTML  = renderAdvancesSummary(summary);
  if (missEl) missEl.innerHTML = renderMissingShiftAdvancesList(missing);
  // Candidate Pay tab: summary mode (no action buttons)
  if (genEl)  genEl.innerHTML  = renderGeneralAdvancesList(general, { context: 'summary' });
}


function openMissingShiftAdvanceModal(candidate) {
  const candId = candidate?.id;
  if (!candId) {
    alert('Save the candidate first before adding advances.');
    return;
  }

  const title = `New missing-shift advance for ${escapeHtml(
    candidate.display_name || `${candidate.first_name || ''} ${candidate.last_name || ''}`
  )}`;

  const formHtml = `
    <div class="form" id="missingShiftAdvanceForm">
      <div class="row">
        <label>Client</label>
        <div class="controls">
          <select name="client_id" id="msa_client_id">
            <option value="">Loading clientsâ€¦</option>
          </select>
        </div>
      </div>
      <div class="row">
        <label>Shift date</label>
        <div class="controls">
          <input type="date" class="input" name="shift_date" />
        </div>
      </div>
      <div class="row">
        <label>Amount (Â£)</label>
        <div class="controls">
          <input type="number" step="0.01" min="0" class="input" name="amount" />
        </div>
      </div>
      <div class="row">
        <label>Best-guess hours</label>
        <div class="controls split">
          <input type="time" class="input" name="best_guess_start" placeholder="Start" />
          <input type="time" class="input" name="best_guess_end" placeholder="End" />
        </div>
      </div>
      <div class="row">
        <label>Notes</label>
        <div class="controls">
          <textarea name="notes" rows="3" placeholder="Optional notesâ€¦"></textarea>
        </div>
      </div>
    </div>
  `;

  showModal(
    title,
    [{ key: 'main', title: 'Advance' }],
    () => formHtml,
    async () => {
      const form = document.getElementById('missingShiftAdvanceForm');
      if (!form) return false;

      const data = collectForm('#missingShiftAdvanceForm') || {};
      const client_id = (data.client_id || '').trim();
      const shift_date = (data.shift_date || '').trim();
      const amount = Number(data.amount || 0);
      const start  = (data.best_guess_start || '').trim();
      const end    = (data.best_guess_end   || '').trim();
      const notes  = (data.notes || '').trim();

      if (!client_id) { alert('Client is required.'); return { ok:false }; }
      if (!shift_date) { alert('Shift date is required.'); return { ok:false }; }
      if (!amount || amount <= 0) { alert('Amount must be greater than zero.'); return { ok:false }; }

      const payload = {
        client_id,
        shift_date,
        amount,
        best_guess_hours: (start || end) ? { start, end } : null,
        notes
      };

      const url = API(`/api/candidates/${encodeURIComponent(candId)}/advances/missing-shift`);
      const res = await authFetch(url, {
        method: 'POST',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify(payload)
      });
      if (!res.ok) {
        const msg = await res.text().catch(() => 'Failed to create missing-shift advance');
        alert(msg || 'Failed to create missing-shift advance');
        return { ok:false };
      }

      await fetchCandidateAdvances(candId);
      return { ok:true };
    },
    false,
    async () => {
      // onReturn: populate clients in dropdown
      try {
        const sel = document.getElementById('msa_client_id');
        if (!sel) return;

        sel.innerHTML = '<option value="">Loading clientsâ€¦</option>';

        const clients = await listClients({ page_size:'ALL' }).catch(() => []);
        if (!Array.isArray(clients) || clients.length === 0) {
          sel.innerHTML = '<option value="">(No clients found)</option>';
          return;
        }

        sel.innerHTML = '<option value="">Select clientâ€¦</option>' +
          clients.map(c =>
            `<option value="${escapeHtml(c.id || '')}">${escapeHtml(c.name || '')}</option>`
          ).join('');
      } catch (e) {
        console.warn('[ADVANCES] failed to populate client list', e);
        const sel = document.getElementById('msa_client_id');
        if (sel) {
          sel.innerHTML = '<option value="">(Failed to load clients)</option>';
        }
      }
    },
    { kind: 'candidate-advance-missing' }
  );
}


function openManualAdvanceModal(candidate) {
  const candId = candidate?.id;
  if (!candId) {
    alert('Save the candidate first before adding advances.');
    return;
  }

  const title = `New advance / loan for ${escapeHtml(candidate.display_name || `${candidate.first_name || ''} ${candidate.last_name || ''}`)}`;

  const formHtml = `
    <div class="form" id="manualAdvanceForm">
      <div class="row">
        <label>Client (optional)</label>
        <div class="controls">
          <select name="client_id" id="ma_client_id">
            <option value="">(None / multiple clients)</option>
          </select>
        </div>
      </div>
      <div class="row">
        <label>Amount (Â£)</label>
        <div class="controls">
          <input type="number" step="0.01" min="0" class="input" name="amount" />
        </div>
      </div>

      <div class="row">
        <label>Repayment mode</label>
        <div class="controls">
          <label class="mini">
            <input type="radio" name="mode" value="simple" checked> Spread over N weeks
          </label>
          <label class="mini" style="margin-left:10px;">
            <input type="radio" name="mode" value="custom"> Custom schedule
          </label>
        </div>
      </div>

      <div id="ma_simple_block">
        <div class="row">
          <label>Start week (Mon)</label>
          <div class="controls">
            <input type="date" class="input" name="start_week_start" />
          </div>
        </div>
        <div class="row">
          <label>Number of weeks</label>
          <div class="controls">
            <input type="number" class="input" name="weeks_count" min="1" value="4" />
          </div>
        </div>
      </div>

      <div id="ma_custom_block" style="display:none;">
        <div class="row">
          <label>Custom schedule</label>
          <div class="controls">
            <table class="grid mini" id="ma_schedule_table">
              <thead>
                <tr>
                  <th>Week start</th>
                  <th>Amount (Â£, deducted)</th>
                  <th></th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
            <button type="button" class="btn mini" data-act="ma-add-row">Add row</button>
            <div class="hint mini">
              Amounts should be positive; they will be treated as deductions from net pay.
            </div>
          </div>
        </div>
      </div>

      <div class="row">
        <label>Notes</label>
        <div class="controls">
          <textarea name="notes" rows="3" placeholder="Optional notesâ€¦"></textarea>
        </div>
      </div>
    </div>
  `;

  showModal(
    title,
    [{ key: 'main', title: 'Advance' }],
    () => formHtml,
    async () => {
      const form = document.getElementById('manualAdvanceForm');
      if (!form) return false;

      const data = collectForm('#manualAdvanceForm') || {};
      const client_id = (data.client_id || '').trim() || null;
      const amount = Number(data.amount || 0);
      const mode   = (data.mode || 'simple').toLowerCase();
      const notes  = (data.notes || '').trim();

      if (!amount || amount <= 0) {
        alert('Amount must be greater than zero.');
        return { ok:false };
      }

      const payload = { client_id, amount, notes };

      if (mode === 'simple') {
        const start = (data.start_week_start || '').trim();
        const weeksCount = Number(data.weeks_count || 0);
        if (!start) { alert('Start week is required for simple schedule.'); return { ok:false }; }
        if (!weeksCount || weeksCount < 1) { alert('Number of weeks must be at least 1.'); return { ok:false }; }

        const weeks = [];
        const base = new Date(`${start}T00:00:00Z`);
        if (Number.isNaN(base.getTime())) {
          alert('Start week must be a valid date.');
          return { ok:false };
        }
        for (let i = 0; i < weeksCount; i++) {
          const d = new Date(base.getTime());
          d.setUTCDate(d.getUTCDate() + i * 7);
          const y = d.getUTCFullYear();
          const m = String(d.getUTCMonth() + 1).padStart(2, '0');
          const dd = String(d.getUTCDate()).padStart(2, '0');
          weeks.push(`${y}-${m}-${dd}`);
        }
        payload.start_week_start = start;
        payload.weeks = weeks;
      } else {
        // custom schedule
        const tbody = document.querySelector('#ma_schedule_table tbody');
        const rows = Array.from(tbody?.querySelectorAll('tr') || []);
        if (!rows.length) {
          alert('Add at least one custom schedule row.');
          return { ok:false };
        }

        const custom_schedule = [];
        for (const tr of rows) {
          const wsInput = tr.querySelector('input[name="week_start"]');
          const amtInput = tr.querySelector('input[name="amount"]');
          const ws  = (wsInput?.value || '').trim();
          const amt = Number(amtInput?.value || 0);
          if (!ws) {
            alert('Each custom row must have a week start date.');
            return { ok:false };
          }
          if (!amt || amt <= 0) {
            alert('Each custom row amount must be greater than zero.');
            return { ok:false };
          }
          custom_schedule.push({ week_start: ws, amount: -Math.abs(amt) }); // negative for deduction
        }

        payload.custom_schedule = custom_schedule;
      }

      const url = API(`/api/candidates/${encodeURIComponent(candId)}/advances/manual`);
      const res = await authFetch(url, {
        method: 'POST',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify(payload)
      });
      if (!res.ok) {
        const msg = await res.text().catch(() => 'Failed to create manual advance');
        alert(msg || 'Failed to create manual advance');
        return { ok:false };
      }

      await fetchCandidateAdvances(candId);
      return { ok:true };
    },
    false,
    async () => {
      // onReturn: wire simple/custom toggle & add-row, populate clients
      try {
        const modeRadios = document.querySelectorAll('#manualAdvanceForm input[name="mode"]');
        const simpleBlock = document.getElementById('ma_simple_block');
        const customBlock = document.getElementById('ma_custom_block');
        const tableBody   = document.querySelector('#ma_schedule_table tbody');
        const addRowBtn   = document.querySelector('#ma_schedule_table').closest('.controls')?.querySelector('[data-act="ma-add-row"]');
        const clientSel   = document.getElementById('ma_client_id');

        // Populate clients
        try {
          if (clientSel) {
            const clients = await listClients({ page_size:'ALL' }).catch(() => []);
            clientSel.innerHTML = '<option value="">(None / multiple clients)</option>' +
              clients.map(c => `<option value="${escapeHtml(c.id || '')}">${escapeHtml(c.name || '')}</option>`).join('');
          }
        } catch (e) {
          console.warn('[ADVANCES] populate client list (manual) failed', e);
        }

        const switchMode = () => {
          const cur = Array.from(modeRadios).find(r => r.checked)?.value || 'simple';
          if (cur === 'custom') {
            simpleBlock.style.display = 'none';
            customBlock.style.display = '';
          } else {
            simpleBlock.style.display = '';
            customBlock.style.display = 'none';
          }
        };

        modeRadios.forEach(r => {
          r.addEventListener('change', switchMode);
        });
        switchMode();

        const addRow = () => {
          if (!tableBody) return;
          const tr = document.createElement('tr');
          tr.innerHTML = `
            <td><input type="date" class="input" name="week_start" /></td>
            <td><input type="number" step="0.01" min="0" class="input" name="amount" /></td>
            <td><button type="button" class="btn mini" data-act="ma-del-row">&times;</button></td>
          `;
          tableBody.appendChild(tr);
        };

        if (addRowBtn) {
          addRowBtn.addEventListener('click', addRow);
        }

        if (tableBody && !tableBody.__wiredDel) {
          tableBody.__wiredDel = true;
          tableBody.addEventListener('click', (e) => {
            const btn = e.target.closest('button[data-act="ma-del-row"]');
            if (!btn) return;
            const tr = btn.closest('tr');
            if (tr) tr.remove();
          });
        }

      } catch (e) {
        console.warn('[ADVANCES] openManualAdvanceModal onReturn wiring failed', e);
      }
    },
    { kind: 'candidate-advance-manual' }
  );
}
function openEditAdvanceScheduleModal(advance) {
  if (!advance || !advance.id) {
    alert('Advance record missing id.');
    return;
  }

  const advId = advance.id;
  const schedule = Array.isArray(advance.schedule_json) ? advance.schedule_json : [];
  const title = `Edit schedule â€“ advance Â£${(Number(advance.original_amount || 0)).toFixed(2)}`;

  const rowsHtml = schedule.map((e, idx) => `
    <tr data-i="${idx}">
      <td><input type="date" class="input" name="week_start" value="${escapeHtml(e.week_start || '')}"></td>
      <td><input type="number" step="0.01" class="input" name="amount" value="${Number(e.amount || 0)}"></td>
      <td><button type="button" class="btn mini" data-act="adv-row-del">&times;</button></td>
    </tr>
  `).join('');

  const formHtml = `
    <div class="form" id="advanceScheduleForm">
      <div class="row">
        <label>Schedule</label>
        <div class="controls">
          <table class="grid mini" id="adv_schedule_table">
            <thead>
              <tr>
                <th>Week start</th>
                <th>Amount (Â£)</th>
                <th></th>
              </tr>
            </thead>
            <tbody>${rowsHtml}</tbody>
          </table>
          <button type="button" class="btn mini" data-act="adv-row-add">Add row</button>
          <div class="hint mini">
            Amounts are stored as signed values (negative = deduction, positive = extra pay).
          </div>
        </div>
      </div>
    </div>
  `;

  showModal(
    title,
    [{ key: 'main', title: 'Schedule' }],
    () => formHtml,
    async () => {
      const tbody = document.querySelector('#adv_schedule_table tbody');
      if (!tbody) return false;

      const rows = Array.from(tbody.querySelectorAll('tr[data-i]') || []);
      const schedule_json = [];

      for (const tr of rows) {
        const ws = (tr.querySelector('input[name="week_start"]')?.value || '').trim();
        const amt = Number(tr.querySelector('input[name="amount"]')?.value || 0);
        if (!ws) {
          alert('Each row must have a week start date.');
          return { ok:false };
        }
        if (!amt && amt !== 0) {
          alert('Each row must have an amount (0 allowed).');
          return { ok:false };
        }
        schedule_json.push({ week_start: ws, amount: amt });
      }

      const payload = { schedule_json };

      const url = API(`/api/advances/${encodeURIComponent(advId)}`);
      const res = await authFetch(url, {
        method: 'PATCH',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify(payload)
      });
      if (!res.ok) {
        const msg = await res.text().catch(() => 'Failed to update advance schedule');
        alert(msg || 'Failed to update advance schedule');
        return { ok:false };
      }

      try {
        const candId = advance.candidate_id || window.modalCtx?.data?.id;
        if (candId) await fetchCandidateAdvances(candId);
      } catch (e) {
        console.warn('[ADVANCES] refresh after edit schedule failed', e);
      }

      return { ok:true };
    },
    false,
    () => {
      // onReturn: wire add/delete buttons
      try {
        const tbody = document.querySelector('#adv_schedule_table tbody');
        const addBtn = document.querySelector('[data-act="adv-row-add"]');
        if (addBtn && tbody) {
          addBtn.addEventListener('click', () => {
            const idx = tbody.querySelectorAll('tr[data-i]').length;
            const tr = document.createElement('tr');
            tr.setAttribute('data-i', String(idx));
            tr.innerHTML = `
              <td><input type="date" class="input" name="week_start"></td>
              <td><input type="number" step="0.01" class="input" name="amount"></td>
              <td><button type="button" class="btn mini" data-act="adv-row-del">&times;</button></td>
            `;
            tbody.appendChild(tr);
          });
        }
        if (tbody && !tbody.__wiredDel) {
          tbody.__wiredDel = true;
          tbody.addEventListener('click', (e) => {
            const btn = e.target.closest('button[data-act="adv-row-del"]');
            if (!btn) return;
            const tr = btn.closest('tr');
            if (tr) tr.remove();
          });
        }
      } catch (e) {
        console.warn('[ADVANCES] openEditAdvanceScheduleModal wiring failed', e);
      }
    },
    { kind: 'candidate-advance-schedule' }
  );
}
async function toggleAdvancePause(advance) {
  if (!advance || !advance.id) {
    alert('Advance record missing id.');
    return;
  }

  const id = advance.id;
  const candId = advance.candidate_id || window.modalCtx?.data?.id || null;
  const isActive = String(advance.status || '').toUpperCase() === 'ACTIVE';
  const path = isActive ? `/api/advances/${encodeURIComponent(id)}/pause`
                        : `/api/advances/${encodeURIComponent(id)}/resume`;

  if (isActive) {
    const ok = window.confirm('Pause repayments for this advance?');
    if (!ok) return;
  } else {
    const ok = window.confirm('Resume repayments for this advance?');
    if (!ok) return;
  }

  try {
    const res = await authFetch(API(path), { method: 'POST' });
    if (!res.ok) {
      const msg = await res.text().catch(() => 'Failed to update advance status');
      alert(msg || 'Failed to update advance status');
      return;
    }
    if (candId) {
      await fetchCandidateAdvances(candId);
    }
  } catch (e) {
    console.warn('[ADVANCES] toggleAdvancePause failed', e);
    alert(e?.message || 'Failed to update advance status');
  }
}

async function openCandidate(row) {
  // ===== Logging helpers (toggle with window.__LOG_MODAL = true/false) =====
  const LOG = (typeof window.__LOG_MODAL === 'boolean') ? window.__LOG_MODAL : false;
  const L  = (...a)=> { if (LOG) console.log('[OPEN_CANDIDATE]', ...a); };
  const W  = (...a)=> { if (LOG) console.warn('[OPEN_CANDIDATE]', ...a); };
  const E  = (...a)=> { if (LOG) console.error('[OPEN_CANDIDATE]', ...a); };

  const deep = (o)=> JSON.parse(JSON.stringify(o || {}));
  const incoming = deep(row || {});
  const seedId   = incoming?.id || null;

  L('ENTRY', { incomingKeys: Object.keys(incoming||{}), seedId });

  // helper to unwrap a single record from many common backend shapes
  const unwrapSingle = (data, key) => {
    if (Array.isArray(data)) return data[0] || null;
    if (data && key && data[key]) return unwrapSingle(data[key], null);
    if (data && Array.isArray(data.rows))  return data.rows[0]  || null;
    if (data && Array.isArray(data.items)) return data.items[0] || null;
    if (data && Array.isArray(data.data))  return data.data[0]  || null;
    return (data && typeof data === 'object') ? data : null;
  };

  // 1) Hydrate full record if we have an id
  let full = incoming;
  if (seedId) {
    try {
      const url = API(`/api/candidates/${encodeURIComponent(seedId)}`);
      L('[HTTP] GET', url);
      const res = await authFetch(url);
      L('[HTTP] status', res?.status, res?.ok);

      try {
        const raw = await res.clone().text();
        if (LOG) console.debug('[HTTP] raw body (â‰¤2KB):', raw.slice(0, 2048));
      } catch (peekErr) {
        W('[HTTP] raw peek failed', peekErr?.message || peekErr);
      }

      if (res.ok) {
        const data       = await res.json().catch((jErr)=>{ W('res.json() failed, using {}', jErr); return {}; });
        const candidate  = data.candidate || unwrapSingle(data, 'candidate');
        const job_titles = Array.isArray(data.job_titles) ? data.job_titles : [];
        const hr_aliases = Array.isArray(data.hr_aliases) ? data.hr_aliases : [];
        L('hydrated JSON keys', Object.keys(data||{}), 'candidate keys', Object.keys(candidate||{}));

        // Store hr_aliases on the hydrated object under a private key,
        // so we can seed modalCtx later without changing the DB schema.
        full = candidate
          ? { ...candidate, job_titles, __hr_aliases: hr_aliases }
          : incoming;
      } else {
        W('non-OK response, using incoming row');
      }

    } catch (e) {
      W('hydrate failed; using summary row', e);
    }
  } else {
    L('no seedId â€” create mode');
  }

  // Helper: build candidateMainModel used by bindCandidateMainFormEvents
  const buildCandidateMainModel = (srcRaw) => {
    const src = srcRaw || {};
    const toStr = (v) => (v == null ? '' : String(v));

    // Normalise job_titles into { job_title_id, is_primary } objects
    let jt = [];
    if (Array.isArray(src.job_titles)) {
      jt = src.job_titles
        .map(t => {
          if (!t) return null;
          const id =
            t.job_title_id ??
            t.id ??
            t.default_job_title_id ??
            null;
          if (!id) return null;
          return {
            job_title_id: id,
            is_primary: !!t.is_primary
          };
        })
        .filter(Boolean);
    }

    // Normalise NHSP/HR aliases into an array of strings
    let aliases = [];
    if (Array.isArray(src.nhsp_hr_name_aliases)) {
      aliases = src.nhsp_hr_name_aliases.filter(Boolean).map(toStr);
    } else if (src.nhsp_hr_name_aliases) {
      aliases = [toStr(src.nhsp_hr_name_aliases)];
    }

    return {
      // Core identity / contact
      first_name:       toStr(src.first_name),
      last_name:        toStr(src.last_name),
      email:            toStr(src.email),
      phone:            toStr(src.phone),
      display_name:     toStr(src.display_name),

      // Pay / rota fields
      pay_method:       src.pay_method || null,
      key_norm:         toStr(src.key_norm),

      // Aliases for NHSP / HealthRoster
      nhsp_hr_name_aliases: aliases,

      // CCR and NI / DOB / gender
      tms_ref:          src.tms_ref ?? null,
      ni_number:        toStr(src.ni_number),
      date_of_birth:    src.date_of_birth || null, // stored as ISO; binder will format
      gender:           toStr(src.gender),

      // Professional registration
      prof_reg_type:    src.prof_reg_type || null,
      prof_reg_number:  toStr(src.prof_reg_number),

      // Address
      address_line1:    toStr(src.address_line1),
      address_line2:    toStr(src.address_line2),
      address_line3:    toStr(src.address_line3),
      town_city:        toStr(src.town_city),
      county:           toStr(src.county),
      postcode:         toStr(src.postcode),
      country:          toStr(src.country),

      // Notes
      notes:            toStr(src.notes),

      // Job titles (normalised, primary will be enforced by binder)
      job_titles:       jt
    };
  };

  // 2) Build modal context from hydrated data
  const fullKeys    = Object.keys(full || {});
  const dbPayMethod = full && full.pay_method ? String(full.pay_method).toUpperCase() : null;

  L('seeding window.modalCtx', {
    entity: 'candidates',
    fullId: full?.id,
    fullKeys,
    dbPayMethod
  });

  // Normalise hr_name_mappings aliases into modalCtx.hrAliasState
  const hrAliasesExisting = Array.isArray(full.__hr_aliases)
    ? full.__hr_aliases
    : [];
  const selectedAliasId = hrAliasesExisting.length
    ? (hrAliasesExisting[0].id ?? null)
    : null;

  window.modalCtx = {
    entity: 'candidates',
    data:   deep(full),
    formState: { __forId: full?.id || null, main: {}, pay: {} },
    rolesState: Array.isArray(full?.roles) ? normaliseRolesForSave(full.roles) : [],
    overrides: { existing: [], stagedNew: [], stagedEdits: {}, stagedDeletes: new Set() },
    clientSettingsState: null,
    openToken: ((full?.id) || 'new') + ':' + Date.now(),
    // ðŸ”¹ Freeze the DB pay method for the lifetime of this modal
    dbPayMethod,
    // ðŸ”¹ Main candidate model used by bindCandidateMainFormEvents (create + edit)
    candidateMainModel: buildCandidateMainModel(full),
    // ðŸ”¹ HR name mappings (NHSP / HealthRoster) for this candidate
    hrAliasState: {
      existing: hrAliasesExisting,   // [{ id, hr_name_norm, hospital_or_trust, ... }, ...]
      stagedDeletes: [],             // alias IDs staged for delete
      selectedId: selectedAliasId    // currently selected alias in the dropdown
    }
  };

  L('window.modalCtx seeded', {
    entity: window.modalCtx.entity,
    dataId: window.modalCtx.data?.id,
    dataKeys: Object.keys(window.modalCtx.data||{}),
    formStateForId: window.modalCtx.formState?.__forId,
    openToken: window.modalCtx.openToken,
    dbPayMethod: window.modalCtx.dbPayMethod,
    candidateMainModelKeys: Object.keys(window.modalCtx.candidateMainModel || {})
  });

  // 3) Render modal
  L('calling showModal with hasId=', !!full?.id, 'rawHasIdArg=', full?.id);
  showModal(
    'Candidate',
    [
      { key:'main',     label:'Main Details' },
      { key:'rates',    label:'Care Packages' },
      { key:'pay',      label:'Payment details' },
      { key:'bookings', label:'Bookings' }
    ],
    (k, r) => {
      L('[renderCandidateTab] tab=', k, 'rowKeys=', Object.keys(r||{}), 'sample=', { first: r?.first_name, last: r?.last_name, id: r?.id });
      return renderCandidateTab(k, r);
    },
    async () => {
      L('[onSave] begin', { dataId: window.modalCtx?.data?.id, forId: window.modalCtx?.formState?.__forId });
      const isNew = !window.modalCtx?.data?.id;

      const fs   = window.modalCtx.formState || { __forId: null, main:{}, pay:{} };
      const hasId = !!window.modalCtx.data?.id;
      const same = hasId
        ? (fs.__forId === window.modalCtx.data.id)
        : (fs.__forId === window.modalCtx.openToken || fs.__forId == null);

      const stateMain = same ? (fs.main || {}) : {};
      const statePay  = same ? (fs.pay  || {}) : {};
      const main      = document.querySelector('#tab-main') ? collectForm('#tab-main') : {};
      const pay       = document.querySelector('#tab-pay')  ? collectForm('#tab-pay')  : {};
      const roles     = normaliseRolesForSave(window.modalCtx.rolesState || window.modalCtx.data?.roles || []);

      let payload   = { ...stateMain, ...statePay, ...main, ...pay, roles };

      // Strip internal-only fields before logging / sending to backend
      for (const k of Object.keys(payload)) {
        // Anything starting with "__" is a front-end staging key (e.g. __forMethod)
        if (k.startsWith('__')) {
          delete payload[k];
        }
      }

      L('[onSave] collected', {
        same,
        stateMainKeys: Object.keys(stateMain||{}),
        statePayKeys:  Object.keys(statePay||{}),
        mainKeys:      Object.keys(main||{}),
        payKeys:       Object.keys(pay||{}),
        rolesCount:    roles?.length || 0,
        bankSnapshot: {
          fromStatePay: {
            account_holder: statePay.account_holder ?? null,
            bank_name:      statePay.bank_name      ?? null,
            sort_code:      statePay.sort_code      ?? null,
            account_number: statePay.account_number ?? null
          },
          fromDomPay: {
            account_holder: pay.account_holder ?? null,
            bank_name:      pay.bank_name      ?? null,
            sort_code:      pay.sort_code      ?? null,
            account_number: pay.account_number ?? null
          }
        }
      });

      delete payload.umbrella_name;
      delete payload.tms_ref;

      if (!payload.first_name && full?.first_name) payload.first_name = full.first_name;
      if (!payload.last_name  && full?.last_name)  payload.last_name  = full.last_name;
      if (typeof payload.key_norm === 'undefined' && typeof full?.key_norm !== 'undefined') payload.key_norm = full.key_norm;

      // Run main tab validation (first/last, phone, email, NI, gender, address)
      const mainValid = validateCandidateMain(payload);
      if (!mainValid) {
        // Do not allow save; user can correct highlighted fields
        return { ok:false };
      }

      if (!payload.display_name) {
        const dn = [payload.first_name, payload.last_name].filter(Boolean).join(' ').trim();
        payload.display_name = dn || full?.display_name || null;
      }

      // Normalise pay_method, allow "Unknown" to mean "no pay method yet" (saved as null)
      let pm = (payload.pay_method || '').trim();
      if (!pm && full?.pay_method) pm = String(full.pay_method || '');
      pm = pm ? pm.toUpperCase() : '';

      if (pm === 'UNKNOWN' || pm === '') {
        payload.pay_method = null;
      } else if (pm === 'PAYE' || pm === 'UMBRELLA') {
        payload.pay_method = pm;
      } else {
        payload.pay_method = null;
      }

      if (payload.pay_method === 'UMBRELLA') {
        if ((!payload.umbrella_id || payload.umbrella_id === '') && full?.umbrella_id) {
          payload.umbrella_id = full.umbrella_id;
        }
        if (!payload.account_holder) {
          const umbNameEl = document.querySelector('#tab-pay #umbrella_name');
          if (umbNameEl && umbNameEl.value) payload.account_holder = umbNameEl.value;
        }
      }

      // PAYE â†’ clear umbrella; UMBRELLA â†’ must have umbrella_id
      if (payload.pay_method === 'PAYE') {
        payload.umbrella_id = null;
      } else if (payload.pay_method === 'UMBRELLA') {
        if (!payload.umbrella_id || payload.umbrella_id === '') {
          alert('Select an umbrella company for UMBRELLA pay.');
          return { ok:false };
        }
      }
      if (payload.umbrella_id === '') payload.umbrella_id = null;

      const originalMethod = (full && full.pay_method) ? String(full.pay_method).toUpperCase() : null;
      const newMethod      = payload.pay_method ? String(payload.pay_method).toUpperCase() : null;
      const hasExistingId  = !!full?.id;

      const isFlip = !!(
        hasExistingId &&
        originalMethod &&
        newMethod &&
        (originalMethod === 'PAYE' || originalMethod === 'UMBRELLA') &&
        (newMethod     === 'PAYE' || newMethod     === 'UMBRELLA') &&
        originalMethod !== newMethod
      );

      // Helper to force-clear candidate bank fields in a payload
      const clearBankOnPayload = (obj) => {
        obj.account_holder = null;
        obj.bank_name      = null;
        obj.sort_code      = null;
        obj.account_number = null;
      };

      // Helper: apply staged HR alias deletions for this candidate
         // Helper: apply staged HR alias deletions for this candidate
      const applyAliasDeletes = async (candId) => {
        try {
          const aliasState = window.modalCtx?.hrAliasState || null;
          const stagedRaw = (aliasState && Array.isArray(aliasState.stagedDeletes))
            ? aliasState.stagedDeletes
            : [];

          // Normalise to a clean list of mapping_ids (strings)
          const mappingIds = stagedRaw
            .map((id) => (id == null ? '' : String(id).trim()))
            .filter(Boolean);

          if (!candId || !mappingIds.length) return { ok: true };

          L('[onSave] deleting staged HR aliases', {
            candidateId: candId,
            stagedCount: mappingIds.length
          });

          const urlAliasDel = API(
            `/api/candidates/${encodeURIComponent(candId)}/aliases`
          );

          L('[onSave][DELETE hr_aliases batch]', {
            url: urlAliasDel,
            mapping_ids: mappingIds
          });

          const resAlias = await authFetch(urlAliasDel, {
            method: 'DELETE',
            headers: { 'content-type': 'application/json' },
            body: JSON.stringify({ mapping_ids: mappingIds })
          });

          if (!resAlias.ok) {
            const msg = await resAlias.text().catch(() => 'Failed to delete alias mappings');
            alert(msg);
            return { ok:false };
          }

          // Update local aliasState to reflect deletions
          if (aliasState) {
            const stagedSet = new Set(mappingIds.map(String));
            const remaining = Array.isArray(aliasState.existing)
              ? aliasState.existing.filter(a => a && !stagedSet.has(String(a.id)))
              : [];

            aliasState.existing      = remaining;
            aliasState.stagedDeletes = [];
            aliasState.selectedId    = remaining.length ? (remaining[0].id ?? null) : null;
          }

          return { ok:true };
        } catch (e) {
          W('applyAliasDeletes failed (non-fatal)', e);
          // Non-fatal: aliases are â€œnice to haveâ€; donâ€™t hard-block the candidate save
          return { ok:true };
        }
      };


      if (isFlip) {
        L('[onSave] detected PAYEâ†”UMBRELLA flip', {
          originalMethod,
          newMethod,
          candidateId: full.id,
          stagedPayAtFlip: {
            ...(window.modalCtx?.formState?.pay || {})
          }
        });

        const idForUpdate = window.modalCtx?.data?.id || full?.id || null;

        // â”€â”€ PAYE â†’ UMBRELLA special handling â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if (originalMethod === 'PAYE' && newMethod === 'UMBRELLA') {
          const effectiveUmbrellaId = payload.umbrella_id || full.umbrella_id || null;

          if (!effectiveUmbrellaId) {
            alert('Before switching to UMBRELLA, select an umbrella company on the Payment details tab and save again.');
            return { ok:false };
          }

          // Normalise DOB so blank "" becomes null before any pre-save
          if (Object.prototype.hasOwnProperty.call(payload, 'date_of_birth') &&
              !payload.date_of_birth) {
            payload.date_of_birth = null;
          }

          // Pre-save umbrella details (but keep pay_method as originalMethod) so the backend
          // bulk change endpoint passes its umbrella_id check.
          if (!full.umbrella_id && effectiveUmbrellaId && idForUpdate) {
            const prePayload = { ...payload };
            prePayload.pay_method = originalMethod;

            // Strip any remaining empty-string fields so we don't send "" to typed columns
            for (const k of Object.keys(prePayload)) {
              if (prePayload[k] === '') delete prePayload[k];
            }

            L('[onSave][FLIP Pâ†’U] pre-saving umbrella details', {
              candidateId: idForUpdate,
              prePayloadBank: {
                account_holder: prePayload.account_holder ?? null,
                bank_name:      prePayload.bank_name      ?? null,
                sort_code:      prePayload.sort_code      ?? null,
                account_number: prePayload.account_number ?? null,
                umbrella_id:    prePayload.umbrella_id    ?? null
              }
            });

            const preSaved = await upsertCandidate(prePayload, idForUpdate).catch(err => {
              E('pre upsertCandidate (umbrella before flip) failed', err);
              return null;
            });

            if (!preSaved || !preSaved.id) {
              alert('Failed to save umbrella details before pay-method change. Please try again.');
              return { ok:false };
            }

            full = { ...full, ...preSaved };
            try {
              window.modalCtx.data = { ...(window.modalCtx.data || {}), ...preSaved };
            } catch (err) {
              W('failed to sync modalCtx.data after pre-saving umbrella', err);
            }
          }

          // Leave the dropdown showing the new method (UMBRELLA) while the flip runs
          try {
            const confirmed = await openCandidatePayMethodChangeModal(full, {
              originalMethod,
              newMethod,
              candidate_id: full.id
            });

            if (!confirmed) {
              L('[onSave] pay-method change cancelled or failed, keeping candidate modal open');
              return { ok:false };
            }

            window.modalCtx.__payFlipDone = true;

            // After backend change, persist the final UMBRELLA state on candidate:
            const postFlipUmbPayload = {
              ...payload,
              pay_method: 'UMBRELLA',
              umbrella_id: effectiveUmbrellaId
            };
            clearBankOnPayload(postFlipUmbPayload);

            for (const k of Object.keys(postFlipUmbPayload)) {
              if (postFlipUmbPayload[k] === '') delete postFlipUmbPayload[k];
            }

            L('[onSave][FLIP Pâ†’U] postFlipUmbPayload', {
              candidateId: idForUpdate,
              pay_method: postFlipUmbPayload.pay_method,
              umbrella_id: postFlipUmbPayload.umbrella_id,
              bank: {
                account_holder: postFlipUmbPayload.account_holder ?? null,
                bank_name:      postFlipUmbPayload.bank_name      ?? null,
                sort_code:      postFlipUmbPayload.sort_code      ?? null,
                account_number: postFlipUmbPayload.account_number ?? null
              }
            });

            const savedUmb = await upsertCandidate(postFlipUmbPayload, idForUpdate).catch(err => {
              E('upsertCandidate after PAYEâ†’UMBRELLA flip failed', err);
              return null;
            });
            if (!savedUmb || !savedUmb.id) {
              alert('Pay-method changed, but failed to finalise UMBRELLA details. Please check and try again.');
              return { ok:false };
            }

            full = { ...full, ...savedUmb };
            try {
              window.modalCtx.data = { ...(window.modalCtx.data || {}), ...savedUmb };
              window.modalCtx.dbPayMethod = 'UMBRELLA';
            } catch (e) {
              W('failed to sync modalCtx.data/dbPayMethod after PAYEâ†’UMBRELLA flip', e);
            }

            L('[onSave] PAYEâ†’UMBRELLA change confirmed; closing candidate modal', {
              finalBank: {
                account_holder: window.modalCtx.data?.account_holder ?? null,
                bank_name:      window.modalCtx.data?.bank_name      ?? null,
                sort_code:      window.modalCtx.data?.sort_code      ?? null,
                account_number: window.modalCtx.data?.account_number ?? null
              }
            });

            const aliasResultFlipPU = await applyAliasDeletes(full.id || window.modalCtx.data?.id);
            if (!aliasResultFlipPU.ok) {
              return { ok:false };
            }

            return { ok:true, saved: window.modalCtx.data };

          } catch (err) {
            W('pay-method change flow (PAYEâ†’UMBRELLA) failed', err);
            alert(err?.message || 'Failed to process pay-method change.');
            return { ok:false };
          }
        }

        // â”€â”€ UMBRELLA â†’ PAYE special handling â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if (originalMethod === 'UMBRELLA' && newMethod === 'PAYE') {
          // Ensure dropdown shows the old method during the child modal
          try {
            const pmSel = document.querySelector('select[name="pay_method"]');
            if (pmSel && originalMethod) {
              pmSel.value = originalMethod;
            }
          } catch (err) {
            W('failed to reset pay_method select to originalMethod', err);
          }

          L('[onSave][FLIP Uâ†’P] starting UMBRELLAâ†’PAYE flow', {
            candidateId: full.id,
            originalMethod,
            newMethod,
            stagedPayBeforeModal: { ...(window.modalCtx?.formState?.pay || {}) }
          });

          try {
            const confirmed = await openCandidatePayMethodChangeModal(full, {
              originalMethod,
              newMethod,
              candidate_id: full.id
            });

            if (!confirmed) {
              L('[onSave] pay-method change cancelled or failed (UMBRELLAâ†’PAYE), keeping candidate modal open');
              return { ok:false };
            }

            window.modalCtx.__payFlipDone = true;

            // After backend change, we must now persist the *new PAYE bank details*.
            const idForUpdate2 = window.modalCtx?.data?.id || full?.id || null;

            // Re-read the staged Pay state in case anything changed between the first onSave and now.
            const fsAfter = window.modalCtx?.formState || {};
            const stagedPayAfter = fsAfter.pay || {};

            const postFlipPayePayload = {
              ...payload
            };

            // Prefer the freshest staged pay values for the PAYE bank fields
            if (Object.prototype.hasOwnProperty.call(stagedPayAfter, 'account_holder')) {
              postFlipPayePayload.account_holder = stagedPayAfter.account_holder;
            }
            if (Object.prototype.hasOwnProperty.call(stagedPayAfter, 'bank_name')) {
              postFlipPayePayload.bank_name = stagedPayAfter.bank_name;
            }
            if (Object.prototype.hasOwnProperty.call(stagedPayAfter, 'sort_code')) {
              postFlipPayePayload.sort_code = stagedPayAfter.sort_code;
            }
            if (Object.prototype.hasOwnProperty.call(stagedPayAfter, 'account_number')) {
              postFlipPayePayload.account_number = stagedPayAfter.account_number;
            }

            if (!postFlipPayePayload.umbrella_id) {
              postFlipPayePayload.umbrella_id = null;
            }
            postFlipPayePayload.pay_method = 'PAYE';

            for (const k of Object.keys(postFlipPayePayload)) {
              if (postFlipPayePayload[k] === '') delete postFlipPayePayload[k];
            }

            L('[onSave][FLIP Uâ†’P] postFlipPayePayload', {
              candidateId: idForUpdate2,
              bankFromStaged: {
                account_holder: stagedPayAfter.account_holder ?? null,
                bank_name:      stagedPayAfter.bank_name      ?? null,
                sort_code:      stagedPayAfter.sort_code      ?? null,
                account_number: stagedPayAfter.account_number ?? null
              },
              bankPersistedPayload: {
                account_holder: postFlipPayePayload.account_holder ?? null,
                bank_name:      postFlipPayePayload.bank_name      ?? null,
                sort_code:      postFlipPayePayload.sort_code      ?? null,
                account_number: postFlipPayePayload.account_number ?? null
              }
            });

            const savedPaye = await upsertCandidate(postFlipPayePayload, idForUpdate2).catch(err => {
              E('upsertCandidate after UMBRELLAâ†’PAYE flip failed', err);
              return null;
            });
            if (!savedPaye || !savedPaye.id) {
              alert('Pay-method changed, but failed to save new PAYE bank details. Please check and try again.');
              return { ok:false };
            }

            full = { ...full, ...savedPaye };
            try {
              window.modalCtx.data = { ...(window.modalCtx.data || {}), ...savedPaye };
              window.modalCtx.dbPayMethod = 'PAYE';
            } catch (e) {
              W('failed to sync modalCtx.data/dbPayMethod after UMBRELLAâ†’PAYE flip', e);
            }

            L('[onSave] UMBRELLAâ†’PAYE change confirmed; closing candidate modal', {
              finalBank: {
                account_holder: window.modalCtx.data?.account_holder ?? null,
                bank_name:      window.modalCtx.data?.bank_name      ?? null,
                sort_code:      window.modalCtx.data?.sort_code      ?? null,
                account_number: window.modalCtx.data?.account_number ?? null
              }
            });

            const aliasResultFlipUP = await applyAliasDeletes(full.id || window.modalCtx.data?.id);
            if (!aliasResultFlipUP.ok) {
              return { ok:false };
            }

            return { ok:true, saved: window.modalCtx.data };

          } catch (err) {
            W('pay-method change flow (UMBRELLAâ†’PAYE) failed', err);
            alert(err?.message || 'Failed to process pay-method change.');
            return { ok:false };
          }
        }

        // Fallback (should not usually hit here, but guard anyway)
        W('[onSave] flip detected with unsupported direction', { originalMethod, newMethod });
      }

      // â”€â”€ Normal save path (no PAYEâ†”UMBRELLA flip) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      // If we are saving as UMBRELLA in a non-flip scenario, always clear bank
      // details on the candidate record to avoid confusion with old PAYE data.
      if (payload.pay_method === 'UMBRELLA') {
        clearBankOnPayload(payload);
      }

   // âœ… Allow clearing key_norm + normalise it
if (Object.prototype.hasOwnProperty.call(payload, 'key_norm')) {
  const v = String(payload.key_norm ?? '').trim();
  payload.key_norm = v ? v.toLowerCase() : null; // null clears it in DB
}

// âœ… Remove empty strings before sending
// - keep key_norm as-is (including null when user cleared it)
// - do NOT allow first/last/display_name to be cleared (convert "" â†’ keep existing / drop from payload)
for (const k of Object.keys(payload)) {
  if (k === 'key_norm') continue;

  // Prevent clearing required identity fields
  if (k === 'first_name' || k === 'last_name' || k === 'display_name') {
    if (payload[k] === '' || payload[k] == null) {
      delete payload[k]; // keep existing DB value
    }
    continue;
  }

  if (payload[k] === '') delete payload[k];
}



      // Sync Job Titles + Registration + DOB from candidateMainModel (unchanged)
      try {
        const cm = window.modalCtx?.candidateMainModel;
        if (cm && typeof cm === 'object') {
          let jobs = Array.isArray(cm.job_titles) ? cm.job_titles.slice() : [];
          jobs = jobs.filter(j => j && j.job_title_id);
          if (jobs.length) {
            let primaryIdx = jobs.findIndex(j => j.is_primary);
            if (primaryIdx === -1) primaryIdx = 0;
            jobs = jobs.map((j, idx) => ({
              ...j,
              is_primary: idx === primaryIdx
            }));
            if (primaryIdx !== 0) {
              const primary = jobs[primaryIdx];
              jobs.splice(primaryIdx, 1);
              jobs.unshift(primary);
            }
          }

          cm.job_titles = jobs;

          const jobIds = jobs.map(j => j.job_title_id).filter(Boolean);
          payload.job_titles   = jobIds;
          payload.job_title_id = jobIds.length ? jobIds[0] : null;

          if (Object.prototype.hasOwnProperty.call(cm, 'prof_reg_type')) {
            payload.prof_reg_type = cm.prof_reg_type || null;
          }
          if (Object.prototype.hasOwnProperty.call(cm, 'prof_reg_number')) {
            payload.prof_reg_number = cm.prof_reg_number || '';
          }
          if (Object.prototype.hasOwnProperty.call(cm, 'date_of_birth')) {
            payload.date_of_birth = cm.date_of_birth || null;
          }
        }
      } catch (err) {
        W('sync from candidateMainModel failed', err);
      }

      const idForUpdate = window.modalCtx?.data?.id || full?.id || null;
      const tokenAtSave = window.modalCtx.openToken;
      L('[onSave] upsertCandidate', {
        idForUpdate,
        payloadKeys: Object.keys(payload||{}),
        bankPayload: {
          account_holder: payload.account_holder ?? null,
          bank_name:      payload.bank_name      ?? null,
          sort_code:      payload.sort_code      ?? null,
          account_number: payload.account_number ?? null,
          pay_method:     payload.pay_method     ?? null,
          umbrella_id:    payload.umbrella_id    ?? null
        }
      });
      const saved = await upsertCandidate(payload, idForUpdate).catch(err => { E('upsertCandidate failed', err); return null; });
      const candidateId = idForUpdate || (saved && saved.id);
      L('[onSave] saved', {
        ok: !!saved,
        candidateId,
        savedKeys: Array.isArray(saved)?[]:Object.keys(saved||{}),
        savedBank: saved ? {
          account_holder: saved.account_holder ?? null,
          bank_name:      saved.bank_name      ?? null,
          sort_code:      saved.sort_code      ?? null,
          account_number: saved.account_number ?? null,
          pay_method:     saved.pay_method     ?? null,
          umbrella_id:    saved.umbrella_id    ?? null
        } : null
      });
      if (!candidateId) { alert('Failed to save candidate'); return { ok:false }; }

      // ===== validate & persist overrides (unchanged from your version) =====
      const O = window.modalCtx.overrides || { existing: [], stagedNew: [], stagedEdits: {}, stagedDeletes: new Set() };

      async function getCoveringDefault(client_id, role, band, date_from) {
        try {
          if (!client_id || !role || !date_from) return null;
          const list = await listClientRates(client_id, { active_on: date_from, only_enabled: true });
          const rows = Array.isArray(list) ? list.filter(w => !w.disabled_at_utc && String(w.role) === String(role)) : [];
          let win = rows.find(w => (w.band ?? null) === (band ?? null));
          if (!win && (band == null)) win = rows.find(w => w.band == null);
          return win || null;
        } catch { return null; }
      }
         const bucketLabel = { day:'Day', night:'Night', sat:'Sat', sun:'Sun', bh:'BH' };
      const erniMult = await (async ()=>{
        if (typeof window.__ERNI_MULT__ === 'number') return window.__ERNI_MULT__;
        try {
          if (typeof getSettingsCached === 'function') {
            const s = await getSettingsCached();

            // New shape: { settings: {...}, finance_windows: [...] }
            const fws = Array.isArray(s?.finance_windows) ? s.finance_windows : [];

            // Pick "current" finance window in scope for today (YYYY-MM-DD).
            let todayYmd = null;
            try { todayYmd = (typeof toLocalParts === 'function') ? (toLocalParts(new Date().toISOString(), null)?.ymd || null) : null; } catch {}
            if (!todayYmd) todayYmd = new Date().toISOString().slice(0, 10);

            const asYmd = (v) => {
              if (!v) return null;
              const ss = String(v).slice(0, 10);
              return /^\d{4}-\d{2}-\d{2}$/.test(ss) ? ss : null;
            };

            let chosen = null;
            for (const w of fws) {
              const df = asYmd(w?.date_from);
              const dt = asYmd(w?.date_to);
              if (!df) continue;
              if (df > todayYmd) continue;
              if (dt && dt < todayYmd) continue;
              if (!chosen) {
                chosen = w;
              } else {
                const cdf = asYmd(chosen?.date_from);
                if (cdf && df > cdf) chosen = w;
              }
            }

            // ERNI from chosen window; fall back to 0 if missing
            let p = chosen?.erni_pct ?? 0;

            p = Number(p)||0;
            if (p>1) p=p/100;
            window.__ERNI_MULT__ = 1 + p;
            return window.__ERNI_MULT__;
          }
        } catch{}
        window.__ERNI_MULT__ = 1;
        return 1;
      })();


      // Validate EDITS
      for (const [editId, patchRaw] of Object.entries(O.stagedEdits || {})) {
        const original = (O.existing || []).find(x => String(x.id) === String(editId));
        if (!original) { alert('Cannot locate original override to validate'); return { ok:false }; }

        const eff = {
          client_id: patchRaw.client_id ?? original.client_id,
          role     : patchRaw.role      ?? original.role,
          band     : (patchRaw.hasOwnProperty('band') ? patchRaw.band : original.band),
          date_from: patchRaw.date_from ?? original.date_from,
          date_to  : patchRaw.hasOwnProperty('date_to') ? patchRaw.date_to : original.date_to,
          rate_type: (patchRaw.rate_type ?? original.rate_type ?? '').toUpperCase(),

          pay_day  : patchRaw.hasOwnProperty('pay_day')   ? patchRaw.pay_day   : original.pay_day,
          pay_night: patchRaw.hasOwnProperty('pay_night') ? patchRaw.pay_night : original.pay_night,
          pay_sat  : patchRaw.hasOwnProperty('pay_sat')   ? patchRaw.pay_sat   : original.pay_sat,
          pay_sun  : patchRaw.hasOwnProperty('pay_sun')   ? patchRaw.pay_sun   : original.pay_sun,
          pay_bh   : patchRaw.hasOwnProperty('pay_bh')    ? patchRaw.pay_bh    : original.pay_bh
        };

        const win = await getCoveringDefault(eff.client_id, eff.role, eff.band, eff.date_from);
        if (!win) { alert(`No active client default covers ${eff.role}${eff.band?` / ${eff.band}`:''} on ${formatIsoToUk(eff.date_from)}.`); return { ok:false }; }
        if (eff.date_to && win.date_to && eff.date_to > win.date_to) { alert(`Client rate ends on ${formatIsoToUk(win.date_to)} â€” override must end on or before this date.`); return { ok:false }; }

        for (const b of ['day','night','sat','sun','bh']) {
          const payB = eff[`pay_${b}`];
          const chg  = win[`charge_${b}`];
          if (payB != null && chg == null) { alert(`No client charge for ${bucketLabel[b]} on ${formatIsoToUk(eff.date_from)}.`); return { ok:false }; }
          if (payB != null && chg != null) {
            const margin = (eff.rate_type==='PAYE') ? (chg - (payB * erniMult)) : (chg - payB);
            if (margin < 0) { alert(`Margin would be negative for ${bucketLabel[b]}.`); return { ok:false }; }
          }
        }
      }

      // Validate NEW rows
      for (const nv of (O.stagedNew || [])) {
        const win = await getCoveringDefault(nv.client_id, nv.role, nv.band ?? null, nv.date_from);
        if (!win) { alert(`No active client default covers ${nv.role}${nv.band?` / ${nv.band}`:''} on ${formatIsoToUk(nv.date_from)}.`); return { ok:false }; }
        if (nv.date_to && win.date_to && nv.date_to > win.date_to) { alert(`Client rate ends on ${formatIsoToUk(win.date_to)} â€” override must end on or before this date.`); return { ok:false }; }
        for (const b of ['day','night','sat','sun','bh']) {
          const payB = nv[`pay_${b}`]; const chg = win[`charge_${b}`];
          if (payB != null && chg == null) { alert(`No client charge for ${bucketLabel[b]} on ${formatIsoToUk(win.date_from)}.`); return { ok:false }; }
          if (payB != null && chg != null) {
            const margin = (String(nv.rate_type).toUpperCase()==='PAYE') ? (chg - (payB * erniMult)) : (chg - payB);
            if (margin < 0) { alert(`Margin would be negative for ${bucketLabel[b]}.`); return { ok:false }; }
          }
        }
      }

      // ===== Persist staged overrides (DELETE uses routed path with candidate_id) =====
      const overridesRef = window.modalCtx.overrides || { existing: [], stagedNew: [], stagedEdits: {}, stagedDeletes: new Set() };
      L('[onSave] overrides', {
        deletes: Array.from(overridesRef.stagedDeletes || []),
        edits:   Object.keys(overridesRef.stagedEdits || {}),
        newCount: (overridesRef.stagedNew || []).length
      });

      // Deletes â€” preferred by id; fallback to legacy filter keys
      for (const delId of overridesRef.stagedDeletes || []) {
        const rowDel = (overridesRef.existing || []).find(r => String(r.id) === String(delId));
        if (!rowDel) continue;

        const q = new URLSearchParams();
        if (rowDel.id) q.set('id', String(rowDel.id));
        else {
          if (rowDel.client_id) q.set('client_id', String(rowDel.client_id));
          if (rowDel.role != null) q.set('role', String(rowDel.role));
          q.set('band', (rowDel.band == null || rowDel.band === '') ? '' : String(rowDel.band));
          if (rowDel.rate_type) q.set('rate_type', String(rowDel.rate_type).toUpperCase());
          if (rowDel.date_from) q.set('date_from', String(rowDel.date_from));
        }

        const urlDel = API(`/api/rates/candidate-overrides/${encodeURIComponent(candidateId)}?${q.toString()}`);
        L('[onSave][DELETE override]', urlDel);
        const resDel = await authFetch(urlDel, { method: 'DELETE' });
        if (!resDel.ok) {
          const msg = await resDel.text().catch(()=> 'Delete override failed');
          alert(msg);
          return { ok:false };
        }
      }

      // Edits â€” PATCH candidate_id in path + ORIGINAL keys in query, updates in body
      for (const [editId, patchRaw] of Object.entries(overridesRef.stagedEdits || {})) {
        const original = (overridesRef.existing || []).find(x => String(x.id) === String(editId));
        if (!original) { alert('Cannot locate original override to patch'); return { ok:false }; }

        const q = new URLSearchParams();
        if (original.client_id) q.set('client_id', original.client_id);
        if (original.role != null) q.set('role', String(original.role));
        q.set('band', (original.band == null || original.band === '') ? '' : String(original.band));
        if (original.rate_type) q.set('rate_type', String(original.rate_type).toUpperCase());

        const bodyPatch = {};
        for (const [k,v] of Object.entries(patchRaw || {})) {
          if (v === '' || v === undefined) continue;
          bodyPatch[k] = v;
        }
        bodyPatch.candidate_id = candidateId;

        const urlPatch = API(`/api/rates/candidate-overrides/${encodeURIComponent(candidateId)}?${q.toString()}`);
        L('[onSave][PATCH override]', { url: urlPatch, body: bodyPatch });
        const resPatch = await authFetch(urlPatch, {
          method:'PATCH',
          headers:{ 'content-type':'application/json' },
          body: JSON.stringify(bodyPatch)
        });
        if (!resPatch.ok) {
          const msg = await resPatch.text().catch(()=> 'Update override failed');
          alert(msg);
          return { ok:false };
        }
      }

      // Creates
      for (const nv of (overridesRef.stagedNew || [])) {
        if (!nv.client_id) { alert('Override must include client_id'); return { ok:false }; }
        const clean = {};
        for (const [k,v] of Object.entries(nv)) {
          if (k === '_tmpId' || v === '') continue;
          clean[k] = v;
        }
        const resCreate = await authFetch(
          API(`/api/rates/candidate-overrides`),
          { method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify({ ...clean, candidate_id: candidateId }) }
        );
        if (!resCreate.ok) {
          const msg = await resCreate.text().catch(()=> 'Create override failed');
          alert(msg);
          return { ok:false };
        }
      }

      // Refresh overrides list from server and clear staging
      try {
        const latest = await listCandidateRates(candidateId);
        if (tokenAtSave === window.modalCtx.openToken && window.modalCtx.data?.id === candidateId) {
          window.modalCtx.overrides.existing = Array.isArray(latest) ? latest : [];
          window.modalCtx.overrides.stagedEdits = {};
          window.modalCtx.overrides.stagedNew   = [];
          if (window.modalCtx.overrides.stagedDeletes?.clear) window.modalCtx.overrides.stagedDeletes.clear();
          const fr1 = window.__getModalFrame?.();
          if (fr1 && fr1.entity === 'candidates' && fr1.currentTabKey === 'rates') {
            await renderCandidateRatesTable();
          }
        }
      } catch (e) {
        W('post-save rates refresh failed', e);
      }

      // ===== Persist staged HR name alias deletions ========================
      const aliasResult = await applyAliasDeletes(candidateId);
      if (!aliasResult.ok) {
        return { ok:false };
      }

      const mergedRoles = (saved && saved.roles) || payload.roles || window.modalCtx.data?.roles || [];

      // Build a fresh job_titles array for modalCtx.data, based on the staged model
      let jobTitlesForCtx = [];
      try {
        const cm = window.modalCtx?.candidateMainModel;
        if (cm && Array.isArray(cm.job_titles)) {
          jobTitlesForCtx = cm.job_titles.map((t) => ({
            job_title_id: t.job_title_id,
            is_primary: !!t.is_primary
          }));
        } else if (Array.isArray(payload.job_titles)) {
          jobTitlesForCtx = payload.job_titles.map((id, idx) => ({
            job_title_id: id,
            is_primary: idx === 0
          }));
        }
      } catch (e) {
        W('onSave: building jobTitlesForCtx failed', e);
      }

      window.modalCtx.data = {
        ...(window.modalCtx.data || {}),
        ...(saved || {}),
        id: candidateId,
        roles: mergedRoles,
        job_titles: jobTitlesForCtx
      };
      window.modalCtx.formState  = { __ForId: candidateId, main: {}, pay: {} };
      window.modalCtx.rolesState = mergedRoles;

      // ðŸ”¹ Keep dbPayMethod in sync with the latest persisted value (if any)
      try {
        const persistedPm = window.modalCtx.data?.pay_method || null;
        window.modalCtx.dbPayMethod = persistedPm ? String(persistedPm).toUpperCase() : null;
      } catch {}

      L('[onSave] final window.modalCtx', {
        dataId: window.modalCtx.data?.id,
        rolesCount: Array.isArray(window.modalCtx.data?.roles) ? window.modalCtx.data.roles.length : 0,
        formStateForId: window.modalCtx.formState?.__ForId,
        dbPayMethod: window.modalCtx.dbPayMethod,
        finalBank: {
          account_holder: window.modalCtx.data?.account_holder ?? null,
          bank_name:      window.modalCtx.data?.bank_name      ?? null,
          sort_code:      window.modalCtx.data?.sort_code      ?? null,
          account_number: window.modalCtx.data?.account_number ?? null
        }
      });

      if (isNew) window.__pendingFocus = { section: 'candidates', ids: [candidateId], primaryIds:[candidateId] };

      return { ok: true, saved: window.modalCtx.data };

    },
    full?.id,
   () => {
  const fr = window.__getModalFrame?.();
  const isBookings = fr && fr.entity === 'candidates' && fr.currentTabKey === 'bookings';
  const candId = window.modalCtx?.data?.id;

  if (isBookings && candId) {
    try {
      const holder = document.getElementById('candidateCalendarHolder');
      if (holder && typeof loadCandidateCalendar === 'function') {
        // Repaint using cached data if available (keeps filter state stable)
        loadCandidateCalendar(holder, candId, { _reuseLast: true }).catch(e => {
          W('loadCandidateCalendar(onReturn) failed', e);
        });
      } else {
        // Fallback
        renderCandidateCalendarTab(candId);
      }
    } catch (e) {
      W('calendar onReturn refresh failed', e);
    }
  }
}

  );
  L('showModal returned (sync)', { currentOpenToken: window.modalCtx.openToken });

  // 4) Optional async companion loads (unchanged)
  if (full?.id) {
    const token = window.modalCtx.openToken;
    const id    = full.id;

    try {
      L('[listCandidateRates] GET', { id, token });
      const existing = await listCandidateRates(id);
      L('[listCandidateRates] result', { count: Array.isArray(existing) ? existing.length : -1, sameToken: token === window.modalCtx.openToken, modalCtxId: window.modalCtx.data?.id });
      if (token === window.modalCtx.openToken && window.modalCtx.data?.id === id) {
        window.modalCtx.overrides.existing = Array.isArray(existing) ? existing : [];
        const fr2 = window.__getModalFrame?.();
        if (fr2 && fr2.entity === 'candidates' && fr2.currentTabKey === 'rates') {
          await renderCandidateRatesTable();
        }
      }
    } catch (e) { E('listCandidateRates failed', e); }
  } else {
    L('skip companion loads (no full.id)');
  }
}


// ====================== mountCandidatePayTab (FIXED) ======================
// FRONTEND â€” UPDATED
// mountCandidatePayTab: also keeps Account Holder in sync with umbrella name when UMNRELLA pay.
// ================== FIXED: openUmbrella (hydrate before showModal) ==================

async function renderCandidateRatesTable() {
  const LOG = !!window.__LOG_RATES;

  // Safety net: auto-create #ratesTable if missing
  let div = byId('ratesTable');
  if (!div) {
    const host = byId('modalBody');
    if (host) {
      div = document.createElement('div');
      div.id = 'ratesTable';
      host.appendChild(div);
      if (LOG) console.warn('[RATES][TABLE] created missing #ratesTable');
    } else {
      if (LOG) console.warn('[RATES][TABLE] no #ratesTable and no #modalBody; abort');
      return;
    }
  }

  const frame = _currentFrame();
  const parentEditable = frame && (frame.mode === 'edit' || frame.mode === 'create');
  if (LOG) console.log('[RATES][TABLE] parentEditable?', parentEditable, 'mode:', frame?.mode);

  // Resolve client names
  let clientsById = {};
  try {
    const clients = await listClientsBasic();
    clientsById = Object.fromEntries((clients || []).map(c => [c.id, c.name]));
  } catch (e) { console.error('[RATES][TABLE] load clients failed', e); }

  const O = (window.modalCtx.overrides ||= { existing: [], stagedNew: [], stagedEdits: {}, stagedDeletes: new Set() });

  if (LOG) console.log('[RATES][TABLE snapshot]', {
    existing: (O.existing||[]).length,
    stagedNew: (O.stagedNew||[]).length,
    stagedEdits: Object.keys(O.stagedEdits||{}).length,
    stagedDeletes: (O.stagedDeletes && O.stagedDeletes.size) || 0,
    peekExisting: (O.existing||[])[0],
    peekNew: (O.stagedNew||[])[0]
  });

  // Merge view
  const pendingDeleteIds = (O.stagedDeletes instanceof Set) ? O.stagedDeletes : new Set();

  const rows = [];
  for (const ex of (O.existing || [])) {
    const isPendingDelete = !!(pendingDeleteIds && ex && pendingDeleteIds.has(ex.id));
    rows.push({
      ...ex,
      ...(O.stagedEdits?.[ex.id] || {}),
      _edited: !!O.stagedEdits?.[ex.id],
      _pendingDelete: isPendingDelete
    });
  }
  for (const n of (O.stagedNew || [])) rows.push({ ...n, _isNew: true });

  if (!rows.length) {
    div.innerHTML = `
      <div class="hint" style="margin-bottom:8px">No candidate-specific overrides. Client defaults will apply.</div>
      <div class="actions">
        <button id="btnAddRate" class="btn mini"${parentEditable ? '' : ' disabled'}>
          Add rate override
        </button>
        ${parentEditable
          ? '<span class="hint">Changes are staged. Click â€œSaveâ€ in the main dialog to persist.</span>'
          : '<span class="hint">Read-only. Click â€œEditâ€ in the main dialog to add/modify overrides.</span>'}
      </div>
    `;
    const addBtn = byId('btnAddRate');
    if (addBtn && parentEditable) addBtn.onclick = () => openCandidateRateModal(window.modalCtx.data?.id);
    if (LOG) console.log('[RATES][TABLE] rendered empty view');
    return;
  }

  const fmt = v => (v==null || Number.isNaN(v)) ? 'â€”' : (Math.round(v*100)/100).toFixed(2);

  // === Today (Europe/London) used for "ongoing" overrides
  const todayIso = (() => {
    try {
      const s = new Intl.DateTimeFormat('en-GB', { timeZone: 'Europe/London', year:'numeric', month:'2-digit', day:'2-digit' }).format(new Date());
      const [dd, mm, yyyy] = s.split('/');
      return `${yyyy}-${mm}-${dd}`;
    } catch { // fallback
      const d = new Date(); const y = d.getFullYear(), m = String(d.getMonth()+1).padStart(2,'0'), day = String(d.getDate()).padStart(2,'0');
      return `${y}-${m}-${day}`;
    }
  })();

  // === ERNI multiplier selection:
  // - If candidate override is ongoing (date_to null or date_to >= today): use today's date
  // - If candidate override finished (date_to < today): use override start date (date_from)
  //
  // Uses finance_windows from getSettingsCached() (no extra network calls).
  const s = await (typeof getSettingsCached === 'function' ? getSettingsCached() : null);
  const fws = Array.isArray(s?.finance_windows) ? s.finance_windows : [];

  const asYmd = (v) => {
    if (!v) return null;
    const ss = String(v).slice(0, 10);
    return /^\d{4}-\d{2}-\d{2}$/.test(ss) ? ss : null;
  };

  const erniMultByDate = Object.create(null);

  const erniMultForYmd = (ymd) => {
    const key = asYmd(ymd) || todayIso;
    if (erniMultByDate[key] != null) return erniMultByDate[key];

    // Pick window with date_from <= key <= date_to (or open), prefer latest date_from
    let chosen = null;
    for (const w of fws) {
      const df = asYmd(w?.date_from);
      const dt = asYmd(w?.date_to);
      if (!df) continue;
      if (df > key) continue;
      if (dt && dt < key) continue;

      if (!chosen) {
        chosen = w;
      } else {
        const cdf = asYmd(chosen?.date_from);
        if (cdf && df > cdf) chosen = w;
      }
    }

    let p = chosen?.erni_pct ?? 0;
    p = Number(p) || 0;
    if (p > 1) p = p / 100; // support 15 vs 0.15

    const mult = (Number.isFinite(1 + p) && (1 + p) > 0) ? (1 + p) : 1;
    erniMultByDate[key] = mult;
    return mult;
  };

  const multForRow = (r) => {
    const startIso = asYmd(r?.date_from) || null;
    const endIso   = asYmd(r?.date_to) || null;
    const finished = !!(endIso && endIso < todayIso);

    // Rule requested:
    // - ongoing -> today
    // - finished -> start_date
    const anchor = (finished && startIso) ? startIso : todayIso;
    return erniMultForYmd(anchor);
  };

  const keyOf = r => [r.client_id, r.role || '', (r.band==null?'':String(r.band)), r.date_from || ''].join('|');
  const uniqueKeys = Array.from(new Set(rows.map(keyOf)));
  const chargeMap = Object.create(null);

  async function loadChargesForKey(key){
    const [client_id, role, bandKey, date_from] = key.split('|');
    const band = (bandKey === '' ? null : bandKey);
    if (!client_id || !role || !date_from) return null;
    try {
      const list = await listClientRates(client_id, { active_on: date_from, only_enabled: true });
      const filtered = Array.isArray(list) ? list.filter(w=>!w.disabled_at_utc && w.role===role) : [];
      let win = filtered.find(w => (w.band ?? null) === (band ?? null));
      if (!win && (band == null)) win = filtered.find(w => w.band == null);
      return win ? {
        day:   win.charge_day   ?? null,
        night: win.charge_night ?? null,
        sat:   win.charge_sat   ?? null,
        sun:   win.charge_sun   ?? null,
        bh:    win.charge_bh    ?? null
      } : null;
    } catch(e){ return null; }
  }
  await Promise.all(uniqueKeys.map(async k => { chargeMap[k] = await loadChargesForKey(k); }));

  // === NEW: check whether a covering client default exists TODAY (Europe/London), per (client,role,band)
  const todayKeyOf = r => [r.client_id, r.role || '', (r.band==null?'':String(r.band))].join('|');
  const todayKeys = Array.from(new Set(rows.map(todayKeyOf)));
  const coverTodayMap = Object.create(null);
  async function loadCoverTodayForKey(key){
    const [client_id, role, bandKey] = key.split('|');
    const band = (bandKey === '' ? null : bandKey);
    if (!client_id || !role) return false;
    try {
      const list = await listClientRates(client_id, { active_on: todayIso, only_enabled: true });
      const filtered = Array.isArray(list) ? list.filter(w=>!w.disabled_at_utc && w.role===role) : [];
      let win = filtered.find(w => (w.band ?? null) === (band ?? null));
      if (!win && (band == null)) win = filtered.find(w => w.band == null);
      return !!win;
    } catch(e){ return false; }
  }
  await Promise.all(todayKeys.map(async k => { coverTodayMap[k] = await loadCoverTodayForKey(k); }));

  const cols    = ['client','role','band','rate_type','pay_day','pay_night','pay_sat','pay_sun','pay_bh','margin_day','margin_night','margin_sat','margin_sun','margin_bh','date_from','date_to','_state'];
  const headers = ['Client','Role','Band','Type','Pay Day','Pay Night','Pay Sat','Pay Sun','Pay BH','Margin Day','Margin Night','Margin Sat','Margin Sun','Margin BH','From','To','Status'];

  const tbl = document.createElement('table'); tbl.className = 'grid';
  const thead = document.createElement('thead'); const trh = document.createElement('tr');
  headers.forEach(h => { const th=document.createElement('th'); th.textContent=h; trh.appendChild(th); });
  thead.appendChild(trh); tbl.appendChild(thead);

  const tb = document.createElement('tbody');
  rows.forEach(r => {
    const tr = document.createElement('tr');
    if (parentEditable) tr.ondblclick = () => openCandidateRateModal(window.modalCtx.data?.id, r);

    const charges = chargeMap[keyOf(r)] || null;
    const isPAYE = String(r.rate_type || '').toUpperCase() === 'PAYE';

    // ERNI multiplier per row (ongoing -> today, finished -> start date)
    const rowMult = isPAYE ? multForRow(r) : 1;

    const margin = {};
    ['day','night','sat','sun','bh'].forEach(b=>{
      const pay = r[`pay_${b}`]; const chg = charges ? charges[b] : null;
      margin[b] = (chg!=null && pay!=null) ? (isPAYE ? (chg - (pay * rowMult)) : (chg - pay)) : null;
    });

    let status =
      r._pendingDelete ? 'Pending delete (save to confirm)' :
      r._isNew        ? 'Staged (new)' :
      r._edited       ? 'Staged (edited)' : '';

    // Determine stale/orphan: (a) no covering client rate at override start OR (b) no covering client rate today
    const hasCoverAtStart = !!charges;
    const hasCoverToday = !!coverTodayMap[todayKeyOf(r)];
    const isStaleOrphan = (!hasCoverAtStart) || (!hasCoverToday);
    if (isStaleOrphan) status = 'Client rate no longer exists';

    // pay columns to 2dp
    const to2 = (v) => (v==null ? 'â€”' : fmt(Number(v)));

    const pretty = {
      client: clientsById[r.client_id] || '', role: r.role || '', band: r.band ?? '', rate_type: r.rate_type || '',
      pay_day: to2(r.pay_day), pay_night: to2(r.pay_night), pay_sat: to2(r.pay_sat), pay_sun: to2(r.pay_sun), pay_bh: to2(r.pay_bh),
      margin_day: fmt(margin.day), margin_night: fmt(margin.night), margin_sat: fmt(margin.sat), margin_sun: fmt(margin.sun), margin_bh: fmt(margin.bh),
      date_from: formatDisplayValue('date_from', r.date_from), date_to: formatDisplayValue('date_to', r.date_to),
      _state   : status
    };

    cols.forEach(c => { const td=document.createElement('td'); td.textContent=String(pretty[c] ?? ''); tr.appendChild(td); });

    // Shade & disable open if stale/orphan
    if (isStaleOrphan) {
      tr.style.opacity = '.55';
      tr.style.cursor = 'not-allowed';
      tr.ondblclick = null;
    }

    tb.appendChild(tr);
  });
  tbl.appendChild(tb);

  const actions = document.createElement('div');
  actions.className = 'actions';
  actions.innerHTML = `
    <button id="btnAddRate" class="btn mini"${parentEditable ? '' : ' disabled'}>
      Add rate override
    </button>
    ${parentEditable
      ? '<span class="hint">Changes are staged. Click â€œSaveâ€ in the main dialog to persist.</span>'
      : '<span class="hint">Read-only. Click â€œEditâ€ in the main dialog to add/modify overrides.</span>'}
  `;

  div.innerHTML = '';
  div.appendChild(tbl);
  div.appendChild(actions);

  const addBtn = byId('btnAddRate');
  if (addBtn && parentEditable) addBtn.onclick = () => openCandidateRateModal(window.modalCtx.data?.id);

  if (LOG) console.log('[RATES][TABLE rendered]', { rows: rows.length, firstState: rows[0]?._state || '(none)' });
}



// Replaces your current function
// =================== renderCandidateRatesTable (FIXED) ===================
// =================== CANDIDATE RATES TABLE (UPDATED) ===================
// âœ… UPDATED â€” renders from modalCtx.overrides (existing âŠ• staged edits/new âŠ– staged deletes)

// ==================================
// 2) renderCandidateRatesTable(...)
// ==================================
// Now computes margins for each override row by resolving client charges at date_from (memoized per render)



// === UPDATED: Candidate modal tabs (adds Roles editor placeholder on 'main') ===


// === DIRTY NAVIGATION GUARDS (add) ===
function isAnyModalDirty(){
  const st = window.__modalStack || [];
  return st.some(f => f && f.isDirty);
}
// ==================== discardAllModalsAndState (kept with geometry reset) ====================

function discardAllModalsAndState(){
  try {
    if (modalCtx && modalCtx._rolesUpdatedHandler) {
      window.removeEventListener('global-roles-updated', modalCtx._rolesUpdatedHandler);
      modalCtx._rolesUpdatedHandler = undefined;
    }
    if (modalCtx && modalCtx._payMethodChangedHandler) {
      window.removeEventListener('pay-method-changed', modalCtx._payMethodChangedHandler);
      modalCtx._payMethodChangedHandler = undefined;
    }
  } catch (e) {
    console.warn('[MODAL] listener cleanup failed', e);
  }

  // Detach any remaining frame-level listeners (dirty/global) from all frames
  try {
    if (Array.isArray(window.__modalStack)) {
      while (window.__modalStack.length) {
        const fr = window.__modalStack.pop();
        if (fr && fr._detachDirty)  { try { fr._detachDirty();  } catch(_) {} }
        if (fr && fr._detachGlobal) { try { fr._detachGlobal(); } catch(_) {} }
      }
    }
  } catch (_) {}

  // Clear any staged calendar changes for open contracts (defensive sweep)
  try {
    if (window.__calStage && typeof clearContractCalendarStageState === 'function') {
      for (const contractId of Object.keys(window.__calStage)) {
        try { clearContractCalendarStageState(contractId); } catch {}
      }
    }
  } catch (e) {
    console.warn('[MODAL] calendar stage cleanup failed', e);
  }

  // Reset modal geometry to prevent "snap to right" on the next open
  const modal = byId('modal');
  if (modal) {
    modal.style.position = '';
    modal.style.left = '';
    modal.style.top = '';
    modal.style.right = '';
    modal.style.bottom = '';
    modal.style.transform = '';
    modal.classList.remove('dragging');
    // Cancel any document-level drag handlers that might still be live
    document.onmousemove = null;
    document.onmouseup   = null;
  }

  // ðŸ”’ Clear any hidden modal DOM so stale inputs can't be read on next open
  const modalBody = document.getElementById('modalBody');
  if (modalBody) modalBody.replaceChildren();
  const modalTabs = document.getElementById('modalTabs');
  if (modalTabs) modalTabs.replaceChildren();
    const modalTitle = document.getElementById('modalTitle');
  if (modalTitle) modalTitle.textContent = '';

  // Clear any lingering bottom-right hint
  const modalHint = document.getElementById('modalHint');
  if (modalHint) {
    modalHint.textContent = '';
    modalHint.removeAttribute('data-tone');
    try { modalHint.classList.remove('ok', 'warn', 'err'); } catch {}
  }

  // Reset modal context
  modalCtx = {
    entity: null, data: null,
    formState: null, rolesState: null,
    ratesState: null, hospitalsState: null,
    clientSettingsState: null,
    openToken: null
  };

  // Hide overlay last
  const back = document.getElementById('modalBack');
  if (back) back.style.display = 'none';

  console.debug('[MODAL] hard reset complete');
}



function confirmDiscardChangesIfDirty(){
  if (!isAnyModalDirty()) return true; // not dirty â†’ acts as plain "Close" guard
  const ok = window.confirm('You have unsaved changes. Discard them and continue?');
  if (!ok) return false;

  // Sanitize geometry before teardown
  const m = byId('modal');
  if (m) {
    m.style.position = '';
    m.style.left = '';
    m.style.top = '';
    m.style.right = '';
    m.style.bottom = '';
    m.style.transform = '';
    m.classList.remove('dragging');
  }
  document.onmousemove = null;
  document.onmouseup   = null;

  // Discard also clears any staged calendar changes (handled inside)
  discardAllModalsAndState();
  return true;
}

async function commitContractCalendarStageIfPending(contractId) {
  const LOG_CAL = (typeof window.__LOG_CAL === 'boolean') ? window.__LOG_CAL : true;
  const L = (...a)=> { if (LOG_CAL) console.log('[CAL][commitIfPending]', ...a); };
  const W = (...a)=> { if ( LOG_CAL) console.warn('[CAL][commitIfPending]', ...a); };
  const E = (...a)=> { if ( LOG_CAL) console.error('[CAL][commitIfPending]', ...a); };

  // âœ… NEW: UI helper
  const showUnplanSummary = (resp, opts = {}) => {
    try {
      const blocked = Array.isArray(resp?.blocked_weeks) ? resp.blocked_weeks : [];
      const removedCount =
        Number(resp?.totals?.emptied_weeks ?? resp?.totals?.patched_weeks ?? 0) ||
        Number(resp?.ranges?.[0]?.emptied_weeks ?? resp?.ranges?.[0]?.patched_weeks ?? 0) ||
        0;

      const fmt = (we) => String(we || '');
      const statusLabel = (b) => {
        if (b?.paid) return 'PAID';
        if (b?.invoiced) return 'INVOICED';
        if (b?.authorised) return 'AUTHORISED';
        if (b?.tsfin_processing_status) return String(b.tsfin_processing_status).toUpperCase();
        if (b?.contract_week_status) return String(b.contract_week_status).toUpperCase();
        return 'HAS_TIMESHEET';
      };

      let msg = '';
      if (!blocked.length) {
        msg = (opts.removeAll)
          ? `All unsubmitted weeks were removed successfully.`
          : `Calendar updated successfully.`;
      } else {
        const lines = blocked
          .slice(0, 12)
          .map(b => `â€¢ W/E ${fmt(b.week_ending_date)} (${statusLabel(b)})`)
          .join('\n');

        msg =
          (opts.removeAll)
            ? `Unsubmitted weeks were removed, but ${blocked.length} week(s) were kept because they already have a timesheet:\n\n${lines}`
            : `Some dates could not be removed because a timesheet already exists (${blocked.length} week(s)):\n\n${lines}`;

        if (blocked.length > 12) {
          msg += `\n\nâ€¦and ${blocked.length - 12} more.`;
        }
      }

      if (typeof showModalHint === 'function') {
        showModalHint(msg, blocked.length ? 'warn' : 'ok');
      } else if (typeof window.__toast === 'function') {
        window.__toast(blocked.length ? 'Removed (some weeks kept)' : 'Removed');
      } else {
        alert(msg);
      }
    } catch (e) {
      // non-fatal
    }
  };

  try {
    const st = getContractCalendarStageState(contractId);
    const hasPending =
      !!st &&
      (st.add.size || st.remove.size || Object.keys(st.additional||{}).length || !!st.removeAll);
    if (!hasPending) {
      L('no pending calendar changes');
      return { ok: true, detail: 'no-op', removedAll: false };
    }

    // Build ranges + symmetry metadata
    const {
      addRanges,
      removeRanges,
      additionals,
      removeAll,
      needsLeftExtend,
      leftEdgeDate,
      rightEdgeDate
    } = buildPlanRangesFromStage(contractId);

    L('ranges from stage', { addRanges, removeRanges, additionals, removeAll });

    // Pull current contract & window from modal
    const contract     = (window.modalCtx && window.modalCtx.data) ? window.modalCtx.data : {};
    const contractStart = contract?.start_date   || null;
    const contractEnd   = contract?.end_date     || null;
    const candidateId   = contract?.candidate_id || null;

    // Special case: "remove all unsubmitted weeks" â†’ single bulk unplan then exit.
    if (removeAll) {
      let resp = null;

      if (removeRanges.length) {
        const payload = {
          when_timesheet_exists: 'skip',
          empty_week_action: 'delete',   // hard delete empty weeks
          ranges: removeRanges           // expect [{ from, to, days: [] }]
        };
        L('DELETE /plan-ranges (removeAll, IfPending)', payload);
        try {
          resp = await contractsUnplanRanges(contractId, payload);
          L('DELETE /plan-ranges (removeAll, IfPending) â†', resp);
        } catch (err) {
          E('unplan-ranges (removeAll, IfPending) failed', err);
          return { ok: false, message: err?.message || 'Calendar commit failed', removedAll: true };
        }
      } else {
        L('removeAll=true but no removeRanges built (IfPending)');
      }

      // âœ… NEW: show user summary
      if (resp) showUnplanSummary(resp, { removeAll: true });

      try { clearContractCalendarStageState(contractId); } catch {}
      L('calendar commit ok (removeAll, IfPending)');
      return { ok: true, detail: 'calendar saved', removedAll: true, unplan_result: resp || null };
    }

    // Optional preflight overlap check when extending left
    if (needsLeftExtend && candidateId) {
      const newStart = leftEdgeDate && contractStart ? (leftEdgeDate < contractStart ? leftEdgeDate : contractStart)
                                                     : (leftEdgeDate || contractStart);
      const newEnd   = rightEdgeDate && contractEnd ? (rightEdgeDate > contractEnd ? rightEdgeDate : contractEnd)
                                                    : (rightEdgeDate || contractEnd || newStart);

      const payload = {
        candidate_id:       candidateId,
        start_date:         newStart,
        end_date:           newEnd,
        ignore_contract_id: contractId
      };

      L('preflight overlap check', payload);
      const overlapRes = await authFetch(API('/api/contracts/check-overlap'), {
        method: 'POST',
        headers: { 'Content-Type':'application/json' },
        body: JSON.stringify(payload)
      });

      // authFetch returns JSON
      if (!overlapRes || overlapRes.error) {
        const msg = overlapRes?.error || 'Overlap check failed';
        console.warn('[CAL][commitIfPending] overlap preflight failed', msg);
        return { ok: false, message: msg, removedAll: false };
      }

      if (overlapRes.has_overlap) {
        const first = Array.isArray(overlapRes.overlaps) && overlapRes.overlaps[0] ? overlapRes.overlaps[0] : null;
        const baseMsg = first
          ? `This extension overlaps ${first.client_name} (${first.role}${first.band ? ' Band ' + first.band : ''}) window ${first.existing_start_date} â†’ ${first.existing_end_date}.`
          : 'This extension overlaps an existing contract window.';
        const proceed = confirm(`${baseMsg}\n\nProceed anyway and save with overlapping windows?`);
        if (!proceed) {
          L('overlap preflight: user cancelled save');
          return { ok: false, message: 'User cancelled due to overlap', removedAll: false, cancelled: true };
        }
        L('overlap preflight: user confirmed proceed');
      }
    }

    // === PLAN (adds) ===
    if (Array.isArray(addRanges) && addRanges.length) {
      const payload = {
        extend_contract_window: true,
        ranges: addRanges
      };
      L('POST /plan-ranges (IfPending)', { ranges: payload.ranges.length, extend_contract_window: true });
      try {
        const resp = await contractsPlanRanges(contractId, payload);
        L('POST /plan-ranges (IfPending) â†', resp);
      } catch (err) {
        E('plan-ranges (IfPending) failed', err);
        return { ok: false, message: err?.message || 'Calendar commit failed', removedAll: false };
      }
    } else {
      L('No addRanges to commit (IfPending)');
    }

    // === UNPLAN (removals) ===
    let lastUnplanResp = null;
    if (Array.isArray(removeRanges) && removeRanges.length) {
      const payload = {
        when_timesheet_exists: 'skip',
        empty_week_action: 'cancel',   // clear weeks + mark CANCELLED
        ranges: removeRanges
      };
      L('DELETE /plan-ranges (IfPending)', { ranges: payload.ranges.length });
      try {
        lastUnplanResp = await contractsUnplanRanges(contractId, payload);
        L('DELETE /plan-ranges (IfPending) â†', lastUnplanResp);

        // âœ… NEW: show summary if backend reports blocked weeks
        if (lastUnplanResp) showUnplanSummary(lastUnplanResp, { removeAll: false });

      } catch (err) {
        E('unplan-ranges (IfPending) failed', err);
        return { ok: false, message: err?.message || 'Calendar commit failed', removedAll: false };
      }
    } else {
      L('No removeRanges to commit (IfPending)');
    }

    // === ADDITIONALS (split weeks) ===
    if (Array.isArray(additionals) && additionals.length) {
      L('Committing additional weeksâ€¦ (IfPending)', { count: additionals.length });
      for (const g of additionals) {
        try {
          L('Create additional for baseWeekId (IfPending)', g.baseWeekId, 'dates=', g.dates);
          const addRow = await contractWeekCreateAdditional(g.baseWeekId);
          L('additional created (IfPending) â†', addRow);
          const payload = { add: g.dates.map(d => ({ date: d })), merge: 'append' };
          L('PATCH /contract-weeks/:id/plan (IfPending)', { week_id: addRow.id, payload });
          const resp = await contractWeekPlanPatch(addRow.id, payload);
          L('PATCH /contract-weeks/:id/plan (IfPending) â†', resp);
        } catch (err) {
          E('additional week flow (IfPending) failed', err);
          return { ok: false, message: err?.message || 'Calendar commit failed', removedAll: false };
        }
      }
    } else {
      L('No additionals to commit (IfPending)');
    }

    // Optimistic in-memory window nudge (for immediate UI consistency)
    try {
      if (window.modalCtx && window.modalCtx.data) {
        if (leftEdgeDate && (!window.modalCtx.data.start_date || leftEdgeDate < window.modalCtx.data.start_date)) {
          window.modalCtx.data.start_date = leftEdgeDate;
        }
        if (rightEdgeDate && (!window.modalCtx.data.end_date || rightEdgeDate > window.modalCtx.data.end_date)) {
          window.modalCtx.data.end_date = rightEdgeDate;
        }
      }
    } catch {}

    try { clearContractCalendarStageState(contractId); } catch {}
    L('calendar commit ok (IfPending)');
    return { ok: true, detail: 'calendar saved', removedAll: false };

  } catch (e) {
    console.warn('[CAL][commitIfPending] failed', e);
    return { ok: false, message: e?.message || 'Calendar commit failed', removedAll: false };
  }
}



// Stage a full-window delete of all TS-free weeks (committed on Save).

async function removeAllUnsubmittedWeeks(contractId, bounds) {
  const LOG_CAL = (typeof window.__LOG_CAL === 'boolean') ? window.__LOG_CAL : true;
  const L = (...a)=> { if (LOG_CAL) console.log('[CAL][removeAllUnsubmittedWeeks]', ...a); };

  const st = getContractCalendarStageState(contractId);

  const rawFrom = bounds?.from || window.modalCtx?.data?.start_date || null;
  const rawTo   = bounds?.to   || window.modalCtx?.data?.end_date   || null;

  const fromIso = (!rawFrom ? null : (rawFrom.includes('/') && typeof parseUkDateToIso === 'function') ? (parseUkDateToIso(rawFrom) || rawFrom) : rawFrom);
  const toIso   = (!rawTo   ? null : (rawTo.includes('/')   && typeof parseUkDateToIso === 'function') ? (parseUkDateToIso(rawTo)   || rawTo)   : rawTo);

  const wew = (window.modalCtx?.data?.week_ending_weekday_snapshot ?? 0);
  const endFrom = computeWeekEnding(fromIso || window.modalCtx?.data?.start_date, wew);
  const startFrom = addDays(endFrom, -6);
  const endTo = computeWeekEnding(toIso || window.modalCtx?.data?.end_date, wew);

  st.removeAll = { from: startFrom, to: endTo };
  st.remove.clear?.();
  st.add.clear?.();
  st.additional = {};

  L('staged removeAll', st.removeAll);

  // âœ… NEW: calendar-only dirty marker
  try {
    window.modalCtx = window.modalCtx || {};
    window.modalCtx.__calendarDirty = true;
    if (!window.modalCtx.__nonCalendarDirty) window.modalCtx.__calendarOnly = true;
  } catch {}

  // Optional nicety: if user triggered â€œremove allâ€, clear any lingering selections immediately
  try { if (typeof clearCalendarSelection === 'function') clearCalendarSelection(`c:${contractId}`); } catch {}

  try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
  return { ok: true, staged: true, bounds: st.removeAll };
}




// After a "remove-all" commit, rebound the contract dates to actuals
// Rule: if any timesheets exist => (start=min_ts, end=max_ts)
//       else => (end = start) leave start as-is.


async function normalizeContractWindowToShifts(contractId) {
  try {
    const r = await authFetch(API(`/api/contracts/${encodeURIComponent(contractId)}`), { method:'GET' });
    const data = await r.json().catch(()=>null);
    const contract = data?.contract || data || {};
    const currStart = contract.start_date || null;
    const currEnd   = contract.end_date   || null;
    if (!currStart || !currEnd) return { ok:false, reason:'no-window' };

    let minTs = null, maxTs = null;
    try {
      const bRes = await authFetch(API(`/api/contracts/check-timesheet-boundary`), {
        method:'POST',
        headers: { 'content-type':'application/json' },
        body: JSON.stringify({ contract_id: contractId, start_date: currStart, end_date: currEnd })
      });
      const b = await bRes.json().catch(()=>null);
      if (b) { minTs = b.min_ts_date || null; maxTs = b.max_ts_date || null; }
    } catch {}

    let newStart = currStart;
    let newEnd   = currEnd;

    if (minTs && maxTs) {
      newStart = minTs;
      newEnd   = maxTs;
    } else {
      try {
        const dRes = await authFetch(API(`/api/contracts/${encodeURIComponent(contractId)}/calendar?from=${encodeURIComponent(currStart)}&to=${encodeURIComponent(currEnd)}&granularity=day`), { method:'GET' });
        const d = await dRes.json().catch(()=>null);
        const items = Array.isArray(d?.items) ? d.items : [];
        const plannedDates = items
          .filter(it => String(it?.state||'').toUpperCase() === 'PLANNED')
          .map(it => it?.date)
          .filter(Boolean)
          .sort();
        if (plannedDates.length) {
          newStart = plannedDates[0];
          newEnd   = plannedDates[plannedDates.length - 1];
        } else {
          newEnd = currStart;
        }
      } catch {
        newEnd = currStart;
      }
    }

    if (newStart !== currStart || newEnd !== currEnd) {
      const payload = { id: contractId, start_date: newStart, end_date: newEnd };
      const saved = await upsertContract(payload, contractId);
      const savedContract = saved?.contract || saved || null;
      if (savedContract) {
        try { window.modalCtx.data = savedContract; } catch {}
        try {
          const fs = (window.modalCtx.formState ||= { __forId: (contractId || null), main:{}, pay:{} });
          fs.main ||= {};
          fs.main.start_date = savedContract.start_date || newStart;
          fs.main.end_date   = savedContract.end_date   || newEnd;
          const fr = window.__getModalFrame?.();
          const currentTab = fr?.currentTabKey || (document.querySelector('#modalTabs button.active')?.textContent?.toLowerCase() || '');
          if (currentTab === 'main' && typeof fr?.setTab === 'function') fr.setTab('main');
        } catch {}
      }
      return { ok:true, start_date: newStart, end_date: newEnd, changed:true };
    }

    return { ok:true, start_date: newStart, end_date: newEnd, changed:false };
  } catch (e) {
    return { ok:false, error: e?.message || String(e) };
  }
}



// ====================== mountCandidateRatesTab (FIXED) ======================
// =================== MOUNT CANDIDATE RATES TAB (unchanged flow) ===================

// ==============================
// 3) mountCandidateRatesTab(...)
// ==============================

// === UPDATED: Candidate Rate Override modal (Clientâ†’Role gated; bands; UK dates; date_to) ===
// ====================== openCandidateRateModal (FIXED) ======================
// =================== CANDIDATE OVERRIDE MODAL (UPDATED) ===================
// ==== CHILD MODAL (CANDIDATE RATE) â€” throw on errors; return true on success ====
// âœ… UPDATED â€” Apply (stage), gate against client defaults active at date_from,
//    auto-truncate incumbent of same rate_type at Nâˆ’1 (staged), NO persistence here
async function mountCandidateRatesTab() {
  const LOG = !!window.__LOG_RATES;
  const token = window.modalCtx.openToken;
  const id    = window.modalCtx.data?.id || null;
  if (LOG) console.log('[RATES][mountCandidateRatesTab] ENTRY', { token, id });

  // Ensure a host exists (only on Rates tab; this function is called from showModal setTab('rates'))
  const host = byId('modalBody');
  if (host && !byId('ratesTable')) {
    const c = document.createElement('div');
    c.id = 'ratesTable';
    host.appendChild(c);
    if (LOG) console.log('[RATES][mountCandidateRatesTab] injected #ratesTable host');
  }

  // CREATE flow
  if (!id) {
    window.modalCtx.overrides = window.modalCtx.overrides || { existing: [], stagedNew: [], stagedEdits: {}, stagedDeletes: new Set() };
    await renderCandidateRatesTable();
    if (LOG) console.log('[RATES][mountCandidateRatesTab] create-flow render (no id)');

    const btn = byId('btnAddRate');
    const frame = _currentFrame();
    if (btn && frame && (frame.mode === 'edit' || frame.mode === 'create')) btn.onclick = () => openCandidateRateModal(window.modalCtx.data?.id);
    return;
  }

  // EDIT flow â€” refresh ONLY existing; preserve stagedNew/Edits/Deletes
  const rates = await listCandidateRates(id);
  if (token !== window.modalCtx.openToken || window.modalCtx.data?.id !== id) {
    if (LOG) console.warn('[RATES][mountCandidateRatesTab] token/id changed mid-flight');
    return;
  }

  const O = window.modalCtx.overrides || (window.modalCtx.overrides = { existing: [], stagedNew: [], stagedEdits: {}, stagedDeletes: new Set() });
  if (Array.isArray(rates)) O.existing = rates.slice();

  await renderCandidateRatesTable();
  if (LOG) console.log('[RATES][mountCandidateRatesTab] renderCandidateRatesTable() called');

  const btn = byId('btnAddRate');
  const frame = _currentFrame();
  if (btn && frame && (frame.mode === 'edit' || frame.mode === 'create')) btn.onclick = () => openCandidateRateModal(window.modalCtx.data?.id);
}

// Mount logic for Contracts â†’ Rates tab (hide/show groups, compute margins, handle preset buttons)

function mountContractRatesTab() {
  const root = byId('contractRatesTab'); if (!root) return;

  const form = document.querySelector('#contractForm');
  const payMethodSel = form?.querySelector('select[name="pay_method_snapshot"], select[name="default_pay_method_snapshot"]');

  // Helper: normalise to 2dp if numeric, leave as-is otherwise
  const normaliseRateInput = (el) => {
    if (!el) return;
    let v = (el.value || '').trim();
    if (!v) return;
    const n = Number(v);
    if (!Number.isFinite(n)) return;
    const fixed = n.toFixed(2);
    if (fixed !== v) {
      el.value = fixed;
    }
  };

  try {
    const fs = (window.modalCtx.formState ||= { __forId:(window.modalCtx.data?.id ?? window.modalCtx.openToken ?? null), main:{}, pay:{} });
    if (!fs.pay || Object.keys(fs.pay).length === 0) {
      const saved = (window.modalCtx.data && window.modalCtx.data.rates_json) || {};
      const buckets = ['paye_day','paye_night','paye_sat','paye_sun','paye_bh','umb_day','umb_night','umb_sat','umb_sun','umb_bh','charge_day','charge_night','charge_sat','charge_sun','charge_bh'];
      fs.pay = fs.pay || {};
      for (const k of buckets) {
        const v = saved[k];
        if (v === 0 || (typeof v === 'number' && Number.isFinite(v))) {
          // store as 2dp string
          fs.pay[k] = Number(v).toFixed(2);
        }
      }
    }
  } catch {}

  const toggleCards = () => {
    const pm = (payMethodSel?.value || root.dataset.payMethod || 'PAYE').toUpperCase();
    const cardPAYE = byId('cardPAYE'), cardUMB = byId('cardUMB');
    if (cardPAYE) cardPAYE.style.display = (pm === 'PAYE') ? '' : 'none';
    if (cardUMB)  cardUMB.style.display  = (pm === 'PAYE') ? 'none' : '';
    return pm;
  };

  let payMethod = toggleCards();

  if (payMethodSel && !payMethodSel.__wired_pm) {
    payMethodSel.__wired_pm = true;
    payMethodSel.addEventListener('change', () => {
      payMethod = toggleCards();
      if (typeof computeContractMargins === 'function') computeContractMargins();
    });
  }

  const rateInputs = root.querySelectorAll('input[name^="paye_"], input[name^="umb_"], input[name^="charge_"]');

  rateInputs.forEach(el => {
    if (!el.__wired_mg) {
      el.__wired_mg = true;

      // Live margins on input
      el.addEventListener('input', () => {
        if (typeof computeContractMargins === 'function') computeContractMargins();
      });

      // Snap to 2dp on blur/tab away
      el.addEventListener('blur', () => {
        const before = el.value;
        normaliseRateInput(el);
        if (el.value !== before && typeof setContractFormValue === 'function') {
          setContractFormValue(el.name, el.value);
        } else if (typeof setContractFormValue === 'function') {
          // still stage even if unchanged, to keep formState in sync
          setContractFormValue(el.name, el.value);
        }
        if (typeof computeContractMargins === 'function') computeContractMargins();
      });
    }
  });

  // Mileage inputs: same behaviour (2dp on blur)
  const mileageInputs = root.querySelectorAll('input[name="mileage_pay_rate"], input[name="mileage_charge_rate"]');
  mileageInputs.forEach(el => {
    if (!el.__wired_mg) {
      el.__wired_mg = true;

      el.addEventListener('input', () => {
        // margins may or may not depend on mileage; cheap to recompute anyway
        if (typeof computeContractMargins === 'function') computeContractMargins();
      });

      el.addEventListener('blur', () => {
        const before = el.value;
        normaliseRateInput(el);
        if (typeof setContractFormValue === 'function') {
          setContractFormValue(el.name, el.value);
        }
        if (typeof computeContractMargins === 'function') computeContractMargins();
      });
    }
  });

  // One-time wiring for negative margin hints + bucket label updates
  if (!root.__wiredNeg) {
    root.__wiredNeg = true;
    window.addEventListener('contract-margins-updated', (ev) => {
      const s = ev?.detail || window.__contractMarginState || { hasNegativeMargins:false, negFlags:{} };
      Object.entries(s.negFlags||{}).forEach(([b,neg]) => {
        const row = document.querySelector(`#marginsTable tbody tr[data-b="${b}"]`);
        if (!row) return;
        const mgEl = row.querySelector('.mg');
        if (neg) {
          row.setAttribute('data-negative','1');
          if (mgEl && !mgEl.querySelector('.mini')) {
            const hint = document.createElement('div');
            hint.className='mini';
            hint.textContent='Margin canâ€™t be negative';
            mgEl.appendChild(hint);
          }
        } else {
          row.removeAttribute('data-negative');
          if (mgEl) {
            const hint = mgEl.querySelector('.mini');
            if (hint) hint.remove();
          }
        }
      });
    });
    window.addEventListener('bucket-labels-changed', () => {
      const merged = mergeContractStateIntoRow(window.modalCtx?.data||{});
      const LBL = merged?.bucket_labels_json || (window.modalCtx?.formState?.main ? {
        day:   window.modalCtx.formState.main.bucket_day || window.modalCtx.formState.main.bucket_label_day,
        night: window.modalCtx.formState.main.bucket_night || window.modalCtx.formState.main.bucket_label_night,
        sat:   window.modalCtx.formState.main.bucket_sat || window.modalCtx.formState.main.bucket_label_sat,
        sun:   window.modalCtx.formState.main.bucket_sun || window.modalCtx.formState.main.bucket_label_sun,
        bh:    window.modalCtx.formState.main.bucket_bh || window.modalCtx.formState.main.bucket_label_bh,
      } : {});
      const labelOf = (k, def) => (LBL && LBL[k]) ? LBL[k] : def;
      const map = { day:'Day', night:'Night', sat:'Sat', sun:'Sun', bh:'BH' };
      Object.entries(map).forEach(([k,def])=>{
        const rows = document.querySelectorAll(`#contractRatesTab .row > label.section, #contractRatesTab .row > label`);
        rows.forEach(lab=>{
          const n = lab.textContent?.trim()||'';
          if (n === def) lab.textContent = labelOf(k, def);
        });
        const tr = document.querySelector(`#marginsTable tbody tr[data-b="${k}"] td:first-child`);
        if (tr) tr.textContent = labelOf(k, def);
      });
      if (typeof computeContractMargins === 'function') computeContractMargins();
    });
  }

  // Initial normalisation pass for values already in the DOM
  try {
    // Rates
    rateInputs.forEach(el => {
      normaliseRateInput(el);
      if (typeof setContractFormValue === 'function') {
        setContractFormValue(el.name, el.value);
      }
    });
    // Mileage
    mileageInputs.forEach(el => {
      normaliseRateInput(el);
      if (typeof setContractFormValue === 'function') {
        setContractFormValue(el.name, el.value);
      }
    });
  } catch {}

  if (typeof computeContractMargins === 'function') computeContractMargins();
}

// Open preset picker (card grid) and return chosen data




async function fetchClientRatePresets({ client_id, role, band, active_on }) {
  if (!client_id) return [];
  const qs = new URLSearchParams();
  qs.set('client_id', client_id);
  if (role) qs.set('role', role);
  if (band != null && band !== '') qs.set('band', band);
  if (active_on) qs.set('active_on', active_on);
  const r = await authFetch(API(`/api/rates/client-defaults?${qs.toString()}`));
  const rows = toList(r) || [];
  return rows;
}

async function fetchCandidateRateOverrides({ candidate_id, client_id, role, band, active_on }) {
  if (!candidate_id) return [];
  const qs = new URLSearchParams();
  qs.set('candidate_id', candidate_id);
  if (client_id) qs.set('client_id', client_id);
  if (role) qs.set('role', role);
  if (band != null && band !== '') qs.set('band', band);
  if (active_on) qs.set('active_on', active_on);
  const r = await authFetch(API(`/api/rates/candidate-overrides?${qs.toString()}`));
  const rows = toList(r) || [];
  return rows;
}



async function computeContractMargins() {
  const fs = (window.modalCtx && window.modalCtx.formState) || { main:{}, pay:{} };
  const form = document.querySelector('#contractRatesTab')?.closest('form') || document.querySelector('#contractForm');

  const pmStaged = (fs.main && fs.main.pay_method_snapshot) || '';
  const payMethodSel = form ? form.querySelector('select[name="pay_method_snapshot"]') : null;
  const payMethod = ((payMethodSel && payMethodSel.value) || pmStaged || 'PAYE').toUpperCase();

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Determine which date to use for finance-window selection:
  // - If contract is ongoing: use today's date (Europe/London)
  // - If contract has finished (end_date < today): use contract start_date
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const todayIso = (() => {
    try {
      const d = new Intl.DateTimeFormat('en-GB', {
        timeZone: 'Europe/London',
        year:'numeric', month:'2-digit', day:'2-digit'
      }).format(new Date());
      const [dd, mm, yyyy] = d.split('/');
      return `${yyyy}-${mm}-${dd}`;
    } catch {
      const d = new Date();
      const y = d.getFullYear();
      const m = String(d.getMonth()+1).padStart(2,'0');
      const day = String(d.getDate()).padStart(2,'0');
      return `${y}-${m}-${day}`;
    }
  })();

  const toIsoYmd = (v) => {
    if (!v) return null;
    const s = String(v).trim();
    if (!s) return null;

    // Accept ISO 'YYYY-MM-DD' (or ISO datetime)
    if (/^\d{4}-\d{2}-\d{2}/.test(s)) return s.slice(0, 10);

    // Accept UK 'DD/MM/YYYY'
    if (/^\d{2}\/\d{2}\/\d{4}$/.test(s) && typeof parseUkDateToIso === 'function') {
      try { return parseUkDateToIso(s) || null; } catch { return null; }
    }
    return null;
  };

  // Best-effort: read dates from staged state, modalCtx.data, or DOM inputs
  const getDateField = (name) => {
    const staged = fs.main ? fs.main[name] : null;
    const dataV  = (window.modalCtx && window.modalCtx.data) ? window.modalCtx.data[name] : null;
    const domV   = form ? form.querySelector(`[name="${name}"]`)?.value : null;
    return (staged != null && staged !== '') ? staged : (domV != null && domV !== '' ? domV : dataV);
  };

  const startIso = toIsoYmd(getDateField('start_date')) || null;
  const endIso   = toIsoYmd(getDateField('end_date'))   || null;

  const isFinished = !!(endIso && endIso < todayIso);
  const asOfIso = (isFinished && startIso) ? startIso : todayIso;

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Ensure we have a sensible ERNI multiplier (1 + erni_pct)
  // UPDATED: getSettingsCached() now returns { settings, finance_windows }
  // and ERNI must be selected using the asOfIso computed above.
  // Cached by date to avoid repeated work/subcalls.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let erniMult = 1;
  try {
    window.__ERNI_MULT_BY_DATE__ = window.__ERNI_MULT_BY_DATE__ || Object.create(null);
    if (window.__ERNI_MULT_BY_DATE__[asOfIso] && window.__ERNI_MULT_BY_DATE__[asOfIso] > 0) {
      erniMult = window.__ERNI_MULT_BY_DATE__[asOfIso];
    } else if (typeof window.getSettingsCached === 'function') {
      const s = await window.getSettingsCached();

      // New shape: { settings: {...}, finance_windows: [...] }
      const fws = Array.isArray(s?.finance_windows) ? s.finance_windows : [];

      const asYmd = (v) => {
        if (!v) return null;
        const ss = String(v).slice(0, 10);
        return /^\d{4}-\d{2}-\d{2}$/.test(ss) ? ss : null;
      };

      // Pick the finance window in-scope for asOfIso
      let chosen = null;
      for (const w of fws) {
        const df = asYmd(w?.date_from);
        const dt = asYmd(w?.date_to);
        if (!df) continue;
        if (df > asOfIso) continue;
        if (dt && dt < asOfIso) continue;

        if (!chosen) {
          chosen = w;
        } else {
          const cdf = asYmd(chosen?.date_from);
          if (cdf && df > cdf) chosen = w;
        }
      }

      // ERNI pct from finance window (preferred), else legacy fallbacks
      let p = (chosen?.erni_pct ?? null);
      if (p == null) p = s?.settings?.erni_pct ?? null;
      if (p == null) p = s?.erni_pct ?? null;
      if (p == null) p = s?.employers_ni_percent ?? null;
      if (p == null) p = 0;

      p = Number(p) || 0;
      if (p > 1) p = p / 100; // support 15 vs 0.15

      erniMult = 1 + p;
      if (!Number.isFinite(erniMult) || erniMult <= 0) erniMult = 1;

      window.__ERNI_MULT_BY_DATE__[asOfIso] = erniMult;
      window.__ERNI_MULT__ = erniMult; // keep legacy single-value cache in sync
    }
  } catch {
    erniMult = 1;
    window.__ERNI_MULT__ = 1;
    window.__ERNI_MULT_BY_DATE__ = window.__ERNI_MULT_BY_DATE__ || Object.create(null);
    window.__ERNI_MULT_BY_DATE__[asOfIso] = 1;
  }

  const get = (n) => {
    const domVal = form ? form.querySelector(`[name="${n}"]`)?.value : null;
    const staged = fs.pay ? fs.pay[n] : null;
    const v = (staged != null && staged !== '') ? staged : (domVal != null ? domVal : '');
    const num = Number(v);
    return Number.isFinite(num) ? num : 0;
  };

  const buckets = ['day','night','sat','sun','bh'];
  const negFlags = {};

  buckets.forEach(b => {
    const ch = get(`charge_${b}`);
    const py = (payMethod === 'PAYE') ? get(`paye_${b}`) : get(`umb_${b}`);

    let mg;

    // Prefer shared helper if present, but force ERNI in
    if (typeof window.calcDailyMargin === 'function') {
      try {
        const v = window.calcDailyMargin({
          bucket: b,
          charge: ch,
          pay:    py,
          method: payMethod,
          erniMultiplier: erniMult
        });
        mg = (v == null || !Number.isFinite(v)) ? null : v;
      } catch {
        mg = null;
      }
    }

    // Fallback if helper missing or returned null
    if (mg == null) {
      if (payMethod === 'PAYE') {
        mg = ch - (py * erniMult);
      } else {
        // UMBRELLA or unknown â†’ no ERNI
        mg = ch - py;
      }
    }

    const row = document.querySelector(`#marginsTable tbody tr[data-b="${b}"]`);
    if (row) {
      const chEl = row.querySelector('.ch');
      const pyEl = row.querySelector('.py');
      const mgEl = row.querySelector('.mg');

      if (pyEl) pyEl.textContent = (py || py === 0) ? py.toFixed(2) : '';
      if (chEl) chEl.textContent = (ch || ch === 0) ? ch.toFixed(2) : '';

      if (mgEl) {
        const showMg = Number.isFinite(mg) ? mg : null;
        mgEl.textContent = (showMg || showMg === 0) ? showMg.toFixed(2) : '';
        mgEl.style.color = (showMg < 0) ? 'var(--fail)' : '';

        if (showMg < 0) {
          mgEl.setAttribute('data-negative','1');
          if (!mgEl.querySelector('.mini')) {
            const hint = document.createElement('div');
            hint.className = 'mini';
            hint.textContent = 'Margin canâ€™t be negative';
            mgEl.appendChild(hint);
          }
          row.setAttribute('data-negative','1');
        } else {
          mgEl.removeAttribute('data-negative');
          const hint = mgEl.querySelector('.mini');
          if (hint) hint.remove();
          row.removeAttribute('data-negative');
        }
      }
    }

    negFlags[b] = (mg < 0);
  });

  const hasNegativeMargins = Object.values(negFlags).some(Boolean);
  window.__contractMarginState = {
    hasNegativeMargins,
    negFlags,
    method: payMethod,

    // useful metadata for debugging/UI if needed
    finance_asof_ymd: asOfIso,
    contract_start_ymd: startIso,
    contract_end_ymd: endIso,
    contract_finished: isFinished
  };

  try { window.dispatchEvent(new CustomEvent('contract-margins-updated', { detail: window.__contractMarginState })); } catch {}
  try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
}



// ==============================
// 1) openCandidateRateModal(...)
// ==============================
// ========== CANDIDATE OVERRIDES ==========
// ========== CHILD MODAL (CANDIDATE OVERRIDE) WITH HEAVY LOGGING ==========


// ========== PARENT TABLE RENDER (WITH LOUD LOGS + SAFETY NET) ==========
async function openCandidateRateModal(candidate_id, existing) {
  const LOG = !!window.__LOG_RATES;
  const LOG_APPLY = (typeof window.__LOG_APPLY === 'boolean') ? window.__LOG_APPLY : LOG;
  const L  = (...a)=> { if (LOG) console.log('[RATES][openCandidateRateModal]', ...a); };
  const LG = (label, obj)=> { if (LOG) { console.groupCollapsed(`[RATES][openCandidateRateModal] ${label}`); console.log(obj); console.groupEnd(); } };

  L('ENTRY', { candidate_id, hasExisting: !!existing });

  const parentFrame   = _currentFrame();
  const parentEditable= parentFrame && (parentFrame.mode === 'edit' || parentFrame.mode === 'create');
  L('parent frame', { editable: !!parentEditable, mode: parentFrame?.mode });

  // ===== load clients =====
  const clients = await listClientsBasic().catch(e=>{ L('listClientsBasic failed', e); return []; });
  L('clients loaded', clients?.length || 0);
  const clientOptions = (clients||[]).map(c => `<option value="${c.id}">${c.name}</option>`).join('');
  const initialClientId = existing?.client_id || '';

  const defaultRateType = existing?.rate_type
    ? String(existing.rate_type).toUpperCase()
    : String(window.modalCtx?.data?.pay_method || 'PAYE').toUpperCase();

  const bucketLabel = { day:'Day', night:'Night', sat:'Sat', sun:'Sun', bh:'BH' };

  // Track the current in-form role/band so they don't reset when date/client changes
  let currentRole = existing?.role || '';
  let currentBand = (existing && existing.band != null) ? String(existing.band) : '';

  // ===== FORM =====
  const formHtml = html(`
    <div class="form" id="candRateForm">
      <div class="row">
        <label>Client (required)</label>
        <select name="client_id" id="cr_client_id" ${parentEditable ? '' : 'disabled'}>
          <option value="">Select clientâ€¦</option>
          ${clientOptions}
        </select>
      </div>

      <div class="row">
        <label>Rate type (required)</label>
        <select name="rate_type" id="cr_rate_type" ${parentEditable ? '' : 'disabled'}>
          <option ${defaultRateType==='PAYE'?'selected':''}>PAYE</option>
          <option ${defaultRateType==='UMBRELLA'?'selected':''}>UMBRELLA</option>
        </select>
      </div>

      <div class="row">
        <label>Role (required)</label>
        <select name="role" id="cr_role" required ${parentEditable ? '' : 'disabled'}>
          <option value="">Select roleâ€¦</option>
        </select>
      </div>

      <div class="row" id="cr_band_row">
        <label>Band (optional)</label>
        <select name="band" id="cr_band" ${parentEditable ? '' : 'disabled'}></select>
      </div>

      <div class="row">
        <label>Effective from (DD/MM/YYYY)</label>
        <input type="text" name="date_from" id="cr_date_from" placeholder="DD/MM/YYYY" ${parentEditable ? '' : 'disabled'} />
      </div>

      <div class="row">
        <label>Effective to (optional, DD/MM/YYYY)</label>
        <input type="text" name="date_to" id="cr_date_to" placeholder="DD/MM/YYYY" ${parentEditable ? '' : 'disabled'} />
        <div class="hint field-hint err" id="cr_date_to_err" style="display:none"></div>
      </div>

      ${['day','night','sat','sun','bh'].map(b => `
        <div class="row" data-bucket="${b}">
          <label>Pay (${b.toUpperCase()})</label>
          <div class="slot" id="slot_${b}">
            <div class="slot-input" id="slot_input_${b}" style="display:none">
              <input type="number" step="0.01" name="pay_${b}" id="pay_${b}"/>
            </div>
            <div class="slot-ph" id="slot_ph_${b}" style="opacity:.75">Not in client rate</div>
          </div>
        </div>`).join('')}

      <div class="row" style="grid-column:1 / -1; margin-top:10px">
        <table class="grid" id="cr_margins_tbl" style="width:100%">
          <thead><tr><th>Bucket</th><th>Margin</th><th class="hint">Uses client charge at start date</th></tr></thead>
          <tbody>
            ${['day','night','sat','sun','bh'].map(b=>`
              <tr><td>${b.toUpperCase()}</td><td><span id="cr_m_${b}">â€”</span></td><td></td></tr>`).join('')}
          </tbody>
        </table>
      </div>

      <div id="cr_err_panel" style="grid-column:1/-1; margin-top:10px; display:none; border:1px solid #7f1d1d; background:rgba(239,68,68,.08); color:#fecaca; padding:10px; border-radius:8px"></div>
    </div>
  `);

  // ===== helpers =====
  const todayIso = (() => {
    try {
      const d = new Intl.DateTimeFormat('en-GB', {
        timeZone: 'Europe/London',
        year:'numeric', month:'2-digit', day:'2-digit'
      }).format(new Date());
      const [dd, mm, yyyy] = d.split('/');
      return `${yyyy}-${mm}-${dd}`;
    } catch {
      const d = new Date();
      const y = d.getFullYear();
      const m = String(d.getMonth()+1).padStart(2,'0');
      const day = String(d.getDate()).padStart(2,'0');
      return `${y}-${m}-${day}`;
    }
  })();

  const asYmd = (v) => {
    if (!v) return null;
    const ss = String(v).slice(0, 10);
    return /^\d{4}-\d{2}-\d{2}$/.test(ss) ? ss : null;
  };

  function numOrNull(v){ if (v===undefined||v===null) return null; if (typeof v === 'string' && v.trim()==='') return null; const n=Number(v); return Number.isFinite(n) ? n : null; }
  const fmt = v => (v==null || Number.isNaN(v)) ? 'â€”' : (Math.round(v*100)/100).toFixed(2);
  function showInlineError(html){ const p = byId('cr_err_panel'); if (!p) return; if (html && String(html).trim() !== '') { p.innerHTML = html; p.style.display = ''; } else { p.innerHTML = ''; p.style.display = 'none'; } }
  function setFieldError(bucket,msg){
    const rowInput = document.querySelector(`#candRateForm input[name="pay_${bucket}"]`);
    if (!rowInput) return;
    let hint = rowInput.parentElement?.querySelector?.(`.field-hint.err[data-bucket="${bucket}"]`);
    if (msg) {
      if (!hint) {
        hint = document.createElement('div');
        hint.className = 'hint field-hint err';
        hint.setAttribute('data-bucket', bucket);
        rowInput.parentElement.appendChild(hint);
      }
      hint.textContent = msg;
    } else if (hint) hint.remove();
  }
  function setDateToError(msg){ const el = byId('cr_date_to_err'); if (!el) return; if (msg) { el.textContent = msg; el.style.display = ''; } else { el.textContent = ''; el.style.display = 'none'; } }
  function clearAllFieldErrors(){ document.querySelectorAll('#candRateForm .field-hint.err').forEach(el=>el.remove()); setDateToError(''); }

  // âœ… ERNI multiplier selection per override:
  // - If override is ongoing (date_to empty or date_to >= today) â†’ use today
  // - If override is finished (date_to < today) â†’ use date_from
  //
  // Uses getSettingsCached() -> finance_windows (no extra network calls).
  async function _erniMultiplier(isoFrom, isoTo){
    try {
      const fromIso = asYmd(isoFrom) || null;
      const toIso   = asYmd(isoTo)   || null;

      const finished = !!(toIso && toIso < todayIso);
      const anchorYmd = (finished && fromIso) ? fromIso : todayIso;

      // cache by anchor date (prevents repeated lookups while typing)
      window.__ERNI_MULT_BY_DATE__ = window.__ERNI_MULT_BY_DATE__ || Object.create(null);
      if (typeof window.__ERNI_MULT_BY_DATE__[anchorYmd] === 'number' && window.__ERNI_MULT_BY_DATE__[anchorYmd] > 0) {
        return window.__ERNI_MULT_BY_DATE__[anchorYmd];
      }

      let fws = [];
      try {
        if (typeof getSettingsCached === 'function') {
          const s = await getSettingsCached();
          fws = Array.isArray(s?.finance_windows) ? s.finance_windows : [];
        }
      } catch {
        fws = [];
      }

      // pick finance window in-scope for anchorYmd
      let chosen = null;
      for (const w of fws) {
        const df = asYmd(w?.date_from);
        const dt = asYmd(w?.date_to);
        if (!df) continue;
        if (df > anchorYmd) continue;
        if (dt && dt < anchorYmd) continue;

        if (!chosen) {
          chosen = w;
        } else {
          const cdf = asYmd(chosen?.date_from);
          if (cdf && df > cdf) chosen = w;
        }
      }

      let pct = chosen?.erni_pct ?? 0;
      pct = Number(pct) || 0;
      if (pct > 1) pct = pct / 100; // support 15 vs 0.15

      let mult = 1 + pct;
      if (!Number.isFinite(mult) || mult <= 0) mult = 1;

      window.__ERNI_MULT_BY_DATE__[anchorYmd] = mult;

      // keep legacy cache in sync (best-effort)
      window.__ERNI_MULT__ = mult;

      return mult;
    } catch {
      window.__ERNI_MULT__ = 1;
      window.__ERNI_MULT_BY_DATE__ = window.__ERNI_MULT_BY_DATE__ || Object.create(null);
      window.__ERNI_MULT_BY_DATE__[todayIso] = 1;
      return 1;
    }
  }

  async function resolveCoveringWindow(client_id, role, band, active_on){
    try {
      const list = await listClientRates(client_id, { active_on, only_enabled: true });
      const wins  = (Array.isArray(list) ? list.filter(w => !w.disabled_at_utc && w.role === role) : []);
      const filtered = wins;
      let win = filtered.find(w => (w.band ?? null) === (band ?? null));
      if (!win && (band == null)) win = filtered.find(w => w.band == null);
      return win ? {
        charges: { day:win.charge_day??null, night:win.charge_night??null, sat:win.charge_sat??null, sun:win.charge_sun??null, bh:win.charge_bh??null },
        capIso: win.date_to || null
      } : null;
    } catch(e){ L('resolveCoveringWindow err', e); return null; }
  }

  let lastApplyState = null;
  function setApplyEnabled(enabled, reasonSummary){
    // DO NOT directly toggle #btnSave here â€“ leave that to the modal framework
    // via _applyDesired and _updateButtons. We only broadcast the state.
    if (LOG_APPLY && lastApplyState !== enabled) {
      console.log('[RATES][APPLY] state â†’', enabled ? 'ENABLED' : 'DISABLED', reasonSummary || '');
      lastApplyState = enabled;
    }
    try {
      window.dispatchEvent(new CustomEvent('modal-apply-enabled', { detail:{ enabled } }));
    } catch {}
  }

  // ===== driver: recompute state (validations + overlap + preview) =====
  async function recomputeOverrideState(){
    const clientId = byId('cr_client_id')?.value || '';
    const role     = byId('cr_role')?.value || '';
    const bandSel  = byId('cr_band')?.value ?? '';
    const band     = (bandSel === '' ? null : bandSel);
    const isoFrom  = parseUkDateToIso(byId('cr_date_from')?.value || '');
    const isoTo    = parseUkDateToIso(byId('cr_date_to')?.value || '');
    const rateType = String(byId('cr_rate_type')?.value || '').toUpperCase();

    const buckets = ['day','night','sat','sun','bh'];
    const inputEl = (b)=> document.querySelector(`#candRateForm input[name="pay_${b}"]`);
    const slotIn  = (b)=> byId(`slot_input_${b}`);
    const slotPh  = (b)=> byId(`slot_ph_${b}`);

    showInlineError(''); clearAllFieldErrors();
    let canApply = true;

    const need = [];
    if (!clientId) need.push('clientId');
    if (!rateType) need.push('rateType');
    if (!role)     need.push('role');
    if (!isoFrom)  need.push('date_from');
    if (need.length) {
      buckets.forEach(b => {
        const inp = inputEl(b);
        if (inp) { inp.disabled = true; }
        if (slotIn(b)) slotIn(b).style.display = 'none';
        if (slotPh(b)) slotPh(b).style.display = '';
        const sp = byId(`cr_m_${b}`); if (sp) sp.textContent = 'â€”';
      });
      setApplyEnabled(false, 'not_ready');
      return;
    }

    const win = await resolveCoveringWindow(clientId, role, band, isoFrom);
    if (!win) {
      buckets.forEach(b => {
        const inp = inputEl(b);
        if (inp) { inp.disabled = true; }
        if (slotIn(b)) slotIn(b).style.display = 'none';
        if (slotPh(b)) slotPh(b).style.display = '';
        const sp = byId(`cr_m_${b}`); if (sp) sp.textContent = 'â€”';
      });
      showInlineError(`No active client default for <b>${escapeHtml(role)}</b>${band?` / <b>${escapeHtml(band)}</b>`:''} on <b>${formatIsoToUk(isoFrom)}</b>.`);
      setApplyEnabled(false, 'no_cover');
      return;
    }

    buckets.forEach(b => {
      const hasCharge = (win.charges[b] != null);
      const inp = inputEl(b);
      if (hasCharge) {
        if (slotPh(b)) slotPh(b).style.display = 'none';
        if (slotIn(b)) slotIn(b).style.display = '';
        if (inp) inp.disabled = false;
      } else {
        if (slotIn(b)) slotIn(b).style.display = 'none';
        if (slotPh(b)) slotPh(b).style.display = '';
        if (inp) { inp.value = ''; inp.disabled = true; }
      }
    });

    const mult = await _erniMultiplier(isoFrom, isoTo);

    const invalid = [];
    buckets.forEach(b => {
      const el  = inputEl(b), chg = win.charges[b];
      if (!el || el.disabled) return;
      const pay = numOrNull(el.value);
      if (pay != null && chg == null) { invalid.push(b); setFieldError(b, `No client charge for ${bucketLabel[b]}.`); }
    });
    if (invalid.length) canApply = false;

    const neg = [];
    buckets.forEach(b => {
      const el  = inputEl(b), chg = win.charges[b];
      if (!el || el.disabled) return;
      const pay = numOrNull(el.value);
      if (pay == null || chg == null) return;
      const m = (rateType === 'PAYE') ? (chg - (pay * mult)) : (chg - pay);
      if (m < 0) { neg.push(b); setFieldError(b, `Margin would be negative for ${bucketLabel[b]}.`); }
    });
    if (neg.length) canApply = false;

    setDateToError('');
    if (isoTo && win.capIso && isoTo > win.capIso) {
      setDateToError(`Client rate ends on ${formatIsoToUk(win.capIso)} â€” override must end on/before this date.`);
      canApply = false;
    }

    const O = window.modalCtx.overrides || { existing: [], stagedNew: [], stagedEdits: {}, stagedDeletes: new Set() };
    const deletedIds = O.stagedDeletes || new Set();
    const unify = [];
    (O.existing||[]).forEach(ex => { if (!deletedIds.has(ex.id)) unify.push({ ...(ex||{}), ...(O.stagedEdits?.[ex.id]||{}) }); });
    (O.stagedNew||[]).forEach(n => unify.push({ ...(n||{}) }));

    const sameKey = (o) =>
      String(o.client_id||'') === clientId &&
      String(o.role||'')      === role &&
      String((o.rate_type||'').toUpperCase()) === rateType &&
      String(o.band??'')      === String(band??'');

    const isSelf = (o) => {
      if (!existing) return false;
      if (existing.id && o.id) return String(o.id) === String(existing.id);
      if (existing._tmpId && o._tmpId) return String(o._tmpId) === String(existing._tmpId);
      return false;
    };

    const conflicts = unify.filter(o => sameKey(o) && !isSelf(o) &&
      !((o.date_to||'9999-12-31') < (isoFrom||'0000-01-01') || (isoTo||'9999-12-31') < (o.date_from||'0000-01-01')));

    if (conflicts.length) {
      canApply = false;
      const ov = conflicts[0];
      const cutThis  = (()=>{ const d=new Date((ov.date_from||'')+'T00:00:00Z'); if(!isNaN(d)) d.setUTCDate(d.getUTCDate()-1); return isNaN(d)?null:`${d.getUTCFullYear()}-${String(d.getUTCMonth()+1).padStart(2,'0')}-${String(d.getUTCDate()).padStart(2,'0')}`; })();
      const cutOther = (()=>{ const d=new Date((isoFrom||'')+'T00:00:00Z'); if(!isNaN(d)) d.setUTCDate(d.getUTCDate()-1); return isNaN(d)?null:`${d.getUTCFullYear()}-${String(d.getUTCMonth()+1).padStart(2,'0')}-${String(d.getUTCDate()).padStart(2,'0')}`; })();

      let fixButtons = '';
      if (cutThis)  fixButtons += `<button id="cr_fix_this"  class="btn mini" style="margin-right:8px">Fix: Shorten <b>THIS</b> to ${formatIsoToUk(cutThis)}</button>`;
      if (cutOther) fixButtons += `<button id="cr_fix_other" class="btn mini">Fix: Shorten <b>OTHER</b> to ${formatIsoToUk(cutOther)}</button>`;

      showInlineError(`
        <div style="font-weight:700;margin-bottom:6px">Overlap detected</div>
        <div style="margin-bottom:8px">Another rate card exists in this category.<br/><span class="hint">Use Fix or adjust dates.</span></div>
        <div>${fixButtons || '<i>No safe automatic fix available.</i>'}</div>
      `);

      setTimeout(()=> {
        const inTo = byId('cr_date_to');
        const fixThis = byId('cr_fix_this');
        if (fixThis && cutThis) fixThis.onclick = ()=> { inTo.value = formatIsoToUk(cutThis); recomputeOverrideState(); };
        const fixOther = byId('cr_fix_other');
        if (fixOther && cutOther) fixOther.onclick = ()=> {
          try {
            const target = conflicts[0];
            const O2 = window.modalCtx.overrides || { existing: [], stagedNew: [], stagedEdits: {}, stagedDeletes: new Set() };
            if (target.id) {
              O2.stagedEdits[target.id] = { ...(O2.stagedEdits[target.id]||{}), date_to: cutOther };
            } else if (target._tmpId) {
              const ix = (O2.stagedNew||[]).findIndex(r=>r._tmpId===target._tmpId);
              if (ix>=0) O2.stagedNew[ix] = { ...O2.stagedNew[ix], date_to: cutOther };
            }
            renderCandidateRatesTable();
            recomputeOverrideState();
          } catch(e){ L('fixOther failed', e); }
        };
      }, 0);
    }

    // Preview margins (never NaN)
    const mult2 = mult;
    buckets.forEach(b => {
      const sp  = byId(`cr_m_${b}`), el = inputEl(b), chg = win.charges[b];
      const pay = (el && !el.disabled) ? numOrNull(el.value) : null;
      const m   = (chg != null && pay != null) ? ((rateType === 'PAYE') ? (chg - (pay * mult2)) : (chg - pay)) : null;
      if (sp) sp.textContent = (m==null ? 'â€”' : fmt(m));
    });

    if (LOG_APPLY) console.log('[RATES][APPLY] canApply?', canApply, { clientId, role, band, isoFrom, isoTo, rateType });
    setApplyEnabled(canApply, canApply ? 'ok' : 'violations');
  }

  showModal(
    existing ? 'Edit Candidate Rate Override' : 'Add Candidate Rate Override',
    [{ key:'form', label:'Form' }],
    () => formHtml,
    async () => {
      await recomputeOverrideState();
      if (lastApplyState === false) { L('Apply blocked by recompute'); return false; }

      const raw = collectForm('#candRateForm');
      LG('Apply collected form', raw);

      const client_id = (raw.client_id || '').trim();
      const role      = (raw.role || '').trim();
      const band      = (raw.band || '').trim() || null;
      const rate_type = String(raw.rate_type || '').toUpperCase();

      const date_from = parseUkDateToIso(raw.date_from);
      const date_to   = raw.date_to ? parseUkDateToIso(raw.date_to) : null;

      const mapPay = (k) => (Object.prototype.hasOwnProperty.call(raw, k) && raw[k] !== '' ? Number(raw[k]) : null);

      const stagedAll = {
        id: existing?.id,
        candidate_id,
        client_id,
        role, band, rate_type,
        date_from, date_to,
        pay_day   : mapPay('pay_day'),
        pay_night : mapPay('pay_night'),
        pay_sat   : mapPay('pay_sat'),
        pay_sun   : mapPay('pay_sun'),
        pay_bh    : mapPay('pay_bh')
      };

      const O = (window.modalCtx.overrides ||= { existing: [], stagedNew: [], stagedEdits: {}, stagedDeletes: new Set() });
      LG('STAGING before', { existing: (O.existing||[]).length, stagedNew:(O.stagedNew||[]).length, stagedEdits:Object.keys(O.stagedEdits||{}).length, stagedDeletes: O.stagedDeletes?.size || 0 });

      if (existing?.id) {
        O.stagedEdits[existing.id] = { ...(O.stagedEdits[existing.id]||{}), ...stagedAll };
      } else if (existing && !existing.id) {
        const tmpId = existing._tmpId || null;
        const idx   = tmpId ? (O.stagedNew||[]).findIndex(r => r._tmpId === tmpId) : -1;
        if (idx >= 0) O.stagedNew[idx] = { ...O.stagedNew[idx], ...stagedAll, _tmpId: tmpId };
        else          O.stagedNew.push({ ...stagedAll, _tmpId: tmpId || `tmp_${Date.now()}` });
      } else {
        O.stagedNew.push({ ...stagedAll, _tmpId: `tmp_${Date.now()}` });
      }

      LG('STAGING after', {
        existing: (O.existing||[]).length,
        stagedNew:(O.stagedNew||[]).length,
        stagedEdits:Object.keys(O.stagedEdits||{}).length,
        stagedDeletes: O.stagedDeletes?.size || 0,
        peekNew: (O.stagedNew||[])[(O.stagedNew||[]).length-1]
      });

      try { await renderCandidateRatesTable(); } catch {}
      try { window.dispatchEvent(new CustomEvent('modal-dirty')); } catch {}
      return true;
    },
    false,
    () => {
      const parent = _currentFrame();
      if (parent) { parent.currentTabKey = 'rates'; parent.setTab('rates'); }
    },
    { kind: 'candidate-override' }
  );

  // ===== prefill & wire =====
  const selClient = byId('cr_client_id');
  const selRateT  = byId('cr_rate_type');
  const selRole   = byId('cr_role');
  const selBand   = byId('cr_band');
  const inFrom    = byId('cr_date_from');
  const inTo      = byId('cr_date_to');

  if (initialClientId) selClient.value = initialClientId;
  if (existing?.date_from) inFrom.value = formatIsoToUk(existing.date_from);
  if (existing?.date_to)   inTo.value   = formatIsoToUk(existing.date_to);

  // Prefill ALL buckets that have values (2dp)
  ['day','night','sat','sun','bh'].forEach(b=>{
    const val = (existing && Number.isFinite(existing[`pay_${b}`])) ? existing[`pay_${b}`] : null;
    const el  = document.querySelector(`#candRateForm input[name="pay_${b}"]`);
    if (el && val != null) {
      const num = Number(val);
      el.value = Number.isFinite(num) ? (Math.round(num*100)/100).toFixed(2) : String(val);
    }
  });

  attachUkDatePicker(inFrom); attachUkDatePicker(inTo);

  async function refreshClientRoles(clientId) {
    selRole.innerHTML = `<option value="">Select roleâ€¦</option>`; selRole.disabled = true;
    selBand.innerHTML = `<option value=""></option>`;             selBand.disabled  = true;

    if (!clientId) { setApplyEnabled(false, 'no_client'); return; }

    const active_on = parseUkDateToIso(inFrom.value || '') || null;
    const list  = await listClientRates(clientId, { active_on, only_enabled: true }).catch(_=>[]);
    const wins  = (Array.isArray(list) ? list.filter(w => !w.disabled_at_utc) : []);
    const roles = new Set(); const bandsByRole = {};
    wins.forEach(w => {
      if (!w.role) return;
      roles.add(w.role);
      (bandsByRole[w.role] ||= new Set()).add(w.band==null ? '' : String(w.band));
    });

    const allowed = [...roles].sort((a,b)=> a.localeCompare(b));
    selRole.innerHTML = `<option value="">Select roleâ€¦</option>` + allowed.map(code => `<option value="${code}">${code}</option>`).join('');
    selRole.disabled = !parentEditable;

    // Choose a role in this order:
    // 1) currentRole if still valid
    // 2) existing.role if still valid
    // 3) blank
    let chosenRole = '';
    if (currentRole && allowed.includes(currentRole)) {
      chosenRole = currentRole;
    } else if (existing?.role && allowed.includes(existing.role)) {
      chosenRole = existing.role;
    }

    if (chosenRole) {
      selRole.value = chosenRole;
      currentRole = chosenRole;

      const bandSet = [...(bandsByRole[chosenRole] || new Set())];
      const hasNull = bandSet.includes('');
      selBand.innerHTML =
        (hasNull ? `<option value="">(none)</option>` : '') +
        bandSet
          .filter(b=>b!=='')
          .sort((a,b)=> String(a).localeCompare(String(b)))
          .map(b => `<option value="${b}">${b}</option>`).join('');
      selBand.disabled = !parentEditable;

      // Pick band: prefer currentBand if still valid; else existing.band
      let desiredBand = '';
      if (currentBand && bandSet.includes(currentBand)) {
        desiredBand = currentBand;
      } else if (existing && existing.band != null) {
        const asStr = String(existing.band);
        if (bandSet.includes(asStr)) desiredBand = asStr;
      }

      if (desiredBand && bandSet.includes(desiredBand)) {
        selBand.value = desiredBand;
        currentBand = desiredBand;
      } else {
        // leave at (none)
        currentBand = '';
      }
    } else {
      selBand.innerHTML = `<option value=""></option>`;
      selBand.disabled  = true;
      currentRole = '';
      currentBand = '';
    }

    await recomputeOverrideState();
  }

  selClient.addEventListener('change', async () => {
    L('[EVENT] client change');
    if (parentEditable) {
      currentRole = ''; // changing client invalidates previous role
      currentBand = '';
      await refreshClientRoles(selClient.value);
    }
  });
  selRateT .addEventListener('change',        () => {
    L('[EVENT] rate_type change');
    if (parentEditable) recomputeOverrideState();
  });
  inFrom   .addEventListener('change',  async () => {
    L('[EVENT] date_from change');
    if (parentEditable) {
      // date change may change which client windows apply, but we keep role/band if still valid
      await refreshClientRoles(selClient.value);
    }
  });
  selRole  .addEventListener('change',  async () => {
    L('[EVENT] role change');
    if (!parentEditable) return;
    currentRole = selRole.value || '';
    // changing role recalculates margins
    await recomputeOverrideState();
  });
  selBand  .addEventListener('change',        () => {
    L('[EVENT] band change');
    if (!parentEditable) return;
    currentBand = selBand.value || '';
    recomputeOverrideState();
  });
  ['pay_day','pay_night','pay_sat','pay_sun','pay_bh'].forEach(n=>{
    const el = document.querySelector(`#candRateForm input[name="${n}"]`);
    if (el) el.addEventListener('input', () => {
      if (LOG_APPLY) console.log('[RATES][EVENT] pay change', n, el.value);
      recomputeOverrideState();
    });
  });

  // Initial state: if there is a client, load its roles, otherwise just compute state
  if (initialClientId) {
    await refreshClientRoles(initialClientId);
  } else {
    await recomputeOverrideState();
  }

  (function wireDeleteButton(){
    const delBtn = byId('btnDelete');
    if (!delBtn) return;
    if (!existing || !existing.id) { delBtn.style.display='none'; return; }
    delBtn.style.display = '';
    delBtn.disabled = false;
    delBtn.onclick = () => {
      try {
        const O = (window.modalCtx.overrides ||= { existing: [], stagedNew: [], stagedEdits: {}, stagedDeletes: new Set() });
        (O.stagedDeletes ||= new Set()).add(existing.id);
        L('staged delete', { id: existing.id, size: O.stagedDeletes.size });
        try { renderCandidateRatesTable(); } catch {}
        try { window.dispatchEvent(new CustomEvent('modal-dirty')); } catch {}
        const closeBtn = byId('btnCloseModal'); if (closeBtn) closeBtn.click();
      } catch (e) { L('stage delete failed', e); }
    };
  })();
}


// ---- Client modal

// =========================== openClient (FIXED) ==========================
// =================== CLIENT MODAL (UPDATED: rates rate_type + hospitals staged-CRUD) ===================
// âœ… UPDATED â€” unified FE model; on load, convert server rows to unified; on save, validate overlaps, bridge to per-type API

// ================== FRONTEND: openClient (UPDATED) ==================
// ================== FIXED: openClient (hydrate before showModal) ==================
// ================== FIXED: openClient (hydrate before showModal) ==================

// ============================================================================
// OPEN CLIENT (parent modal) â€” skip posting disabled windows on Save
// (No delete button is added here; ensure any existing parent delete UI is removed elsewhere.)
// ============================================================================

// =================== CLIENT RATES TABLE (UPDATED) ===================
// âœ… UPDATED â€” unified table view, dbl-click opens unified modal
// ============================================================================
// RENDER CLIENT RATES TABLE (adds "Status" col; shows disabled who/when)
// ============================================================================



// Now shows derived PAYE & Umbrella margins per bucket in the table
async function openClient(row) {
  // ===== Logging helpers (toggle with window.__LOG_MODAL = true/false) =====
  const LOG = (typeof window.__LOG_MODAL === 'boolean') ? window.__LOG_MODAL : true;
  const APILOG = (typeof window !== 'undefined' && !!window.__LOG_API) || (typeof __LOG_API !== 'undefined' && !!__LOG_API);
  const L  = (...a)=> { if (LOG) console.log('[OPEN_CLIENT]', ...a); };
  const W  = (...a)=> { if (LOG) console.warn('[OPEN_CLIENT]', ...a); };
  const E  = (...a)=> { if (LOG) console.error('[OPEN_CLIENT]', ...a); };

  const deep = (o)=> JSON.parse(JSON.stringify(o || {}));
  const incoming = deep(row || {});
  const seedId   = incoming?.id || null;

  L('ENTRY', { incomingKeys: Object.keys(incoming||{}), seedId });

  const unwrapSingle = (data, key) => {
    if (Array.isArray(data)) return data[0] || null;
    if (data && key && data[key]) return unwrapSingle(data[key], null);
    if (data && Array.isArray(data.rows))  return data.rows[0]  || null;
    if (data && Array.isArray(data.items)) return data.items[0] || null;
    if (data && Array.isArray(data.data))  return data.data[0]  || null;
    return (data && typeof data === 'object') ? data : null;
  };

  // 1) Hydrate full client if we have an id
  let full = incoming;
  let settingsSeed = null;
  if (seedId) {
    try {
      const url = API(`/api/clients/${encodeURIComponent(seedId)}`);
      L('[HTTP] GET', url);
      const r = await authFetch(url);
      L('[HTTP] status', r?.status, r?.ok);

      try {
        const raw = await r.clone().text();
        if (LOG) console.debug('[HTTP] raw body (â‰¤2KB):', raw.slice(0, 2048));
      } catch (peekErr) { W('[HTTP] raw peek failed', peekErr?.message || peekErr); }
      if (r.ok) {
        const data = await r.json().catch(()=> ({}));

        const clientObj = data?.client || unwrapSingle(data, 'client') || null;

        // âœ… Robust: support multiple response shapes:
        // - { client_settings: {...} }
        // - { settings: {...} }
        // - { client: { ..., client_settings: {...} } }
        // - { client: { ... }, client_settings: { ... } }
        const settingsObj =
          data?.client_settings ||
          data?.settings ||
          clientObj?.client_settings ||
          data?.client?.client_settings ||
          null;

        settingsSeed = (settingsObj && typeof settingsObj === 'object') ? deep(settingsObj) : null;

        full = clientObj || incoming;

        L('hydrated JSON keys', Object.keys(data||{}), 'client keys', Object.keys(clientObj||{}), 'hasSettingsSeed', !!settingsSeed);
      } else {
        W('non-OK response, using incoming row');
      }

    } catch (e) {
      W('openClient hydrate failed; using summary row', e);
    }
  } else {
    L('no seedId â€” create mode');
  }

  // 2) Seed modal context
  const fullKeys = Object.keys(full || {});
  L('seeding window.modalCtx', { entity: 'clients', fullId: full?.id, fullKeys });

  window.modalCtx = {
    entity: 'clients',
    data: deep(full),
    formState: { __forId: full?.id || null, main: {} },
    ratesState: [],
    ratesBaseline: [],
    hospitalsState: { existing: [], stagedNew: [], stagedEdits: {}, stagedDeletes: new Set() },

    // âœ… NEW: keep an immutable DB baseline (used for comparisons / â€œsnap backâ€ safety)
    clientSettingsBaseline: settingsSeed ? deep(settingsSeed) : {},

    // âœ… State used by UI for edits (starts as DB snapshot)
    clientSettingsState: settingsSeed ? deep(settingsSeed) : {},

    openToken: ((full?.id) || 'new') + ':' + Date.now(),
    // NEW: persistent set for staged client-rate deletes (survives refresh/merge)
    ratesStagedDeletes: (window.modalCtx && window.modalCtx.ratesStagedDeletes instanceof Set)
      ? window.modalCtx.ratesStagedDeletes
      : new Set()
  };

  // Canonicalise immediately so UI always starts in a consistent state
  // âœ… Preserve manual-invoice routing + auto-invoice + new invoicing/ref-to-issue fields
  try {
    const cs0 = window.modalCtx.clientSettingsState || {};

    const keepAutoInv     = !!cs0.auto_invoice_default;
    const keepManualFlag  = !!cs0.send_manual_invoices_to_different_email;
    const keepManualEmail = String(cs0.manual_invoices_alt_email_address || '').trim();

    // âœ… preserve these fields even if canonicalize strips unknown keys
    const keepInvConsol =
      (cs0.invoice_consolidation_mode != null) ? String(cs0.invoice_consolidation_mode) : '';
    const keepRefToIssue = (() => {
      const v = cs0.reference_number_required_to_issue_invoice;
      if (typeof v === 'boolean') return v;
      if (v === 1 || v === '1') return true;
      const s = String(v ?? '').trim().toLowerCase();
      if (s === 'true' || s === 't' || s === 'yes' || s === 'y' || s === 'on') return true;
      return false;
    })();

    window.modalCtx.clientSettingsState = canonicalizeClientSettings(cs0 || {});

    window.modalCtx.clientSettingsState.auto_invoice_default = keepAutoInv;
    window.modalCtx.clientSettingsState.send_manual_invoices_to_different_email = keepManualFlag;
    window.modalCtx.clientSettingsState.manual_invoices_alt_email_address = keepManualFlag ? keepManualEmail : '';

    // âœ… restore new fields after canonicalize
    if (keepInvConsol != null && String(keepInvConsol).trim() !== '') {
      window.modalCtx.clientSettingsState.invoice_consolidation_mode = String(keepInvConsol).trim();
    }
    window.modalCtx.clientSettingsState.reference_number_required_to_issue_invoice = !!keepRefToIssue;
  } catch {}

  L('window.modalCtx seeded', {
    entity: window.modalCtx.entity,
    dataId: window.modalCtx.data?.id,
    dataKeys: Object.keys(window.modalCtx.data||{}),
    formStateForId: window.modalCtx.formState?.__forId,
    openToken: window.modalCtx.openToken,
    preseededSettings: Object.keys(window.modalCtx.clientSettingsState||{})
  });

  // 3) Render modal
  L('calling showModal with hasId=', !!full?.id, 'rawHasIdArg=', full?.id);
  showModal(
    'Client',
    [
      {key:'main',     label:'Main'},
      {key:'rates',    label:'Care Package Rates'},
      {key:'settings', label:'Client settings'},
      {key:'hospitals',label:'Hospitals & wards'}
    ],
    (k, r) => { L('[renderClientTab] tab=', k, 'rowKeys=', Object.keys(r||{}), 'sample=', { name: r?.name, id: r?.id }); return renderClientTab(k, r); },
    async ()=> {
      L('[onSave] begin', { dataId: window.modalCtx?.data?.id, forId: window.modalCtx?.formState?.__forId });
      const isNew = !window.modalCtx?.data?.id;

      // Collect "main" form
      const fs = window.modalCtx.formState || { __forId: null, main:{} };
      const hasId = !!window.modalCtx.data?.id;
      const same = hasId ? (fs.__forId === window.modalCtx.data.id)
                         : (fs.__forId === window.modalCtx.openToken || fs.__forId == null);

      const stagedMain = same ? (fs.main || {}) : {};
      const liveMain   = byId('tab-main') ? collectForm('#tab-main') : {};
      const payload    = { ...stagedMain, ...liveMain };

      L('[onSave] collected', { same, stagedKeys: Object.keys(stagedMain||{}), liveKeys: Object.keys(liveMain||{}) });

      delete payload.but_let_cli_ref;
      if (!payload.name && full?.name) payload.name = full.name;

      // Validate client main tab
      const clientValid = validateClientMain(payload);
      if (!clientValid) {
        return { ok:false };
      }

      // Settings normalization (including BH hours)
      const baseline = window.modalCtx.clientSettingsState || {};
      const hasFormMounted = !!byId('clientSettingsForm');
      const hasFullBaseline = ['day_start','day_end','night_start','night_end'].every(k => typeof baseline[k] === 'string' && baseline[k] !== '');

      const hasClientSettingsKeys =
        Object.prototype.hasOwnProperty.call(baseline, 'send_manual_invoices_to_different_email') ||
        Object.prototype.hasOwnProperty.call(baseline, 'manual_invoices_alt_email_address') ||
        Object.prototype.hasOwnProperty.call(baseline, 'auto_invoice_default') ||
        Object.prototype.hasOwnProperty.call(baseline, 'invoice_consolidation_mode') ||
        Object.prototype.hasOwnProperty.call(baseline, 'reference_number_required_to_issue_invoice');

      const shouldValidateSettings = hasFormMounted || hasFullBaseline || hasClientSettingsKeys;

      let pendingSettings = null;

      // âœ… NEW: capture client-level ts_queries_email from settings tab if present (HealthRoster VERIFY)
      // Do NOT overwrite unless the field is present in the mounted form.
      if (hasFormMounted) {
        try {
          const liveSettingsPeek = collectForm('#clientSettingsForm', false);
          if (liveSettingsPeek && Object.prototype.hasOwnProperty.call(liveSettingsPeek, 'ts_queries_email')) {
            const v = String(liveSettingsPeek.ts_queries_email ?? '').trim();
            // keep as '' if blank => upsertClient will translate to null and clear
            payload.ts_queries_email = v;
          }
        } catch {}
      }

      if (shouldValidateSettings) {
        let csMerged = { ...(baseline || {}) };

        if (hasFormMounted) {
          const formEl = byId('clientSettingsForm');
          const liveSettings = collectForm('#clientSettingsForm', false);

          const normKeys = ['day_start','day_end','night_start','night_end','sat_start','sat_end','sun_start','sun_end','bh_start','bh_end'];

          // âœ… merge time fields INCLUDING blanks so clears propagate ('' â†’ null in normalizeClientSettingsForSave)
          normKeys.forEach(k => {
            if (!Object.prototype.hasOwnProperty.call(liveSettings, k)) return;
            const v = liveSettings[k];
            csMerged[k] = (v == null) ? '' : String(v).trim(); // keep '' to mean â€œclearâ€
          });

          // âœ… timezone_id (allow clearing)
          if (Object.prototype.hasOwnProperty.call(liveSettings, 'timezone_id')) {
            const tz = liveSettings.timezone_id;
            csMerged.timezone_id = (tz == null) ? '' : String(tz).trim(); // '' â†’ null in normalizeClientSettingsForSave
          }

          // âœ… week ending day (0 is valid; do NOT use || '')
          if (Object.prototype.hasOwnProperty.call(liveSettings, 'week_ending_weekday')) {
            const raw = liveSettings.week_ending_weekday;
            csMerged.week_ending_weekday =
              (raw === '' || raw === null || raw === undefined) ? null : String(raw).trim();
          }

          // default submission mode
          if (typeof liveSettings.default_submission_mode !== 'undefined') {
            csMerged.default_submission_mode = String(liveSettings.default_submission_mode || '').trim();
          }

          // Weekly mode radios (UI helper keys)
          if (formEl) {
            const wm = formEl.querySelector('input[type="radio"][name="weekly_mode"]:checked');
            const hp = formEl.querySelector('input[type="radio"][name="hr_weekly_behaviour"]:checked');
            if (wm) csMerged.weekly_mode = String(wm.value || '').trim();
            if (hp) csMerged.hr_weekly_behaviour = String(hp.value || '').trim();

            // âœ… invoice consolidation mode radio (DB-backed)
            const icm = formEl.querySelector('input[type="radio"][name="invoice_consolidation_mode"]:checked');
            if (icm) csMerged.invoice_consolidation_mode = String(icm.value || '').trim();

            // Checkboxes that may be present depending on gate
            const BOOL_KEYS = [
              'pay_reference_required',
              'invoice_reference_required',
              'self_bill_no_invoices_sent',
              'daily_calc_of_invoices',
              'group_nightsat_sunbh',
              'auto_invoice_default',
              'hr_attach_to_invoice',
              'ts_attach_to_invoice',
              'send_manual_invoices_to_different_email',
              'reference_number_required_to_issue_invoice'
            ];
            csMerged.__from_ui = true;
            for (const key of BOOL_KEYS) {
              const el = formEl.querySelector(`input[type="checkbox"][name="${key}"]`);
              if (el) csMerged[key] = !!el.checked;
            }

            // manual invoices alt email input
            if (Object.prototype.hasOwnProperty.call(liveSettings, 'manual_invoices_alt_email_address')) {
              csMerged.manual_invoices_alt_email_address = String(liveSettings.manual_invoices_alt_email_address || '').trim();
            }
            if (!csMerged.send_manual_invoices_to_different_email) {
              csMerged.manual_invoices_alt_email_address = '';
            }
          }
        }

        const keepManualFlag  = !!csMerged.send_manual_invoices_to_different_email;
        const keepManualEmail = String(csMerged.manual_invoices_alt_email_address || '').trim();
        const keepAutoInv     = !!csMerged.auto_invoice_default;

        const keepInvConsol = (csMerged.invoice_consolidation_mode != null) ? String(csMerged.invoice_consolidation_mode) : '';
        const keepRefToIssue = !!csMerged.reference_number_required_to_issue_invoice;

        try {
          csMerged = canonicalizeClientSettings(csMerged);
        } catch {}

        csMerged.auto_invoice_default = keepAutoInv;
        csMerged.send_manual_invoices_to_different_email = keepManualFlag;
        csMerged.manual_invoices_alt_email_address = keepManualFlag ? keepManualEmail : '';

        if (keepInvConsol != null && String(keepInvConsol).trim() !== '') {
          csMerged.invoice_consolidation_mode = String(keepInvConsol).trim();
        }
        csMerged.reference_number_required_to_issue_invoice = !!keepRefToIssue;

        if (csMerged.send_manual_invoices_to_different_email) {
          const em = String(csMerged.manual_invoices_alt_email_address || '').trim();
          if (!em) {
            alert('Manual invoices alternate email address is required when "Send manual invoices to different email" is enabled.');
            return { ok:false };
          }
          csMerged.manual_invoices_alt_email_address = em;
        } else {
          csMerged.manual_invoices_alt_email_address = '';
        }

        const toHHMM = (v) => {
          if (v == null) return '';
          const s = String(v).trim();
          const m = s.match(/^(\d{2}:\d{2})/);
          return m ? m[1] : s;
        };
        const TIME_KEYS = ['day_start','day_end','night_start','night_end','sat_start','sat_end','sun_start','sun_end','bh_start','bh_end'];
        TIME_KEYS.forEach(k => {
          if (!Object.prototype.hasOwnProperty.call(csMerged, k)) return;
          const raw = csMerged[k];
          if (raw === '' || raw == null) return;
          csMerged[k] = toHHMM(raw);
        });

        const { cleaned: csCleanRaw, invalid: csInvalid } = normalizeClientSettingsForSave(csMerged);

        const csClean = { ...(csCleanRaw || {}) };
        delete csClean.weekly_mode;
        delete csClean.hr_weekly_behaviour;
        delete csClean.__from_ui;

        csClean.send_manual_invoices_to_different_email = !!csMerged.send_manual_invoices_to_different_email;
        csClean.manual_invoices_alt_email_address =
          csClean.send_manual_invoices_to_different_email
            ? (String(csMerged.manual_invoices_alt_email_address || '').trim() || null)
            : null;

        csClean.auto_invoice_default = !!csMerged.auto_invoice_default;

        csClean.invoice_consolidation_mode = String(csMerged.invoice_consolidation_mode || '').trim() || 'NONE';
        csClean.reference_number_required_to_issue_invoice = !!csMerged.reference_number_required_to_issue_invoice;

        if (APILOG) console.log('[OPEN_CLIENT] client_settings (mergedâ†’canonâ†’clean)', { csMerged, csClean, csInvalid, hasFormMounted, hasFullBaseline });
        if (csInvalid) { alert('Times must be HH:MM (24-hour).'); return { ok:false }; }

        if (Object.keys(csClean).length) pendingSettings = csClean;

        try { window.modalCtx.clientSettingsState = { ...(window.modalCtx.clientSettingsState || {}), ...csMerged }; } catch {}
      }

      // 3) Upsert client
      const idForUpdate = window.modalCtx?.data?.id || full?.id || null;
      if (APILOG) console.log('[OPEN_CLIENT] upsertClient â†’ request', { idForUpdate, payload });

      delete payload.client_settings;

      const clientResp  = await upsertClient(payload, idForUpdate).catch(err => { E('upsertClient failed', err); return null; });
      const clientId    = idForUpdate || (clientResp && clientResp.id);
      if (APILOG) console.log('[OPEN_CLIENT] upsertClient â† response', { ok: !!clientResp, clientId });
      if (!clientId) { alert('Failed to save client'); return { ok:false }; }

      const savedClient = clientResp && typeof clientResp === 'object' ? clientResp : { id: clientId, ...payload };
      window.modalCtx.data = { ...(window.modalCtx.data || {}), ...savedClient, id: clientId };

      // 4) Save Client settings (after client exists)
      try {
        if (pendingSettings && Object.keys(pendingSettings).length) {
          if (APILOG) console.log('[OPEN_CLIENT] upsertClient (settings) â†’ PUT /api/clients/:id', { clientId, pendingSettings });
          const upd = await upsertClient({ client_settings: pendingSettings }, clientId);
          if (!upd) throw new Error('Settings update failed');
          if (upd && typeof upd === 'object') window.modalCtx.data = { ...window.modalCtx.data, ...upd, id: clientId };
        }
      } catch (err) {
        alert(`Failed to save Client settings: ${String(err?.message || err)}`);
        return { ok:false };
      }

      // 5) Hospitals CRUD (typed-safe; skip when no staged changes)
      try {
        const hsRaw = window.modalCtx.hospitalsState || {};
        const hs = {
          existing     : Array.isArray(hsRaw.existing) ? hsRaw.existing : [],
          stagedNew    : Array.isArray(hsRaw.stagedNew) ? hsRaw.stagedNew : [],
          stagedEdits  : (hsRaw.stagedEdits && typeof hsRaw.stagedEdits === 'object') ? hsRaw.stagedEdits : {},
          stagedDeletes: (hsRaw.stagedDeletes instanceof Set)
            ? hsRaw.stagedDeletes
            : new Set(Array.isArray(hsRaw.stagedDeletes) ? hsRaw.stagedDeletes : Object.keys(hsRaw.stagedDeletes || {}))
        };

        const hasDel   = hs.stagedDeletes.size > 0;
        const hasEdits = Object.keys(hs.stagedEdits).length > 0;
        const hasNew   = hs.stagedNew.length > 0;

        if (hasDel || hasEdits || hasNew) {
          if (hasDel) {
            for (const hid of hs.stagedDeletes) {
              const url = API(`/api/clients/${encodeURIComponent(clientId)}/hospitals/${encodeURIComponent(hid)}`);
              if (APILOG) console.log('[OPEN_CLIENT] DELETE hospital â†’', url);
              const res = await authFetch(url, { method: 'DELETE' });
              if (!res.ok) throw new Error(await res.text());
            }
          }

          if (hasEdits) {
            for (const [hid, patchRaw] of Object.entries(hs.stagedEdits)) {
              const patch = {};
              if (patchRaw && Object.prototype.hasOwnProperty.call(patchRaw,'hospital_name_norm')) {
                const name = String(patchRaw.hospital_name_norm || '').trim();
                if (!name) throw new Error('Hospital name cannot be blank.');
                patch.hospital_name_norm = name;
              }
              if (patchRaw && Object.prototype.hasOwnProperty.call(patchRaw,'ward_hint')) {
                const hint = String(patchRaw.ward_hint ?? '').trim();
                patch.ward_hint = hint === '' ? null : hint;
              }
              if (Object.keys(patch).length === 0) continue;
              const url = API(`/api/clients/${encodeURIComponent(clientId)}/hospitals/${encodeURIComponent(hid)}`);
              if (APILOG) console.log('[OPEN_CLIENT] PATCH hospital â†’', url, patch);
              const res = await authFetch(url, { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(patch) });
              if (!res.ok) throw new Error(await res.text());
            }
          }

          if (hasNew) {
            for (const n of hs.stagedNew) {
              const body = { hospital_name_norm: String(n?.hospital_name_norm || '').trim(), ward_hint: (String(n?.ward_hint ?? '').trim() || null) };
              if (!body.hospital_name_norm) throw new Error('Hospital name cannot be blank.');
              const url = API(`/api/clients/${encodeURIComponent(clientId)}/hospitals`);
              if (APILOG) console.log('[OPEN_CLIENT] POST hospital â†’', url, body);
              const res = await authFetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
              if (!res.ok) throw new Error(await res.text());
            }
          }

          window.modalCtx.hospitalsState.stagedDeletes = new Set();
          window.modalCtx.hospitalsState.stagedEdits   = {};
          window.modalCtx.hospitalsState.stagedNew     = [];

          try {
            const fresh = await listClientHospitals(clientId);
            window.modalCtx.hospitalsState.existing = Array.isArray(fresh) ? fresh : [];
            try { renderClientHospitalsTable(); } catch {}
          } catch (e) {
            W('[OPEN_CLIENT] hospitals refresh failed', e);
          }
        }
      } catch (err) {
        alert(`Failed to save Hospitals & wards: ${String(err?.message || err)}`);
        return { ok:false };
      }

      // 6) DELETE staged client windows BEFORE toggles/edits/inserts
      try {
        const allWindows = Array.isArray(window.modalCtx.ratesState) ? window.modalCtx.ratesState : [];
        L('[onSave] delete phase', { windows: allWindows.length, stagedDeleteSet: window.modalCtx.ratesStagedDeletes?.size || 0 });
        const setIds = (window.modalCtx.ratesStagedDeletes instanceof Set) ? new Set([...window.modalCtx.ratesStagedDeletes]) : new Set();
        for (const w of allWindows) if (w && w.id && w.__delete === true) setIds.add(String(w.id));

        if (setIds.size) {
          if (APILOG) console.log('[OPEN_CLIENT] deleting staged client windows', [...setIds]);
          for (const id of setIds) {
            const url = API(`/api/rates/client-defaults/${encodeURIComponent(id)}`);
            const res = await authFetch(url, { method: 'DELETE' });
            if (res.status === 404) continue;
            if (!res.ok) {
              const body = await res.text().catch(()=> '');
              if (res.status === 409) alert(`Delete blocked: ${body || 'Associated data prevents deletion.'}`);
              else alert(`Failed to delete client rate window: ${body || res.status}`);
              return { ok:false };
            }
          }
          window.modalCtx.ratesState    = allWindows.filter(w => !(w && w.id && setIds.has(String(w.id))));
          window.modalCtx.ratesBaseline = (Array.isArray(window.modalCtx.ratesBaseline) ? window.modalCtx.ratesBaseline : [])
                                          .filter(b => !(b && b.id && setIds.has(String(b.id))));
          if (window.modalCtx.ratesStagedDeletes instanceof Set) {
            for (const id of setIds) window.modalCtx.ratesStagedDeletes.delete(id);
          }
        }
      } catch (errDel) {
        alert(`Failed to process deletions: ${String(errDel?.message || errDel || '')}`);
        return { ok:false };
      }

      // 7) Apply status toggles
      const baselineRates = Array.isArray(window.modalCtx.ratesBaseline) ? window.modalCtx.ratesBaseline : [];
      const prevById = new Map(baselineRates.filter(r => r && r.id).map(r => [String(r.id), r]));
      let windows = Array.isArray(window.modalCtx.ratesState) ? window.modalCtx.ratesState.slice() : [];

      const toggles = [];
      for (const w of windows) {
        if (!w?.id) continue;
        const prev = prevById.get(String(w.id));
        if (!prev) continue;
        if (!!prev.disabled_at_utc !== !!w.disabled_at_utc) toggles.push({ id: w.id, disabled: !!w.disabled_at_utc });
      }
      L('[onSave] toggle phase', { togglesCount: toggles.length, windows: windows.length, baseline: baselineRates.length });
      if (toggles.length) {
        if (APILOG) console.log('[OPEN_CLIENT] applying toggles', toggles);
        for (const t of toggles) {
          try { await patchClientDefault(t.id, { disabled: t.disabled }); }
          catch (e) {
            const msg = String(e?.message || e || '');
            if (msg.includes('duplicate')) alert('Cannot enable this window: another enabled window already starts on the same date for the same role/band.');
            else alert(`Failed to update status: ${msg}`);
            return { ok:false };
          }
        }
      }

      // 8) Negative-margin guard
      const erniMultForWindow = await (async ()=> {
        const todayIso = (() => {
          try {
            const s = new Intl.DateTimeFormat('en-GB', { timeZone: 'Europe/London', year:'numeric', month:'2-digit', day:'2-digit' }).format(new Date());
            const [dd, mm, yyyy] = s.split('/');
            return `${yyyy}-${mm}-${dd}`;
          } catch {
            const d = new Date(); const y = d.getFullYear(), m = String(d.getMonth()+1).padStart(2,'0'), day = String(d.getDate()).padStart(2,'0');
            return `${y}-${m}-${day}`;
          }
        })();

        const asYmd = (v) => {
          if (!v) return null;
          const ss = String(v).slice(0, 10);
          return /^\d{4}-\d{2}-\d{2}$/.test(ss) ? ss : null;
        };

        let fws = [];
        try {
          if (typeof getSettingsCached === 'function') {
            const s = await getSettingsCached();
            fws = Array.isArray(s?.finance_windows) ? s.finance_windows : [];
          }
        } catch {
          fws = [];
        }

        const multByYmd = Object.create(null);

        const multForYmd = (ymd) => {
          const key = asYmd(ymd) || todayIso;
          if (multByYmd[key] != null) return multByYmd[key];

          let chosen = null;
          for (const w of fws) {
            const df = asYmd(w?.date_from);
            const dt = asYmd(w?.date_to);
            if (!df) continue;
            if (df > key) continue;
            if (dt && dt < key) continue;

            if (!chosen) {
              chosen = w;
            } else {
              const cdf = asYmd(chosen?.date_from);
              if (cdf && df > cdf) chosen = w;
            }
          }

          let p = chosen?.erni_pct ?? 0;
          p = Number(p) || 0;
          if (p > 1) p = p / 100;

          let mult = 1 + p;
          if (!Number.isFinite(mult) || mult <= 0) mult = 1;

          multByYmd[key] = mult;
          return mult;
        };

        try { window.__ERNI_MULT__ = multForYmd(todayIso); } catch {}

        return (rateWindow) => {
          const endIso   = asYmd(rateWindow?.date_to) || null;
          const startIso = asYmd(rateWindow?.date_from) || null;

          const finished = !!(endIso && endIso < todayIso);
          const anchorIso = (finished && startIso) ? startIso : todayIso;

          return multForYmd(anchorIso);
        };
      })();

      for (const w of windows) {
        if (w.disabled_at_utc) continue;

        const mult = erniMultForWindow(w);

        for (const b of ['day','night','sat','sun','bh']) {
          const chg  = w[`charge_${b}`], paye = w[`paye_${b}`], umb = w[`umb_${b}`];
          if (chg != null && paye != null && (chg - (paye * mult)) < 0) { alert(`PAYE margin would be negative for ${w.role}${w.band?` / ${w.band}`:''} (${b.toUpperCase()}). Fix before saving.`); return { ok:false }; }
          if (chg != null && umb  != null && (chg - umb) < 0)            { alert(`Umbrella margin would be negative for ${w.role}${w.band?` / ${w.band}`:''} (${b.toUpperCase()}). Fix before saving.`); return { ok:false }; }
        }
      }

      // 9) UPDATE existing, POST new (skip disabled)
      const toUpdate = windows.filter(w => w.id && !w.disabled_at_utc);
      const toCreate = windows.filter(w => !w.id && !w.disabled_at_utc);
      L('[onSave] upsert phase', { toUpdate: toUpdate.length, toCreate: toCreate.length });

      const buildBody = (w) => ({
        client_id : clientId,
        role      : w.role || '',
        band      : w.band ?? null,
        date_from : w.date_from || null,
        date_to   : w.date_to ?? null,

        charge_day   : w.charge_day   ?? null,
        charge_night : w.charge_night ?? null,
        charge_sat   : w.charge_sat   ?? null,
        charge_sun   : w.charge_sun   ?? null,
        charge_bh    : w.charge_bh    ?? null,

        paye_day     : w.paye_day     ?? null,
        paye_night   : w.paye_night   ?? null,
        paye_sat     : w.paye_sat     ?? null,
        paye_sun     : w.paye_sun     ?? null,
        paye_bh      : w.paye_bh      ?? null,

        umb_day      : w.umb_day      ?? null,
        umb_night    : w.umb_night    ?? null,
        umb_sat      : w.umb_sat      ?? null,
        umb_sun      : w.umb_sun      ?? null,
        umb_bh       : w.umb_bh       ?? null
      });

      for (const w of toUpdate) {
        if (!w.id) continue;
        try {
          const url = API(`/api/rates/client-defaults/${encodeURIComponent(w.id)}`);
          if (APILOG) console.log('[OPEN_CLIENT] PUT client-default window â†’', w.id);
          const res = await authFetch(url, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(buildBody(w))
          });
          if (!res.ok) {
            const body = await res.text().catch(()=> '');
            alert(`Failed to update client rate window: ${body || res.status}`);
            return { ok:false };
          }
        } catch (e) {
          alert(`Failed to update a client rate window: ${String(e?.message || e)}`); return { ok:false };
        }
      }

      for (const w of toCreate) {
        try {
          if (APILOG) console.log('[OPEN_CLIENT] POST client-default window â†’', w);
          await upsertClientRate(buildBody(w));
        } catch (e) {
          E('Upsert client default window failed', w, e);
          alert('Failed to create a client rate window. See console for details.');
          return { ok:false };
        }
      }

      // 10) Refresh & rebuild baseline
      try {
        const refreshed = await listClientRates(clientId);
        const stagedDelIds = (window.modalCtx.ratesStagedDeletes instanceof Set) ? window.modalCtx.ratesStagedDeletes : new Set();
        window.modalCtx.ratesState = (Array.isArray(refreshed) ? refreshed.map(x => ({ ...x })) : []).map(x => {
          if (stagedDelIds.has(String(x.id))) x.__delete = true;
          return x;
        });
        window.modalCtx.ratesBaseline = JSON.parse(JSON.stringify(window.modalCtx.ratesState));
        L('[onSave] post-refresh', { refreshed: window.modalCtx.ratesState.length });
        try { renderClientRatesTable(); } catch {}
      } catch (e) {
        W('[openClient] post-save refresh failed', e);
      }

      window.modalCtx.formState = { __forId: clientId, main:{} };
      if (isNew) window.__pendingFocus = { section: 'clients', id: clientId };
      L('[onSave] EXIT ok=true');
      return { ok: true, saved: window.modalCtx.data };
    },
    full?.id
  );

  // 4) Post-paint async loads (merge metadata; preserve delete flags)
  if (full?.id) {
    const token = window.modalCtx.openToken;
    const id    = full.id;
    try {
      const unified = await listClientRates(id);
      if (token === window.modalCtx.openToken && window.modalCtx.data?.id === id) {
        const stagedDelIds = (window.modalCtx.ratesStagedDeletes instanceof Set) ? window.modalCtx.ratesStagedDeletes : new Set();
        const hasStaged = Array.isArray(window.modalCtx.ratesState) && window.modalCtx.ratesState.length > 0;
        if (!hasStaged) {
          window.modalCtx.ratesState = (Array.isArray(unified) ? unified.map(r => ({ ...r })) : []).map(r => {
            if (stagedDelIds.has(String(r.id))) r.__delete = true;
            return r;
          });
          window.modalCtx.ratesBaseline = JSON.parse(JSON.stringify(window.modalCtx.ratesState));
        } else {
          const staged = Array.isArray(window.modalCtx.ratesState) ? window.modalCtx.ratesState.slice() : [];
          const stagedById = new Map(staged.map(r => [String(r.id), r]));
          (Array.isArray(unified) ? unified : []).forEach(srv => {
            const s = stagedById.get(String(srv.id));
            if (s) {
              s.disabled_at_utc  = srv.disabled_at_utc ?? null;
              s.disabled_by_name = srv.disabled_by_name ?? null;
              if (stagedDelIds.has(String(srv.id))) s.__delete = true;
            } else {
              const row = { ...srv };
              if (stagedDelIds.has(String(row.id))) row.__delete = true;
              staged.push(row);
            }
          });
          window.modalCtx.ratesState = staged;
        }
        L('[POST-PAINT] rates merged', { count: window.modalCtx.ratesState.length });
        try { renderClientRatesTable(); } catch {}
      }
    } catch (e) { W('openClient POST-PAINT rates error', e); }

    try {
      const freshHosp = await listClientHospitals(id);
      if (token === window.modalCtx.openToken && window.modalCtx.data?.id === id) {
        window.modalCtx.hospitalsState.existing = Array.isArray(freshHosp) ? freshHosp : [];
        try { renderClientHospitalsTable(); } catch {}
      }
    } catch (e) { W('openClient POST-PAINT hospitals error', e); }

  } else {
    L('skip companion loads (no full.id)');
  }
}




function ensureSelectionStyles(){
  const ID = 'gridSelectionStyles';
  if (document.getElementById(ID)) return;
  const style = document.createElement('style');
  style.id = ID;
  style.textContent = `
    /* Subtle selected-row highlight â€” readable, not shouty */
    .grid tbody tr.selected {
      background: rgba(30,136,229,0.12) !important;  /* soft blue tint */
      color: inherit !important;                     /* keep text color */
      box-shadow: inset 0 0 0 1px rgba(29,78,216,.35); /* delicate rim */
    }
    .grid tbody tr.selected td { color: inherit !important; }

    /* Hover stays understated */
    .grid tbody tr:hover {
      background: rgba(0,0,0,0.04);
    }
  `;
  document.head.appendChild(style);
}

function renderClientTab(key, row = {}){
  if (key==='main') return html(`
    <div class="form" id="tab-main">
      ${input('name','Client name', row.name)}

      <!-- CLI: display-only, never posted -->
      <div class="row">
        <label>Client Ref (CLI-â€¦)</label>
        <input id="cli_ref_display"
               value="${row.cli_ref ? String(row.cli_ref) : 'Awaiting CLI number from server'}"
               disabled
               readonly
               style="opacity:.7" />
      </div>

      <div class="row" style="grid-column:1/-1"><label>Invoice address</label><textarea name="invoice_address">${row.invoice_address || ''}</textarea></div>
      ${input('primary_invoice_email','Primary invoice email', row.primary_invoice_email,'email')}
      ${input('ap_phone','A/P phone', row.ap_phone)}
      ${select('vat_chargeable','VAT chargeable', row.vat_chargeable? 'Yes' : 'No', ['Yes','No'])}
      ${input('payment_terms_days','Payment terms (days)', row.payment_terms_days || 30, 'number')}
    </div>
  `);

  if (key === 'rates') return html(`
  <div class="form" id="tab-rates">
    <div class="row">
      <label>Care Package Rates</label>
      <div class="controls">
        <div id="clientRates"></div>
      </div>
    </div>
  </div>
`);

if (key === 'settings') return html(`
  <div class="form" id="tab-settings">
    <div class="row">
      <label>Client settings</label>
      <div class="controls">
        <div id="clientSettings"></div>
      </div>
    </div>
  </div>
`);


  if (key==='hospitals') {
    // Ensure initial render AND first-mount fetch if needed, then render the table
    setTimeout(async () => {
      try {
        const id = window.modalCtx?.data?.id || null;
        const hs = window.modalCtx?.hospitalsState || {};
        const hasExisting = Array.isArray(hs.existing) && hs.existing.length > 0;

        if (id && !hasExisting) {
          const fresh = await listClientHospitals(id);
          if (window.modalCtx?.data?.id === id) {
            window.modalCtx.hospitalsState.existing = Array.isArray(fresh) ? fresh : [];
          }
        }
        try { renderClientHospitalsTable(); } catch {}
      } catch (_) {}
    }, 0);

    return html(`<div id="clientHospitals"></div>`);
  }

  return '';
}


// ===========================
// 5) mountCandidatePayTab(...)
// (auto-populate Umbrella or PAYE bank fields + logging)
// ===========================
// ========== PAY TAB (just extra logs; logic unchanged) ==========
// This function now RESOLVES ONLY AFTER prefill (when umbrella_id is known).
// In your modal's setTab/renderTab: `return mountCandidatePayTab();` and await it.

async function mountCandidatePayTab() {
  const LOG = !!window.__LOG_PAYTAB;
  const fr  = (window.__modalStack || [])[ (window.__modalStack || []).length - 1 ] || null;
  const mode = fr ? fr.mode : 'view';
  const isEdit = (mode === 'edit' || mode === 'create');

  // ðŸ”¹ Use the *frozen* DB pay method when available
  let persistedMethod = '';
  if (window.modalCtx && window.modalCtx.dbPayMethod) {
    persistedMethod = String(window.modalCtx.dbPayMethod || '').toUpperCase();
  } else if (window.modalCtx && window.modalCtx.data && window.modalCtx.data.pay_method) {
    persistedMethod = String(window.modalCtx.data.pay_method || '').toUpperCase();
  }

  const payMethod    = (window.modalCtx?.payMethodState || persistedMethod || 'PAYE').toUpperCase();
  const currentUmbId = window.modalCtx?.data?.umbrella_id || '';

  if (LOG) {
    console.log('[PAYTAB] ENTRY', {
      mode,
      isEdit,
      dbPayMethod: window.modalCtx?.dbPayMethod || null,
      dataPayMethod: window.modalCtx?.data?.pay_method || null,
      persistedMethod,
      payMethod
    });
  }

  const umbRow    = document.getElementById('umbRow');
  const nameInput = document.getElementById('umbrella_name');
  const listEl    = document.getElementById('umbList');
  const idHidden  = document.getElementById('umbrella_id');

  const accHolder = document.querySelector('#tab-pay input[name="account_holder"]');
  const bankName  = document.querySelector('#tab-pay input[name="bank_name"]');
  const sortCode  = document.querySelector('#tab-pay input[name="sort_code"]');
  const accNum    = document.querySelector('#tab-pay input[name="account_number"]');

  // ----- Ensure modalCtx + formState/pay exist (no optional-chaining on assignment) -----

  window.modalCtx = window.modalCtx || {};
  if (!window.modalCtx.formState) {
    window.modalCtx.formState = {
      __forId: (window.modalCtx.data?.id ?? window.modalCtx.openToken ?? null),
      main: {},
      pay:  {}
    };
  }

  const fs = window.modalCtx.formState;
  fs.pay = fs.pay || {};
  const stagedPay = fs.pay;

  if (LOG) {
    console.log('[PAYTAB] STATE@ENTRY', {
      persistedMethod,
      payMethod,
      currentUmbId,
      stagedPay: { ...stagedPay }
    });
  }

  // ----- Shared helpers ----------------------------------------------------

  const unwrapList = (data) => {
    if (Array.isArray(data)) return data;
    if (data && Array.isArray(data.items)) return data.items;
    if (data && Array.isArray(data.rows))  return data.rows;
    if (data && Array.isArray(data.data))  return data.data;
    return [];
  };

  function unwrapSingle(json) {
    if (!json) return null;
    if (Array.isArray(json)) return json[0] || null;
    if (json.data && Array.isArray(json.data)) return json.data[0] || null;
    if (Array.isArray(json.rows)) return json.rows[0] || null;
    if (json.item && typeof json.item === 'object' && !Array.isArray(json.item)) return json.item;
    const keys = Object.keys(json);
    if (keys.length === 1) {
      const only = json[keys[0]];
      if (only && typeof only === 'object' && !Array.isArray(only)) return only;
    }
    return json;
  }

  const normaliseSort = (v) => {
    if (!v) return '';
    const digits = String(v).replace(/\D+/g, '').slice(0, 6);
    if (digits.length !== 6) return v;
    return digits.replace(/(\d{2})(\d{2})(\d{2})/, '$1-$2-$3');
  };

  function setBankDisabled(disabled) {
    [accHolder, bankName, sortCode, accNum].forEach(el => { if (el) el.disabled = !!disabled; });
    const umbInput = document.getElementById('umbrella_name');
    // Umbrella name should still be editable when weâ€™re editing the candidate
    if (umbInput) umbInput.disabled = !isEdit;
    try { window.__BANK_FIELDS_DISABLED__ = !!disabled; } catch {}
    if (LOG) console.log('[PAYTAB] setBankDisabled', { disabled, isEdit });
  }

  // ----- Staging helpers ---------------------------------------------------

  function stageFromDom() {
    stagedPay.account_holder = accHolder ? accHolder.value : '';
    stagedPay.bank_name      = bankName  ? bankName.value  : '';
    stagedPay.sort_code      = sortCode  ? sortCode.value  : '';
    stagedPay.account_number = accNum    ? accNum.value    : '';
    stagedPay.umbrella_name  = nameInput ? nameInput.value : '';
    stagedPay.umbrella_id    = idHidden  ? idHidden.value  : '';
    stagedPay.__forMethod    = payMethod || null;   // tag staging with the *current* method
    if (LOG) console.log('[PAYTAB] stageFromDom', { ...stagedPay });
  }

  function clearBankAndUmbrella() {
    if (accHolder) accHolder.value = '';
    if (bankName)  bankName.value  = '';
    if (sortCode)  sortCode.value  = '';
    if (accNum)    accNum.value    = '';
    if (nameInput) nameInput.value = '';
    if (idHidden)  idHidden.value  = '';

    stagedPay.account_holder = '';
    stagedPay.bank_name      = '';
    stagedPay.sort_code      = '';
    stagedPay.account_number = '';
    stagedPay.umbrella_name  = '';
    stagedPay.umbrella_id    = '';
    stagedPay.__forMethod    = null;

    if (LOG) console.log('[PAYTAB] clearBankAndUmbrella (DOM + staged)');
  }

  function fillFromCandidate() {
    const d = window.modalCtx?.data || {};
    if (accHolder) accHolder.value = d.account_holder || '';
    if (bankName)  bankName.value  = d.bank_name      || '';
    if (sortCode)  sortCode.value  = normaliseSort(d.sort_code || '');
    if (accNum)    accNum.value    = d.account_number || '';

    stageFromDom();
    if (LOG) console.log('[PAYTAB] fillFromCandidate', {
      account_holder: accHolder?.value,
      bank_name:      bankName?.value,
      sort_code:      sortCode?.value,
      account_number: accNum?.value
    });
  }

  async function fetchUmbrellaById(id) {
    try {
      const res = await authFetch(API(`/api/umbrellas/${encodeURIComponent(id)}`));
      if (!res || !res.ok) return null;
      const json = await res.json().catch(() => null);
      const row = json && (json.umbrella || unwrapSingle(json));
      return row || null;
    } catch (e) {
      if (LOG) console.warn('[PAYTAB] fetchUmbrellaById failed', id, e);
      return null;
    }
  }

  function prefillUmbrellaBankFields(umb) {
    if (!umb) return;

    // IMPORTANT: no id guard here â€“ we want repeated prefill for the same umbrella after flips
    const bank = umb.bank_name || umb.bank || umb.bankName || '';
    const sc   = umb.sort_code || umb.bank_sort_code || umb.sortCode || '';
    const an   = umb.account_number || umb.bank_account_number || umb.accountNumber || '';
    const ah   = umb.name || umb.account_holder || umb.bank_account_name || umb.accountHolder || '';

    if (bankName)  bankName.value  = bank;
    if (sortCode)  sortCode.value  = normaliseSort(sc);
    if (accNum)    accNum.value    = an;
    if (accHolder) accHolder.value = ah;

    if (nameInput && !nameInput.value) {
      nameInput.placeholder = umb.name || nameInput.placeholder || '';
    }

    stagedPay.account_holder = accHolder ? accHolder.value : '';
    stagedPay.bank_name      = bankName  ? bankName.value  : '';
    stagedPay.sort_code      = sortCode  ? sortCode.value  : '';
    stagedPay.account_number = accNum    ? accNum.value    : '';
    stagedPay.umbrella_name  = nameInput ? (nameInput.value || umb.name || '') : (umb.name || '');
    stagedPay.umbrella_id    = umb.id || '';
    stagedPay.__forMethod    = payMethod || 'UMBRELLA';

    if (LOG) console.log('[PAYTAB] prefillUmbrellaBankFields', {
      umb_id: umb.id,
      name:   umb.name,
      bank, sc, an, ah,
      stagedPay: { ...stagedPay }
    });
  }

  async function fetchAndPrefill(id) {
    if (!id) return;
    const umb = await fetchUmbrellaById(id);
    if (umb) {
      if (idHidden) idHidden.value = umb.id || idHidden.value || '';
      prefillUmbrellaBankFields(umb);
    } else if (LOG) {
      console.warn('[PAYTAB] fetchAndPrefill: umbrella not found', id);
    }
  }

  async function loadUmbrellaList() {
    let umbrellas = [];
    try {
      const res = await authFetch(API('/api/umbrellas'));
      if (res && res.ok) {
        const j = await res.json().catch(()=>[]);
        umbrellas = unwrapList(j);
      }
    } catch (e) {
      if (LOG) console.warn('[PAYTAB] loadUmbrellaList failed', e);
      umbrellas = [];
    }
    if (LOG) console.log('[PAYTAB] umbrellas list loaded', umbrellas.length);

    if (listEl) {
      listEl.innerHTML = (umbrellas || []).map(u => {
        const label = u.name || u.remittance_email || u.id;
        return `<option data-id="${u.id}" value="${label}"></option>`;
      }).join('');
    }
  }

  function syncUmbrellaSelection() {
    const val = (nameInput && nameInput.value) ? nameInput.value.trim() : '';
    if (!val) {
      if (idHidden) idHidden.value = '';
      stagedPay.umbrella_name = '';
      stagedPay.umbrella_id   = '';
      stagedPay.__forMethod   = payMethod || null;
      if (LOG) console.log('[PAYTAB] selection cleared (umbrella_name empty)', {
        stagedPay: { ...stagedPay }
      });
      return;
    }

    const allOpts = Array.from((listEl && listEl.options) ? listEl.options : []);
    const hitOpt = allOpts.find(o => o.value === val);
    const id = hitOpt && hitOpt.getAttribute('data-id');

    if (id) {
      if (LOG) console.log('[PAYTAB] selected umbrella', { label: val, id });
      if (idHidden) idHidden.value = id;
      stagedPay.umbrella_name = val;
      stagedPay.umbrella_id   = id;
      stagedPay.__forMethod   = payMethod || 'UMBRELLA';
      fetchAndPrefill(id);
    } else {
      // User typed a label that does not match any option â€“ keep text, but clear id & bank
      if (LOG) console.warn('[PAYTAB] no exact label match; clearing id & bank fields', { typed: val });
      if (idHidden) idHidden.value = '';
      stagedPay.umbrella_name = val;
      stagedPay.umbrella_id   = '';
      if (bankName) bankName.value = '';
      if (sortCode) sortCode.value = '';
      if (accNum)   accNum.value   = '';
      stagedPay.bank_name      = '';
      stagedPay.sort_code      = '';
      stagedPay.account_number = '';
      stagedPay.__forMethod    = payMethod || null;
    }
  }

  // ----- Staged state helpers / flags --------------------------------------

  function hasAnyStagedPay() {
    return ['account_holder','bank_name','sort_code','account_number','umbrella_id','umbrella_name']
      .some(k => Object.prototype.hasOwnProperty.call(stagedPay, k) && stagedPay[k] !== '' && stagedPay[k] != null);
  }

  function hasStagedForCurrentMethod() {
    if (!hasAnyStagedPay()) return false;
    const m = stagedPay.__forMethod || null;
    if (!m) return true;           // legacy/untagged â€“ treat as for current method
    return m === payMethod;
  }

  const isFlipFromPersisted =
    !!(persistedMethod && payMethod && payMethod !== persistedMethod);

  const flipFromPAYEtoUMBRELLA =  isFlipFromPersisted && persistedMethod === 'PAYE'     && payMethod === 'UMBRELLA';
  const flipFromUMBRELLAtoPAYE =  isFlipFromPersisted && persistedMethod === 'UMBRELLA' && payMethod === 'PAYE';
  const atOriginalPAYE         = !isFlipFromPersisted && persistedMethod === 'PAYE'     && payMethod === 'PAYE';
  const atOriginalUMBRELLA     = !isFlipFromPersisted && persistedMethod === 'UMBRELLA' && payMethod === 'UMBRELLA';

  if (LOG) {
    console.log('[PAYTAB] FLAGS', {
      dbPayMethod: window.modalCtx?.dbPayMethod || null,
      dataPayMethod: window.modalCtx?.data?.pay_method || null,
      persistedMethod,
      payMethod,
      isFlipFromPersisted,
      flipFromPAYEtoUMBRELLA,
      flipFromUMBRELLAtoPAYE,
      atOriginalPAYE,
      atOriginalUMBRELLA,
      hasAnyStagedPay:      hasAnyStagedPay(),
      hasStagedForCurrent:  hasStagedForCurrentMethod(),
      stagedForMethod:      stagedPay.__forMethod || null
    });
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Pay-method change handler (fires while this tab is open)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const onPmChanged = () => {
    const pm = (window.modalCtx?.payMethodState || window.modalCtx?.data?.pay_method || 'PAYE').toUpperCase();
    const nowHasStaged = hasStagedForCurrentMethod();
    if (LOG) console.log('[PAYTAB] pay-method-changed', {
      pm,
      persistedMethod,
      nowHasStaged,
      stagedForMethod: stagedPay.__forMethod || null
    });

    // On a real flip, we DO want a clean slate for the new method
    clearBankAndUmbrella();

    if (pm === 'UMBRELLA') {
      if (umbRow) umbRow.style.display = '';
      setBankDisabled(true);

      // Only auto-restore original umbrella if this was originally UMBRELLA and there is no staged state
      if (!nowHasStaged && persistedMethod === 'UMBRELLA' && currentUmbId) {
        if (LOG) console.log('[PAYTAB] pay-method-changed â†’ restore original umbrella from DB');
        fetchAndPrefill(currentUmbId);
      }
    } else {
      if (umbRow) umbRow.style.display = 'none';
      setBankDisabled(!isEdit);

      // Only auto-restore original PAYE if this was originally PAYE and there is no staged state
      if (!nowHasStaged && persistedMethod === 'PAYE') {
        if (LOG) console.log('[PAYTAB] pay-method-changed â†’ restore original PAYE from candidate');
        fillFromCandidate();
      }
    }
  };

  try {
    if (window.__payTabOnPmChanged) {
      window.removeEventListener('pay-method-changed', window.__payTabOnPmChanged);
    }
    window.__payTabOnPmChanged = onPmChanged;
    window.addEventListener('pay-method-changed', onPmChanged);
  } catch (e) {
    if (LOG) console.warn('[PAYTAB] failed to attach pay-method-changed listener', e);
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Initial render (when Pay tab is entered)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  const hadStagedAtEntry = hasStagedForCurrentMethod();

  if (payMethod === 'UMBRELLA') {
    if (umbRow) umbRow.style.display = '';
    setBankDisabled(true);

    // Always ensure umbrella dropdown is populated
    loadUmbrellaList().catch(() => {});

    if (hadStagedAtEntry) {
      // We already have staged values *for UMBRELLA* â€“ do NOT clear them; just repaint DOM
      if (LOG) console.log('[PAYTAB] initial UMBRELLA using staged pay', {
        stagedPay: { ...stagedPay }
      });
      if (accHolder) accHolder.value = stagedPay.account_holder || '';
      if (bankName)  bankName.value  = stagedPay.bank_name      || '';
      if (sortCode)  sortCode.value  = normaliseSort(stagedPay.sort_code || '');
      if (accNum)    accNum.value    = stagedPay.account_number || '';
      if (nameInput) nameInput.value = stagedPay.umbrella_name  || '';
      if (idHidden)  idHidden.value  = stagedPay.umbrella_id    || '';
    } else {
      // No UMBRELLA-staged state â†’ we can safely clear and rebuild from DB/blank
      clearBankAndUmbrella();

      if (atOriginalUMBRELLA && currentUmbId) {
        if (LOG) console.log('[PAYTAB] initial/original UMBRELLA: prefill from candidate umbrella_id');
        await fetchAndPrefill(currentUmbId);
      } else if (flipFromPAYEtoUMBRELLA) {
        if (LOG) console.log('[PAYTAB] PAYEâ†’UMBRELLA flip: start blank');
      } else {
        if (LOG) console.log('[PAYTAB] UMBRELLA/unknown origin: blank');
      }
    }

    // Wiring for user selection & future changes
    if (nameInput) {
      nameInput.disabled = !isEdit;
      nameInput.oninput  = syncUmbrellaSelection;
      nameInput.onchange = syncUmbrellaSelection;
    }
    if (idHidden) {
      idHidden.onchange = () => fetchAndPrefill(idHidden.value);
    }

  } else {
    // PAYE branch
    if (umbRow) umbRow.style.display = 'none';
    setBankDisabled(!isEdit);

    if (hadStagedAtEntry) {
      // Only re-use staged pay when it belongs to PAYE
      if (LOG) console.log('[PAYTAB] initial PAYE using staged pay', {
        stagedPay: { ...stagedPay }
      });
      if (accHolder) accHolder.value = stagedPay.account_holder || '';
      if (bankName)  bankName.value  = stagedPay.bank_name      || '';
      if (sortCode)  sortCode.value  = normaliseSort(stagedPay.sort_code || '');
      if (accNum)    accNum.value    = stagedPay.account_number || '';
      if (nameInput) nameInput.value = stagedPay.umbrella_name  || '';
      if (idHidden)  idHidden.value  = stagedPay.umbrella_id    || '';
    } else {
      // No PAYE-staged state â†’ clear and rebuild from DB/blank
      clearBankAndUmbrella();
      if (nameInput && idHidden) { nameInput.value = ''; idHidden.value = ''; }

      if (atOriginalPAYE) {
        if (LOG) console.log('[PAYTAB] initial/original PAYE: fill from candidate');
        fillFromCandidate();
      } else if (flipFromUMBRELLAtoPAYE) {
        // This is the case you care about:
        // UMBRELLA â†’ PAYE flip â†’ always start BLANK, never reuse umbrella staging.
        if (LOG) console.log('[PAYTAB] UMBRELLAâ†’PAYE flip: start blank');
      } else {
        if (LOG) console.log('[PAYTAB] PAYE/unknown origin: blank');
      }
    }
  }

  if (LOG) {
    console.log('[PAYTAB] EXIT', {
      finalDom: {
        account_holder: accHolder?.value ?? null,
        bank_name:      bankName?.value  ?? null,
        sort_code:      sortCode?.value  ?? null,
        account_number: accNum?.value    ?? null,
        umbrella_name:  nameInput?.value ?? null,
        umbrella_id:    idHidden?.value  ?? null
      },
      finalStagedPay: { ...stagedPay }
    });
  }

  // IMPORTANT: async function â€“ resolves AFTER any umbrella prefill.
}


// ============================================================================
// CALENDAR â€“ SHARED HELPERS & STATE
// ============================================================================

window.__calState = window.__calState || {};     // per contract_id: { view, win, weekEndingWeekday }
window.__candCalState = window.__candCalState || {}; // per candidate_id
window.__calStage = window.__calStage || {};     // staged changes per contract_id

// ---------- Date utilities ----------
function ymd(d) { return (typeof d === 'string') ? d.slice(0,10) : (new Date(d)).toISOString().slice(0,10); }
function ymdToDate(ymdStr) { return new Date(ymdStr + 'T00:00:00Z'); }
function dateToYmd(dt) { return dt.toISOString().slice(0,10); }
// define once, both as window prop and local alias
// 1) Ensure a single global + local alias for toYmd
window.toYmd = window.toYmd || (
  (typeof dateToYmd === 'function')
    ? dateToYmd
    : (d) => {
        const y = d.getUTCFullYear();
        const m = String(d.getUTCMonth() + 1).padStart(2, '0');
        const day = String(d.getUTCDate()).padStart(2, '0');
        return `${y}-${m}-${day}`;
      }
);
var toYmd = window.toYmd; // avoids redeclare on re-exec

// 2) Define addDays (and expose globally)
window.addDays = window.addDays || function(ymdStr, delta){
  const d = ymdToDate(ymdStr);
  d.setUTCDate(d.getUTCDate() + Number(delta || 0));
  return toYmd(d);
};
var addDays = window.addDays; // optional local alias

function enumerateDates(fromYmd, toYmd) {
  const out = []; let d = ymdToDate(fromYmd), end = ymdToDate(toYmd);
  while (d <= end) { out.push(dateToYmd(d)); d.setUTCDate(d.getUTCDate() + 1); }
  return out;
}
function computeYearWindow(year)   { return { from: `${year}-01-01`, to: `${year}-12-31` }; }
function monthBounds(year, monthIndex) { const s = new Date(Date.UTC(year, monthIndex, 1)); const e = new Date(Date.UTC(year, monthIndex+1, 0)); return { from: dateToYmd(s), to: dateToYmd(e) }; }
function computeMonthWindow(year, monthIndex) { return monthBounds(year, monthIndex); }
function stepMonth(win, delta) { const s = ymdToDate(win.from); const n = new Date(Date.UTC(s.getUTCFullYear(), s.getUTCMonth()+delta, 1)); return monthBounds(n.getUTCFullYear(), n.getUTCMonth()); }

// ---------- Week ending ----------
function computeWeekEnding(ymdStr, weekEndingWeekday /* 0=Sun..6=Sat */) {
  const d = ymdToDate(ymdStr); const dow = d.getUTCDay(); const delta = (weekEndingWeekday - dow + 7) % 7; d.setUTCDate(d.getUTCDate() + delta); return dateToYmd(d);
}

// ---------- Colors / states ----------
function colorForState(state) {
  const s = String(state || 'EMPTY').toUpperCase();

  if (s === 'PLANNED')                return 'cal-planned';
  if (s === 'PROCESSED_NOT_READY')    return 'cal-processed';
  if (s === 'READY')                  return 'cal-ready';

  if (s === 'INVOICED')               return 'cal-invoiced';
  if (s === 'INVOICE_ON_HOLD')        return 'cal-invoice-hold';

  if (s === 'PAY_ON_HOLD')            return 'cal-pay-hold';
  if (s === 'PAY_AND_INVOICE_ON_HOLD')return 'cal-pay-invoice-hold';

  if (s === 'PAID')                   return 'cal-paid';

  // legacy (optional)
  if (s === 'SUBMITTED')              return 'cal-submitted';
  if (s === 'AUTHORISED')             return 'cal-authorised';

  return ''; // EMPTY -> white
}


// ---------- Selection helpers ----------
function initSelBucket(bucketKey) {
  const store = (bucketKey === 'cand') ? window.__candSel : window.__calSel;
  if (!store) {
    if (bucketKey === 'cand') window.__candSel = { set: new Set(), anchor: null };
    else window.__calSel = { set: new Set(), anchor: null };
  }
  return (bucketKey === 'cand') ? window.__candSel : window.__calSel;
}
function toggleDaySelected(bucketKey, ymdStr, additive = false) {
  const sel = initSelBucket(bucketKey);
  if (!additive) sel.set.clear();
  if (sel.set.has(ymdStr) && additive) sel.set.delete(ymdStr); else sel.set.add(ymdStr);
  sel.anchor = ymdStr;
}
function selectRange(bucketKey, fromYmd, toYmd, additive = false) {
  const sel = initSelBucket(bucketKey);
  if (!additive) sel.set.clear();
  const lo = (fromYmd < toYmd) ? fromYmd : toYmd;
  const hi = (fromYmd < toYmd) ? toYmd   : fromYmd;
  enumerateDates(lo, hi).forEach(d => sel.set.add(d));
}
function clearCalendarSelection(bucketKey) {
  const sel = initSelBucket(bucketKey); sel.set.clear(); sel.anchor = null;
}
function computeSelectionBounds(selection /* array of ymd */) {
  if (!selection?.length) return null;
  let lo = selection[0], hi = selection[0];
  for (const d of selection) { if (d < lo) lo = d; if (d > hi) hi = d; }
  return { from: lo, to: hi };
}

// ---------- Index builders ----------
function buildDateIndex(items) { const map = new Map(); for (const it of (items||[])) { const k = it.date; const arr = map.get(k) || []; arr.push(it); map.set(k, arr); } return map; }
function buildWeekIndex(weeks) {
  const m = new Map();
  for (const w of (weeks || [])) {
    const key = w.week_ending_date;
    const e = m.get(key) || { baseWeekId: null, baseHasTs: false, baseMode: 'ELECTRONIC', siblings: [] };
    e.siblings.push(w);

    if (Number(w.additional_seq || 0) === 0) {
      e.baseWeekId = w.id;
      e.baseHasTs  = !!(w.timesheet_id || w.has_timesheet);
      e.baseMode   = w.submission_mode_snapshot || 'ELECTRONIC';
    }

    m.set(key, e);
  }
  return m;
}


/**
 * buildWeeklyScheduleFromLinesAndValidate
 *
 * Converts the WEEKLY manual grid model (weeklyLinesByDate) into the canonical schedule array
 * and validates overlaps / break rules. Designed to be the single shared truth used by:
 *  - Lines tab (pre-save live preview)
 *  - Save handler (final guard)
 *
 * Input model (per line):
 *  - Shift line: { ref, start, end, break_start, break_end, break_mins }
 *  - Break-only line (attaches to most recent shift above): { start:'', end:'', break_* set }
 *
 * Break rules:
 *  - For a given shift, you may use either break windows OR break minutes (not both).
 *  - Multiple break-only lines are allowed and attach to the current shift.
 *  - Break minutes can be entered on the shift line and/or break-only lines (they sum).
 *
 * Overnight:
 *  - Supported: end <= start means shift crosses midnight into next day.
 *  - Overlap detection accounts for overnight shifts (splits into two intervals).
 *
 * Returns:
 *  {
 *    schedule: [ {date,start,end,ref_num,breaks?:[{start,end}],break_minutes?:number} ... ],
 *    hasErrors: boolean,
 *    errorsByDate: { [ymd]: string[] }
 *  }
 */
function buildWeeklyScheduleFromLinesAndValidate(weeklyLinesByDate, weekDays, opts = {}) {
  const allowOvernight = (opts.allowOvernight !== false);
  const allowBreakMins = (opts.allowBreakMins !== false);

  const byDate = (weeklyLinesByDate && typeof weeklyLinesByDate === 'object') ? weeklyLinesByDate : {};
  const dayList = Array.isArray(weekDays) && weekDays.length
    ? weekDays.map(d => String(d?.ymd || '')).filter(Boolean)
    : Object.keys(byDate);

  const errorsByDate = {};
  const schedule = [];

  const err = (ymd, msg) => {
    const d = String(ymd || '');
    if (!d) return;
    (errorsByDate[d] ||= []).push(String(msg || 'Invalid'));
  };

  const str = (x) => (x == null) ? '' : String(x).trim();

  // Flexible time parser: accepts "8", "800", "08:00", "8:00", "0830", etc.
  // Returns { mins, hhmm } or null if invalid.
  const parseTime = (raw) => {
    let s = str(raw);
    if (!s) return null;

    // Normal HH:MM / H:MM
    let m = s.match(/^(\d{1,2}):(\d{2})$/);
    if (m) {
      const hh = Number(m[1]), mm = Number(m[2]);
      if (!Number.isFinite(hh) || !Number.isFinite(mm)) return null;
      if (hh < 0 || hh > 23 || mm < 0 || mm > 59) return null;
      const hhmm = `${String(hh).padStart(2, '0')}:${String(mm).padStart(2, '0')}`;
      return { mins: hh * 60 + mm, hhmm };
    }

    // Digits-only: "8" => 08:00, "800" => 08:00, "830" => 08:30, "0830" => 08:30
    s = s.replace(/\s+/g, '').replace(':', '');
    if (!/^\d{1,4}$/.test(s)) return null;

    let hh = 0, mm = 0;
    if (s.length <= 2) {
      hh = Number(s);
      mm = 0;
    } else {
      mm = Number(s.slice(-2));
      hh = Number(s.slice(0, -2));
    }
    if (!Number.isFinite(hh) || !Number.isFinite(mm)) return null;
    if (hh < 0 || hh > 23 || mm < 0 || mm > 59) return null;

    const hhmm = `${String(hh).padStart(2, '0')}:${String(mm).padStart(2, '0')}`;
    return { mins: hh * 60 + mm, hhmm };
  };

  // Break minutes parser: accepts "30", "30m", "".
  // Returns:
  //   - 0 for blank
  //   - integer >=0 for valid
  //   - NaN for invalid string
  const parseBreakMins = (raw) => {
    const s = str(raw);
    if (!s) return 0;
    if (!allowBreakMins) return NaN;
    const m = s.match(/^(\d{1,4})(?:\s*m)?$/i);
    if (!m) return NaN;
    const n = Number(m[1]);
    if (!Number.isFinite(n) || n < 0) return NaN;
    return Math.floor(n);
  };

  // Normalize break window times into the shift's timeline (supports overnight):
  // - shiftStartMins: [0..1439]
  // - shiftEndAdj: can be >1440 if overnight
  // Returns { sAdj, eAdj, startHHMM, endHHMM } or { err } or null if invalid parse.
  const normalizeBreakWindowToShift = (shiftStartMins, shiftEndAdj, rawStart, rawEnd) => {
    const ps = parseTime(rawStart);
    const pe = parseTime(rawEnd);
    if (!ps || !pe) return null;

    let bs = ps.mins;
    while (bs < shiftStartMins) bs += 1440;

    let be = pe.mins;
    while (be < bs) be += 1440;

    if (be <= bs) return { err: 'Break end must be after break start' };
    if (be > shiftEndAdj) return { err: 'Break is outside shift' };

    return {
      sAdj: bs,
      eAdj: be,
      startHHMM: ps.hhmm,
      endHHMM: pe.hhmm
    };
  };

  // Convert a shift into one or two intervals within a 0..1440 day (for overlap detection)
  const dayIntervalsForShift = (startMins, endMinsRaw, isOvernight) => {
    if (!isOvernight) return [[startMins, endMinsRaw]];
    return [[startMins, 1440], [0, endMinsRaw]];
  };

  for (const ymd of dayList) {
    const lines = Array.isArray(byDate[ymd]) ? byDate[ymd] : [];

    // Build shift objects; breaks attach to the most recent shift above
    const shifts = [];
    let cur = null;

    for (let i = 0; i < lines.length; i++) {
      const ln = lines[i] || {};

      const ref = str(ln.ref);
      const startRaw = str(ln.start);
      const endRaw   = str(ln.end);

      const bStart = str(ln.break_start);
      const bEnd   = str(ln.break_end);
      const hasBreakWindow = !!(bStart || bEnd);

      // âœ… SIMPLE RULE:
      // If a break window exists, ignore break_mins entirely (it can be display-only).
      let bMins = 0;
      if (!hasBreakWindow) {
        bMins = parseBreakMins(ln.break_mins);
        if (Number.isNaN(bMins) && str(ln.break_mins)) {
          err(ymd, `Line ${i + 1}: Break (mins) must be a number (e.g. 30)`);
        }
      }

      const hasShift = !!(startRaw || endRaw);
      const hasBreakMins = Number.isFinite(bMins) && bMins > 0;
      const hasAnyBreak = hasBreakWindow || hasBreakMins;

      if (hasShift) {
        cur = {
          lineIdx: i,
          ref_num: ref,
          startRaw,
          endRaw,
          breakWindows: [], // [{ lineIdx, startRaw, endRaw }]
          breakMinsTotal: 0,
          hasWindow: false,
          hasMins: false
        };
        shifts.push(cur);

        if (hasBreakWindow) {
          cur.hasWindow = true;
          cur.breakWindows.push({ lineIdx: i, startRaw: bStart, endRaw: bEnd });
          if (!bStart || !bEnd) {
            err(ymd, `Line ${i + 1}: break start/end must both be filled (or both blank)`);
          }
        } else if (hasBreakMins) {
          cur.hasMins = true;
          cur.breakMinsTotal += bMins;
        }
      } else if (hasAnyBreak) {
        // Break-only line
        if (!cur) {
          err(ymd, `Line ${i + 1}: break provided without a shift above`);
          continue;
        }

        if (hasBreakWindow) {
          cur.hasWindow = true;
          cur.breakWindows.push({ lineIdx: i, startRaw: bStart, endRaw: bEnd });
          if (!bStart || !bEnd) {
            err(ymd, `Line ${i + 1}: break start/end must both be filled (or both blank)`);
          }
        } else if (hasBreakMins) {
          cur.hasMins = true;
          cur.breakMinsTotal += bMins;
        }
      }
    }

    // Validate shifts + build schedule segments
    const validShiftRecs = [];

    for (const sh of shifts) {
      const hasStart = !!sh.startRaw;
      const hasEnd   = !!sh.endRaw;

      if (hasStart !== hasEnd) {
        err(ymd, `Line ${sh.lineIdx + 1}: Start and End must both be filled (or both blank)`);
        continue;
      }
      if (!hasStart && !hasEnd) continue;

      const ps = parseTime(sh.startRaw);
      const pe = parseTime(sh.endRaw);
      if (!ps || !pe) {
        err(ymd, `Line ${sh.lineIdx + 1}: invalid Start/End time`);
        continue;
      }

      const startMins = ps.mins;
      const endMinsRaw = pe.mins;

      const overnight = allowOvernight && (endMinsRaw <= startMins);
      if (!allowOvernight && (endMinsRaw <= startMins)) {
        err(ymd, `Line ${sh.lineIdx + 1}: End must be after Start`);
        continue;
      }

      const endAdj = overnight ? (endMinsRaw + 1440) : endMinsRaw;
      const shiftDur = endAdj - startMins;

      if (!(shiftDur > 0)) {
        err(ymd, `Line ${sh.lineIdx + 1}: shift duration must be > 0`);
        continue;
      }

      // Disallow mixing (defensive; should not happen now)
      if (sh.hasWindow && sh.hasMins) {
        err(ymd, `Line ${sh.lineIdx + 1}: use either Break (mins) OR Break start/end times (not both)`);
      }

      let outBreaks = [];
      let outBreakMinutes = null;

      if (sh.hasWindow) {
        const intervals = [];

        for (const bw of sh.breakWindows) {
          const bs = str(bw.startRaw);
          const be = str(bw.endRaw);
          if (!!bs !== !!be) continue;
          if (!bs && !be) continue;

          const norm = normalizeBreakWindowToShift(startMins, endAdj, bs, be);
          if (!norm) {
            err(ymd, `Line ${bw.lineIdx + 1}: invalid break time`);
            continue;
          }
          if (norm.err) {
            err(ymd, `Line ${bw.lineIdx + 1}: ${norm.err}`);
            continue;
          }

          intervals.push({
            s: norm.sAdj,
            e: norm.eAdj,
            lineIdx: bw.lineIdx,
            startHHMM: norm.startHHMM,
            endHHMM: norm.endHHMM
          });
        }

        intervals.sort((a, b) => a.s - b.s);
        for (let i = 1; i < intervals.length; i++) {
          if (intervals[i].s < intervals[i - 1].e) {
            err(ymd, `Line ${intervals[i].lineIdx + 1}: break overlaps another break`);
          }
        }

        outBreaks = intervals.map(b => ({ start: b.startHHMM, end: b.endHHMM }));
      } else if (sh.hasMins) {
        const bm = Number(sh.breakMinsTotal || 0);
        if (bm > 0) {
          if (bm >= shiftDur) {
            err(ymd, `Line ${sh.lineIdx + 1}: Break (mins) must be less than shift duration`);
          } else {
            outBreakMinutes = Math.floor(bm); // âœ… numeric integer
          }
        }
      }

      const parts = dayIntervalsForShift(startMins, endMinsRaw, overnight);
      validShiftRecs.push({ lineIdx: sh.lineIdx, startMins, endMinsRaw, overnight, parts });

      const seg = {
        date: ymd,
        start: ps.hhmm,
        end: pe.hhmm,
        ref_num: str(sh.ref_num)
      };

      // âœ… never emit both
      if (outBreaks.length) {
        seg.breaks = outBreaks;
      } else if (outBreakMinutes != null && outBreakMinutes > 0) {
        seg.break_minutes = outBreakMinutes;
      }

      schedule.push(seg);
    }

    // Shift overlap detection
    for (let a = 0; a < validShiftRecs.length; a++) {
      for (let b = a + 1; b < validShiftRecs.length; b++) {
        const A = validShiftRecs[a];
        const B = validShiftRecs[b];

        let overlaps = false;
        for (const pA of A.parts) {
          for (const pB of B.parts) {
            const s = Math.max(pA[0], pB[0]);
            const e = Math.min(pA[1], pB[1]);
            if (s < e) { overlaps = true; break; }
          }
          if (overlaps) break;
        }

        if (overlaps) {
          err(ymd, `Line ${A.lineIdx + 1}: shift overlaps another shift`);
          err(ymd, `Line ${B.lineIdx + 1}: shift overlaps another shift`);
        }
      }
    }
  }

  const sortKeyMins = (hhmm) => (parseTime(hhmm)?.mins ?? 0);
  schedule.sort((a, b) => {
    const da = str(a.date);
    const db = str(b.date);
    if (da !== db) return da.localeCompare(db);
    return sortKeyMins(a.start) - sortKeyMins(b.start);
  });

  const hasErrors = Object.keys(errorsByDate).length > 0;
  return { schedule, hasErrors, errorsByDate };
}


// ---------- Staging state ----------

function getContractCalendarStageState(contractId) {
  return (window.__calStage[contractId] ||= {
    add: new Set(),
    remove: new Set(),
    additional: {},
    weekEndingWeekday: (window.__calState[contractId]?.weekEndingWeekday || 0),
    removeAll: null
  });
}


function clearContractCalendarStageState(contractId) {
  // Ensure stage store exists
  window.__calStage = window.__calStage || {};
  window.__calState = window.__calState || {};

  window.__calStage[contractId] = {
    add: new Set(),
    remove: new Set(),
    additional: {},
    weekEndingWeekday: (window.__calState[contractId]?.weekEndingWeekday || 0),
    removeAll: null
  };

  // âœ… NEW: clear the UI selection too (selection is separate from stage)
  try {
    if (typeof clearCalendarSelection === 'function') {
      clearCalendarSelection(`c:${contractId}`);
    }
  } catch {}

  // âœ… NEW: if weâ€™re in a contract modal, and this matches, clear calendar dirty markers
  try {
    if (window.modalCtx && String(window.modalCtx?.data?.id || '') === String(contractId)) {
      window.modalCtx.__calendarDirty = false;
      window.modalCtx.__calendarOnly  = false;
    }
  } catch {}
}




async function discardContractCalendarStage(contractId) {
  clearContractCalendarStageState(contractId);
  const last = window.__calState?.[contractId]?.win || computeYearWindow((new Date()).getUTCFullYear());
  await fetchAndRenderContractCalendar(contractId, { from: last.from, to: last.to, view: window.__calState?.[contractId]?.view || 'year' });
  return { ok:true };
}























async function fetchContractChangeRatesPreview(contract_id, cutoff_we) {
  const LOGC = (typeof window.__LOG_CONTRACTS === 'boolean') ? window.__LOG_CONTRACTS : false;

  if (!contract_id) {
    throw new Error('fetchContractChangeRatesPreview: contract_id is required');
  }

  const qs = new URLSearchParams();
  if (cutoff_we) {
    qs.set('cutoff_week_ending_date', String(cutoff_we));
  }

  const path = `/api/contracts/${_enc(contract_id)}/change-rates-outstanding${qs.toString() ? `?${qs.toString()}` : ''}`;
  const url  = API(path);

  if (LOGC) {
    console.log('[CONTRACTS] fetchContractChangeRatesPreview â†’', { contract_id, cutoff_we, url });
  }

  let res;
  try {
    res = await authFetch(url);
  } catch (err) {
    if (LOGC) console.error('[CONTRACTS] change-rates-outstanding preview network error', { url, err });
    throw err;
  }

  const text = await res.text().catch(() => '');
  if (!res.ok) {
    if (LOGC) {
      console.error('[CONTRACTS] change-rates-outstanding preview failed', {
        status: res.status,
        url,
        body: text
      });
    }
    throw new Error(text || 'Failed to load outstanding weeks for this contract');
  }

  let json;
  try {
    json = text ? JSON.parse(text) : null;
  } catch (e) {
    if (LOGC) console.warn('[CONTRACTS] change-rates-outstanding preview: non-JSON body', { text });
    json = null;
  }

  if (LOGC) {
    console.log('[CONTRACTS] fetchContractChangeRatesPreview â†', json);
  }

  // Backend returns { contract_id, weeks:[...], ... }; normalise to object
  return json || { contract_id, weeks: [] };
}

async function applyChangeContractRates(contract_id, payload) {
  const LOGC = (typeof window.__LOG_CONTRACTS === 'boolean') ? window.__LOG_CONTRACTS : false;

  if (!contract_id) {
    throw new Error('applyChangeContractRates: contract_id is required');
  }

  const path = `/api/contracts/${_enc(contract_id)}/change-rates-outstanding`;
  const url  = API(path);

  const body = payload || {};
  if (LOGC) {
    console.log('[CONTRACTS] applyChangeContractRates â†’', { contract_id, url, body });
  }

  let res;
  try {
    res = await authFetch(url, {
      method: 'POST',
      headers: { 'content-type': 'application/json' },
      body: _json(body)
    });
  } catch (err) {
    if (LOGC) console.error('[CONTRACTS] applyChangeContractRates network error', { url, err });
    throw err;
  }

  const text = await res.text().catch(() => '');
  if (!res.ok) {
    if (LOGC) {
      console.error('[CONTRACTS] applyChangeContractRates failed', {
        status: res.status,
        url,
        body: text
      });
    }
    throw new Error(text || 'Failed to change contract rates for outstanding weeks');
  }

  let json;
  try {
    json = text ? JSON.parse(text) : null;
  } catch (e) {
    if (LOGC) console.warn('[CONTRACTS] applyChangeContractRates: non-JSON body', { text });
    json = null;
  }

  if (LOGC) {
    console.log('[CONTRACTS] applyChangeContractRates â†', json);
  }

  // Backend returns { old_contract_id, new_contract_id, weeks_migrated, timesheets_migrated, ... }
  return json || {};
}

async function fetchCandidatePayMethodChangePreview(candidate_id, newMethod) {
  const LOG = (typeof window.__LOG_CAND === 'boolean')
    ? window.__LOG_CAND
    : (typeof window.__LOG_CONTRACTS === 'boolean' ? window.__LOG_CONTRACTS : false);

  if (!candidate_id) {
    throw new Error('fetchCandidatePayMethodChangePreview: candidate_id is required');
  }

  const method = String(newMethod || '').toUpperCase();
  if (method !== 'PAYE' && method !== 'UMBRELLA') {
    throw new Error('fetchCandidatePayMethodChangePreview: newMethod must be PAYE or UMBRELLA');
  }

  const qs   = new URLSearchParams({ new_method: method });
  const path = `/api/candidates/${_enc(candidate_id)}/pay-method-change-preview?${qs.toString()}`;
  const url  = API(path);

  if (LOG) {
    console.log('[CAND][PAY-METHOD] preview â†’', { candidate_id, method, url });
  }

  let res;
  try {
    res = await authFetch(url);
  } catch (err) {
    if (LOG) console.error('[CAND][PAY-METHOD] preview network error', { url, err });
    throw err;
  }

  const text = await res.text().catch(() => '');
  if (!res.ok) {
    if (LOG) {
      console.error('[CAND][PAY-METHOD] preview failed', {
        status: res.status,
        url,
        body: text
      });
    }
    throw new Error(text || 'Failed to preview pay-method change');
  }

  let json;
  try {
    json = text ? JSON.parse(text) : null;
  } catch (e) {
    if (LOG) console.warn('[CAND][PAY-METHOD] preview: non-JSON body', { text });
    json = null;
  }

  if (LOG) {
    console.log('[CAND][PAY-METHOD] preview â†', json);
  }

  // Backend: { candidate_id, original_method, new_method, contracts:[...] }
  return json || { candidate_id, original_method: null, new_method: method, contracts: [] };
}

async function applyCandidatePayMethodChange(candidate_id, body) {
  const LOG = (typeof window.__LOG_CAND === 'boolean')
    ? window.__LOG_CAND
    : (typeof window.__LOG_CONTRACTS === 'boolean' ? window.__LOG_CONTRACTS : false);

  if (!candidate_id) {
    throw new Error('applyCandidatePayMethodChange: candidate_id is required');
  }

  const payload = body || {};
  const method  = String(payload.new_method || '').toUpperCase();
  if (method !== 'PAYE' && method !== 'UMBRELLA') {
    throw new Error('applyCandidatePayMethodChange: payload.new_method must be PAYE or UMBRELLA');
  }

  const path = `/api/candidates/${_enc(candidate_id)}/pay-method-change`;
  const url  = API(path);

  if (LOG) {
    console.log('[CAND][PAY-METHOD] apply â†’', {
      candidate_id,
      url,
      payload: { ...payload, /* avoid logging huge arrays in full */ contract_ids_count: Array.isArray(payload.contract_ids) ? payload.contract_ids.length : 0 }
    });
  }

  let res;
  try {
    res = await authFetch(url, {
      method: 'POST',
      headers: { 'content-type': 'application/json' },
      body: _json(payload)
    });
  } catch (err) {
    if (LOG) console.error('[CAND][PAY-METHOD] apply network error', { url, err });
    throw err;
  }

  const text = await res.text().catch(() => '');
  if (!res.ok) {
    if (LOG) {
      console.error('[CAND][PAY-METHOD] apply failed', {
        status: res.status,
        url,
        body: text
      });
    }
    throw new Error(text || 'Failed to apply pay-method change');
  }

  let json;
  try {
    json = text ? JSON.parse(text) : null;
  } catch (e) {
    if (LOG) console.warn('[CAND][PAY-METHOD] apply: non-JSON body', { text });
    json = null;
  }

  if (LOG) {
    console.log('[CAND][PAY-METHOD] apply â†', json);
  }

  // Backend: { candidate_id, original_method, new_method, old_contract_ids, new_contract_ids, affected_timesheet_ids, summary:{...} }
  return json || {
    candidate_id,
    original_method: null,
    new_method: method,
    old_contract_ids: [],
    new_contract_ids: [],
    affected_timesheet_ids: [],
    summary: { contracts_changed: 0, weeks_migrated: 0 }
  };
}

async function openChangeContractRatesModal(contractId) {
  const LOGC = (typeof window.__LOG_CONTRACTS === 'boolean') ? window.__LOG_CONTRACTS : true;
  const L    = (...a)=> { if (LOGC) console.log('[CONTRACTS][CHANGE-RATES]', ...a); };
  const W    = (...a)=> { if (LOGC) console.warn('[CONTRACTS][CHANGE-RATES]', ...a); };
  const E    = (...a)=> { if (LOGC) console.error('[CONTRACTS][CHANGE-RATES]', ...a); };

  if (!contractId) {
    alert('No contract selected.');
    return;
  }

  let preview;
  try {
    preview = await fetchContractChangeRatesPreview(contractId, null);
  } catch (err) {
    E('preview failed', err);
    alert(err?.message || 'Could not load outstanding weeks for this contract.');
    return;
  }

  const weeks = Array.isArray(preview?.weeks) ? preview.weeks.slice() : [];
  if (!weeks.length) {
    alert('There are no outstanding weeks on this contract. Nothing to change.');
    return;
  }

  weeks.sort((a, b) => String(a.week_ending_date).localeCompare(String(b.week_ending_date)));

  const defaultCutoff = preview.cutoff_week_ending_date || weeks[0].week_ending_date;

  // Seed rates + schedule from current contract modalCtx if available
  const deep = (o)=> JSON.parse(JSON.stringify(o || {}));
  const baseContract =
    (window.modalCtx &&
     window.modalCtx.entity === 'contracts' &&
     window.modalCtx.data &&
     String(window.modalCtx.data.id || '') === String(contractId))
      ? deep(window.modalCtx.data)
      : deep(preview || {});

  const R = baseContract.rates_json || {};
  const payMethod = String(baseContract.pay_method_snapshot || 'PAYE').toUpperCase();
  const showPAYE = (payMethod === 'PAYE');
  const LBL = baseContract.bucket_labels_json || {};
  const labelOf = (k) => {
    if (k==='day') return (LBL.day||'Day');
    if (k==='night') return (LBL.night||'Night');
    if (k==='sat') return (LBL.sat||'Sat');
    if (k==='sun') return (LBL.sun||'Sun');
    if (k==='bh') return (LBL.bh||'BH');
    return k;
  };
  const numStr = (v) => (v == null ? '' : String(v));

  const sched = (() => {
    const src = baseContract.std_schedule_json || {};
    const out = {};
    ['mon','tue','wed','thu','fri','sat','sun'].forEach(d => {
      const day = src[d] || {};
      out[d] = {
        start: day.start || '',
        end:   day.end   || '',
        break_minutes: (day.break_minutes != null ? String(day.break_minutes) : '')
      };
    });
    return out;
  })();

  const weeksTableHtml = `
    <div class="group">
      <div class="row">
        <label>Outstanding weeks</label>
        <div class="controls">
          <div class="hint">Only weeks that are not invoiced and not paid will be moved onto the new contract.</div>
          <div style="max-height:220px;overflow:auto;border:1px solid var(--line);border-radius:10px;margin-top:6px">
            <table class="grid compact">
              <thead>
                <tr>
                  <th>Week ending</th>
                  <th>Status</th>
                  <th>Timesheet</th>
                  <th>Invoiced?</th>
                  <th>Paid?</th>
                </tr>
              </thead>
              <tbody>
                ${weeks.map(w => `
                  <tr>
                    <td>${w.week_ending_date || ''}</td>
                    <td>${w.status || ''}</td>
                    <td>${w.timesheet_id ? 'Yes' : 'No'}</td>
                    <td>${w.is_invoiced ? 'Yes' : 'No'}</td>
                    <td>${w.is_paid ? 'Yes' : 'No'}</td>
                  </tr>
                `).join('')}
              </tbody>
            </table>
          </div>
        </div>
      </div>
      <div class="row">
        <label>Apply new rates from</label>
        <div class="controls">
          <select class="input" name="cutoff_we">
            ${weeks.map(w => `
              <option value="${w.week_ending_date}" ${w.week_ending_date === defaultCutoff ? 'selected' : ''}>
                ${w.week_ending_date}
              </option>
            `).join('')}
          </select>
          <span class="mini">Weeks on or after this week-ending date will be moved to a new contract with the updated rates and schedule.</span>
          <div class="mini" id="cutoffSummary" style="margin-top:4px;"></div>
        </div>
      </div>
    </div>
  `;

  const ratesHtml = `
    <div class="group">
      <div class="row">
        <label>Rates</label>
        <div class="controls small">
          <div class="grid-5" style="margin-bottom:4px">
            <div></div>
            <div class="mini">PAYE</div>
            <div class="mini">Umbrella</div>
            <div class="mini">Charge</div>
            <div class="mini">Margin (info only)</div>
          </div>

          ${['day','night','sat','sun','bh'].map(b => `
            <div class="grid-5" data-bucket="${b}" style="margin-bottom:4px">
              <div class="split"><span class="mini">${labelOf(b)}</span></div>
              <div><input class="input" name="paye_${b}"   placeholder="PAYE"     value="${numStr(R[`paye_${b}`])}" ${showPAYE ? '' : 'disabled'} /></div>
              <div><input class="input" name="umb_${b}"    placeholder="Umbrella" value="${numStr(R[`umb_${b}`])}"  ${showPAYE ? 'disabled' : ''} /></div>
              <div><input class="input" name="charge_${b}" placeholder="Charge"   value="${numStr(R[`charge_${b}`])}" /></div>
              <div class="mini" data-role="margin-note"></div>
            </div>
          `).join('')}
          <div class="mini">You can change any pay/charge buckets here. Margins will be checked before applying, and recomputed automatically in TSFIN after the change.</div>
        </div>
      </div>
    </div>
  `;

  const scheduleHtml = `
    <div class="group">
      <div class="row"><label>Default weekly schedule (Monâ€“Sun)</label>
        <div class="controls small">
          <div class="grid-3">
            ${['mon','tue','wed','thu','fri','sat','sun'].map(d => {
              const lab = d.charAt(0).toUpperCase() + d.slice(1);
              const day = sched[d] || {};
              return `
                <div class="rp-day" data-day="${d}" style="margin-bottom:6px">
                  <div class="split">
                    <span class="mini">${lab} start</span>
                    <input class="input" name="${d}_start" value="${day.start || ''}" placeholder="HH:MM" />
                  </div>
                  <div class="split">
                    <span class="mini">${lab} end</span>
                    <input class="input" name="${d}_end" value="${day.end || ''}" placeholder="HH:MM" />
                  </div>
                  <div class="split">
                    <span class="mini">Break (min)</span>
                    <input class="input" type="number" min="0" step="1" name="${d}_break" value="${day.break_minutes || ''}" placeholder="0" />
                  </div>
                </div>
              `;
            }).join('')}
          </div>
          <div class="mini" style="margin-top:4px">Leave a day blank to clear it from the schedule on the new contract.</div>
        </div>
      </div>
    </div>
  `;

  const modalHtml = html(`
    <div class="tabc" id="changeContractRatesForm">
      <div class="hint" style="margin-bottom:8px">
        This will create a <strong>new successor contract</strong> with the updated rates and schedule.
        All outstanding weeks from the chosen cut-off week onward will be moved to the new contract.
        Historic (paid/invoiced) weeks stay on the original contract.
      </div>
      ${weeksTableHtml}
      ${ratesHtml}
      ${scheduleHtml}
    </div>
  `);

  const timeNorm = (raw) => {
    const t = String(raw || '').trim();
    if (!t) return '';
    const m = t.match(/^(\d{1,2})(?::?(\d{2}))$/);
    if (!m) return '';
    const h = +m[1], mi = +m[2];
    if (!Number.isFinite(h) || !Number.isFinite(mi) || h < 0 || h > 23 || mi < 0 || mi > 59) return '';
    return String(h).padStart(2, '0') + ':' + String(mi).padStart(2, '0');
  };

  const buildPayloadFromDom = () => {
    const root = document.getElementById('changeContractRatesForm');
    if (!root) return null;

    const cutoffSel = root.querySelector('select[name="cutoff_we"]');
    const cutoff_we = cutoffSel ? (cutoffSel.value || '').trim() : '';
    if (!cutoff_we) {
      if (typeof showModalHint === 'function') showModalHint('Choose a cut-off week ending date.', 'warn');
      else alert('Choose a cut-off week ending date.');
      return null;
    }

    // Collect rates
    const BUCKETS = ['day','night','sat','sun','bh'];
    const rateInputs = {};
    BUCKETS.forEach(b => {
      rateInputs[`paye_${b}`]   = root.querySelector(`input[name="paye_${b}"]`);
      rateInputs[`umb_${b}`]    = root.querySelector(`input[name="umb_${b}"]`);
      rateInputs[`charge_${b}`] = root.querySelector(`input[name="charge_${b}"]`);
    });

    const parseRate = (name) => {
      const el = rateInputs[name];
      if (!el) return null;
      const raw = (el.value || '').trim();
      if (!raw) return null;
      const n = Number(raw);
      return Number.isFinite(n) ? n : null;
    };

    const rates_json = {};
    BUCKETS.forEach(b => {
      const pd = parseRate(`paye_${b}`);
      const ud = parseRate(`umb_${b}`);
      const cd = parseRate(`charge_${b}`);
      if (pd != null) rates_json[`paye_${b}`] = pd;
      if (ud != null) rates_json[`umb_${b}`] = ud;
      if (cd != null) rates_json[`charge_${b}`] = cd;
    });

    // Schedule
    const days = ['mon','tue','wed','thu','fri','sat','sun'];
    const schedOut = {};
    let hasAny = false;

    days.forEach(d => {
      const sEl = root.querySelector(`input[name="${d}_start"]`);
      const eEl = root.querySelector(`input[name="${d}_end"]`);
      const bEl = root.querySelector(`input[name="${d}_break"]`);

      const sNorm = timeNorm(sEl ? sEl.value : '');
      const eNorm = timeNorm(eEl ? eEl.value : '');
      const brRaw = bEl ? (bEl.value || '').trim() : '';

      if (sNorm && eNorm) {
        const brNum = Math.max(0, Number(brRaw || 0) || 0);
        schedOut[d] = { start: sNorm, end: eNorm, break_minutes: brNum };
        hasAny = true;
      }
    });

    const std_schedule_json = hasAny ? schedOut : null;

    return {
      cutoff_week_ending_date: cutoff_we,
      rates_json,
      std_schedule_json
    };
  };

    // Helper to ensure we have ERNI multiplier from settings (used for margin check)
  // UPDATED:
  // - getSettingsCached() returns { settings, finance_windows }
  // - ERNI comes from finance_windows window in-scope for an anchor date
  // - Anchor date rule:
  //    - if contract ongoing -> today (Europe/London)
  //    - if contract finished (end_date < today) -> contract start_date
  const ensureErniMult = async () => {
    // Today (Europe/London)
    const todayIso = (() => {
      try {
        const s = new Intl.DateTimeFormat('en-GB', {
          timeZone: 'Europe/London',
          year:'numeric', month:'2-digit', day:'2-digit'
        }).format(new Date());
        const [dd, mm, yyyy] = s.split('/');
        return `${yyyy}-${mm}-${dd}`;
      } catch {
        const d = new Date();
        const y = d.getFullYear();
        const m = String(d.getMonth()+1).padStart(2,'0');
        const day = String(d.getDate()).padStart(2,'0');
        return `${y}-${m}-${day}`;
      }
    })();

    const asYmd = (v) => {
      if (!v) return null;
      const ss = String(v).slice(0, 10);
      return /^\d{4}-\d{2}-\d{2}$/.test(ss) ? ss : null;
    };

    // Determine anchor date from baseContract start/end
    const startIso = asYmd(baseContract?.start_date) || null;
    const endIso   = asYmd(baseContract?.end_date)   || null;
    const isFinished = !!(endIso && endIso < todayIso);
    const anchorIso = (isFinished && startIso) ? startIso : todayIso;

    // Cache ERNI_MULT per anchor date (so we don't recompute repeatedly)
    window.__ERNI_MULT_BY_DATE__ = window.__ERNI_MULT_BY_DATE__ || Object.create(null);
    if (typeof window.__ERNI_MULT_BY_DATE__[anchorIso] === 'number' && window.__ERNI_MULT_BY_DATE__[anchorIso] > 0) {
      window.__ERNI_MULT__ = window.__ERNI_MULT_BY_DATE__[anchorIso]; // keep legacy cache aligned
      return window.__ERNI_MULT_BY_DATE__[anchorIso];
    }

    try {
      if (typeof getSettingsCached === 'function') {
        const s = await getSettingsCached();

        // New shape: { settings: {...}, finance_windows: [...] }
        const fws = Array.isArray(s?.finance_windows) ? s.finance_windows : [];

        // Pick finance window in-scope for anchorIso (prefer latest date_from)
        let chosen = null;
        for (const w of fws) {
          const df = asYmd(w?.date_from);
          const dt = asYmd(w?.date_to);
          if (!df) continue;
          if (df > anchorIso) continue;
          if (dt && dt < anchorIso) continue;

          if (!chosen) {
            chosen = w;
          } else {
            const cdf = asYmd(chosen?.date_from);
            if (cdf && df > cdf) chosen = w;
          }
        }

        // ERNI pct from finance window; fallback to legacy fields if needed
        let p = chosen?.erni_pct ?? null;
        if (p == null) p = s?.settings?.erni_pct ?? null;
        if (p == null) p = s?.erni_pct ?? null;
        if (p == null) p = s?.employers_ni_percent ?? null;
        if (p == null) p = 0;

        p = Number(p) || 0;
        if (p > 1) p = p / 100;

        let mult = 1 + p;
        if (!Number.isFinite(mult) || mult <= 0) mult = 1;

        window.__ERNI_MULT_BY_DATE__[anchorIso] = mult;
        window.__ERNI_MULT__ = mult;

        return mult;
      }
    } catch (e) {
      W('ensureErniMult failed, defaulting to 1', e);
    }

    window.__ERNI_MULT_BY_DATE__[anchorIso] = 1;
    window.__ERNI_MULT__ = 1;
    return 1;
  };


  // Margin validation before submit (per bucket)
  const validateMargins = async (ratesOverride) => {
    const BUCKETS = ['day','night','sat','sun','bh'];
    const erniMult = await ensureErniMult();
    const bad = [];

    for (const b of BUCKETS) {
      const chargeKey  = `charge_${b}`;
      const payPayeKey = `paye_${b}`;
      const payUmbKey  = `umb_${b}`;

      const rawCharge =
        (ratesOverride && ratesOverride.hasOwnProperty(chargeKey))
          ? ratesOverride[chargeKey]
          : R[chargeKey];

      const rawPay =
        payMethod === 'PAYE'
          ? ((ratesOverride && ratesOverride.hasOwnProperty(payPayeKey)) ? ratesOverride[payPayeKey] : R[payPayeKey])
          : ((ratesOverride && ratesOverride.hasOwnProperty(payUmbKey))  ? ratesOverride[payUmbKey]  : R[payUmbKey]);

      const ch = Number(rawCharge);
      const pa = Number(rawPay);

      if (!Number.isFinite(ch) || !Number.isFinite(pa)) continue;

      let margin;
      if (payMethod === 'PAYE') {
        margin = ch - pa * erniMult;
      } else {
        margin = ch - pa;
      }

      // Allow tiny floating point wiggle; treat anything < -0.001 as negative
      if (margin < -0.001) {
        bad.push(labelOf(b));
      }
    }

    return bad;
  };

  showModal(
    'Change Contract Rates',
    [{ key:'main', label:'Change' }],
    () => modalHtml,
    async () => {
      const payload = buildPayloadFromDom();
      if (!payload) return false;

      // ðŸ”¹ Validate margins before applying
      try {
        const badBuckets = await validateMargins(payload.rates_json || {});
        if (badBuckets.length) {
          const msg =
            'One or more buckets would have a negative margin with the new rates:\n\n' +
            badBuckets.map(b => `â€¢ ${b}`).join('\n') +
            '\n\nPlease adjust pay and/or charge so that margins remain non-negative.';
          alert(msg);
          return false;
        }
      } catch (err) {
        W('margin validation failed (non-fatal, but blocking apply)', err);
        alert('Could not validate margins. Please try again or adjust rates.');
        return false;
      }

      try {
        const resp = await applyChangeContractRates(contractId, payload);
        L('applyChangeContractRates success', resp);

        // Seed pending focus so when user closes out, Contracts summary highlights old/new contracts
        try {
          const oldId = resp?.old_contract_id;
          const newId = resp?.new_contract_id;
          const ids = [];
          if (newId) ids.push(newId);
          if (oldId && oldId !== newId) ids.push(oldId);

          if (ids.length) {
            window.__pendingFocus = {
              section: 'contracts',
              ids: ids,
              primaryIds: newId ? [newId] : []
            };
          }
        } catch (e) {
          W('failed to set pending focus (non-fatal)', e);
        }

        try { window.__toast && window.__toast('New contract created; outstanding weeks moved.'); } catch {}

        return true; // close child modal
      } catch (err) {
        E('applyChangeContractRates failed', err);
        alert(err?.message || 'Failed to change contract rates.');
        return false;
      }
    },
    false,
    null,
    { kind:'contract-change-rates', noParentGate:true, forceEdit:true }
  );

  // ðŸ”¹ After the modal is mounted, wire up the cut-off summary text
  setTimeout(() => {
    try {
      const root = document.getElementById('changeContractRatesForm');
      if (!root) return;
      const sel = root.querySelector('select[name="cutoff_we"]');
      const summary = root.querySelector('#cutoffSummary');
      if (!sel || !summary) return;

      const updateSummary = () => {
        const v = sel.value || '';
        if (!v) {
          summary.textContent = 'Choose a week ending date for the new contract to start applying.';
        } else {
          summary.textContent = `New rates and schedule will apply to weeks on or after week ending ${v}.`;
        }
      };

      sel.addEventListener('change', updateSummary);
      updateSummary();
    } catch (e) {
      W('failed to wire cutoffSummary (non-fatal)', e);
    }
  }, 0);
}

async function openCandidatePayMethodChangeModal(candidate, context = {}) {
  const LOG = (typeof window.__LOG_CAND === 'boolean')
    ? window.__LOG_CAND
    : (typeof window.__LOG_MODAL === 'boolean' ? window.__LOG_MODAL : false);
  const L  = (...a)=> { if (LOG) console.log('[CAND][PAY-METHOD][MODAL]', ...a); };
  const W  = (...a)=> { if (LOG) console.warn('[CAND][PAY-METHOD][MODAL]', ...a); };
  const E  = (...a)=> { if (LOG) console.error('[CAND][PAY-METHOD][MODAL]', ...a); };

  const cand = candidate || {};
  const candidateId = cand.id || context.candidate_id || context.id;
  if (!candidateId) {
    alert('Candidate id missing for pay-method change.');
    return false;
  }

  const origMethod = String(context.originalMethod || cand.pay_method || '').toUpperCase() || null;
  const newMethodRaw = context.newMethod || context.new_method || '';
  const newMethod = String(newMethodRaw).toUpperCase();

  L('ENTRY', {
    candidateId,
    origMethod,
    newMethodRaw,
    newMethod,
    contextKeys: Object.keys(context || {})
  });

  if (!newMethod || (newMethod !== 'PAYE' && newMethod !== 'UMBRELLA')) {
    alert('New pay method must be PAYE or UMBRELLA.');
    return false;
  }
  if (!origMethod || (origMethod !== 'PAYE' && origMethod !== 'UMBRELLA')) {
    alert('Current pay method must be PAYE or UMBRELLA to use this change flow.');
    return false;
  }
  if (origMethod === newMethod) {
    alert('New pay method is the same as the current one.');
    return false;
  }

  let preview;
  try {
    L('preview â†’ fetchCandidatePayMethodChangePreview', { candidateId, newMethod });
    preview = await fetchCandidatePayMethodChangePreview(candidateId, newMethod);
    L('preview â†', {
      candidate_id: preview?.candidate_id,
      original_method: preview?.original_method,
      new_method: preview?.new_method,
      contractsCount: Array.isArray(preview?.contracts) ? preview.contracts.length : 0
    });
  } catch (err) {
    E('preview failed', err);
    alert(err?.message || 'Failed to preview pay-method change.');
    return false;
  }

  const contracts = Array.isArray(preview?.contracts) ? preview.contracts.slice() : [];
  const directionLabel = `${origMethod} â†’ ${newMethod}`;
  const candName =
    (cand.display_name || `${cand.first_name || ''} ${cand.last_name || ''}`).trim() ||
    (cand.tms_ref || cand.id || '');

  // No contracts to touch â†’ simple confirm, then call apply endpoint (which will just flip pay_method)
  if (!contracts.length) {
    const msg = [
      `You are changing ${candName}'s pay method from ${origMethod} to ${newMethod}.`,
      '',
      'There are no weekly contracts with outstanding weeks that need adjusting.',
      'Only the candidateâ€™s pay method will be changed.',
      '',
      'Do you want to proceed?'
    ].join('\n');
    const ok = window.confirm(msg);
    if (!ok) {
      // User cancelled â†’ caller should keep Candidate modal open
      L('[NO-CONTRACTS] user cancelled simple flip dialog');
      return false;
    }

    try {
      L('[NO-CONTRACTS] applyCandidatePayMethodChange â†’', {
        candidateId,
        newMethod
      });
      const resp = await applyCandidatePayMethodChange(candidateId, { new_method: newMethod, contract_ids: [] });
      L('[NO-CONTRACTS] applyCandidatePayMethodChange â†', {
        candidate_id: resp?.candidate_id,
        original_method: resp?.original_method,
        new_method: resp?.new_method,
        summary: resp?.summary || null
      });
      focusContractsAfterBulkChange(resp);
      try { window.__toast && window.__toast('Pay method changed.'); } catch {}
      // Flip confirmed
      return true;
    } catch (err) {
      E('applyCandidatePayMethodChange failed (no contracts)', err);
      alert(err?.message || 'Failed to apply pay-method change.');
      return false;
    }
  }

  contracts.sort((a, b) => {
    const aFrom = String(a?.date_range?.start_date || '');
    const bFrom = String(b?.date_range?.start_date || '');
    return aFrom.localeCompare(bFrom);
  });

  const sanitize = (typeof window !== 'undefined' && typeof window.sanitize === 'function')
    ? window.sanitize
    : (s => String(s ?? '').replace(/&/g,'&amp;')
                           .replace(/</g,'&lt;')
                           .replace(/>/g,'&gt;')
                           .replace(/"/g,'&quot;')
                           .replace(/'/g,'&#39;'));

  const tableHtml = `
    <div class="group">
      <div class="row">
        <label>Affected weekly contracts</label>
        <div class="controls">
          <div class="hint">
            The following contracts have outstanding weeks (not yet invoiced or paid) that will be moved
            to successor contracts with pay method <strong>${newMethod}</strong>.
          </div>
          <div style="max-height:260px;overflow:auto;border:1px solid var(--line);border-radius:10px;margin-top:6px">
            <table class="grid compact">
              <thead>
                <tr>
                  <th>Client</th>
                  <th>Role / Band</th>
                  <th>Date range</th>
                  <th>Current snapshot</th>
                  <th>Outstanding weeks</th>
                  <th>First W/E</th>
                  <th>Last W/E</th>
                </tr>
              </thead>
              <tbody>
                ${contracts.map(c => {
                  const dr = c.date_range || {};
                  const range = [dr.start_date || '', dr.end_date || ''].filter(Boolean).join(' â†’ ');
                  return `
                    <tr>
                      <td>${sanitize(c.client_name || '')}</td>
                      <td>${sanitize(c.role || '')}${c.band ? ` (Band ${sanitize(c.band)})` : ''}</td>
                      <td>${sanitize(range)}</td>
                      <td>${sanitize(c.pay_method_snapshot || '')}</td>
                      <td>${c.outstanding_weeks || 0}</td>
                      <td>${c.first_outstanding_we || ''}</td>
                      <td>${c.last_outstanding_we || ''}</td>
                    </tr>
                  `;
                }).join('')}
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
  `;

  const bodyHtml = html(`
    <div class="tabc" id="candPayMethodChange">
      <div class="hint" style="margin-bottom:8px">
        You are changing <strong>${sanitize(candName)}</strong> from <strong>${sanitize(origMethod)}</strong> to
        <strong>${sanitize(newMethod)}</strong>.
        <br/>
        For each contract below, a new successor contract will be created with the new pay method, and
        all outstanding weeks will be moved over. Pay rates will be adjusted so that the <em>margin per bucket</em>
        remains the same where possible.
      </div>
      ${tableHtml}
      <div class="hint" style="margin-top:8px">
        If youâ€™d like different rates than the automatically calculated ones, you can adjust them later on the new contracts directly.
      </div>
    </div>
  `);

  const contractIds = contracts.map(c => c.contract_id).filter(Boolean).map(String);

  // Wrap showModal in a Promise so the caller can know if the user confirmed or cancelled
  return await new Promise((resolve) => {
    let settled = false;
    const done = (ok) => {
      if (settled) return;
      settled = true;
      L('RESOLVE', { candidateId, confirmed: !!ok, origMethod, newMethod });
      resolve(!!ok);
    };

    showModal(
      `Change pay method â€” ${directionLabel}`,
      [{ key:'main', label:'Summary' }],
      () => bodyHtml,
      async () => {
        // Called when user clicks Apply/Save on this modal
        try {
          L('APPLY â†’ applyCandidatePayMethodChange', {
            candidateId,
            newMethod,
            contractIds
          });
          const resp = await applyCandidatePayMethodChange(candidateId, {
            new_method: newMethod,
            contract_ids: contractIds
          });
          L('APPLY â† applyCandidatePayMethodChange', {
            candidate_id: resp?.candidate_id,
            original_method: resp?.original_method,
            new_method: resp?.new_method,
            summary: resp?.summary || null,
            old_contract_ids: resp?.old_contract_ids || [],
            new_contract_ids: resp?.new_contract_ids || []
          });

          // Prepare Contracts section to focus the before/after contracts
          focusContractsAfterBulkChange(resp);

          try { window.__toast && window.__toast('Pay method changed and contracts updated.'); } catch {}

          done(true);   // flip confirmed
          return true;  // close this modal
        } catch (err) {
          E('applyCandidatePayMethodChange failed', err);
          alert(err?.message || 'Failed to apply pay-method change.');
          done(false);  // treat as not-confirmed
          return false; // keep this modal open
        }
      },
      false,  // hasId
      () => {
        // onReturn is called when the modal is closed via X/Cancel etc.
        // If we get here and haven't already resolved, treat it as cancel.
        W('[CAND][PAY-METHOD][MODAL] closed without confirmation (cancel)');
        done(false);
      },
      { kind: 'candidate-pay-method-change', noParentGate: true, forceEdit: true }
    );
  });
}
function focusContractsAfterBulkChange(info) {
  if (!info || typeof info !== 'object') info = {};
  const newIds = Array.isArray(info.new_contract_ids) ? info.new_contract_ids.map(String) : [];
  const oldIds = Array.isArray(info.old_contract_ids) ? info.old_contract_ids.map(String) : [];

  const ids = [];
  newIds.forEach(id => { if (id && !ids.includes(id)) ids.push(id); });
  oldIds.forEach(id => { if (id && !ids.includes(id)) ids.push(id); });

  const primaryIds = newIds.filter(id => !!id);

  // Seed pending focus so renderSummary() can highlight once modals close
  if (ids.length) {
    window.__pendingFocus = {
      section: 'contracts',
      ids,
      primaryIds
    };
  }

  // Narrow Contracts list to just the affected contracts (old + new),
  // falling back to candidate_id only if we somehow have no ids.
  const candId = info.candidate_id || info.candidateId || null;
  window.__listState = window.__listState || {};
  const st = (window.__listState.contracts ||= {
    page: 1,
    pageSize: 50,
    total: null,
    hasMore: false,
    filters: null,
    sort: { key: null, dir: 'asc' }
  });

  if (!st.sort || typeof st.sort !== 'object') {
    st.sort = { key: null, dir: 'asc' };
  }

  if (!st.filters || typeof st.filters !== 'object') {
    st.filters = {};
  }

  if (ids.length) {
    // Use ids of affected contracts so we only see old+new
    st.filters.ids = ids;          // loadSection should turn this into ?ids=uuid1,uuid2,...
    st.page = 1;
    // (candidate_id is redundant at this point, so we can drop it if present)
    delete st.filters.candidate_id;
  } else if (candId) {
    // Fallback: narrow to candidate if no contract ids were provided
    st.filters.candidate_id = String(candId);
    st.page = 1;
  }

  // When jumping here from a bulk change, prefer "All" so the affected
  // contracts are visible regardless of previous status tab.
  st.filters.status = 'all';

  // Jump section to Contracts; renderAll() will be invoked either:
  // - by caller explicitly, or
  // - after the last modal is closed (see close logic that checks __pendingFocus).
  try {
    currentSection = 'contracts';
  } catch {}

  // We intentionally do NOT call renderAll() here so that
  // modal close logic can handle it once the stack is torn down.
}








































function stageContractCalendarBookings(contractId, dates /* array of ymd */) {
  const st = getContractCalendarStageState(contractId);
  for (const d of dates) { st.remove.delete(d); st.add.add(d); }

  // âœ… NEW: calendar-only dirty marker
  try {
    window.modalCtx = window.modalCtx || {};
    window.modalCtx.__calendarDirty = true;
    if (!window.modalCtx.__nonCalendarDirty) window.modalCtx.__calendarOnly = true;
  } catch {}

  try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
}

function stageContractCalendarUnbookings(contractId, dates /* array of ymd */) {
  const st = getContractCalendarStageState(contractId);
  for (const d of dates) { st.add.delete(d); st.remove.add(d); }

  // âœ… NEW: calendar-only dirty marker
  try {
    window.modalCtx = window.modalCtx || {};
    window.modalCtx.__calendarDirty = true;
    if (!window.modalCtx.__nonCalendarDirty) window.modalCtx.__calendarOnly = true;
  } catch {}

  try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
}

function stageContractCalendarAdditional(contractId, baseWeekId, dates /* array of ymd */) {
  const st = getContractCalendarStageState(contractId);
  const set = (st.additional[baseWeekId] ||= new Set());
  for (const d of dates) set.add(d);

  // âœ… NEW: calendar-only dirty marker
  try {
    window.modalCtx = window.modalCtx || {};
    window.modalCtx.__calendarDirty = true;
    if (!window.modalCtx.__nonCalendarDirty) window.modalCtx.__calendarOnly = true;
  } catch {}

  try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
}

// Overlay staged colors onto fetched items (without persisting)
function applyStagedContractCalendarOverlay(contractId, itemsByDate /* Map<date, [items]> */, weekIndex) {
  const st = getContractCalendarStageState(contractId);
  const overlay = new Map(itemsByDate ? itemsByDate : []);
  const addDates = [...st.add];
  const remDates = [...st.remove];

  const ensureArr = (k) => { const a = overlay.get(k) || []; overlay.set(k, a); return a; };

  const strong = (x) => {
    const s = String(x?.state || 'EMPTY').toUpperCase();
    return [
      'PROCESSED_NOT_READY',
      'READY',
      'PAY_ON_HOLD',
      'INVOICE_ON_HOLD',
      'PAY_AND_INVOICE_ON_HOLD',
      'INVOICED',
      'PAID',

      // legacy safety
      'SUBMITTED',
      'AUTHORISED'
    ].includes(s);
  };

  if (st.removeAll && (st.removeAll.from || st.removeAll.to)) {
    const from = st.removeAll.from || '0000-01-01';
    const to   = st.removeAll.to   || '9999-12-31';
    const dates = enumerateDates(from, to);

    for (const d of dates) {
      const we = computeWeekEnding(d, st.weekEndingWeekday || 0);
      let wi = weekIndex.get(we);

      if (!wi) {
        const weStart = addDays(we, -6);
        let hasStrongForThis = false;
        for (let i = 0; i < 7; i++) {
          const dd = addDays(weStart, i);
          const arr = overlay.get(dd) || [];
          if (arr.some(x => String(x.contract_id || '') === String(contractId) && strong(x))) {
            hasStrongForThis = true;
            break;
          }
        }
        wi = { baseHasTs: hasStrongForThis ? true : false };
      }

      const arr = ensureArr(d);
      if (wi.baseHasTs) continue;

      const filtered = arr.filter(x => !(
        String(x.contract_id || '') === String(contractId) &&
        String(x.state || 'EMPTY').toUpperCase() === 'PLANNED'
      ));
      overlay.set(d, filtered);
    }
  }

  for (const d of addDates) {
    const arr = ensureArr(d);
    const hasStrong = arr.some(strong);
    if (!hasStrong) {
      arr.push({ date: d, state: 'PLANNED', contract_id: contractId });
    }
  }

  for (const d of remDates) {
    const arr = ensureArr(d);
    const top = topState(arr);
    if (top === 'PLANNED') overlay.set(d, []);
  }

  for (const [baseWeekId, set] of Object.entries(st.additional)) {
    for (const d of set) {
      const arr = ensureArr(d);
      const hasStrong = arr.some(strong);
      if (!hasStrong) {
        arr.push({ date: d, state: 'PLANNED', contract_id: contractId });
      }
    }
  }

  return overlay;
}


// NEW â€” stage "Add missing weeks" (preview only)
// Decides dates from bounds and current template (std_schedule_json / __template),
// adds them into st.add; UI repaints via fetchAndRenderContractCalendar.
async function stageAddMissingWeeks(contractId, bounds) {
  const LOG_CAL = (typeof window.__LOG_CAL === 'boolean') ? window.__LOG_CAL : true;
  const L = (...a)=> { if (LOG_CAL) console.log('[CAL][stageAddMissingWeeks]', ...a); };

  const st = getContractCalendarStageState(contractId);

  const rawFrom = bounds?.from || window.modalCtx?.data?.start_date || null;
  const rawTo   = bounds?.to   || window.modalCtx?.data?.end_date   || null;
  if (!rawFrom || !rawTo) return { ok:false, reason:'no-bounds' };

  const from = (rawFrom.includes('/') && typeof parseUkDateToIso === 'function') ? (parseUkDateToIso(rawFrom) || rawFrom) : rawFrom;
  const to   = (rawTo.includes('/')   && typeof parseUkDateToIso === 'function') ? (parseUkDateToIso(rawTo)   || rawTo)   : rawTo;

  let template = (window.modalCtx?.data?.std_schedule_json && typeof window.modalCtx.data.std_schedule_json === 'object')
    ? window.modalCtx.data.std_schedule_json
    : null;
  if (!template) {
    try {
      const fsT = window.modalCtx?.formState?.main?.__template;
      if (fsT && typeof fsT === 'object') template = fsT;
    } catch {}
  }
  if (!template || typeof template !== 'object') return { ok:false, reason:'no-template' };

  const activeDows = new Set();
  const valid = (d) => d && typeof d.start === 'string' && d.start && typeof d.end === 'string' && d.end;
  if (valid(template.sun)) activeDows.add(0);
  if (valid(template.mon)) activeDows.add(1);
  if (valid(template.tue)) activeDows.add(2);
  if (valid(template.wed)) activeDows.add(3);
  if (valid(template.thu)) activeDows.add(4);
  if (valid(template.fri)) activeDows.add(5);
  if (valid(template.sat)) activeDows.add(6);

  st.removeAll = null;

  const days = enumerateDates(from, to);
  let added = 0;
  for (const d of days) {
    const dow = ymdToDate(d).getUTCDay();
    if (!activeDows.has(dow)) continue;
    st.remove.delete(d);
    if (!st.add.has(d)) { st.add.add(d); added++; }
  }

  try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
  L('staged add-missing', { from, to, added });
  return { ok:true, added, from, to };
}

function topState(arr) {
  if (!arr?.length) return 'EMPTY';

  // Highest wins
  const order = [
    'EMPTY',
    'PLANNED',

    // legacy workflow states (kept for safety)
    'SUBMITTED',
    'AUTHORISED',

    // new pipeline states
    'PROCESSED_NOT_READY',
    'READY',

    'INVOICED',
    'INVOICE_ON_HOLD',
    'PAY_ON_HOLD',
    'PAY_AND_INVOICE_ON_HOLD',
    'PAID'
  ];

  const prio = Object.fromEntries(order.map((s, i) => [s, i]));

  let best = 'EMPTY';
  for (const it of arr) {
    const st = String(it?.state || 'EMPTY').toUpperCase();

    // If a totally unknown state appears, keep it low (above EMPTY only if planned exists elsewhere)
    const p = (prio[st] != null) ? prio[st] : 0;

    if (p > (prio[best] || 0)) best = st;
  }
  return best;
}


// Build payloads for commit
function buildPlanRangesFromStage(contractId) {
  const LOG_CAL = (typeof window.__LOG_CAL === 'boolean') ? window.__LOG_CAL : true;
  const L = (...a)=> { if (LOG_CAL) console.log('[CAL][buildRanges]', ...a); };

  const st = getContractCalendarStageState(contractId);
  const adds = [...st.add].sort();
  const rems = [...st.remove].sort();

  const boundsOf = (arr) => computeSelectionBounds(arr);

  const isConsecutiveDailyRun = (arr) => {
    if (arr.length < 2) return false;
    const ONE = 24*60*60*1000;
    for (let i = 1; i < arr.length; i++) {
      const prev = new Date(arr[i-1] + 'T00:00:00Z').getTime();
      const curr = new Date(arr[i]   + 'T00:00:00Z').getTime();
      if ((curr - prev) !== ONE) return false;
    }
    return true;
  };

  // Current contract window in modal (ISO YYYY-MM-DD)
  const contract = (window.modalCtx && window.modalCtx.data) ? window.modalCtx.data : {};
  const contractStart = contract?.start_date || null;
  const contractEnd   = contract?.end_date   || null;

  // Template (std_schedule_json) if present
  let template = (window.modalCtx?.data?.std_schedule_json && typeof window.modalCtx.data.std_schedule_json === 'object')
    ? window.modalCtx.data.std_schedule_json
    : null;
  if (!template) {
    try {
      const fsT = window.modalCtx?.formState?.main?.__template;
      if (fsT && typeof fsT === 'object') template = fsT;
    } catch {}
  }

  const activeDows = (() => {
    const s = new Set();
    if (!template) return s;
    const valid = (d) => d && typeof d.start === 'string' && d.start && typeof d.end === 'string' && d.end;
    if (valid(template.sun)) s.add(0);
    if (valid(template.mon)) s.add(1);
    if (valid(template.tue)) s.add(2);
    if (valid(template.wed)) s.add(3);
    if (valid(template.thu)) s.add(4);
    if (valid(template.fri)) s.add(5);
    if (valid(template.sat)) s.add(6);
    return s;
  })();

  // If 'Remove All' was staged, build a single removal range across the (possibly current) contract window.
  if (st.removeAll) {
    const removeRanges = [];
    const from = st.removeAll.from || contractStart || null;
    const to   = st.removeAll.to   || contractEnd   || null;
    removeRanges.push({ from, to, days: [] });
    L('removeRanges (removeAll)', { bounds: { from, to } });
    return {
      addRanges: [],
      removeRanges,
      additionals: [],
      removeAll: true,
      // meta for symmetry callers
      needsLeftExtend: false,
      leftEdgeDate: null,
      rightEdgeDate: null
    };
  }

  // ---- Add ranges (with left-extend symmetry) ----
  const addRanges = [];
  let leftEdgeDate  = null;
  let rightEdgeDate = null;
  let needsLeftExtend = false;

  if (adds.length) {
    leftEdgeDate  = adds[0];
    rightEdgeDate = adds[adds.length - 1];

    // Detect if any add is strictly before the current contract start
    if (contractStart && leftEdgeDate < contractStart) {
      needsLeftExtend = true; // <-- symmetry trigger
    }

    const b = boundsOf(adds);
    const LONG_CONSECUTIVE_THRESHOLD = 10;
    const consecutive = isConsecutiveDailyRun(adds);

    // IMPORTANT: never produce an empty explicitDays when no template exists.
    // Only use weekday-compression if a valid template is present.
    const haveTemplate = activeDows.size > 0;
    let explicitDays;

    if (consecutive && adds.length >= LONG_CONSECUTIVE_THRESHOLD && haveTemplate) {
      explicitDays = adds
        .filter(d => activeDows.has(new Date(d + 'T00:00:00Z').getUTCDay()))
        .map(d => ({ date: d }));
    } else {
      // Always send explicit days when:
      // - no template, or
      // - selection is short/not long-consecutive, or
      // - we need left-extend (ensure backend sees concrete pre-start dates)
      explicitDays = adds.map(d => ({ date: d }));
    }

    addRanges.push({
      from: b.from,
      to:   b.to,
      days: explicitDays,
      merge: 'append',
      when_timesheet_exists: 'create_additional'
    });
    L('addRanges', { bounds: b, count: explicitDays.length, sample: explicitDays.slice(0, 5), needsLeftExtend });
  } else {
    L('addRanges: none');
  }

  // ---- Remove ranges ----
  const removeRanges = [];
  if (rems.length) {
    const b = boundsOf(rems);
    removeRanges.push({
      from: b.from,
      to:   b.to,
      days: rems
    });
    L('removeRanges', { bounds: b, count: rems.length, sample: rems.slice(0, 5) });
  } else {
    L('removeRanges: none');
  }

  // ---- Additional days (for split weeks) ----
  const additionals = Object.entries(st.additional).map(([baseWeekId, set]) => ({
    baseWeekId, dates: [...set].sort()
  }));
  L('additionals', { count: additionals.length, sample: additionals.slice(0, 3) });

  return {
    addRanges,
    removeRanges,
    additionals,
    removeAll: false,
    // symmetry meta for the commit path
    needsLeftExtend,
    leftEdgeDate,
    rightEdgeDate
  };
}
function revertContractCalendarStage(contractId) {
  clearContractCalendarStageState(contractId);
}

// ============================================================================
// CALENDAR â€“ API WRAPPERS
// ============================================================================

async function getContractCalendar(contract_id, opts) {
  const qs = new URLSearchParams();
  if (typeof opts === 'number') {
    qs.set('year', String(opts));
  } else if (opts && typeof opts === 'object') {
    if (opts.from) qs.set('from', String(opts.from));
    if (opts.to) qs.set('to',   String(opts.to));
    if (opts.granularity) qs.set('granularity', String(opts.granularity)); else qs.set('granularity', 'week');
    if (!opts.from && !opts.to && opts.year) qs.set('year', String(opts.year));
  } else {
    qs.set('year', String((new Date()).getUTCFullYear()));
  }
  const url = `/api/contracts/${_enc(contract_id)}/calendar?` + qs.toString();
  const r = await authFetch(API(url));
  if (!r?.ok) throw new Error('Calendar fetch failed');
  return r.json();
}
async function getContractCalendarRange(contract_id, from, to, granularity = 'day') {
  return getContractCalendar(contract_id, { from, to, granularity });
}
// Thin wrapper to match existing call sites.
// Backend returns day-level items; granularity is ignored for now.
async function getCandidateCalendarRange(candidate_id, from, to, granularity = 'day') {
  const qs = new URLSearchParams();
  qs.set('from', from);
  qs.set('to', to);

  try {
    const r = await authFetch(API(`/api/candidates/${_enc(candidate_id)}/calendar?` + qs.toString()));
    if (!r || !r.ok) {
      try { const err = await r.json(); console.warn('[CAL][candidate] non-200', err); } catch {}
      return { candidate_id, from, to, contracts: [], items: [] };
    }

    const data = await r.json().catch(() => null);
    if (!data) return { candidate_id, from, to, contracts: [], items: [] };

    // Expect: { candidate_id, from, to, contracts: [...], items: [...] }
    const items = Array.isArray(data.items) ? data.items : [];
    const contracts = Array.isArray(data.contracts) ? data.contracts : [];

    return {
      candidate_id: data.candidate_id || candidate_id,
      from: data.from || from,
      to: data.to || to,
      contracts,
      items
    };
  } catch (e) {
    console.warn('[CAL][candidate] fetch failed', e);
    return { candidate_id, from, to, contracts: [], items: [] };
  }
}


async function getCandidateCalendar(candidate_id, from, to) {
  const qs = new URLSearchParams(); qs.set('from', from); qs.set('to', to);
  const r = await authFetch(API(`/api/candidates/${_enc(candidate_id)}/calendar?` + qs.toString()));
  if (!r?.ok) throw new Error('Candidate calendar fetch failed');
  return r.json();
}
async function contractsPlanRanges(contract_id, payload) {
  const r = await authFetch(API(`/api/contracts/${_enc(contract_id)}/plan-ranges`), { method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify(payload) });
  if (!r?.ok) throw new Error(await r.text()); return r.json();
}
async function contractsUnplanRanges(contract_id, payload) {
  const r = await authFetch(API(`/api/contracts/${_enc(contract_id)}/plan-ranges`), { method:'DELETE', headers:{'content-type':'application/json'}, body: JSON.stringify(payload) });
  if (!r?.ok) throw new Error(await r.text()); return r.json();
}
async function contractWeekPlanPatch(week_id, payload) {
  const r = await authFetch(API(`/api/contract-weeks/${_enc(week_id)}/plan`), { method:'PATCH', headers:{'content-type':'application/json'}, body: JSON.stringify(payload) });
  if (!r?.ok) throw new Error(await r.text()); return r.json();
}

// ============================================================================
// CALENDAR â€“ CONTEXT MENU
// ============================================================================
function openCalendarContextMenu({ anchorEl, bucketKey, selection, capabilities, onAction }) {
  const LOG_CAL = (typeof window.__LOG_CAL === 'boolean') ? window.__LOG_CAL : true;
  const L = (...a)=> { if (LOG_CAL) console.log('[CAL][ctx]', ...a); };

  // Remove any existing menu first
  document.getElementById('calCtxMenu')?.remove();

  // Create menu
  const menu = document.createElement('div');
  menu.id = 'calCtxMenu';
  menu.className = 'ctx-menu';

  // Position
  const r = anchorEl.getBoundingClientRect();
  menu.style.position = 'absolute';
  menu.style.zIndex = 10000;
  menu.style.top  = (window.scrollY + r.bottom) + 'px';
  menu.style.left = (window.scrollX + r.left) + 'px';

  // Dark, bordered, legible styling (inline so it works even without CSS)
  menu.style.minWidth = '180px';
  menu.style.padding = '6px';
  menu.style.border = '1px solid var(--line)';
  menu.style.borderRadius = '10px';
  menu.style.background = 'rgba(12, 21, 42, 0.98)'; // slightly lighter than page bg
  menu.style.boxShadow = '0 12px 28px rgba(0,0,0,.45), inset 0 0 0 1px rgba(255,255,255,.02)';
  menu.style.backdropFilter = 'blur(6px) saturate(120%)';

  // Items
  menu.innerHTML = `
    <div class="ctx-item ${capabilities.canBook ? '' : 'disabled'}"  data-act="book">Book</div>
    <div class="ctx-item ${capabilities.canUnbook ? '' : 'disabled'}" data-act="unbook">Unbook</div>
    <div class="ctx-item ${capabilities.canAddAdditional ? '' : 'disabled'}" data-act="additional">Add additional sheet</div>
  `;

  // Minimal inline item styles + hover
  [...menu.querySelectorAll('.ctx-item')].forEach((el, i) => {
    el.style.color = 'var(--text)';
    el.style.padding = '8px 10px';
    el.style.borderRadius = '8px';
    el.style.cursor = el.classList.contains('disabled') ? 'not-allowed' : 'pointer';
    el.style.userSelect = 'none';
    el.style.lineHeight = '1.25';
    if (i > 0) el.style.marginTop = '4px';
    el.addEventListener('mouseenter', () => { if (!el.classList.contains('disabled')) el.style.background = 'var(--hover)'; });
    el.addEventListener('mouseleave', () => { el.style.background = 'transparent'; });
    if (el.classList.contains('disabled')) { el.style.opacity = '.45'; el.style.filter = 'saturate(0.6) brightness(0.9)'; }
  });

  document.body.appendChild(menu);

  // Diagnostic log
  L('open', {
    bucketKey,
    selection: selection.slice(),
    capabilities
  });

  // Close + dispatch
  const close = () => { try { menu.remove(); } catch {} };
  menu.addEventListener('click', (e) => {
    const act = e.target?.getAttribute?.('data-act');
    if (!act || e.target.classList.contains('disabled')) return;
    close();
    onAction && onAction({ type: act, selection });
  });

  // Dismiss when clicking outside
  const onDoc = (e) => {
    if (!menu.contains(e.target)) {
      close();
      document.removeEventListener('mousedown', onDoc, true);
    }
  };
  setTimeout(() => document.addEventListener('mousedown', onDoc, true), 0);
}


// ============================================================================
// CALENDAR â€“ GENERIC DAY GRID
// ============================================================================


function renderCalendarLegend(container) {
  if (!container) return;

  container.innerHTML = `
    <div class="legend">
      <span class="chip cal-planned">Planned</span>
      <span class="chip cal-processed">Processed (not ready)</span>
      <span class="chip cal-ready">Ready</span>
      <span class="chip cal-invoiced">Invoiced</span>
      <span class="chip cal-invoice-hold">Invoice on hold</span>
      <span class="chip cal-pay-hold">Pay on hold</span>
      <span class="chip cal-pay-invoice-hold">Pay + invoice on hold</span>
      <span class="chip cal-paid">Paid</span>

      <span class="chip">Not booked</span>

      <span class="chip cal-flag-payline">Pay line held</span>
      <span class="chip cal-flag-invoiceline">Invoice line delayed</span>
      <span class="chip occupied-other">Other contract (occupied)</span>
    </div>`;
}

function renderDayGrid(hostEl, opts) {
  if (!hostEl) return;
  const { from, to, itemsByDate, view, bucketKey } = opts;
  const sel = initSelBucket(bucketKey);
  const isContractBucket = (typeof bucketKey === 'string') && bucketKey.startsWith('c:');
  const currentKey = isContractBucket ? bucketKey.slice(2) : null;
  const interactive = (typeof opts.isInteractive === 'boolean') ? opts.isInteractive : true;

  hostEl.tripwire && hostEl.tripwire.abort?.();
  const controller = new AbortController();
  hostEl.tripwire = controller;

  hostEl.innerHTML = '';
  const toolbar = document.createElement('div');
  toolbar.className = 'row';
  toolbar.style.justifyContent = 'space-between';
  toolbar.style.alignItems = 'center';
  toolbar.innerHTML = `
    <div class="actions">
      <button id="calPrev">â—€</button>
      <button id="calNext">â–¶</button>
      <button id="calToggle">${view === 'year' ? 'Month view' : 'Year view'}</button>
    </div>
    <div class="hint">${from} â†’ ${to}</div>`;
  hostEl.appendChild(toolbar);

  const wrap = document.createElement('div');
  wrap.className = (view === 'year') ? 'year-wrap' : 'month-wrap';
  hostEl.appendChild(wrap);

  const months = [];
  if (view === 'year') {
    const y = ymdToDate(from).getUTCFullYear();
    for (let m = 0; m < 12; m++) months.push({ y, m });
  } else {
    const d0 = ymdToDate(from);
    months.push({ y: d0.getUTCFullYear(), m: d0.getUTCMonth() });
  }

  // Monday-first weekday labels (Mon..Sun)
  const DOW_LONG  = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
  const DOW_SHORT = ['M', 'T', 'W', 'T', 'F', 'S', 'S'];

  // NEW: human-readable state labels for hover tooltips
  const prettyStateLabel = (st) => {
    const s = String(st || '').toUpperCase();
    if (!s || s === 'EMPTY') return 'Not booked';
    if (s === 'PLANNED') return 'Booked';
    if (s === 'PROCESSED') return 'Processed';
    if (s === 'READY') return 'Ready';
    if (s === 'AUTHORISED' || s === 'AUTHORIZED') return 'Authorised';
    if (s === 'INVOICED') return 'Invoiced';
    if (s === 'PAID') return 'Paid';
    return s; // fallback
  };

  for (const { y, m } of months) {
    const box = document.createElement('div');
    box.className = 'month';
    box.innerHTML = `<h4>${new Date(Date.UTC(y, m, 1)).toLocaleString(undefined, { month: 'long' })} ${y}</h4>`;

    // Weekday header row (Mon..Sun)
    const hdr = document.createElement('div');
    hdr.className = 'days dow-head';
    const labels = (view === 'year') ? DOW_SHORT : DOW_LONG;
    for (let i = 0; i < 7; i++) {
      const h = document.createElement('div');
      h.className = 'dow-h';
      h.textContent = labels[i];
      hdr.appendChild(h);
    }
    box.appendChild(hdr);

    // Day grid
    const days = document.createElement('div');
    days.className = (view === 'year') ? 'days' : 'days days-large';

    // Monday-first offset:
    // JS: Sun=0..Sat=6  â†’  Mon-first index: Mon=0..Sun=6
    const first = new Date(Date.UTC(y, m, 1));
    const jsDow = first.getUTCDay();           // 0..6 (Sun..Sat)
    const monIndex = (jsDow + 6) % 7;          // 0..6 (Mon..Sun)

    for (let i = 0; i < monIndex; i++) {
      const blank = document.createElement('div');
      blank.className = 'd blank';
      days.appendChild(blank);
    }

    const daysInMonth = new Date(Date.UTC(y, m + 1, 0)).getUTCDate();

    for (let d = 1; d <= daysInMonth; d++) {
      const cell = document.createElement('div');
      cell.className = 'd';
      const dYmd = `${y}-${String(m + 1).padStart(2, '0')}-${String(d).padStart(2, '0')}`;
      const items = itemsByDate.get(dYmd) || [];

      // Decide which items are relevant for colouring + overlays
      let relevant = items;
      let ownedByCurrent = false;

      if (isContractBucket) {
        const keyStr = String(currentKey || '');
        relevant = items.filter(it => String(it?.contract_id || '') === keyStr);
        ownedByCurrent = relevant.length > 0;
      }

      // Base state from relevant items (candidate unfiltered = all items; filtered/contract = owned)
      const finalState = (relevant.length > 0)
        ? ((typeof topState === 'function') ? topState(relevant) : 'EMPTY')
        : 'EMPTY';

      const stateClass = (typeof colorForState === 'function') ? colorForState(finalState) : null;
      if (stateClass) cell.classList.add(stateClass);

      // Per-line hold overlays (only for relevant items)
      const hasPayLineHold = relevant.some(it => it && it.pay_line_on_hold === true);
      const hasInvoiceLineHold = relevant.some(it => it && it.invoice_line_on_hold === true);
      if (hasPayLineHold) cell.classList.add('flag-payline-hold');
      if (hasInvoiceLineHold) cell.classList.add('flag-invoiceline-hold');

      // Grey â€œoccupied by other contractâ€ days in contract-centric views
      let occupiedByOtherOnly = false;
      if (isContractBucket) {
        const keyStr = String(currentKey || '');
        occupiedByOtherOnly =
          !ownedByCurrent &&
          items.some(it => {
            const cid = String(it?.contract_id || '');
            return !!cid && cid !== keyStr;
          });
        if (occupiedByOtherOnly) {
          cell.classList.add('occupied-other');
        }
      }

      if (sel.set.has(dYmd)) cell.className += ' selected';

      // Cell content: ONLY the date number
      cell.innerHTML = `<div class="ico"><div class="num">${d}</div></div>`;
      cell.setAttribute('data-date', dYmd);

      // NEW: Hover tooltip shows STATUS in words (and includes the date)
      try {
        const jsDay = new Date(Date.UTC(y, m, d)).getUTCDay();
        const monDay = (jsDay + 6) % 7;

        // Base label: other-contract overrides everything in contract-centric view
        let statusLabel = occupiedByOtherOnly
          ? 'Other contract'
          : prettyStateLabel(finalState);

        // Add holds/details (only when the date has something meaningful)
        const extras = [];

        // Contract-level holds (these appear on day items in your payloads)
        const hasPayHold = relevant.some(it => it && it.pay_on_hold === true);
        const hasInvoiceHold = relevant.some(it => it && it.invoice_on_hold === true);

        if (hasPayHold) extras.push('Pay on hold');
        if (hasInvoiceHold) extras.push('Invoice on hold');
        if (hasPayLineHold) extras.push('Pay line held');
        if (hasInvoiceLineHold) extras.push('Invoice line delayed');

        // Candidate view: if multiple different contracts exist on this date, mention it
        if (!isContractBucket) {
          const uniq = new Set(
            (items || [])
              .map(it => String(it?.contract_id || '').trim())
              .filter(Boolean)
          );
          if (uniq.size > 1) extras.push(`Multiple contracts (${uniq.size})`);
        }

        const extraStr = extras.length ? ` â€¢ ${extras.join(' â€¢ ')}` : '';
        cell.title = `${statusLabel}${extraStr}\n${DOW_LONG[monDay]} ${dYmd}`;
      } catch {}

      if (interactive) {
        const onClick = (ev) => {
          if (controller.signal.aborted) return;
          const additive = ev.ctrlKey || ev.metaKey;
          const bucket = bucketKey;
          const anchor = initSelBucket(bucket).anchor;
          const useRange = ev.shiftKey && !!(anchor);
          if (useRange) {
            selectRange(bucket, anchor, dYmd, additive);
          } else {
            toggleDaySelected(bucket, dYmd, additive);
          }
          wrap.querySelectorAll('.d.selected').forEach(n => n.classList.remove('selected'));
          initSelBucket(bucket).set.forEach(s => {
            const dom = wrap.querySelector(`.d[data-date="${CSS.escape(s)}"]`);
            if (dom) dom.classList.add('selected');
          });
        };
        const onCtx = (ev) => {
          if (controller.signal.aborted) return;
          ev.preventDefault();
          const bucket = bucketKey;
          const selSet = initSelBucket(bucket).set;
          if (!selSet.has(dYmd)) {
            clearCalendarSelection(bucket);
            toggleDaySelected(bucket, dYmd, false);
            cell.classList.add('selected');
          }
          opts.onCellContextMenu && opts.onCellContextMenu(dYmd, ev);
        };
        cell.addEventListener('click', onClick, { signal: controller.signal });
        cell.addEventListener('contextmenu', onCtx, { signal: controller.signal });
      }

      days.appendChild(cell);
    }

    box.appendChild(days);
    wrap.appendChild(box);
  }

  toolbar.querySelector('#calPrev')?.addEventListener('click', () => {
    if (!controller.signal.aborted) opts.onNav && opts.onNav(-1);
  }, { signal: controller.signal });

  toolbar.querySelector('#calNext')?.addEventListener('click', () => {
    if (!controller.signal.aborted) opts.onNav && opts.onNav(1);
  }, { signal: controller.signal });

  toolbar.querySelector('#calToggle')?.addEventListener('click', () => {
    if (!controller.signal.aborted) opts.onToggleView && opts.onToggleView();
  }, { signal: controller.signal });
}




// ============================================================================
// CONTRACTS â€“ FETCH & RENDER (DAY CALENDAR) with STAGING
// ============================================================================


// Calendar Save/Discard is deprecated â€” keep as a no-op to avoid breaking older calls.
function wireContractCalendarSaveControls(contractId, holder, weekIndex) {
  // Remove old bar if present, and do not render anything new
  holder.querySelector('#calSaveBar')?.remove();
  // No-op: Big Save (modal) is responsible for committing calendar changes now.
}

// ============================================================================
// CONTRACTS â€“ TAB RENDERER
// ============================================================================

function renderContractCalendarTab(ctx) {
  const LOGM = !!window.__LOG_MODAL;
  const c = ctx?.data || {};
  const holderId = 'contractCalendarHolder';

  const currentKey = (c.id || window.modalCtx?.openToken || null);
  const candId = c.candidate_id
              || (window.modalCtx?.formState?.main?.candidate_id || '').trim()
              || (document.querySelector('#contractForm input[name="candidate_id"]')?.value || '').trim();

  const weekEnding = (c.week_ending_weekday_snapshot ?? window.modalCtx?.formState?.main?.week_ending_weekday_snapshot ?? 0);

  const fr = (typeof window.__getModalFrame === 'function') ? window.__getModalFrame() : null;
  const inViewMode = !!(fr && fr.mode === 'view');

  // --- actions (includes Duplicate + Change Rates)
  const actionsHtml = (c.id
    ? `<div class="actions" style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap">
         ${inViewMode ? `` : `<button id="btnAddMissing">Add missing weeks</button>
         <button id="btnRemoveAll">Remove all weeks</button>`}
         ${inViewMode ? `<button id="btnCloneExtend">Clone & Extendâ€¦</button>
         <button id="btnDuplicateContract">Duplicate Contractâ€¦</button>
         <button id="btnChangeRatesOutstanding">Change Contract Ratesâ€¦</button>` : ``}
       </div>`
    : ``);

  // --- early hint ONLY for brand-new contracts with no candidate
  const hasId = !!c.id;
  if (!hasId && !candId) {
    if (LOGM) console.log('[CAL][contract] no candidate yet for NEW contract; render hint');
    return `
      <div id="${holderId}" class="tabc">
        <div class="info-row" style="margin:0 0 8px 0;font-size:13px;">
          <strong>Candidate:</strong>
          <span class="unassigned" style="color:var(--danger,#c0392b);margin-left:6px;">&lt;Unassigned&gt;</span>
        </div>
        <div class="hint">Pick a candidate to view and stage calendar dates.</div>
        ${actionsHtml}
      </div>`;
  }

  setTimeout(async () => {
    try {
      const el = byId(holderId); if (!el) return;

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // âœ… FULL FIX: preserve view/window + restore scroll on every repaint
      // Priority:
      //  1) modalCtx.__calViewport (captured before save/edit)
      //  2) window.__calState[contractId] (persisted by fetchAndRenderContractCalendar)
      //  3) fallback current year
      // Also: capture scroll BEFORE we replace DOM
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      const contractId = c.id || null;

      // capture existing scroll BEFORE we rebuild DOM (otherwise it becomes 0)
      const prevScrollTop  = byId('__calScroll')?.scrollTop  ?? 0;
      const prevScrollLeft = byId('__calScroll')?.scrollLeft ?? 0;

      const vp = (contractId && window.modalCtx?.__calViewport && window.modalCtx.__calViewport.contract_id === contractId)
        ? window.modalCtx.__calViewport
        : null;

      const st = (contractId && window.__calState && window.__calState[contractId])
        ? window.__calState[contractId]
        : null;

      const view =
        vp?.view ||
        st?.view ||
        'year';

      const win =
        (vp?.win && vp.win.from && vp.win.to)
          ? vp.win
          : (st?.win && st.win.from && st.win.to)
            ? st.win
            : computeYearWindow((new Date()).getUTCFullYear());

      const restoreScroll = {
        top:  (vp?.scrollTop  ?? st?.scrollTop  ?? prevScrollTop  ?? 0),
        left: (vp?.scrollLeft ?? st?.scrollLeft ?? prevScrollLeft ?? 0)
      };

      el.innerHTML = `
        <div class="tabc" style="display:flex;flex-direction:column;gap:8px;height:calc(72vh);max-height:calc(72vh)">
          <div class="info-row" style="font-size:13px;">
            <strong>Candidate:</strong>
            <span id="__calCandidateName" style="margin-left:6px;"></span>
          </div>
          <div id="__calScroll" style="flex:1;min-height:0;overflow:auto;border:1px solid var(--line,#e5e5e5);border-radius:8px;padding:4px;">
            <div id="__contractCal"></div>
          </div>
          ${actionsHtml}
        </div>`;

      // Render the candidate label (supports <Unassigned>)
      try {
        const nameEl = el.querySelector('#__calCandidateName');
        if (nameEl) {
          const stagedLabel = (window.modalCtx?.formState?.main?.candidate_display || '').trim();
          const rowLabel    = (c.candidate_display || c.candidate_name || '').trim();
          const label       = stagedLabel || rowLabel || '';
          if (label) {
            nameEl.textContent = label;
          } else {
            nameEl.textContent = '<Unassigned>';
            nameEl.style.color = 'var(--danger,#c0392b)';
          }
        }
      } catch {}

      if (c.id) {
        // EXISTING contract â†’ use preserved view/window + restore scroll
        if (LOGM) console.log('[CAL][contract] render with real contract id (preserve viewport)', {
          id: c.id, view, win, restoreScroll
        });

        await fetchAndRenderContractCalendar(c.id, {
          from: win.from,
          to: win.to,
          view,
          weekEnding: Number(weekEnding),
          __restoreScroll: restoreScroll
        });

      } else {
        // CREATE mode with candidate â†’ preserve window/view only (scroll restore still helps)
        if (LOGM) console.log('[CAL][contract] render in CREATE mode (candidate-wide) with token bucket', {
          token: currentKey, candId, weekEnding, view, win, restoreScroll
        });

        await fetchAndRenderCandidateCalendarForContract(
          currentKey,
          candId,
          {
            from: win.from,
            to: win.to,
            view,
            weekEnding: Number(weekEnding),
            __restoreScroll: restoreScroll
          }
        );

        // best-effort restore if candidate-wide renderer doesnâ€™t support __restoreScroll
        try {
          const sb = byId('__calScroll');
          if (sb) {
            requestAnimationFrame(() => requestAnimationFrame(() => {
              sb.scrollTop  = restoreScroll.top  || 0;
              sb.scrollLeft = restoreScroll.left || 0;
            }));
          }
        } catch {}
      }

      if (c.id) {
        const btnAdd = el.querySelector('#btnAddMissing');
        if (btnAdd && !btnAdd.__wired) {
          btnAdd.__wired = true;
          btnAdd.addEventListener('click', async () => {
            if (typeof stageAddMissingWeeks === 'function') {
              if (LOGM) console.log('[CAL][contract] stage add missing weeks', { id: c.id, from: c.start_date || win.from, to: c.end_date || win.to });
              await stageAddMissingWeeks(c.id, { from: c.start_date || win.from, to: c.end_date || win.to });
              try { showModalHint?.('Missing weeks staged (preview only). Save to persist.', 'warn'); } catch {}
            }

            const sb0 = byId('__calScroll');
            const prev = sb0 ? sb0.scrollTop : 0;
            const prevL = sb0 ? sb0.scrollLeft : 0;

            await fetchAndRenderContractCalendar(
              c.id,
              {
                from: window.__calState[c.id]?.win?.from,
                to:   window.__calState[c.id]?.win?.to,
                view: window.__calState[c.id]?.view,
                weekEnding: Number(weekEnding),
                __restoreScroll: { top: prev, left: prevL }
              }
            );
          });
        }

        const btnRem = el.querySelector('#btnRemoveAll');
        if (btnRem && !btnRem.__wired) {
          btnRem.__wired = true;
          btnRem.addEventListener('click', async () => {
            if (!window.confirm('Remove all unsubmitted weeks for this contract?')) return;
            if (typeof removeAllUnsubmittedWeeks === 'function') {
              if (LOGM) console.log('[CAL][contract] stage remove all unsubmitted weeks', { id: c.id, from: c.start_date || null, to: c.end_date || null });
              await removeAllUnsubmittedWeeks(c.id, { from: c.start_date || null, to: c.end_date || null });
              try { showModalHint?.('All unsubmitted weeks staged for removal (preview only). Save to persist.', 'warn'); } catch {}
            }

            const sb0 = byId('__calScroll');
            const prev = sb0 ? sb0.scrollTop : 0;
            const prevL = sb0 ? sb0.scrollLeft : 0;

            await fetchAndRenderContractCalendar(
              c.id,
              {
                from: window.__calState[c.id]?.win?.from,
                to:   window.__calState[c.id]?.win?.to,
                view: window.__calState[c.id]?.view,
                weekEnding: Number(weekEnding),
                __restoreScroll: { top: prev, left: prevL }
              }
            );
          });
        }

        const btnCE = el.querySelector('#btnCloneExtend');
        if (btnCE && !btnCE.__wired) {
          btnCE.__wired = true;
          btnCE.addEventListener('click', () => {
            if (LOGM) console.log('[CAL][contract] open clone & extend', { id: c.id });
            openContractCloneAndExtend(c.id);
          });
        }

        // NEW: Change Contract Rates (outstanding weeks)
        const btnCR = el.querySelector('#btnChangeRatesOutstanding');
        if (btnCR && !btnCR.__wired) {
          btnCR.__wired = true;
          btnCR.addEventListener('click', () => {
            if (typeof openChangeContractRatesModal === 'function') {
              if (LOGM) console.log('[CAL][contract] open change contract rates', { id: c.id });
              openChangeContractRatesModal(c.id);
            } else {
              alert('Change Contract Rates is not available in this build.');
            }
          });
        }

        // Duplicate Contractâ€¦
        const btnDup = el.querySelector('#btnDuplicateContract');
        if (btnDup && !btnDup.__wired) {
          btnDup.__wired = true;
          btnDup.addEventListener('click', async () => {
            try {
              const countStr = window.prompt(
                'How many duplicate contracts do you require? (1â€“10)',
                '1'
              );
              if (countStr == null) return; // user hit Cancel

              const n = Number(countStr);
              if (!Number.isInteger(n) || n < 1 || n > 10) {
                alert('Please enter a whole number between 1 and 10.');
                return;
              }

              if (typeof duplicateContract !== 'function') {
                alert('Duplicate action is unavailable in this build.');
                return;
              }

              const res = await duplicateContract(c.id, { count: n });
              const ok  = !!(res && (res.ok === undefined ? true : res.ok));
              if (!ok) {
                const msg = res && res.message ? res.message : 'Duplicate failed';
                alert(msg);
                return;
              }

              const created = (res && Number.isInteger(res.count)) ? res.count : n;
              try {
                window.__toast?.(
                  `${created} duplicate contract${created > 1 ? 's' : ''} created`
                );
              } catch {}

              // Refresh list (and hence calendars/rows)
              try { await renderAll(); } catch {}
            } catch (e) {
              if (LOGM) console.warn('[CAL][contract] duplicate failed', e);
              alert(e?.message || 'Duplicate failed');
            }
          });
        }
      }
    } catch (e) {
      const el = byId(holderId); if (el) el.innerHTML = `<div class="error">Calendar load failed.</div>`;
      if (LOGM) console.warn('[CAL][contract] calendar render failed', e);
    }
  }, 0);

  return `
    <div id="${holderId}" class="tabc">
      <div class="info-row" style="margin:0 0 8px 0;font-size:13px;">
        <strong>Candidate:</strong>
        <span id="__calCandidateName" style="margin-left:6px;"></span>
      </div>
      <div class="hint">Loading calendarâ€¦</div>
      ${actionsHtml}
    </div>`;
}


function isConsecutiveDailyRun(dates) {
  if (!Array.isArray(dates) || dates.length < 2) return false;
  const arr = [...dates].sort();
  let hasPair = false;
  for (let i = 1; i < arr.length; i++) {
    const a = ymdToDate(arr[i - 1]);
    const b = ymdToDate(arr[i]);
    const diff = Math.round((b - a) / 86400000);
    if (diff === 1) hasPair = true;
  }
  return hasPair;
}

function updateCalendarInteractivity(isInteractive) {
  window.__calInteractive = !!isInteractive;
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 5) Optional thin wrapper if you prefer not to call the API
//    directly throughout the UI (used by calendar wrapper).
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function fetchCandidateCalendarForRange(candidateId, fromYmd, toYmd) {
  if (typeof getCandidateCalendarRange !== 'function') return { items: [] };
  try {
    return await getCandidateCalendarRange(candidateId, fromYmd, toYmd, 'day');
  } catch {
    return { items: [] };
  }
}
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 4) Unbooking helper (present in some snippets, ensure available)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function stageContractCalendarUnbookings(contractId, dates /* array of ymd */) {
  const st = getContractCalendarStageState(contractId);
  for (const d of dates) { st.add.delete(d); st.remove.add(d); }
}
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 3) Stage adoption helper (token â†’ real id) for create flow
//    You can use this inside openContract.onSave to simplify.
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function adoptCalendarStageFromToken(openToken, contractId) {
  const LOG_CAL = (typeof window.__LOG_CAL === 'boolean') ? window.__LOG_CAL : false;
  if (!openToken || !contractId || typeof getContractCalendarStageState !== 'function') return false;
  try {
    const stToken = getContractCalendarStageState(openToken);
    if (!stToken) return false;
    const has = (stToken.add?.size || stToken.remove?.size || Object.keys(stToken.additional||{}).length);
    if (!has) return false;
    const stId = getContractCalendarStageState(contractId);
    for (const d of stToken.add)    stId.add.add(d);
    for (const d of stToken.remove) stId.remove.add(d);
    stId.additional = { ...(stId.additional||{}), ...(stToken.additional||{}) };
    stToken.add?.clear?.(); stToken.remove?.clear?.(); stToken.additional = {};
    if (LOG_CAL) console.log('[CAL][adopt] token â†’ id', { openToken, contractId });
    return true;
  } catch (e) {
    if (LOG_CAL) console.warn('[CAL][adopt] failed', e);
    return false;
  }
}
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 2) Candidate-wide calendar renderer for the contract modal
//    Always renders ALL bookings for the candidate and stages
//    against currentKey (contract.id or openToken).
//    (Used by renderContractCalendarTab and openContract repaint)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function computeContractSaveEligibility() {
  try {
    const fs   = (window.modalCtx && window.modalCtx.formState) || { main:{}, pay:{} };
    const data = (window.modalCtx && window.modalCtx.data) || {};
    const form = document.querySelector('#contractForm');

    const val = (name) => {
      const staged = fs.main && fs.main[name];
      if (staged !== undefined && staged !== null && String(staged).trim() !== '') return String(staged).trim();
      const el = form ? form.querySelector(`[name="${name}"]`) : null;
      return el ? String(el.value || '').trim() : '';
    };

    const hasText = (s) => !!(s && String(s).trim().length);

    // -------- Required entities with fallback to saved data
    const candidateOk = hasText(val('candidate_id')) || !!data.candidate_id;
    const clientOk    = hasText(val('client_id'))    || !!data.client_id;
    const roleOk      = hasText(val('role'))         || !!data.role;

    // -------- Dates (with fallback to saved row, and awareness of pending auto-expand)
    const toIso = (uk) => {
      if (!uk) return '';
      try { return (typeof parseUkDateToIso === 'function') ? (parseUkDateToIso(uk) || '') : uk; }
      catch { return uk; }
    };
    const vSd = val('start_date'), vEd = val('end_date');
    const sdIsoRaw = toIso(vSd) || (data.start_date || '');
    const edIsoRaw = toIso(vEd) || (data.end_date   || '');

    const bothDatesProvided = /^\d{4}-\d{2}-\d{2}$/.test(sdIsoRaw) && /^\d{4}-\d{2}-\d{2}$/.test(edIsoRaw);
    const dateOrderOk       = (!bothDatesProvided) || (sdIsoRaw <= edIsoRaw);

    const pendingExpand = (window.modalCtx && window.modalCtx.__windowExpand && window.modalCtx.__windowExpand.start && window.modalCtx.__windowExpand.end) ? window.modalCtx.__windowExpand : null;

    // -------- Is there any staged calendar?
    let hasStaged = false;
    try {
      const key = data.id || window.modalCtx?.openToken || null;
      if (key && typeof getContractCalendarStageState === 'function') {
        const st = getContractCalendarStageState(key);
        hasStaged = !!(st && (st.add?.size || st.remove?.size || (st.additional && Object.keys(st.additional).length)));
      }
    } catch {}

    // -------- Schedule validation (pending time format supported) with template fallback
    const reValidHHMM   = /^(\d{1,2}):(\d{2})$/;
    const rePendingOnly = /^\d{3,4}$/;
    const hhmm = (s) => {
      const m = String(s||'').match(reValidHHMM);
      if (!m) return null;
      const h = +m[1], mi = +m[2];
      if (h<0 || h>23 || mi<0 || mi>59) return null;
      return [h,mi];
    };

    const days = ['mon','tue','wed','thu','fri','sat','sun'];
    let hasValidPair   = false;
    let hasPendingPair = false;
    const pendingFields = [];
    const pendingDays   = [];

    for (const d of days) {
      const s = val(`${d}_start`);
      const e = val(`${d}_end`);
      if (!s || !e) continue;

      const sValid   = !!hhmm(s);
      const eValid   = !!hhmm(e);
      const sPending = rePendingOnly.test(s);
      const ePending = rePendingOnly.test(e);

      if (sValid && eValid) {
        hasValidPair = true;
      } else if ((sValid || sPending) && (eValid || ePending)) {
        hasPendingPair = true;
        if (sPending) pendingFields.push(`${d}_start`);
        if (ePending) pendingFields.push(`${d}_end`);
        pendingDays.push(d);
      }
    }

    const hasTemplate = !!(data.std_schedule_json && typeof data.std_schedule_json === 'object' && Object.keys(data.std_schedule_json).length);
    const scheduleOk = (hasValidPair || hasPendingPair || hasStaged || hasTemplate);
    const pendingTimeFormat = hasPendingPair || pendingFields.length > 0;

    // -------- Finance checks (with fallback to saved rates_json)
    const payMethod = ((val('pay_method_snapshot') || data.pay_method_snapshot || 'PAYE')).toUpperCase();

    const getNum = (n) => {
      if (fs.pay && Object.prototype.hasOwnProperty.call(fs.pay, n)) {
        const rawS = fs.pay[n];
        if (rawS !== '' && rawS !== null && rawS !== undefined) {
          const numS = Number(rawS);
          if (Number.isFinite(numS)) return numS;
        }
      }
      if (form) {
        const el = form.querySelector(`[name="${n}"]`);
        if (el && el.value !== '' && el.value !== null && el.value !== undefined) {
          const numD = Number(el.value);
          if (Number.isFinite(numD)) return numD;
        }
      }
      try {
        const saved = (window.modalCtx && window.modalCtx.data && window.modalCtx.data.rates_json) || {};
        const v = saved[n];
        if (v === 0 || (typeof v === 'number' && Number.isFinite(v))) return Number(v);
      } catch {}
      return null;
    };

    const payBuckets = (payMethod === 'PAYE')
      ? ['paye_day','paye_night','paye_sat','paye_sun','paye_bh']
      : ['umb_day','umb_night','umb_sat','umb_sun','umb_bh'];
    const chargeBuckets = ['charge_day','charge_night','charge_sat','charge_sun','charge_bh'];

    const anyPay    = payBuckets.some(b => getNum(b) !== null);
    const anyCharge = chargeBuckets.some(b => getNum(b) !== null);

    let hasNegativeMargins = false;
    if (window.__contractMarginState && typeof window.__contractMarginState.hasNegativeMargins === 'boolean') {
      hasNegativeMargins = !!window.__contractMarginState.hasNegativeMargins;
    } else {
      for (const cb of chargeBuckets) {
        const b  = cb.split('_')[1];
        const ch = getNum(`charge_${b}`);
        const py = getNum(`${payMethod === 'PAYE' ? 'paye' : 'umb'}_${b}`);
        if (ch !== null && py !== null && (ch - py) < 0) { hasNegativeMargins = true; break; }
      }
    }

    // -------- Timesheet boundary guard (uses cached result)
    let tsBoundaryViolation = false;
    let tsBoundaryMsg = null;
    try {
      const tsRes = window.__tsBoundaryResult;
      if (data?.id && tsRes && tsRes.ok === false) {
        tsBoundaryViolation = true;
        const v = tsRes.violations || [];
        if (v.length) {
          const sample = v.slice(0,3).map(x => {
            const nm = x.client_name || 'Client';
            const dt = x.date || '';
            const st = x.status || '';
            return `${nm} ${dt}${st?` (${st})`:''}`;
          }).join(' â€¢ ');
          tsBoundaryMsg = `Dates exclude existing timesheets: ${sample}${v.length>3? 'â€¦':''}`;
        } else if (tsRes.min_ts_date || tsRes.max_ts_date) {
          tsBoundaryMsg = `Dates exclude timesheets in range ${tsRes.min_ts_date||''} â†’ ${tsRes.max_ts_date||''}.`;
        } else {
          tsBoundaryMsg = 'Dates exclude existing timesheets.';
        }
      }
    } catch {}

    // -------- Compose eligibility & reasons (with pending auto-expand awareness)
    const reasons = [];

    if (!candidateOk) reasons.push({ code:'MISSING_CANDIDATE', message:'Pick a candidate.' });
    if (!clientOk)    reasons.push({ code:'MISSING_CLIENT',    message:'Pick a client.' });
    if (!roleOk)      reasons.push({ code:'MISSING_ROLE',      message:'Enter a role.' });

    const hasWindowExpand = !!pendingExpand;

    if (!bothDatesProvided && !hasStaged && !hasWindowExpand) {
      reasons.push({ code:'DATES_OR_STAGE_REQUIRED', message:'Provide start & end dates or stage calendar changes.' });
    } else if (bothDatesProvided && !dateOrderOk) {
      reasons.push({ code:'DATE_ORDER_INVALID', message:'Start date must be on or before end date.' });
    }

    if (!scheduleOk) {
      reasons.push({ code:'SCHEDULE_REQUIRED', message:'Add at least one day with Start & End (or stage calendar changes).' });
    }

    if (!anyPay)    reasons.push({ code:'MISSING_PAY_RATES',    message:'Enter at least one pay bucket.' });
    if (!anyCharge) reasons.push({ code:'MISSING_CHARGE_RATES', message:'Enter at least one charge bucket.' });
    if (hasNegativeMargins) reasons.push({ code:'NEGATIVE_MARGIN', message:'One or more buckets produce a negative margin.' });

    if (tsBoundaryViolation) {
      reasons.push({ code:'TS_BOUNDARY_VIOLATION', message: tsBoundaryMsg || 'Dates exclude existing timesheets.' });
    }

    // âœ… FINAL ELIGIBILITY:
    //   â€¢ Candidate is NO LONGER a hard requirement here (still warned via reasons).
    const ok =
      /* candidateOk && */            // <-- removed from hard gate
      clientOk &&
      roleOk &&
      (
        (bothDatesProvided ? dateOrderOk : true) // dates ok if provided & ordered
        || hasStaged
        || hasWindowExpand
      ) &&
      scheduleOk &&
      anyPay &&
      anyCharge &&
      !hasNegativeMargins &&
      !tsBoundaryViolation;

    const detail = {
      ok,
      pendingTimeFormat,
      pending: {
        timeFormat: pendingTimeFormat,
        fields: pendingFields,
        days: pendingDays
      },
      checkpoints: {
        candidateOk, clientOk, roleOk,
        dates: { bothDatesProvided, dateOrderOk, hasStagedCalendar: hasStaged, tsBoundaryOk: !tsBoundaryViolation, willAutoExpand: !!hasWindowExpand },
        schedule: { hasValidPair, hasPendingPair, hasStagedCalendar: hasStaged, hasTemplate },
        finance: { anyPay, anyCharge, hasNegativeMargins, payMethod }
      },
      reasons,
      tip: pendingTimeFormat ? 'Weâ€™ll format times like 0900 â†’ 09:00 when you tab out or save.' : null
    };

    window.__contractEligibility = detail;
    return ok;
  } catch (e) {
    window.__contractEligibility = { ok:false, reasons:[{ code:'INTERNAL_ERROR', message:String(e && e.message || e || 'unknown error') }] };
    return false;
  }
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 1) Non-blocking date-window overlap checker (Main tab hint)
//    Call from renderContractMainTab on start/end date change.
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function callCheckContractWindowOverlap(candidate_id, start_date_iso, end_date_iso, exclude_contract_id) {
  const LOGC = (typeof window.__LOG_CONTRACTS === 'boolean') ? window.__LOG_CONTRACTS : false;
  const payload = {
    candidate_id: candidate_id || null,
    start_date  : start_date_iso || null,
    end_date    : end_date_iso || null,
    ignore_contract_id: exclude_contract_id || null
  };
  if (!candidate_id || !start_date_iso || !end_date_iso) return { has_overlap: false, overlaps: [] };
  if (typeof checkContractOverlap !== 'function') { if (LOGC) console.warn('[CONTRACTS] checkContractOverlap missing'); return { has_overlap:false, overlaps:[] }; }
  try {
    if (LOGC) console.log('[CONTRACTS] callCheckContractWindowOverlap â†’ req', payload);
    const res = await checkContractOverlap(payload);
    if (LOGC) console.log('[CONTRACTS] callCheckContractWindowOverlap â† res', res);
    return res || { has_overlap:false, overlaps:[] };
  } catch (e) {
    if (LOGC) console.warn('[CONTRACTS] window overlap check failed', e);
    return { has_overlap:false, overlaps:[] };
  }
}

function openContract(row) {
  const LOGC = (typeof window.__LOG_CONTRACTS === 'boolean') ? window.__LOG_CONTRACTS : true;

  // âœ… Robust: support either shape:
  //   - contract row (has id)
  //   - wrapper payload { contract, counts, weeks, warnings, ... }
  const __wrapper = (row && typeof row === 'object' && row.contract && typeof row.contract === 'object') ? row : null;
  const __baseRow = __wrapper ? __wrapper.contract : row;

  const isCreate = !__baseRow || !__baseRow.id;
  if (LOGC) console.log('[CONTRACTS] openContract ENTRY', {
    isCreate,
    rowPreview: !!row,
    id: __baseRow?.id,
    wrapper: !!__wrapper,
    wrapper_id: __wrapper?.contract?.id
  });
    window.modalCtx = {
  entity: 'contracts',
  mode: isCreate ? 'create' : 'view',
  data: { ...(__baseRow || {}) },
  _saveInFlight: false,

  // âœ… NEW: track whether this save is calendar-only
  __calendarDirty: false,
  __nonCalendarDirty: false,

  // âœ… NEW: only block contract settings edits when the user actually touched those fields
  __contractSettingsDirty: false,

  // âœ… NEW: keep latest client_settings snapshot in memory (used by overrideclientsettings seeding)
  client_settings_snapshot: null,
  client_settings_snapshot_client_id: null,

  // âœ… NEW: stash used by Contract Settings modal override toggle
  __overrideClientSettingsStash: null
};



   // âœ… If backend returned warnings separately (wrapper shape), attach them so your existing UI works
  try {
    if (__wrapper && Array.isArray(__wrapper.warnings)) {
      window.modalCtx.data.warnings = __wrapper.warnings;
    }
  } catch {}

   // âœ… Prefer server-provided finance/margins from wrapper (when opening an existing contract)
  try {
    if (__wrapper && __wrapper.finance && typeof __wrapper.finance === 'object') {
      window.modalCtx.finance = __wrapper.finance;
      window.modalCtx.data.finance = __wrapper.finance;
    }
  } catch {}

  try {
    if (__wrapper && __wrapper.margins && typeof __wrapper.margins === 'object') {
      window.modalCtx.margins = __wrapper.margins;
      window.modalCtx.data.margins = __wrapper.margins;
    }
  } catch {}

  // âœ… Apply finance into legacy globals + date-keyed caches (prevents stale overrides later)
  const applyFinanceGlobals = (fin) => {
    if (!fin || typeof fin !== 'object') return;

    window.modalCtx.finance = fin;
    window.modalCtx.data.finance = fin;

    const anchor = (fin.anchor_ymd != null) ? String(fin.anchor_ymd) : null;

    try {
      const em = Number(fin.erni_multiplier);
      if (Number.isFinite(em) && em > 0) {
        window.__ERNI_MULT__ = em;

        // âœ… CRITICAL: also prime the by-date cache so ensureErniMultiplier() won't reintroduce stale values
        window.__ERNI_MULT_BY_DATE__ = window.__ERNI_MULT_BY_DATE__ || Object.create(null);
        if (anchor) window.__ERNI_MULT_BY_DATE__[anchor] = em;
      }
    } catch {}

    try {
      const vm = Number(fin.vat_multiplier);
      if (Number.isFinite(vm) && vm > 0) {
        window.__VAT_MULT__ = vm;

        // Optional symmetry (only if you later add VAT-by-date usage)
        window.__VAT_MULT_BY_DATE__ = window.__VAT_MULT_BY_DATE__ || Object.create(null);
        if (anchor) window.__VAT_MULT_BY_DATE__[anchor] = vm;
      }
    } catch {}

    if (LOGC) console.log('[CONTRACTS] finance applied', {
      anchor_ymd: fin.anchor_ymd,
      erni_pct: fin.erni_pct,
      erni_multiplier: fin.erni_multiplier,
      vat_rate_pct: fin.vat_rate_pct,
      vat_multiplier: fin.vat_multiplier
    });
  };

  // If wrapper provided finance, apply immediately
  try {
    if (window.modalCtx.finance) applyFinanceGlobals(window.modalCtx.finance);
  } catch {}

  // âœ… Pull prevailing finance globals (TODAY) ONLY when needed:
  // - create mode
  // - or wrapper did not include finance
  (async () => {
    if (!isCreate && window.modalCtx.finance) return;

    try {
      const r = await authFetch(API('/api/contracts/finance-globals'));
      if (!r || !r.ok) {
        const t = r ? await r.text().catch(() => '') : '';
        throw new Error(t || 'finance-globals fetch failed');
      }
      const j = await r.json().catch(() => ({}));
      const fin = (j && typeof j === 'object' && j.finance && typeof j.finance === 'object') ? j.finance : null;

      if (fin) {
        applyFinanceGlobals(fin);

        // If the modal is already open, recompute margins (non-fatal)
        try { if (typeof computeContractMargins === 'function') computeContractMargins(); } catch {}
        try { window.dispatchEvent(new Event('contracts-finance-globals-loaded')); } catch {}
      }
    } catch (e) {
      if (LOGC) console.warn('[CONTRACTS] finance-globals fetch failed (non-fatal)', e?.message || e);
    }
  })();


  // âœ… NEW: load and store client_settings snapshot when opening the contract (or after reload)
  (async () => {
    try {
      const cid = window.modalCtx?.data?.client_id || null;
      if (!cid) return;

      const existingFor = window.modalCtx?.client_settings_snapshot_client_id || null;
      if (existingFor && String(existingFor) === String(cid) && window.modalCtx?.client_settings_snapshot) return;

      const client = await getClient(cid);
      const cs = client?.client_settings || null;

      if (cs && typeof cs === 'object') {
        window.modalCtx.client_settings_snapshot = cs;
        window.modalCtx.client_settings_snapshot_client_id = String(cid);
        if (LOGC) console.log('[CONTRACTS] stored client_settings snapshot (open)', { client_id: cid });
      } else {
        if (LOGC) console.warn('[CONTRACTS] client_settings snapshot missing on client payload (open)', { client_id: cid });
      }
    } catch (e) {
      if (LOGC) console.warn('[CONTRACTS] failed to load client_settings snapshot (open, non-fatal)', e);
    }
  })();

  const preToken = window.__preOpenToken || null;
  if (LOGC) console.log('[CONTRACTS] preOpenToken snapshot', preToken);


  if (isCreate) {
    if (preToken) {
      window.modalCtx.openToken = preToken;
      try { delete window.__preOpenToken; } catch {}
      if (LOGC) console.log('[CONTRACTS] using preOpenToken for create', preToken);
    } else if (!window.modalCtx.openToken) {
      window.modalCtx.openToken = `contract:new:${Date.now()}:${Math.random().toString(36).slice(2)}`;
      if (LOGC) console.log('[CONTRACTS] openToken issued for create', window.modalCtx.openToken);
    }
  }

  // If this create comes from Clone&Extend staging, pull intent (end-old etc.)
  try {
    const intents = (window.__cloneIntents || {});
    const token   = window.modalCtx.openToken;
    const ci      = intents[token];

    if (LOGC) console.groupCollapsed('[CLONE][attach-intent]');
    if (LOGC) console.log('openToken', token);
    if (LOGC) console.log('staging.keys', Object.keys(intents || {}));
    if (LOGC) console.log('staging.has(openToken)?', Object.prototype.hasOwnProperty.call(intents, token));

    if (ci) {
      // Normalise & echo intent
      const endIso = ci.end_existing_on || null;
      window.modalCtx.__cloneIntent = {
        source_contract_id: ci.source_contract_id || null,
        end_existing: !!ci.end_existing,
        end_existing_on: endIso
      };
      if (LOGC) console.log('ATTACHED', window.modalCtx.__cloneIntent);
      // one-shot: keep it only on this modal
      try { delete intents[token]; if (LOGC) console.log('intent cleared from staging bucket'); } catch {}
    } else {
      if (LOGC) console.log('NO_INTENT_FOR_TOKEN (possible token mismatch) â€“ will not truncate tail unless a later step re-attaches.');
    }
    if (LOGC) console.groupEnd?.();
  } catch (e) {
    if (LOGC) console.warn('[CLONE][attach-intent] EXCEPTION', e);
  }

  try {
    const base = window.modalCtx.data || {};

    const fs = (window.modalCtx.formState ||= { __forId: (base.id ?? window.modalCtx.openToken ?? null), main:{}, pay:{} });
    fs.__forId = preToken || fs.__forId || (base.id ?? window.modalCtx.openToken ?? null);
    if (LOGC) console.log('[CONTRACTS] formState forId bound', { preToken, forId: fs.__forId, openToken: window.modalCtx.openToken });

 const m = (fs.main ||= {});
if (m.__seeded !== true) {
  if (base.candidate_id != null) m.candidate_id = base.candidate_id;
  if (base.client_id != null)    m.client_id    = base.client_id;
  if (base.role != null)         m.role         = base.role;
  if (base.band != null)         m.band         = base.band;
  if (base.display_site != null) m.display_site = base.display_site;
  if (base.start_date)           m.start_date   = base.start_date;
  if (base.end_date)             m.end_date     = base.end_date;
   if (base.pay_method_snapshot)  m.pay_method_snapshot = base.pay_method_snapshot;

  // âœ… Only stage contract.default_submission_mode if overrideclientsettings is TRUE.
  // When overrideclientsettings is FALSE, this field must behave as INHERIT (i.e., not used / not sent).
  if (base.overrideclientsettings === true && base.default_submission_mode) {
    m.default_submission_mode = base.default_submission_mode;
  }

  // NEW: seed contract route/settings overrides (only if present on row)
  if (base.is_nhsp != null)               m.is_nhsp = base.is_nhsp;
  if (base.autoprocess_hr != null)        m.autoprocess_hr = base.autoprocess_hr;
  if (base.requires_hr != null)           m.requires_hr = base.requires_hr;
  if (base.no_timesheet_required != null) m.no_timesheet_required = base.no_timesheet_required;

  if (base.daily_calc_of_invoices != null) m.daily_calc_of_invoices = base.daily_calc_of_invoices;
  if (base.group_nightsat_sunbh != null) m.group_nightsat_sunbh = base.group_nightsat_sunbh;
  if (base.self_bill != null)            m.self_bill = base.self_bill;

  // âœ… NEW: attachments (seed into formState.main)
  if (base.hr_attach_to_invoice != null)  m.hr_attach_to_invoice = base.hr_attach_to_invoice;
  if (base.ts_attach_to_invoice != null)  m.ts_attach_to_invoice = base.ts_attach_to_invoice;

  // âœ… NEW: contract-level refs + auto-invoice (seed into formState.main)
  if (base.auto_invoice != null)                 m.auto_invoice = base.auto_invoice;
  if (base.require_reference_to_pay != null)     m.require_reference_to_pay = base.require_reference_to_pay;
  if (base.require_reference_to_invoice != null) m.require_reference_to_invoice = base.require_reference_to_invoice;

  if (base.week_ending_weekday_snapshot != null) m.week_ending_weekday_snapshot = String(base.week_ending_weekday_snapshot);
  if (base.bucket_labels_json)   m.__bucket_labels = base.bucket_labels_json;
  if (base.std_schedule_json)    m.__template      = base.std_schedule_json;
  if (base.std_hours_json)       m.__hours         = base.std_hours_json;
  // Seed mileage if present on row
  if (base.mileage_charge_rate != null) m.mileage_charge_rate = base.mileage_charge_rate;
  if (base.mileage_pay_rate != null)    m.mileage_pay_rate    = base.mileage_pay_rate;

  m.__seeded = true;

  if (LOGC) console.log('[CONTRACTS] seed formState (main/pay) from base row', {
    forId: (window.modalCtx.formState && window.modalCtx.formState.__forId),
    mainKeys: Object.keys(window.modalCtx.formState?.main || {}),
    payKeys: Object.keys(window.modalCtx.formState?.pay || {})
  });
}

    const p = (fs.pay ||= {});
    if (!Object.keys(p).length && base.rates_json && typeof base.rates_json === 'object') {
      const buckets = ['paye_day','paye_night','paye_sat','paye_sun','paye_bh','umb_day','umb_night','umb_sat','umb_sun','umb_bh','charge_day','charge_night','charge_sat','charge_sun','charge_bh'];
      for (const k of buckets) {
        const v = base.rates_json[k];
        if (v === 0 || (typeof v === 'number' && Number.isFinite(v))) p[k] = String(v);
      }
    }
  } catch {}

    const extraButtons = [];

  // Only attach Delete Contract for existing contracts that the backend
  // has marked as deletable (can_delete === true).
  const hasId     = !!window.modalCtx.data?.id;
  const canDelete = !!(hasId && window.modalCtx.data?.can_delete);

  if (!isCreate && hasId && canDelete) {
    extraButtons.push({
      label: 'Delete contract',
      role: 'danger',
      onClick: async () => {
        const id = window.modalCtx.data?.id;
        if (!id) return;

        // Only allow action in EDIT mode â€“ if still in view mode,
        // nudge the user to click Edit first.
        const fr = (typeof window.__getModalFrame === 'function')
          ? window.__getModalFrame()
          : null;
        if (fr && fr.mode !== 'edit') {
          alert('Click Edit to make changes before deleting this contract.');
          return;
        }

        const ok = window.confirm('Do you want to permanently delete this contract?');
        if (!ok) return;

        try {
          if (LOGC) console.log('[CONTRACTS] deleteContract', { id });
          await deleteContract(id);
          try { discardAllModalsAndState(); } catch {}
          await renderAll();
        } catch (e) {
          alert(e?.message || 'Delete failed');
        }
      }
    });
  }

const tabDefs = [
  { key: 'main',     title: 'Main' },
  { key: 'rates',    title: 'Rates' },
  { key: 'extras',   title: 'Additional Rates' }, // NEW TAB
  { key: 'calendar', title: 'Calendar' }
];
if (LOGC) console.log('[CONTRACTS] tabs', tabDefs.map(t => t.key));

  const isSuccessorCreate = isCreate && ( !!window.modalCtx?.__cloneIntent || !!preToken );
  if (LOGC) console.log('[CONTRACTS] showModal opts preview', {
    hasId, isCreate, isSuccessorCreate,
    stayOpenOnSave: !!isSuccessorCreate, noParentGate: !!isSuccessorCreate,
    openToken: window.modalCtx.openToken, hasCloneIntent: !!window.modalCtx.__cloneIntent
  });

  showModal(

  isCreate ? 'Create Contract' : 'Edit Contract',
  tabDefs,
  (key, row) => {
    const ctx = { data: row };
    if (key === 'main')     return renderContractMainTab(ctx);
    if (key === 'rates')    return renderContractRatesTab(ctx);
    if (key === 'extras')   return renderContractAdditionalRatesTab(ctx); // NEW
    if (key === 'calendar') return renderContractCalendarTab(ctx);
    return `<div class="tabc">Unknown tab.</div>`;
  },
  async () => {
      if (window.modalCtx?._saveInFlight) return false;
      window.modalCtx._saveInFlight = true;
      try {
        if (LOGC) console.groupCollapsed('[CONTRACTS] onSave pipeline');

        snapshotContractForm();
        console.warn('[BREACH A] after snapshotContractForm');

// âœ… Capture calendar viewport BEFORE we do anything that might re-render/reset it
try {
  const fr0 = window.__getModalFrame?.();
  const tab0 = fr0?.currentTabKey || (document.querySelector('#modalTabs button.active')?.textContent?.toLowerCase() || '');
  const cid0 = window.modalCtx?.data?.id || null;

  if (tab0 === 'calendar' && cid0) {
    const cal0 = window.__calState?.[cid0] || {};
    const sb0  = document.getElementById('__calScroll');

    window.modalCtx.__calViewport = {
      contract_id: cid0,
      view: cal0.view || 'year',
      win: (cal0.win && cal0.win.from && cal0.win.to) ? { from: cal0.win.from, to: cal0.win.to } : null,
      scrollTop: sb0 ? sb0.scrollTop : 0,
      scrollLeft: sb0 ? sb0.scrollLeft : 0
    };

    if (LOGC) console.log('[CAL][viewport] captured', window.modalCtx.__calViewport);
  }
} catch (e) {
  if (LOGC) console.warn('[CAL][viewport] capture failed (non-fatal)', e);
}







        // Keep a stable copy in case something re-renders and drops modalCtx.__cloneIntent
        const __preCloneIntent = window.modalCtx?.__cloneIntent
          ? { ...window.modalCtx.__cloneIntent }
          : null;
        if (LOGC) console.log('[CLONE][pre-save snapshot]', __preCloneIntent || '(none)');

        const base = window.modalCtx?.data || {};
        const fs   = (window.modalCtx?.formState || { main:{}, pay:{} });
        const fdForm = document.querySelector('#contractForm');
        const fd = fdForm ? new FormData(fdForm) : null;

        const fromFS = (k, fallback='') => {
          const v = (fs.main||{})[k]; return (v===undefined ? fallback : v);
        };
        const fromFD = (k, fallback='') => {
          if (!fd) return fallback;
          const raw = fd.get(k); return (raw==null ? fallback : String(raw).trim());
        };
        const choose = (key, fallback='') => {
          const fsVal = fromFS(key, null);
          if (fsVal !== null && fsVal !== undefined && fsVal !== '') return fsVal;
          const fdVal = fromFD(key, null);
          if (fdVal !== null && fdVal !== undefined && fdVal !== '') return fdVal;
          return (base[key] ?? fallback);
        };

        const ukToIso = (ddmmyyyy, fb=null) => {
          try {
            return (typeof parseUkDateToIso === 'function')
              ? (parseUkDateToIso(ddmmyyyy) || fb)
              : ((ddmmyyyy && /^\d{2}\/\d{2}\/\d{4}$/.test(ddmmyyyy)) ? ddmmyyyy : (ddmmyyyy || fb));
          } catch { return ddmmyyyy || fb; }
        };

              const domLabels = (typeof _collectBucketLabelsFromForm === 'function')
          ? _collectBucketLabelsFromForm('#contractForm')
          : null;

        let bucket_labels_json = null;

        // 1) Prefer DOM-collected labels (used as-is, including empty strings)
        if (domLabels && typeof domLabels === 'object' && Object.keys(domLabels).length) {
          bucket_labels_json = { ...domLabels };
        }

        // 2) Else prefer staged labels from preset/application (__bucket_labels)
        if (!bucket_labels_json) {
          const stagedMap = (fs.main && typeof fs.main.__bucket_labels === 'object')
            ? fs.main.__bucket_labels
            : null;
          if (stagedMap && Object.keys(stagedMap).length) {
            bucket_labels_json = { ...stagedMap };
          }
        }

        // 3) Else fall back to individual bucket_* / bucket_label_* fields
        if (!bucket_labels_json) {
          const staged = {
            day   : String(fs.main?.bucket_day            ?? fs.main?.bucket_label_day   ?? '').trim(),
            night : String(fs.main?.bucket_night          ?? fs.main?.bucket_label_night ?? '').trim(),
            sat   : String(fs.main?.bucket_sat            ?? fs.main?.bucket_label_sat   ?? '').trim(),
            sun   : String(fs.main?.bucket_sun            ?? fs.main?.bucket_label_sun   ?? '').trim(),
            bh    : String(fs.main?.bucket_bh             ?? fs.main?.bucket_label_bh    ?? '').trim()
          };
          const hasAnyFromStaged = Object.values(staged).some(v => v !== '');
          bucket_labels_json = hasAnyFromStaged ? staged : (base.bucket_labels_json ?? null);
        }


        const numOrNull = (s) => {
          const raw = fromFS(s, fromFD(s, ''));
          if (raw === '' || raw === null || raw === undefined) return null;
          const n = Number(raw); return Number.isFinite(n) ? n : null;
        };
            const gh = { mon: numOrNull('gh_mon'), tue: numOrNull('gh_tue'), wed: numOrNull('gh_wed'),
                     thu: numOrNull('gh_thu'), fri: numOrNull('gh_fri'), sat: numOrNull('gh_sat'), sun: numOrNull('gh_sun') };
        const ghFilled = Object.values(gh).some(v => v != null && v !== 0);
        let std_hours_json = ghFilled ? gh : (base.std_hours_json ?? null);
        if (!std_hours_json && fs.main && fs.main.__hours) std_hours_json = fs.main.__hours;

        // --- Build std_schedule_json from mon_start/end/break etc. ---
        const buildScheduleJson = () => {
          const formEl = document.querySelector('#contractForm');
          const fd = formEl ? new FormData(formEl) : null;
          const fsLocal = window.modalCtx?.formState || {};
          const mainFS  = fsLocal.main || {};
          const baseRow = window.modalCtx?.data || {};

          const fromFS = (k, fallback = '') => {
            const v = mainFS[k];
            return (v === undefined ? fallback : v);
          };
          const fromFD = (k, fallback = '') => {
            if (!fd) return fallback;
            const raw = fd.get(k);
            return (raw == null ? fallback : String(raw).trim());
          };
          const val = (key, fallback = '') => {
            const staged = fromFS(key, undefined);
            if (staged !== undefined && staged !== null && String(staged).trim() !== '') {
              return String(staged).trim();
            }
            const domVal = fromFD(key, undefined);
            if (domVal !== undefined && domVal !== null && String(domVal).trim() !== '') {
              return String(domVal).trim();
            }
            return fallback;
          };

          const parseTime = (raw) => {
            const s = String(raw || '').trim();
            if (!s) return null;

            // 3â€“4 digits â†’ HHMM (800, 0830, 2000)
            if (/^\d{3,4}$/.test(s)) {
              const p = s.padStart(4, '0');
              const h = +p.slice(0, 2);
              const m = +p.slice(2, 4);
              if (h < 0 || h > 23 || m < 0 || m > 59) return null;
              return { h, m };
            }

            // H:MM / HH:MM
            if (/^\d{1,2}:\d{1,2}$/.test(s)) {
              const [hh, mm] = s.split(':');
              const h = +hh;
              const m = +mm;
              if (h < 0 || h > 23 || m < 0 || m > 59) return null;
              return { h, m };
            }

            return null;
          };

          const days   = ['mon','tue','wed','thu','fri','sat','sun'];
          const sched  = {};
          const issues = [];

          for (const d of days) {
            const startRaw = val(`${d}_start`, '');
            const endRaw   = val(`${d}_end`, '');
            const brRaw    = val(`${d}_break`, '');

            // Completely blank day â†’ skip
            if (!startRaw && !endRaw && !brRaw) continue;

            const start = parseTime(startRaw);
            const end   = parseTime(endRaw);
            const br    = brRaw ? (Number(brRaw) || 0) : 0;

            if (!start || !end) {
              issues.push(d.toUpperCase());
              continue;
            }

            const startStr = `${String(start.h).padStart(2,'0')}:${String(start.m).padStart(2,'0')}`;
            const endStr   = `${String(end.h).padStart(2,'0')}:${String(end.m).padStart(2,'0')}`;

            sched[d] = {
              start: startStr,
              end:   endStr,
              break_minutes: Math.max(0, br)
            };
          }

          if (issues.length) {
            const msg = `Fix invalid times on: ${issues.join(', ')}`;
            if (typeof showModalHint === 'function') showModalHint(msg, 'warn');
            else alert(msg);
          }

          return { schedule: sched, issues };
        };

        const { schedule, issues } = buildScheduleJson();
        if (issues.length) {
          // Block save; user must fix bad times first
          window.modalCtx._saveInFlight = false;
          if (LOGC) console.groupEnd?.();
          return false;
        }

        let std_schedule_json = null;

        if (schedule && Object.keys(schedule).length) {
          // New schedule fully replaces previous one
          std_schedule_json = schedule;
        } else if (fs.main && fs.main.__template) {
          // No rows entered this time â†’ keep last template if present
          std_schedule_json = fs.main.__template;
        } else if (base.std_schedule_json) {
          std_schedule_json = base.std_schedule_json;
        }



        const prevStartIso = base.start_date || null;
        const prevEndIso   = base.end_date   || null;

        const startIso = ukToIso(choose('start_date', ''), base.start_date ?? null);
        const endIso   = ukToIso(choose('end_date', ''),   base.end_date   ?? null);

        const payMethodSnap = String(
          (fs.main?.pay_method_snapshot) ||
          fromFD('pay_method_snapshot', fromFD('default_pay_method_snapshot', base.pay_method_snapshot || 'PAYE')) ||
          base.pay_method_snapshot || 'PAYE'
        ).toUpperCase();

      // âœ… UPDATED: allow â€œinheritâ€ (NULL) for default_submission_mode
        const dsmRaw = choose('default_submission_mode', (base.default_submission_mode ?? 'ELECTRONIC'));
        const dsmUp = (dsmRaw == null) ? '' : String(dsmRaw).trim().toUpperCase();
        let default_submission_mode = (!dsmUp || dsmUp === 'INHERIT') ? null : dsmUp;

        const week_ending_weekday_snapshot = String(
          choose('week_ending_weekday_snapshot', (base.week_ending_weekday_snapshot ?? '0'))
        );

    const candidate_id = choose('candidate_id', base.candidate_id ?? null) || null;

// NEW: polite confirmation when saving with no candidate
if (!candidate_id) {
  const okProceed = window.confirm('No candidate is selected. Save this contract as â€œ<Unassigned>â€?');
  if (!okProceed) {
    window.modalCtx._saveInFlight = false;
    if (LOGC) console.groupEnd?.();
    return false;
  }
}

const client_id    = choose('client_id', base.client_id ?? null) || null;
const role         = choose('role', base.role ?? null);
const band         = choose('band', base.band ?? null);
const display_site = choose('display_site', base.display_site ?? '');


         const boolFromFS = (name, baseVal=false) => {
          if (fs && fs.main && Object.prototype.hasOwnProperty.call(fs.main, name)) {
            const v = fs.main[name];
            return v === 'on' || v === true || v === 'true' || v === 1 || v === '1';
          }
          return !!base[name];
        };

        // NEW: tri-state boolean (preserve NULL contract overrides unless explicitly set)
           const boolTriFromFS = (name) => {
          // Tri-state rule:
          // - if field is NOT present in fs.main: preserve base boolean or null
          // - if field IS present in fs.main: interpret truthy vs falsey ('' counts as false, not null)
          if (fs && fs.main && Object.prototype.hasOwnProperty.call(fs.main, name)) {
            const v = fs.main[name];
            if (v === null || v === undefined) return null;
            return v === 'on' || v === true || v === 'true' || v === 1 || v === '1';
          }
          const b = base ? base[name] : undefined;
          return (b === true || b === false) ? b : null;
        };


      // NEW: contract route/settings fields (tri-state)
let is_nhsp               = boolTriFromFS('is_nhsp');
let autoprocess_hr        = boolTriFromFS('autoprocess_hr');
let requires_hr           = boolTriFromFS('requires_hr');
let no_timesheet_required = boolTriFromFS('no_timesheet_required');
let daily_calc_of_invoices= boolTriFromFS('daily_calc_of_invoices');
let group_nightsat_sunbh  = boolTriFromFS('group_nightsat_sunbh');
let self_bill             = boolTriFromFS('self_bill');

// âœ… FIX: define attachment flags BEFORE theyâ€™re referenced in settingsChanged
let hr_attach_to_invoice  = boolTriFromFS('hr_attach_to_invoice');
let ts_attach_to_invoice  = boolTriFromFS('ts_attach_to_invoice');

// NEW: canonicalise route flags only if any route override is present (avoids clobbering NULL legacy overrides)
const anyRouteSet = [is_nhsp, autoprocess_hr, no_timesheet_required].some(v => v === true || v === false);
if (anyRouteSet) {
  // Manual: is_nhsp=false, autoprocess_hr=false, no_timesheet_required=false
  // NHSP: is_nhsp=true, autoprocess_hr=false, no_timesheet_required=false
  // HR required: autoprocess_hr=true, is_nhsp=false, no_timesheet_required=false
  // HR no-timesheets: autoprocess_hr=true, is_nhsp=false, no_timesheet_required=true
  if (is_nhsp === true) {
    autoprocess_hr = false;
    no_timesheet_required = false;
  }
  if (no_timesheet_required === true) {
    autoprocess_hr = true;
    is_nhsp = false;
  }
  if (autoprocess_hr === true) {
    is_nhsp = false;
  }
  if (autoprocess_hr !== true) {
    no_timesheet_required = false;
  }
}

// âœ… UPDATED: these must be tri-state (nullable) when overrideclientsettings is toggled off
let auto_invoice                 = boolTriFromFS('auto_invoice');
let require_reference_to_pay     = boolTriFromFS('require_reference_to_pay');
let require_reference_to_invoice = boolTriFromFS('require_reference_to_invoice');

  // âœ… NEW: overrideclientsettings (boolean)
        const overrideclientsettings = boolFromFS('overrideclientsettings', !!base.overrideclientsettings);
          // âœ… CRITICAL: when overrideclientsettings is FALSE, contract.default_submission_mode must behave as INHERIT.
        // So force it to NULL in the payload logic (and later we also ensure it is not sent on PUT).
        if (overrideclientsettings !== true) {
          default_submission_mode = null;
        }

// âœ… NEW: additional contract-level settings
let reference_number_required_to_issue_invoice = boolTriFromFS('reference_number_required_to_issue_invoice');
let send_manual_invoices_to_different_email    = boolTriFromFS('send_manual_invoices_to_different_email');

// contract-level string (nullable)
let manual_invoices_alt_email_address = null;
try {
  const v =
    (fs && fs.main && Object.prototype.hasOwnProperty.call(fs.main, 'manual_invoices_alt_email_address'))
      ? fs.main.manual_invoices_alt_email_address
      : (base.manual_invoices_alt_email_address ?? null);
  manual_invoices_alt_email_address = (v === null || v === undefined) ? null : String(v).trim();
  if (manual_invoices_alt_email_address === '') manual_invoices_alt_email_address = (send_manual_invoices_to_different_email === true) ? '' : null;
} catch {
  manual_invoices_alt_email_address = null;
}


// âœ… FE guard: if real timesheets exist, block changes to route/settings.
// Backend should enforce authoritatively; this is a UX guard only.
const hasRealTimesheets =
  (Number(base.real_timesheets_count ?? base.timesheets_count ?? 0) > 0) ||
  (base.has_real_timesheets === true) ||
  (base.has_timesheets === true);

// âœ… UPDATED: tri-state change detection (null vs false is a real change)
const normTri = (v) => {
  if (v === null || v === undefined) return null;
  const s = String(v).trim().toLowerCase();
  if (v === true || s === 'on' || s === 'true' || s === '1' || s === 'yes') return true;
  if (v === false || s === '' || s === 'false' || s === '0' || s === 'no') return false;
  return null;
};

const settingsChanged =
  (normTri(base.is_nhsp) !== normTri(is_nhsp)) ||
  (normTri(base.autoprocess_hr) !== normTri(autoprocess_hr)) ||
  (normTri(base.no_timesheet_required) !== normTri(no_timesheet_required)) ||
  (normTri(base.requires_hr) !== normTri(requires_hr)) ||
  (normTri(base.self_bill) !== normTri(self_bill)) ||
  (normTri(base.daily_calc_of_invoices) !== normTri(daily_calc_of_invoices)) ||
  (normTri(base.group_nightsat_sunbh) !== normTri(group_nightsat_sunbh)) ||
  (normTri(base.auto_invoice) !== normTri(auto_invoice)) ||
  (normTri(base.hr_attach_to_invoice) !== normTri(hr_attach_to_invoice)) ||
  (normTri(base.ts_attach_to_invoice) !== normTri(ts_attach_to_invoice)) ||
  (normTri(base.require_reference_to_pay) !== normTri(require_reference_to_pay)) ||
  (normTri(base.require_reference_to_invoice) !== normTri(require_reference_to_invoice)) ||
  (normTri(base.overrideclientsettings) !== normTri(overrideclientsettings)) ||
  (normTri(base.reference_number_required_to_issue_invoice) !== normTri(reference_number_required_to_issue_invoice)) ||
  (normTri(base.send_manual_invoices_to_different_email) !== normTri(send_manual_invoices_to_different_email)) ||
  (String((base.manual_invoices_alt_email_address ?? '')).trim() !== String((manual_invoices_alt_email_address ?? '')).trim()) ||
   (String((base.default_submission_mode ?? '')).trim().toUpperCase() !== String((default_submission_mode ?? '')).trim().toUpperCase());

const contractSettingsTouched = !!window.modalCtx?.__contractSettingsDirty;

if (hasRealTimesheets && contractSettingsTouched && settingsChanged) {
  alert('Cannot change contract settings because real timesheets already exist for this contract.');
  window.modalCtx._saveInFlight = false;
  console.groupEnd?.();
  return false;
}







        const BUCKETS = ['paye_day','paye_night','paye_sat','paye_sun','paye_bh','umb_day','umb_night','umb_sat','umb_sun','umb_bh','charge_day','charge_night','charge_sat','charge_sun','charge_bh'];
        const baseRates = { ...(base.rates_json || {}) };
        const mergedRates = { ...baseRates };
        for (const k of BUCKETS) {
          const staged = (fs.pay || {})[k];
          if (staged !== undefined && staged !== '') {
            const n = Number(staged);
            mergedRates[k] = Number.isFinite(n) ? n : 0;
          } else {
            const domVal = fd ? fd.get(k) : null;
            if (domVal !== null && domVal !== undefined && String(domVal).trim() !== '') {
              const n = Number(domVal);
              mergedRates[k] = Number.isFinite(n) ? n : 0;
            }
          }
        }

      // NEW: mileage values â€” prefer Rates tab DOM, then FS staging, else null
const mcrDom = document.querySelector('#contractRatesTab input[name="mileage_charge_rate"]');
const mprDom = document.querySelector('#contractRatesTab input[name="mileage_pay_rate"]');
const mileage_charge_rate = (mcrDom && mcrDom.value !== '') ? (Number(mcrDom.value) || null) : numOrNull('mileage_charge_rate');
const mileage_pay_rate    = (mprDom && mprDom.value !== '') ? (Number(mprDom.value) || null) : numOrNull('mileage_pay_rate');

// NEW: collect Additional Rates (up to 5 slots) from "Additional Rates" tab
let additional_rates_json = null;
try {
  const existing = Array.isArray(base.additional_rates_json) ? base.additional_rates_json : null;
  const rows = [];

  const normaliseFrequency = (raw) => {
    if (!raw) return null;
    const s = String(raw).trim().toUpperCase();
    const ALLOWED = [
      'ONE_PER_WEEK',
      'ONE_PER_DAY',
      'WEEKENDS_AND_BH_ONLY',
      'WEEKDAYS_EXCL_BH_ONLY'
    ];
    return ALLOWED.includes(s) ? s : null;
  };

  const tab = document.getElementById('contractAdditionalRatesTab');
  if (tab) {
    for (let i = 1; i <= 5; i++) {
      const code = `EX${i}`;
      const bnEl = tab.querySelector(`input[name="extra_bucket_name_${i}"]`);
      const unEl = tab.querySelector(`input[name="extra_unit_name_${i}"]`);
      const frEl = tab.querySelector(`select[name="extra_frequency_${i}"]`);
      const prEl = tab.querySelector(`input[name="extra_pay_${i}"]`);
      const crEl = tab.querySelector(`input[name="extra_charge_${i}"]`);

      const bucket_name = (bnEl?.value || '').trim();
      const unit_name   = (unEl?.value || '').trim();
      const freqRaw     = (frEl?.value || '').trim();
      const payRaw      = (prEl?.value || '').trim();
      const chargeRaw   = (crEl?.value || '').trim();

      const hasAny = !!(bucket_name || unit_name || freqRaw || payRaw || chargeRaw);
      if (!hasAny) continue;

      const payNum    = payRaw === '' ? null : Number(payRaw);
      const chargeNum = chargeRaw === '' ? null : Number(chargeRaw);
      const frequency = normaliseFrequency(freqRaw) || 'ONE_PER_WEEK';

      rows.push({
        code,
        bucket_name,
        unit_name: unit_name || null,
        frequency,
        pay_rate: Number.isFinite(payNum) ? payNum : null,
        charge_rate: Number.isFinite(chargeNum) ? chargeNum : null
      });
    }
  }

  if (rows.length) {
    additional_rates_json = rows;
  } else if (existing) {
    // If the tab was never touched this session, keep what backend sent
    additional_rates_json = existing;
  } else {
    additional_rates_json = null;
  }
} catch (e) {
  if (LOGC) console.warn('[CONTRACTS] additional_rates_json build failed', e);
  const fallback = Array.isArray(base.additional_rates_json) ? base.additional_rates_json : null;
  additional_rates_json = fallback || null;
}
const data = {
  id: window.modalCtx.data?.id || null,
  candidate_id,
  client_id,
  role,
  band,
  display_site,
  start_date:   startIso,
  end_date:     endIso,
  pay_method_snapshot: payMethodSnap,

  // âœ… UPDATED: nullable (inherit) supported
  default_submission_mode,

  week_ending_weekday_snapshot,

  // âœ… NEW: overrideclientsettings gate
  overrideclientsettings,

  // contract route/settings overrides (nullable)
  is_nhsp,
  autoprocess_hr,
  requires_hr,
  no_timesheet_required,
  daily_calc_of_invoices,
  group_nightsat_sunbh,
  self_bill,

  // attachments (nullable)
  hr_attach_to_invoice,
  ts_attach_to_invoice,

  // refs/auto-invoice (nullable)
  auto_invoice,
  require_reference_to_pay,
  require_reference_to_invoice,

  // âœ… NEW: extra contract-level settings (nullable)
  reference_number_required_to_issue_invoice,
  send_manual_invoices_to_different_email,
  manual_invoices_alt_email_address,

  rates_json: mergedRates,
  std_hours_json,
  std_schedule_json,
  bucket_labels_json,
  additional_rates_json,
  mileage_charge_rate: mileage_charge_rate,
  mileage_pay_rate:    mileage_pay_rate
};


if (LOGC) {
  const preview = {
    ...data,
    rates_json: '(object)',
    std_hours_json: std_hours_json ? '(object)' : null,
    std_schedule_json: std_schedule_json ? '(object)' : null,
    additional_rates_json: additional_rates_json ? '(object)' : null
  };
  console.log('[CONTRACTS] onSave payload (preview)', preview);
}

        let overlapProceed = true;
        try {
          if (typeof checkContractOverlap === 'function' && data.candidate_id && data.start_date && data.end_date) {
            const ov = await checkContractOverlap({
              candidate_id: data.candidate_id,
              start_date: data.start_date,
              end_date: data.end_date,
              ignore_contract_id: data.id || null
            });
            if (ov && ov.has_overlap) {
              const lines = (ov.overlaps || []).slice(0, 3).map(o => {
                const nm = o.client_name || o.client || 'Client';
                const a  = o.overlap_from || '';
                const b  = o.overlap_to   || '';
                return `${nm} ${a}â†’${b}`;
              });
              const extra = (ov.overlaps || []).length > 3 ? ` â€¦and ${ov.overlaps.length - 3} more` : '';
              const msg = `This contract overlaps existing contract(s):\nâ€¢ ${lines.join('\nâ€¢ ')}${extra}\n\nProceed anyway?`;
              overlapProceed = !!window.confirm(msg);
            }
          }
        } catch (e) {
          if (LOGC) console.warn('[CONTRACTS] overlap check failed (non-blocking)', e);
        }
        if (!overlapProceed) {
          window.modalCtx._saveInFlight = false;
          if (LOGC) console.log('[CONTRACTS] Save cancelled by user on overlap dialog');
          console.groupEnd?.();
          return false;
        }

        try {} catch {}

        if (!isCreate && data.id && typeof callCheckTimesheetBoundary === 'function' && data.start_date && data.end_date) {
          try {
            const boundary = await callCheckTimesheetBoundary(data.id, data.start_date, data.end_date);
            window.__tsBoundaryResult = boundary || null;
            if (!boundary || boundary.ok === false) {
              let msg = 'Date range excludes existing timesheets.';
              try {
                const v = boundary?.violations || [];
                if (v.length) {
                  const sample = v.slice(0,3).map(x => {
                    const nm = x.client_name || 'Client';
                    const dt = x.date || '';
                    const st = x.status || '';
                    return `${nm} ${dt}${st?` (${st})`:''}`;
                  }).join(' â€¢ ');
                  msg = `Dates exclude existing timesheets: ${sample}${v.length>3? 'â€¦':''}`;
                } else if (boundary?.min_ts_date || boundary?.max_ts_date) {
                  const a = boundary.min_ts_date || '';
                  const b = boundary.max_ts_date || '';
                  msg = `Dates exclude timesheets in range ${a} â†’ ${b}.`;
                }
              } catch {}
              if (typeof showModalHint === 'function') showModalHint(msg, 'warn'); else alert(msg);
              window.modalCtx._saveInFlight = false;
              console.groupEnd?.();
              return false;
            }
          } catch (e) {
            if (LOGC) console.warn('[CONTRACTS] timesheet boundary check failed (non-blocking fallback)', e);
          }
        }

        let hasManualStage = false;
        try {
          const stageKey = data.id || window.modalCtx.openToken || null;
          if (stageKey && typeof getContractCalendarStageState === 'function') {
            const st = getContractCalendarStageState(stageKey);
            hasManualStage = !!(st && (st.add?.size || st.remove?.size || Object.keys(st.additional || {}).length));
          }
        } catch {}

        if (!isCreate && hasManualStage) data.skip_generate_weeks = true;

        // --- detect calendar stage shape BEFORE any persistence ---
        let stageShape = { hasAny:false, hasRemoveAll:false, hasAdds:false, hasAdditionals:false };
        try {
          const stageKey = data.id || window.modalCtx.openToken || null;
          if (stageKey && typeof getContractCalendarStageState === 'function') {
            const st = getContractCalendarStageState(stageKey);
            stageShape.hasAny         = !!st && (!!st.removeAll || st.add.size || st.remove.size || Object.keys(st.additional||{}).length);
            stageShape.hasRemoveAll   = !!st?.removeAll;
            stageShape.hasAdds        = !!(st && st.add && st.add.size);
            stageShape.hasAdditionals = !!(st && st.additional && Object.keys(st.additional).length);
          }
        } catch {}

        // === CREATE vs EDIT ordering ===
        // CREATE: upsert first to obtain id â†’ then commit stage (if any) â†’ normalize window â†’ (maybe) generate defaults
        // EDIT: if any stage present, always commit calendar FIRST â†’ normalize window â†’ then upsert metadata
  if (!isCreate && data.id && stageShape.hasAny) {
  if (LOGC) console.log('[CONTRACTS] calendar (any stage) â†’ commitContractCalendarStageIfPending');
  const preCalRes = await commitContractCalendarStageIfPending(data.id);
  if (!preCalRes.ok) {
    const msg = `Calendar save failed: ${preCalRes.message || 'unknown error'}. Contract details were not saved.`;
    if (LOGC) console.warn('[CONTRACTS] calendar commit failed (pre-upsert)', preCalRes);
    if (typeof showModalHint === 'function') showModalHint(msg, 'warn'); else alert(msg);
    window.modalCtx._saveInFlight = false;
    console.groupEnd?.();
    return false;
  }

  // Do NOT normalize on the FE â€” backend now owns window shrink/extend.
  // Instead, pull the fresh contract (authoritative window) and bind it.
  try {
    const fresh = await getContract(data.id);
    if (fresh && fresh.id) {
      window.modalCtx.data = fresh;

      // Update formState (so subsequent PUTs never push stale dates)
      const fs = (window.modalCtx.formState ||= { __forId: (data.id||null), main:{}, pay:{} });
      fs.main ||= {};
      fs.main.start_date = fresh.start_date || null;
      fs.main.end_date   = fresh.end_date   || null;

      // Update visible inputs if we're on the Main tab
      try {
        const form = document.querySelector('#contractForm');
        if (form) {
          const sd = form.querySelector('input[name="start_date"]');
          const ed = form.querySelector('input[name="end_date"]');
          const toUk = (iso) => {
            try { return (typeof formatIsoToUk === 'function') ? (formatIsoToUk(iso) || iso) : iso; } catch { return iso; }
          };
          if (sd && fresh.start_date) sd.value = toUk(fresh.start_date);
          if (ed && fresh.end_date)   ed.value = toUk(fresh.end_date);
        }
      } catch {}
      // Ensure the payload carries authoritative dates unless user explicitly changed them
      const userEditedStart = !!(prevStartIso && startIso && startIso !== prevStartIso);
      const userEditedEnd   = !!(prevEndIso   && endIso   && endIso   !== prevEndIso);
      data.__userChangedDates = (userEditedStart || userEditedEnd);
      if (!data.__userChangedDates) {
        data.start_date = fresh.start_date;
        data.end_date   = fresh.end_date;
      }
    }
  } catch (e) {
    if (LOGC) console.warn('[CONTRACTS] fresh refetch failed (proceeding with current modal data)', e);
  }

  // Avoid auto-generation when calendar stage was present
  data.skip_generate_weeks = true;
}


// âœ… NEW: calendar-only saves should NOT PUT the contract (avoids â€œratesâ€ validation etc)
const calendarOnlySave =
  !isCreate &&
  !!data.id &&
  !!stageShape?.hasAny &&
  window.modalCtx?.__calendarDirty === true &&
  window.modalCtx?.__nonCalendarDirty !== true;

if (calendarOnlySave) {
  if (LOGC) console.log('[CONTRACTS] calendar-only save: skipping upsertContract (no contract fields changed)');

  // Clear markers so future edits behave normally
  try {
    window.modalCtx.__calendarDirty = false;
    window.modalCtx.__calendarOnly = false;
  } catch {}

  if (LOGC) console.groupEnd?.();
  return { ok: true, saved: (window.modalCtx.data || base) };
}

if (LOGC) console.log('[CONTRACTS] upsert â†’ upsertContract');
const saved = await upsertContract(data, data.id || undefined);


const persistedId = saved?.id || saved?.contract?.id || null;
if (LOGC) console.log('[CONTRACTS] upsertContract result', {
  isCreate, persistedId, rawHasSaved: !!saved
});

window.modalCtx.data = saved?.contract || saved || window.modalCtx.data;
if (LOGC) console.log('[CONTRACTS] modalCtx.data snapshot', {
  id: window.modalCtx.data?.id || null,
  start_date: window.modalCtx.data?.start_date || null,
  end_date:   window.modalCtx.data?.end_date   || null
});

// ðŸ”Ž breadcrumb to prove we reached the post-save gate
console.warn('[AFTER UPSERT] reached post-save pre-gate', {
  modalId: window.modalCtx?.data?.id,
  isCreate,
  openToken: window.modalCtx?.openToken,
  persistedId
});

        try {
          const warnings = saved?.warnings || saved?.contract?.warnings || [];
          const warnStr  = Array.isArray(warnings) ? warnings.join(', ') : (saved?.warning || '');
          if (warnStr) { if (LOGC) console.warn('[CONTRACTS] warnings', warnStr); showModalHint?.(`Warning: ${warnStr}`, 'warn'); }
        } catch {}

        const contractId = saved?.id || saved?.contract?.id;
        if (contractId) {
          window.__pendingFocus = { section: 'contracts', id: contractId };

          // If this was a Clone&Extend staging and user opted to end the old contract, apply now.
          try {
            const t0 = Date.now();
            const savedContractId = contractId || (saved?.contract?.id) || (saved?.id) || null;

            // Prefer the live intent; if lost due to UI state flips, fall back to the pre-save snapshot
            const ciLive     = window.modalCtx?.__cloneIntent || null;
            const ciSnapshot = __preCloneIntent || null;
            const ci         = (ciLive ?? ciSnapshot) || null;

            const hasCi      = !!ci;
            const wantsEnd   = !!ci?.end_existing;
            const hasSource  = !!ci?.source_contract_id;
            const hasEndDate = !!ci?.end_existing_on;

            // Resolve callable from either module/global or window
            const fnLive = (typeof endContractSafely === 'function') ? endContractSafely : undefined;
            const fnWin  = (typeof window !== 'undefined' && typeof window.endContractSafely === 'function') ? window.endContractSafely : undefined;
            const trimFn = fnLive || fnWin;
            const hasFn  = !!trimFn;

            if (LOGC) {
              console.groupCollapsed('[CLONE][post-save gate]');
              console.log({
                isCreate,
                savedContractId,
                modalCtxId: window.modalCtx?.data?.id || null,
                savedStart: window.modalCtx?.data?.start_date || null,
                savedEnd:   window.modalCtx?.data?.end_date   || null,
                openToken:  window.modalCtx?.openToken || null,
                hasCi, wantsEnd, hasSource, hasEndDate,
                ciLive: !!ciLive,
                ciSnapshot: !!ciSnapshot,
                ci: {
                  source_contract_id: ci?.source_contract_id ?? null,
                  end_existing:       ci?.end_existing ?? null,
                  end_existing_on:    ci?.end_existing_on ?? null
                },
                hasFnLive:  !!fnLive,
                hasFnWin:   !!fnWin,
                hasFnResolved: hasFn
              });
              console.groupEnd();
            }

            if (hasCi && wantsEnd && hasSource && hasEndDate && hasFn) {
              if (LOGC) console.log('WILL_CALL endContractSafely', { source: ci.source_contract_id, desired_end: ci.end_existing_on });

              let res = null, ok=false, clamped=false, safe_end=null, message=null, t1=0;
              try {
                console.groupCollapsed('[TRIM_CALL] â†’', { source: ci.source_contract_id, desired_end: ci.end_existing_on });
                res = await trimFn(ci.source_contract_id, ci.end_existing_on);
                t1 = Date.now();
                ok       = !!(res && (res.ok ?? (res === true)));
                clamped  = !!res?.clamped;
                safe_end = res?.safe_end || null;
                message  = res?.message  || null;
                console.log('result', { ok, clamped, safe_end, message, raw: res, elapsed_ms: (t1 - t0) });
                console.groupEnd();
              } catch (err) {
                console.warn('[TRIM_CALL] âœ– threw', err);
              }

              if (ok) {
                if (clamped && typeof showTailClampWarning === 'function') {
                  try { showTailClampWarning(safe_end, ci.end_existing_on); } catch {}
                }
                if (typeof refreshOldContractAfterTruncate === 'function') {
                  try { await refreshOldContractAfterTruncate(ci.source_contract_id); } catch (e) { if (LOGC) console.warn('refreshOldContractAfterTruncate failed', e); }
                }
                if (LOGC) console.log('CLEAR_INTENT (after endContractSafely)');
                clearCloneIntent();
              } else {
                if (LOGC) console.warn('TRIM_CALL did not report ok', { res });
                if (LOGC) console.log('CLEAR_INTENT (after not-ok result)');
                clearCloneIntent();
              }
            } else {
              const reasons = [];
              if (!hasCi)               reasons.push('NO_INTENT');
              if (hasCi && !wantsEnd)   reasons.push('BOX_UNTICKED_end_existing=false');
              if (hasCi && !hasSource)  reasons.push('MISSING_source_contract_id');
              if (hasCi && !hasEndDate) reasons.push('MISSING_end_existing_on');
              if (!hasFn)               reasons.push(`NO_endContractSafely (live=${!!fnLive}, window=${!!fnWin})`);
              console.warn('[CLONE][post-save SKIP] not calling endContractSafely', { reasons });
              console.log('CLEAR_INTENT (skip path)');
              clearCloneIntent();
            }

          } catch (e) {
            if (LOGC) console.warn('[CLONE][post-save decision] EXCEPTION', e);
          }

        }

        try { if (typeof computeContractMargins === 'function') computeContractMargins(); } catch {}

        try {
          const fr = window.__getModalFrame?.();
          const currentTab = fr?.currentTabKey || (document.querySelector('#modalTabs button.active')?.textContent?.toLowerCase() || 'main');
          if (LOGC) console.log('[CONTRACTS] post-save repaint (in-place)', { currentTab, contractId: (window.modalCtx?.data?.id) });
if (currentTab === 'calendar' && window.modalCtx?.data?.id) {
  const contractId2 = window.modalCtx.data.id;
  const candId = window.modalCtx?.data?.candidate_id || null;

  // âœ… Prefer captured viewport from pre-save (stable), otherwise fall back to current calState
  const vp = (window.modalCtx && window.modalCtx.__calViewport && window.modalCtx.__calViewport.contract_id === contractId2)
    ? window.modalCtx.__calViewport
    : null;

  const cal = window.__calState?.[contractId2] || {};
  const view = vp?.view || cal.view || 'year';
  const win  = vp?.win  || cal.win  || null;

  const prevScrollTop  = (vp?.scrollTop  ?? document.getElementById('__calScroll')?.scrollTop ?? 0);
  const prevScrollLeft = (vp?.scrollLeft ?? document.getElementById('__calScroll')?.scrollLeft ?? 0);

  const applyScroll = () => {
    const sb = document.getElementById('__calScroll');
    if (!sb) return;
    sb.scrollTop  = prevScrollTop;
    sb.scrollLeft = prevScrollLeft;
  };

  if (typeof fetchAndRenderCandidateCalendarForContract === 'function' && candId) {
    await fetchAndRenderCandidateCalendarForContract(contractId2, candId, {
      from: win?.from, to: win?.to, view,
      weekEnding: window.modalCtx?.data?.week_ending_weekday_snapshot ?? 0,
      __restoreScroll: { top: prevScrollTop, left: prevScrollLeft }
    });
  } else {
    await fetchAndRenderContractCalendar(contractId2, win ? {
      from: win.from, to: win.to, view,
      __restoreScroll: { top: prevScrollTop, left: prevScrollLeft }
    } : undefined);
  }

  // âœ… Restore scroll AFTER layout settles (prevents snapping to top)
  requestAnimationFrame(() => requestAnimationFrame(applyScroll));
}
 else if (currentTab === 'rates') {
            try { computeContractMargins(); } catch {}
          }
          try { window.__toast?.('Saved'); } catch {}
        } catch (e) {
          if (LOGC) console.warn('[CONTRACTS] post-save repaint failed', e);
        }

        if (LOGC) console.groupEnd?.();
        // Return the saved row so saveForFrame() can set hasId=true and flip to View
        const savedRow = (window.modalCtx.data || null);
        return { ok: true, saved: savedRow };

       } catch (e) {
        if (LOGC) { console.error('[CONTRACTS] Save failed', e); console.groupEnd?.(); }
        alert(`Save failed: ${e?.message || e}`);
        return false;
      } finally {
        window.modalCtx._saveInFlight = false;
      }
    },

    hasId, // 5th

    // 6th: onReturn â€” single, deduped
    () => {
      const wire = () => {
        snapshotContractForm();

     const form   = document.querySelector('#contractForm');
    const tabsEl = document.getElementById('modalTabs');
    const active = tabsEl?.querySelector('button.active')?.textContent?.toLowerCase() || 'main';


     if (form) {
      if (!form.__wiredStage) {
        form.__wiredStage = true;
const stage = (e) => {
  const t = e.target;
  if (!t || !t.name) return;

  const name = t.name;

  const v = t.type === 'checkbox'
    ? (t.checked ? 'on' : '')
    : t.value;

  const isScheduleTime = /^(mon|tue|wed|thu|fri|sat|sun)_(start|end)$/.test(name);

  // âœ… NEW: mark contract-settings dirty only when a contract-settings field is touched
  const CONTRACT_SETTINGS_FIELDS = new Set([
    'overrideclientsettings',
    'is_nhsp',
    'autoprocess_hr',
    'requires_hr',
    'no_timesheet_required',
    'daily_calc_of_invoices',
    'group_nightsat_sunbh',
    'self_bill',
    'hr_attach_to_invoice',
    'ts_attach_to_invoice',
    'auto_invoice',
    'require_reference_to_pay',
    'require_reference_to_invoice',
    'reference_number_required_to_issue_invoice',
    'send_manual_invoices_to_different_email',
    'manual_invoices_alt_email_address',
    'default_submission_mode'
  ]);

  // âœ… NEW: any form input here is NON-calendar (calendar staging uses separate functions)
  try {
    window.modalCtx = window.modalCtx || {};
    window.modalCtx.__nonCalendarDirty = true;
    window.modalCtx.__calendarOnly = false;

    // Only flip this flag when user touches an actual contract-settings control
    if (CONTRACT_SETTINGS_FIELDS.has(name)) {
      window.modalCtx.__contractSettingsDirty = true;
    }
  } catch {}

  if (isScheduleTime) {
    window.modalCtx = window.modalCtx || {};
    const fs = (window.modalCtx.formState ||= {
      __forId: (window.modalCtx.data?.id ?? window.modalCtx.openToken ?? null),
      main:{},
      pay:{}
    });
    fs.main ||= {};
    fs.main[name] = v;
  } else {
    setContractFormValue(name, v);

    if (name === 'pay_method_snapshot' || /^(paye_|umb_|charge_)/.test(name)) {
      computeContractMargins();
    }
  }

  try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
};







        form.addEventListener('input', stage, true);
        form.addEventListener('change', stage, true);

        // NEW: lock pay_method_snapshot select appropriately
        try {
          const sel = form.querySelector('select[name="pay_method_snapshot"], select[name="default_pay_method_snapshot"]');
          const candId = window.modalCtx?.data?.candidate_id || null;
          const hasId  = !!window.modalCtx?.data?.id;
          const mainFs = (window.modalCtx?.formState && window.modalCtx.formState.main) || {};

          if (sel) {
            if (hasId) {
              // Edit mode: always read-only â€“ pay method comes from candidate / history
              sel.disabled = true;
            } else if (candId) {
              // New contract with candidate already chosen:
              // re-use derived snapshot and keep it locked
              sel.disabled = true;
            } else if (mainFs.__pay_locked) {
              // Candidate picker has already derived & locked the snapshot
              sel.disabled = true;
            } else {
              // Brand-new, no candidate yet â†’ leave editable (rare case, but allowed)
              sel.disabled = false;
            }
          }
        } catch (e) {
          if (LOGC) console.warn('[CONTRACTS] pay_method_snapshot lock wiring failed', e);
        }

            const normaliseTimeInput = (t) => {
              if (!t || !/^(mon|tue|wed|thu|fri|sat|sun)_(start|end)$/.test(t.name)) return;
              const raw = (t.value || '').trim();
              const norm = (function (x) {
                if (!x) return '';
                const y = x.replace(/\s+/g, '');
                let h, m;
                if (/^\d{3,4}$/.test(y)) {
                  const s = y.padStart(4, '0'); h = +s.slice(0, 2); m = +s.slice(2, 4);
                } else if (/^\d{1,2}:\d{1,2}$/.test(y)) {
                  const parts = y.split(':'); h = +parts[0]; m = +parts[1];
                } else return '';
                if (h < 0 || h > 23 || m < 0 || m > 59) return '';
                return String(h).padStart(2, '0') + ':' + String(m).padStart(2, '0');
              })(raw);

              if (!norm && raw) {
                t.value = '';
                t.setAttribute('data-invalid', '1');
                t.setAttribute('title', 'Enter a valid time HH:MM (00:00â€“23:59)');
                setContractFormValue(t.name, '');
                try { t.dispatchEvent(new Event('input', { bubbles: true })); t.dispatchEvent(new Event('change', { bubbles: true })); } catch {}
                try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
                return;
              }

              if (norm) {
                t.value = norm;
                t.removeAttribute('data-invalid');
                t.removeAttribute('title');
                setContractFormValue(t.name, norm);
                try { t.dispatchEvent(new Event('input', { bubbles: true })); t.dispatchEvent(new Event('change', { bubbles: true })); } catch {}
                try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
              }
            };

            const onBlurNorm = (e) => { normaliseTimeInput(e.target); };
            form.addEventListener('blur', onBlurNorm, true);

            const onKeydownNorm = (e) => {
              if (e.key === 'Tab') normaliseTimeInput(e.target);
            };
            form.addEventListener('keydown', onKeydownNorm, true);
          }

          if (active === 'main') {
            try {
              const sd = form.querySelector('input[name="start_date"]');
              const ed = form.querySelector('input[name="end_date"]');
              const toUk = (iso) => {
                try { return (typeof formatIsoToUk === 'function') ? (formatIsoToUk(iso) || '') : (iso || ''); }
                catch { return iso || ''; }
              };
              if (sd && /^\d{4}-\d{2}-\d{2}$/.test(sd.value||'')) sd.value = toUk(sd.value);
              if (ed && /^\d{4}-\d{2}-\d{2}$/.test(ed.value||'')) ed.value = toUk(ed.value);
              if (sd) { sd.setAttribute('placeholder','DD/MM/YYYY'); if (typeof attachUkDatePicker === 'function') attachUkDatePicker(sd); }
              if (ed) { ed.setAttribute('placeholder','DD/MM/YYYY'); if (typeof attachUkDatePicker === 'function') attachUkDatePicker(ed, { minDate: sd?.value || null }); }
              if (sd && ed) {
                sd.addEventListener('change', () => {
                  const sv = sd.value || '';
                  if (typeof attachUkDatePicker === 'function') attachUkDatePicker(ed, { minDate: sv || null });
                  if (sv && ed.value) {
                    try {
                      const si = parseUkDateToIso?.(sv) || sv;
                      const ei = parseUkDateToIso?.(ed.value) || ed.value;
                      if (si && ei && si > ei) { ed.value=''; showModalHint?.('Pick an end date after start','warn'); setContractFormValue('end_date',''); }
                    } catch {}
                  }
                });
              }
              if (LOGC) console.log('[CONTRACTS] datepickers wired for start_date/end_date', { hasStart: !!sd, hasEnd: !!ed });
            } catch (e) {
              if (LOGC) console.warn('[CONTRACTS] datepicker wiring failed', e);
            }

            const btnPC = document.getElementById('btnPickCandidate');
            const btnCC = document.getElementById('btnClearCandidate');
            const btnPL = document.getElementById('btnPickClient');
            const btnCL = document.getElementById('btnClearClient');
            const candInput = document.getElementById('candidate_name_display');
            const cliInput  = document.getElementById('client_name_display');

            const ensurePrimed = async (entity) => {
              try {
                await ensurePickerDatasetPrimed(entity);
                const fp = getSummaryFingerprint(entity);
                const mem = getSummaryMembership(entity, fp);
                if (!mem?.ids?.length || mem?.stale) {
                  await primeSummaryMembership(entity, fp);
                }
              } catch (e) { if (LOGC) console.warn('[CONTRACTS] typeahead priming failed', entity, e); }
            };

            const buildItemLabel = (entity, r) => {
              if (entity === 'candidates') {
                const first = (r.first_name||'').trim();
                const last  = (r.last_name||'').trim();
                const role  = ((r.roles_display||'').split(/[â€¢;,]/)[0]||'').trim();
                return `${last}${last?', ':''}${first}${role?` ${role}`:''}`.trim();
              } else {
                const name  = (r.name||'').trim();
                return name;
              }
            };

            const wireTypeahead = async (entity, inputEl, hiddenName, labelElId) => {
              if (!inputEl) return;
              await ensurePrimed(entity);

              const menuId = entity === 'candidates' ? 'candTypeaheadMenu' : 'clientTypeaheadMenu';
              let menu = document.getElementById(menuId);
              if (!menu) {
                menu = document.createElement('div');
                menu.id = menuId;
                menu.className = 'typeahead-menu';
                menu.style.position = 'absolute';
                menu.style.zIndex = '1000';
                menu.style.background = 'var(--panel, #fff)';
                menu.style.border = '1px solid var(--line, #ddd)';
                menu.style.boxShadow = '0 4px 12px rgba(0,0,0,0.08)';
                menu.style.maxHeight = '240px';
                menu.style.overflowY = 'auto';
                menu.style.display = 'none';
                document.body.appendChild(menu);
              }

              const positionMenu = () => {
                const r = inputEl.getBoundingClientRect();
                menu.style.minWidth = `${Math.max(260, r.width)}px`;
                menu.style.left = `${window.scrollX + r.left}px`;
                menu.style.top  = `${window.scrollY + r.bottom + 4}px`;
              };

              const closeMenu = () => { menu.style.display = 'none'; menu.innerHTML = ''; };
              const openMenu  = () => { positionMenu(); menu.style.display = ''; };

              const getDataset = () => {
                const fp  = getSummaryFingerprint(entity);
                const mem = getSummaryMembership(entity, fp);
                const ds  = (window.__pickerData ||= {})[entity] || { since:null, itemsById:{} };
                const items = ds.itemsById || {};
                let ids = Array.isArray(mem?.ids) ? mem.ids : [];
                if (!ids.length) ids = Object.keys(items);
                return { ids, items };
              };

              const applyList = (rows) => {
                menu.innerHTML = rows.slice(0, 10).map(r => {
                  const label = buildItemLabel(entity, r);
                  return `<div class="ta-item" data-id="${r.id||''}" data-label="${(label||'').replace(/"/g,'&quot;')}" style="padding:8px 10px;cursor:pointer;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${label}</div>`;
                }).join('');
                const first = menu.querySelector('.ta-item');
                if (first) first.style.background = 'var(--hover, #f5f5f5)';
              };

              const selectRow = (id, label) => {
                setContractFormValue(hiddenName, id);
                inputEl.value = label || '';
                const labEl = document.getElementById(labelElId);
                if (labEl) labEl.textContent = label ? `Chosen: ${label}` : '';

                try {
                  const fs = (window.modalCtx.formState ||= { __forId: (window.modalCtx.data?.id ?? window.modalCtx.openToken ?? null), main:{}, pay:{} });
                  fs.main ||= {};
                  fs.main[hiddenName] = id;
                  if (hiddenName === 'candidate_id') fs.main['candidate_display'] = label;
                  if (hiddenName === 'client_id')    fs.main['client_name']       = label;
                } catch {}

                try {
                  window.modalCtx.data = window.modalCtx.data || {};
                  if (hiddenName === 'candidate_id') { window.modalCtx.data.candidate_id = id; window.modalCtx.data.candidate_display = label; }
                  if (hiddenName === 'client_id')    { window.modalCtx.data.client_id    = id; window.modalCtx.data.client_name = label; }
                } catch {}
if (hiddenName === 'candidate_id') {
  (async () => {
    try {
      const candRaw = await getCandidate(id);
      // Support both shapes: { candidate:{...} } or flat row
      const cand = (candRaw && candRaw.candidate) ? candRaw.candidate : candRaw;

      const pmRaw = cand && cand.pay_method ? String(cand.pay_method).toUpperCase() : '';
      const derived =
        (pmRaw === 'UMBRELLA' && cand && cand.umbrella_id)
          ? 'UMBRELLA'
          : 'PAYE';

      const fsm = (window.modalCtx.formState ||= { main:{}, pay:{} }).main ||= {};
      fsm.pay_method_snapshot = derived;
      fsm.__pay_locked = true;
      const sel = document.querySelector('select[name="pay_method_snapshot"], select[name="default_pay_method_snapshot"]');
      if (sel) { sel.value = derived; sel.disabled = true; }
      computeContractMargins();
    } catch (e) {
      if (LOGC) console.warn('[CONTRACTS] derive pay method failed', e);
    }
  })();
}


                closeMenu();
                try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
              };

              let debTimer = 0;
              const handleInput = () => {
                const q = (inputEl.value||'').trim();
                if (q.length < 3) { closeMenu(); return; }
                if (debTimer) clearTimeout(debTimer);
                debTimer = setTimeout(() => {
                  const { ids, items } = getDataset();
                  const rows = pickersLocalFilterAndSort(entity, ids, q, entity==='candidates'?'last_name':'name', 'asc')
                    .map(v => (typeof v === 'object' ? v : items[String(v)]))
                    .filter(Boolean);
                  if (!rows.length) { closeMenu(); return; }
                  applyList(rows);
                  openMenu();
                }, 120);
              };

              const handleKeyDown = (e) => {
                if (menu.style.display === 'none') return;
                const items = Array.from(menu.querySelectorAll('.ta-item'));
                if (!items.length) return;
                const idx = items.findIndex(n => n.style.background && n.style.background.includes('hover'));
                const setActive = (i) => {
                  items.forEach(n => n.style.background='');
                  items[i].style.background = 'var(--hover, #f5f5f5)';
                  items[i].scrollIntoView({ block:'nearest' });
                };
                if (e.key === 'ArrowDown') { e.preventDefault(); setActive(Math.min((idx<0?0:idx+1), items.length-1)); }
                if (e.key === 'ArrowUp')   { e.preventDefault(); setActive(Math.max((idx<0?0:idx-1), 0)); }
                if (e.key === 'Enter')     { e.preventDefault(); const n = items[Math.max(idx,0)]; if (n) selectRow(n.dataset.id, n.dataset.label); }
                if (e.key === 'Escape')    { e.preventDefault(); closeMenu(); }
              };

              menu.addEventListener('click', (ev) => {
                const n = ev.target && ev.target.closest('.ta-item'); if (!n) return;
                selectRow(n.dataset.id, n.dataset.label);
              });

              let blurTimer = 0;
              inputEl.addEventListener('blur', () => { blurTimer = setTimeout(closeMenu, 150); });
              menu.addEventListener('mousedown', () => { if (blurTimer) clearTimeout(blurTimer); });

              inputEl.addEventListener('input', handleInput);
              inputEl.addEventListener('keydown', handleKeyDown);
            };

            wireTypeahead('candidates', candInput, 'candidate_id', 'candidatePickLabel');
            wireTypeahead('clients',    cliInput,  'client_id',    'clientPickLabel');

   if (btnPC && !btnPC.__wired) {
  btnPC.__wired = true;
  btnPC.addEventListener('click', async () => {
    if (LOGC) console.log('[CONTRACTS] Pick Candidate clicked');
    openCandidatePicker(async ({ id, label }) => {
      if (LOGC) console.log('[CONTRACTS] Pick Candidate â†’ selected', { id, label });

      let candRow = null;
      try {
        const candRaw = await getCandidate(id);
        // Support both shapes: { candidate:{...} } or flat row
        candRow = (candRaw && candRaw.candidate) ? candRaw.candidate : candRaw;
      } catch (e) {
        alert('Failed to load candidate details for this contract.');
        if (LOGC) console.warn('[CONTRACTS] getCandidate failed', e);
        return;
      }

      const pmRaw = candRow && candRow.pay_method ? String(candRow.pay_method).toUpperCase() : '';
      const pm    = (pmRaw === 'PAYE' || pmRaw === 'UMBRELLA') ? pmRaw : null;

      if (!pm) {
        alert('This candidate has no pay method set (Unknown). Please set their pay method to PAYE or UMBRELLA before creating a contract.');
        if (LOGC) console.warn('[CONTRACTS] blocking contract create for candidate with Unknown pay_method', {
          candidate_id: id,
          pay_method: candRow?.pay_method
        });
        return;
      }

      // Only now do we bind candidate + snapshot into the contract form
      setContractFormValue('candidate_id', id);
      const lab = document.getElementById('candidatePickLabel'); if (lab) lab.textContent = `Chosen: ${label}`;
      try {
        const fs2 = (window.modalCtx.formState ||= { __forId: (window.modalCtx.data?.id ?? window.modalCtx.openToken ?? null), main:{}, pay:{} });
        fs2.main ||= {}; fs2.main.candidate_id = id; fs2.main.candidate_display = label;
        window.modalCtx.data = window.modalCtx.data || {};
        window.modalCtx.data.candidate_id = id; window.modalCtx.data.candidate_display = label;
      } catch {}

      try {
        const fsm = (window.modalCtx.formState ||= { main:{}, pay:{} }).main ||= {};
        fsm.pay_method_snapshot = pm;
        fsm.__pay_locked = true;
        const sel = document.querySelector('select[name="pay_method_snapshot"], select[name="default_pay_method_snapshot"]');
        if (sel) { sel.value = pm; sel.disabled = true; }
        computeContractMargins();
      } catch (e) {
        if (LOGC) console.warn('[CONTRACTS] prefillPayMethodFromCandidate failed', e);
      }
    });
  });

  if (LOGC) console.log('[CONTRACTS] wired btnPickCandidate');
}

      if (btnCC && !btnCC.__wired) {
  btnCC.__wired = true;
  btnCC.addEventListener('click', () => {
    if (LOGC) console.log('[CONTRACTS] Clear Candidate clicked');
    setContractFormValue('candidate_id', '');

    // ðŸ”¹ Clear the visible candidate text input as well
    const candInput = document.getElementById('candidate_name_display');
    if (candInput) candInput.value = '';

    const lab = document.getElementById('candidatePickLabel');
    if (lab) lab.textContent = '';

    try {
      const fs2 = (window.modalCtx.formState ||= {
        __forId: (window.modalCtx.data?.id ?? window.modalCtx.openToken ?? null),
        main:{}, pay:{}
      });
      fs2.main ||= {};
      delete fs2.main.candidate_id;
      delete fs2.main.candidate_display;
      fs2.main.__pay_locked = false;
      fs2.main.pay_method_snapshot = 'PAYE';

      const sel = document.querySelector('select[name="pay_method_snapshot"], select[name="default_pay_method_snapshot"]');
      if (sel) { sel.disabled = false; sel.value = 'PAYE'; }

      window.modalCtx.data = window.modalCtx.data || {};
      delete window.modalCtx.data.candidate_id;
      delete window.modalCtx.data.candidate_display;
    } catch {}
    try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
  });
  if (LOGC) console.log('[CONTRACTS] wired btnClearCandidate');
}


            if (btnPL && !btnPL.__wired) {
              btnPL.__wired = true;
              btnPL.addEventListener('click', async () => {
                if (LOGC) console.log('[CONTRACTS] Pick Client clicked');
                openClientPicker(async ({ id, label }) => {
                  if (LOGC) console.log('[CONTRACTS] Pick Client â†’ selected', { id, label });
                  setContractFormValue('client_id', id);
                  const lab = document.getElementById('clientPickLabel'); if (lab) lab.textContent = `Chosen: ${label}`;
                  try {
                    const fs2 = (window.modalCtx.formState ||= { __forId: (window.modalCtx.data?.id ?? window.modalCtx.openToken ?? null), main:{}, pay:{} });
                    fs2.main ||= {}; fs2.main.client_id = id; fs2.main.client_name = label;
                    window.modalCtx.data = window.modalCtx.data || {};
                    window.modalCtx.data.client_id = id; window.modalCtx.data.client_name = label;
                  } catch {}
                         try {
                    const client = await getClient(id);

                    // âœ… NEW: store the latest client_settings snapshot for overrideclientsettings seeding
                    try {
                      const cs = client?.client_settings || null;
                      if (cs && typeof cs === 'object') {
                        window.modalCtx.client_settings_snapshot = cs;
                        window.modalCtx.client_settings_snapshot_client_id = String(id);
                        if (LOGC) console.log('[CONTRACTS] stored client_settings snapshot (client change)', { client_id: id });
                      } else {
                        window.modalCtx.client_settings_snapshot = null;
                        window.modalCtx.client_settings_snapshot_client_id = String(id);
                        if (LOGC) console.warn('[CONTRACTS] client_settings snapshot missing on client payload (client change)', { client_id: id });
                      }
                    } catch {}

                    const h = checkClientInvoiceEmailPresence(client);
                    if (h) showModalHint(h, 'warn');
                    const we = (client?.week_ending_weekday ?? (client?.client_settings && client.client_settings.week_ending_weekday)) ?? 0;

                    const fs2 = (window.modalCtx.formState ||= { main:{}, pay:{} });
                    fs2.main ||= {}; fs2.main.week_ending_weekday_snapshot = String(we);
                    const weekNames = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];
                    const lbl = document.getElementById('weLabel'); if (lbl) lbl.textContent = weekNames[Number(we)] || 'Sunday';
                    const hidden = form?.querySelector('input[name="week_ending_weekday_snapshot"]'); if (hidden) hidden.value = String(we);

                      // NEW: 2.5 defaults (only on brand new contract and if not manually set yet)
try {
  const isNewContract = !window.modalCtx?.data?.id;
  const cs = client?.client_settings || {};
  if (isNewContract) {
    const main = (window.modalCtx.formState ||= {main:{},pay:{}}).main ||= {};

    // NEW: contract route defaults from client settings (only if unset)
    if (!Object.prototype.hasOwnProperty.call(main, 'is_nhsp')) {
      const v = !!cs.is_nhsp;
      setContractFormValue('is_nhsp', v ? 'on' : '');
      main.is_nhsp = v;
    }
    if (!Object.prototype.hasOwnProperty.call(main, 'autoprocess_hr')) {
      const v = !!cs.autoprocess_hr;
      setContractFormValue('autoprocess_hr', v ? 'on' : '');
      main.autoprocess_hr = v;
    }
    if (!Object.prototype.hasOwnProperty.call(main, 'requires_hr')) {
      const v = !!cs.requires_hr;
      setContractFormValue('requires_hr', v ? 'on' : '');
      main.requires_hr = v;
    }
    if (!Object.prototype.hasOwnProperty.call(main, 'no_timesheet_required')) {
      const v = !!cs.no_timesheet_required;
      setContractFormValue('no_timesheet_required', v ? 'on' : '');
      main.no_timesheet_required = v;
    }
       if (!Object.prototype.hasOwnProperty.call(main, 'daily_calc_of_invoices')) {
      const v = !!cs.daily_calc_of_invoices;
      setContractFormValue('daily_calc_of_invoices', v ? 'on' : '');
      main.daily_calc_of_invoices = v;
    }
       if (!Object.prototype.hasOwnProperty.call(main, 'group_nightsat_sunbh')) {
      const v = !!cs.group_nightsat_sunbh;
      setContractFormValue('group_nightsat_sunbh', v ? 'on' : '');
      main.group_nightsat_sunbh = v;
    }

    // NEW: self-bill default (client_settings column is self_bill_no_invoices_sent)
    if (!Object.prototype.hasOwnProperty.call(main, 'self_bill')) {
      const v = !!cs.self_bill_no_invoices_sent;
      setContractFormValue('self_bill', v ? 'on' : '');
      main.self_bill = v;
    }

    // NEW: canonicalise route flags (matches brief)
    // Manual: is_nhsp=false, autoprocess_hr=false, no_timesheet_required=false
    // NHSP: is_nhsp=true, autoprocess_hr=false, no_timesheet_required=false
    // HR required: autoprocess_hr=true, is_nhsp=false, no_timesheet_required=false
    // HR no-timesheets: autoprocess_hr=true, is_nhsp=false, no_timesheet_required=true
    const r_isNhsp = !!main.is_nhsp;
    const r_isHr   = !!main.autoprocess_hr;
    const r_noTs   = !!main.no_timesheet_required;



    if (r_isNhsp) {
      if (main.autoprocess_hr) {
        setContractFormValue('autoprocess_hr', '');
        main.autoprocess_hr = false;
      }
      if (main.no_timesheet_required) {
        setContractFormValue('no_timesheet_required', '');
        main.no_timesheet_required = false;
      }
    }
    if (r_noTs) {
      if (!main.autoprocess_hr) {
        setContractFormValue('autoprocess_hr', 'on');
        main.autoprocess_hr = true;
      }
      if (main.is_nhsp) {
        setContractFormValue('is_nhsp', '');
        main.is_nhsp = false;
      }
    }
    if (main.autoprocess_hr) {
      if (main.is_nhsp) {
        setContractFormValue('is_nhsp', '');
        main.is_nhsp = false;
      }
    }
    if (!main.autoprocess_hr) {
      if (main.no_timesheet_required) {
        setContractFormValue('no_timesheet_required', '');
        main.no_timesheet_required = false;
      }
    }

    // Optional: update visible route label immediately if present (non-blocking)
    try {
      const lbl = document.getElementById('contractRouteLabel');
      if (lbl) {
        const isNhsp = !!main.is_nhsp;
        const isHr   = !!main.autoprocess_hr;
        const noTs   = !!main.no_timesheet_required;
        const routeLabel =
          isNhsp ? 'NHSP' :
          (isHr && noTs) ? 'HealthRoster (no timesheets)' :
          (isHr) ? 'HealthRoster (timesheets required)' :
          'Manual';
        lbl.innerHTML = `<strong>${routeLabel}</strong>`;
      }
    } catch {}

    if (!Object.prototype.hasOwnProperty.call(main, 'require_reference_to_pay')) {
      const v = !!cs.pay_reference_required;
      setContractFormValue('require_reference_to_pay', v ? 'on' : '');
      main.require_reference_to_pay = v;
    }
    if (!Object.prototype.hasOwnProperty.call(main, 'require_reference_to_invoice')) {
      const v = !!cs.invoice_reference_required;
      setContractFormValue('require_reference_to_invoice', v ? 'on' : '');
      main.require_reference_to_invoice = v;
    }
    if (!Object.prototype.hasOwnProperty.call(main, 'default_submission_mode')) {
      const mode = String(cs.default_submission_mode || 'ELECTRONIC').toUpperCase();
      const sel = document.querySelector('select[name="default_submission_mode"]');
      if (sel) sel.value = mode;
      main.default_submission_mode = mode;
    }

       // NEW: auto_invoice default from client_settings (client-level default feeds contract)
    if (!Object.prototype.hasOwnProperty.call(main, 'auto_invoice')) {
      const v = !!cs.auto_invoice_default;
      setContractFormValue('auto_invoice', v ? 'on' : '');
      main.auto_invoice = v;
      const cb = form?.querySelector('input[name="auto_invoice"]');
      if (cb) cb.checked = v;
    }



    // NEW: mileage default from client when empty
    const mcrEl = document.querySelector('#contractRatesTab input[name="mileage_charge_rate"]');
    const mprEl = document.querySelector('#contractRatesTab input[name="mileage_pay_rate"]');
    const isBlank = (el) => !el || String(el.value||'').trim()==='';
    if ((isBlank(mcrEl) && !main.mileage_charge_rate) || (isBlank(mprEl) && !main.mileage_pay_rate)) {
      const charge = (client?.mileage_charge_rate != null) ? Number(client.mileage_charge_rate) : null;
      if (charge != null && Number.isFinite(charge)) {
        const pay = Math.max(0, charge - 0.10);
        if (mcrEl) mcrEl.value = charge;
        if (mprEl) mprEl.value = pay;
        main.mileage_charge_rate = charge;
        main.mileage_pay_rate    = pay;
        try {
          if (mcrEl) { mcrEl.dispatchEvent(new Event('input',{bubbles:true})); mcrEl.dispatchEvent(new Event('change',{bubbles:true})); }
          if (mprEl) { mprEl.dispatchEvent(new Event('input',{bubbles:true})); mprEl.dispatchEvent(new Event('change',{bubbles:true})); }
        } catch {}
      }
    }
  }
} catch (e) { if (LOGC) console.warn('[CONTRACTS] client defaults (gates/submission/mileage) failed', e); }


                    try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
                  } catch (e) { if (LOGC) console.warn('[CONTRACTS] client hint/week-ending check failed', e); }
                });
              });
              if (LOGC) console.log('[CONTRACTS] wired btnPickClient');
            }
        if (btnCL && !btnCL.__wired) {
  btnCL.__wired = true;
  btnCL.addEventListener('click', () => {
    if (LOGC) console.log('[CONTRACTS] Clear Client clicked');
    setContractFormValue('client_id', '');

    // ðŸ”¹ Clear the visible client text input as well
    const cliInput = document.getElementById('client_name_display');
    if (cliInput) cliInput.value = '';

    const lab = document.getElementById('clientPickLabel');
    if (lab) lab.textContent = '';

    try {
      const fs2 = (window.modalCtx.formState ||= {
        __forId: (window.modalCtx.data?.id ?? window.modalCtx.openToken ?? null),
        main:{}, pay:{}
      });
      fs2.main ||= {};
      delete fs2.main.client_id;
      delete fs2.main.client_name;
      delete fs2.main.week_ending_weekday_snapshot;

      // âœ… NEW: clear stored client_settings snapshot when client is cleared
      try {
        window.modalCtx.client_settings_snapshot = null;
        window.modalCtx.client_settings_snapshot_client_id = null;
      } catch {}


      window.modalCtx.data = window.modalCtx.data || {};
      delete window.modalCtx.data.client_id;
      delete window.modalCtx.data.client_name;

      const lbl = document.getElementById('weLabel');
      if (lbl) lbl.textContent = 'Sunday';

      const hidden = form?.querySelector('input[name="week_ending_weekday_snapshot"]');
      if (hidden) hidden.value = '';
    } catch {}
    try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
  });
  if (LOGC) console.log('[CONTRACTS] wired btnClearClient');
}


            const openOnType = (inputEl, openerName) => {
              if (!inputEl || inputEl.__wiredTyping) return;
              inputEl.__wiredTyping = true;
              if (LOGC) console.log('[CONTRACTS] typing handler installed for', openerName);
            };
            openOnType(candInput, 'candidate');
            openOnType(cliInput, 'client');
          }
        }

           const ratesTab = document.querySelector('#contractRatesTab');
        if (ratesTab) {
          // One-time wiring for the tab container (stageRates, margins)
          if (!ratesTab.__wiredStage) {
            ratesTab.__wiredStage = true;

            // Stage numeric rate fields + margins
            const stageRates = (e) => {
              const t = e.target;
              if (!t || !t.name) return;
              if (/^(paye_|umb_|charge_)/.test(t.name) || /^mileage_(charge|pay)_rate$/.test(t.name)) {
                setContractFormValue(t.name, t.value);
                if (/^(paye_|umb_|charge_)/.test(t.name)) computeContractMargins();
                try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
              }
            };
            ratesTab.addEventListener('input', stageRates, true);
            ratesTab.addEventListener('change', stageRates, true);
            computeContractMargins();
          }

          // Choose preset wiring: may run on every wire(), guarded per-button
 // Choose preset wiring: may run on every wire(), guarded per-button
const chooseBtn = document.getElementById('btnChoosePreset');
if (chooseBtn && !chooseBtn.__wired) {
  chooseBtn.__wired = true;
  chooseBtn.addEventListener('click', () => {
    console.log('[CONTRACTS] Choose preset clicked');

    const payMethod = (function () {
      try {
        const v =
          (window.modalCtx?.formState?.main?.pay_method_snapshot) ||
          document.querySelector('select[name="pay_method_snapshot"], select[name="default_pay_method_snapshot"]')?.value ||
          window.modalCtx?.data?.pay_method_snapshot ||
          'PAYE';
        return String(v).toUpperCase();
      } catch { return 'PAYE'; }
    })();

    const formEl = document.querySelector('#contractForm');
    const fsMain = window.modalCtx?.formState?.main || {};

    // Prefer staged state and modalCtx.data for client_id; DOM is last resort
    let clientId =
      (fsMain.client_id && String(fsMain.client_id).trim()) ||
      (window.modalCtx?.data?.client_id && String(window.modalCtx.data.client_id).trim()) ||
      (formEl?.querySelector('[name="client_id"]')?.value?.trim()) ||
      null;

    clientId = clientId || null; // normalise empty string to null

    const start =
      (formEl?.querySelector('[name="start_date"]')?.value?.trim()) ||
      (fsMain.start_date && String(fsMain.start_date)) ||
      (window.modalCtx?.data?.start_date && String(window.modalCtx.data.start_date)) ||
      null;

    openRatePresetPicker(
      (preset) => {
        // NEW: pre-apply snapshot for Reset
        try {
          if (typeof snapshotContractForm === 'function') snapshotContractForm();
          const src = window.modalCtx && window.modalCtx.formState ? window.modalCtx.formState : null;
          if (src) {
            window.modalCtx.__presetBefore =
              (typeof structuredClone === 'function')
                ? structuredClone(src)
                : JSON.parse(JSON.stringify(src));
          }
        } catch (e) {
          console.warn('[CONTRACTS] pre-apply snapshot failed (non-fatal)', e);
        }

        applyRatePresetToContractForm(preset, payMethod);
        try {
          const chip = document.getElementById('presetChip');
          if (chip) {
            chip.style.display = '';
            const title =
              preset.name ||
              [preset.role, preset.band ? `Band ${preset.band}` : '']
                .filter(Boolean)
                .join(' / ') ||
              'Preset';
            chip.textContent = `Preset: ${title}`;
          }
        } catch {}
        try { computeContractMargins(); } catch {}
        // Mark the contracts frame dirty so Save becomes available
        try {
          const fr = window.__getModalFrame?.();
          if (fr && (fr.kind === 'contracts' || fr.entity === 'contracts')) {
            fr.isDirty = true;
            if (typeof fr._updateButtons === 'function') fr._updateButtons();
          }
        } catch {}
        try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
      },
      {
        client_id:    clientId,
        start_date:   start,
        defaultScope: clientId ? 'CLIENT' : 'GLOBAL'
      }
    );
  });
}



          // Full reset wiring: same pattern (per-button guard, not tied to __wiredStage)
              // Full reset wiring: same pattern (per-button guard, not tied to __wiredStage)
            const resetBtn = document.getElementById('btnResetPreset');
          if (resetBtn && !resetBtn.__wired) {
            resetBtn.__wired = true;
            resetBtn.addEventListener('click', () => {
              const snap = window.modalCtx && window.modalCtx.__presetBefore ? window.modalCtx.__presetBefore : null;
              if (snap && typeof snap === 'object') {
                // Restore from snapshot
                try {
                  const form = document.querySelector('#contractForm');
                  const writeInput = (name, value) => {
                    const el = document.querySelector(`#contractRatesTab input[name="${name}"]`) ||
                               (form && form.querySelector(`[name="${name}"]`)) ||
                               document.querySelector(`[name="${name}"]`);
                    if (el) el.value = (value == null ? '' : String(value));
                    setContractFormValue(name, (value == null ? '' : String(value)));
                  };

                  // Rates
                  const rateKeys = ['paye_day','paye_night','paye_sat','paye_sun','paye_bh','umb_day','umb_night','umb_sat','umb_sun','umb_bh','charge_day','charge_night','charge_sat','charge_sun','charge_bh'];
                  for (const k of rateKeys) writeInput(k, (snap.pay || {})[k] ?? '');

                  // Mileage â€“ try both main & pay snapshots
                  const mp = (snap.main || {})['mileage_pay_rate'];
                  const mc = (snap.main || {})['mileage_charge_rate'];
                  const mp2= (snap.pay  || {})['mileage_pay_rate'];
                  const mc2= (snap.pay  || {})['mileage_charge_rate'];
                  writeInput('mileage_pay_rate',    mp  ?? mp2  ?? '');
                  writeInput('mileage_charge_rate', mc  ?? mc2  ?? '');

                  // Bucket labels (prefer consolidated labels map if present)
                  const L = (snap.main && snap.main.__bucket_labels) ? snap.main.__bucket_labels : {
                    day:   (snap.main || {})['bucket_day']   || '',
                    night: (snap.main || {})['bucket_night'] || '',
                    sat:   (snap.main || {})['bucket_sat']   || '',
                    sun:   (snap.main || {})['bucket_sun']   || '',
                    bh:    (snap.main || {})['bucket_bh']    || ''
                  };
                  [['day','bucket_label_day'],
                   ['night','bucket_label_night'],
                   ['sat','bucket_label_sat'],
                   ['sun','bucket_label_sun'],
                   ['bh','bucket_label_bh']].forEach(([k, field]) => {
                    writeInput(field, L[k] || '');
                    // mirror to any "bucket_" fields if present
                    if (form) {
                      const el2 = form.querySelector(`[name="bucket_${k}"]`);
                      if (el2) el2.value = (L[k] || '');
                    }
                    const tr = document.querySelector(`#marginsTable tr[data-b="${k}"] > td:first-child`);
                    if (tr) tr.textContent = (L[k] || '');
                    ['cardPAYE','cardUMB','cardCHG'].forEach(cid=>{
                      const card = document.getElementById(cid);
                      const inp = card?.querySelector(`input[name$="_${k}"]`);
                      if (card && inp) { const row = inp.closest('.row'); if (row) { const lab=row.querySelector('label'); if (lab) lab.textContent=(L[k] || ''); } }
                    });
                  });

                  // Schedule
                  const tpl = (snap.main || {}).__template || null;
                  const days = ['mon','tue','wed','thu','fri','sat','sun'];
                  if (tpl) {
                    days.forEach(d => {
                      const S = tpl[d] || {};
                      writeInput(`${d}_start`, S.start || '');
                      writeInput(`${d}_end`,   S.end   || '');
                      writeInput(`${d}_break`, (S.break_minutes == null ? '' : String(S.break_minutes)));
                    });
                    const fs = (window.modalCtx.formState ||= { main:{}, pay:{} });
                    fs.main.__template = tpl;
                  } else {
                    // fallback: if snapshot had raw fields
                    days.forEach(d => {
                      writeInput(`${d}_start`, (snap.main || {})[`${d}_start`] || '');
                      writeInput(`${d}_end`,   (snap.main || {})[`${d}_end`]   || '');
                      writeInput(`${d}_break`, (snap.main || {})[`${d}_break`] || '');
                    });
                    const fs = (window.modalCtx.formState ||= { main:{}, pay:{} });
                    fs.main.__template = null;
                  }

                  // Role / band / display_site
                  writeInput('role',         (snap.main || {}).role || '');
                  writeInput('band',         (snap.main || {}).band || '');
                  writeInput('display_site', (snap.main || {}).display_site || '');

                  // Hide chip
                  try { const chip=document.getElementById('presetChip'); if (chip) { chip.style.display='none'; chip.textContent=''; } } catch {}
                } catch (err) {
                  console.warn('[CONTRACTS] preset reset restore failed, falling back to clear', err);
                }

                try { computeContractMargins(); } catch {}
                try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
                return;
              }

              // Fallback: your previous clear-to-blank behavior
              const clear = (sel) => { ratesTab.querySelectorAll(sel).forEach(el => { el.value=''; setContractFormValue(el.name, ''); }); };
              clear('input[name^="paye_"]');
              clear('input[name^="umb_"]');
              clear('input[name^="charge_"]');

              // Clear mileage
              ['mileage_charge_rate','mileage_pay_rate'].forEach(n=>{
                const el = ratesTab.querySelector(`input[name="${n}"]`);
                if (el) el.value = '';
                setContractFormValue(n, '');
              });

              // Reset bucket labels to defaults & update headings
              try {
                const defaults = { day:'Day', night:'Night', sat:'Sat', sun:'Sun', bh:'BH' };
                const form = document.querySelector('#contractForm');
                Object.entries(defaults).forEach(([k,v])=>{
                  setContractFormValue(`bucket_label_${k}`, v);
                  if (form) {
                    const el1 = form.querySelector(`[name="bucket_label_${k}"]`);
                    const el2 = form.querySelector(`[name="bucket_${k}"]`);
                    if (el1) el1.value = v;
                    if (el2) el2.value = v;
                  }
                  const tr = document.querySelector(`#marginsTable tr[data-b="${k}"] > td:first-child`);
                  if (tr) tr.textContent = v;
                  ['cardPAYE','cardUMB','cardCHG'].forEach(cid=>{
                    const card = document.getElementById(cid);
                    const inp = card?.querySelector(`input[name$="_${k}"]`);
                    if (card && inp) { const row = inp.closest('.row'); if (row) { const lab=row.querySelector('label'); if (lab) lab.textContent=v; } }
                  });
                });
              } catch {}

              // Clear schedule grid and stage std_schedule_json=null
              try {
                const days = ['mon','tue','wed','thu','fri','sat','sun'];
                days.forEach(d=>{
                  const s = document.querySelector(`input[name="${d}_start"]`);
                  const e = document.querySelector(`input[name="${d}_end"]`);
                  const b = document.querySelector(`input[name="${d}_break"]`);
                  if (s) s.value = '';
                  if (e) e.value = '';
                  if (b) b.value = '';
                });
                const fs = (window.modalCtx.formState ||= { main:{}, pay:{} });
                fs.main.__template = null;
              } catch {}

              // Clear role/band/display_site
              try {
                const fs = (window.modalCtx.formState ||= { main:{}, pay:{} }).main ||= {};
                fs.role = ''; fs.band = ''; fs.display_site = '';
                const form = document.querySelector('#contractForm');
                if (form) {
                  const r=form.querySelector('[name="role"]'); if (r) r.value='';
                  const b=form.querySelector('[name="band"]'); if (b) b.value='';
                  const s=form.querySelector('[name="display_site"]'); if (s) s.value='';
                }
              } catch {}

              // Clear chip & recompute margins
              try { const chip=document.getElementById('presetChip'); if (chip) { chip.style.display='none'; chip.textContent=''; } } catch {}
              try { computeContractMargins(); } catch {}
              try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
            });
          }


        }

       };

  setTimeout(() => {
        const fr = window.__getModalFrame?.();
        const prevDirty = fr?.isDirty;
        if (fr) fr._suppressDirty = true;

        wire();

        if (fr) {
          fr._suppressDirty = false;
          fr.isDirty = prevDirty;
          fr._updateButtons && fr._updateButtons();
        }
      }, 0);
      if (!window.__contractsWireBound) {
        window.__contractsWireBound = true;

        const rewire = () => {
          const fr = window.__getModalFrame?.();
          const prevDirty = fr?.isDirty;
          if (fr) fr._suppressDirty = true;

          setTimeout(() => {
            wire();
            if (fr) {
              fr._suppressDirty = false;
              fr.isDirty = prevDirty;
              fr._updateButtons && fr._updateButtons();
            }
          }, 0);
        };

        window.addEventListener('contracts-main-rendered', rewire);
        window.addEventListener('contracts-rates-rendered', rewire);
      }

 // Re-wire when the user clicks between Main / Rates / Calendar
      const tabsEl = document.getElementById('modalTabs');
      if (tabsEl && !tabsEl.__wired_contract_stage) {
        tabsEl.__wired_contract_stage = true;
        tabsEl.addEventListener('click', () => {
          const fr = window.__getModalFrame?.();
          const prevDirty = fr?.isDirty;
          if (fr) fr._suppressDirty = true;

          snapshotContractForm();
          setTimeout(() => {
            wire();
            if (fr) {
              fr._suppressDirty = false;
              fr.isDirty = prevDirty;
              fr._updateButtons && fr._updateButtons();
            }
          }, 0);
        });
      }

    },


    // 7th: options (now with noParentGate)
    {
      kind: 'contracts',
      extraButtons,
      noParentGate: !!isSuccessorCreate,
      stayOpenOnSave: !!isSuccessorCreate,
      _trace: (LOGC && {
        tag: 'contracts-open',
        isCreate,
        isSuccessorCreate,
        openToken: window.modalCtx.openToken
      })
    }
  );
   setTimeout(() => {
    try {
      const fr = window.__getModalFrame?.();
      if (fr && (fr.entity === 'contracts' || fr.kind === 'contracts') && typeof fr.onReturn === 'function' && !fr.__contractsInit) {
        fr.__contractsInit = true;
        fr.onReturn();
        if (LOGC) console.log('[CONTRACTS] initial onReturn() executed');
      } else if (LOGC) {
        console.log('[CONTRACTS] onReturn not executed', {
          hasFrame: !!fr, entity: fr?.entity, kind: fr?.kind, hasOnReturn: typeof fr?.onReturn === 'function', init: !!fr?.__contractsInit
        });
      }

      // ðŸ”¹ After wiring, surface any pay-method mismatch warnings returned by backend
      try {
        const baseData = (window.modalCtx && window.modalCtx.data)
          ? window.modalCtx.data
          : (row || {});
        const warnings = Array.isArray(baseData.warnings) ? baseData.warnings : [];
        if (warnings.length && typeof showModalHint === 'function') {
          showModalHint(warnings.join(' '), 'warn');
        }
      } catch (warnErr) {
        if (LOGC) console.warn('[CONTRACTS] show pay-method warnings failed', warnErr);
      }

    } catch (e) {
      if (LOGC) console.warn('[CONTRACTS] initial onReturn failed', e);
    } finally {
      if (LOGC) console.log('[CONTRACTS] openContract EXIT');
    }
  }, 0);
}



// ============================================================================
// CANDIDATE â€“ RENDER CALENDAR TAB
// ============================================================================

async function fetchAndRenderContractCalendar(contractId, opts) {
  const LOG_CAL = (typeof window.__LOG_CAL === 'boolean') ? window.__LOG_CAL : true;
  const L = (...a)=> { if (LOG_CAL) console.log('[CAL][contract]', ...a); };

  const state = (window.__calState[contractId] ||= {
    view: 'year',
    win: computeYearWindow((new Date()).getUTCFullYear()),
    weekEndingWeekday: (window.modalCtx?.data?.week_ending_weekday_snapshot ?? 0),
    scrollTop: 0,
    scrollLeft: 0
  });

  // âœ… Treat explicit opts as authoritative (do not reset to defaults)
  if (opts?.view) state.view = opts.view;
  if (opts?.from && opts?.to) state.win = { from: opts.from, to: opts.to };
  if (typeof opts?.weekEnding !== 'undefined') state.weekEndingWeekday = Number(opts.weekEnding);

  const holder = byId('contractCalendarHolder'); if (!holder) return;
  const scrollBox0 = byId('__calScroll') || holder;

  // Capture scroll BEFORE repaint (unless caller explicitly provides restore)
  if (opts?.__restoreScroll && typeof opts.__restoreScroll === 'object') {
    state.scrollTop  = Number(opts.__restoreScroll.top  || 0);
    state.scrollLeft = Number(opts.__restoreScroll.left || 0);
  } else {
    state.scrollTop  = scrollBox0.scrollTop  || 0;
    state.scrollLeft = scrollBox0.scrollLeft || 0;
  }

  const candidateId = window.modalCtx?.data?.candidate_id || window.modalCtx?.formState?.main?.candidate_id || null;

  let candidateItems = [];
  try {
    if (candidateId && typeof getCandidateCalendarRange === 'function') {
      const resp = await getCandidateCalendarRange(candidateId, state.win.from, state.win.to, 'day');
      candidateItems = Array.isArray(resp?.items) ? resp.items : [];
    }
  } catch (e) {
    L('getCandidateCalendarRange failed', e);
    candidateItems = [];
  }

  const itemsByDate = buildDateIndex(candidateItems);

  const dayResp = await getContractCalendarRange(contractId, state.win.from, state.win.to, 'day');
  const dayItems = Array.isArray(dayResp?.items) ? dayResp.items : [];
  for (const it of dayItems) {
    const d = it?.date; if (!d) continue;
    const arr = itemsByDate.get(d) || [];
    if (it && !it.contract_id) it.contract_id = contractId;
    arr.push(it);
    itemsByDate.set(d, arr);
  }

  const bufFrom = addDays(state.win.from, -7);
  const bufTo   = addDays(state.win.to,   +7);
  const weeksForIndex = (await getContractCalendar(contractId, { from: bufFrom, to: bufTo, granularity:'week' })).items || [];
  const weekIndex = buildWeekIndex(weeksForIndex);

  const overlayedMap = applyStagedContractCalendarOverlay(contractId, itemsByDate, weekIndex);

  const gridHost = document.createElement('div'); gridHost.id = 'contractDayGrid';
  const container = byId('__contractCal') || holder;
  if (container === holder) holder.innerHTML = '';
  container.innerHTML = '';
  container.appendChild(gridHost);

  renderDayGrid(gridHost, {
    from: state.win.from,
    to: state.win.to,
    itemsByDate: overlayedMap,
    view: state.view,
    bucketKey: `c:${contractId}`,
    isInteractive: !!window.__calInteractive,
    onNav: async (delta) => {
      if (state.view === 'year') {
        const y = ymdToDate(state.win.from).getUTCFullYear() + delta;
        const nextWin = computeYearWindow(y);
        await fetchAndRenderContractCalendar(contractId, {
          from: nextWin.from, to: nextWin.to, view: 'year',
          weekEnding: state.weekEndingWeekday,
          __restoreScroll: { top: state.scrollTop, left: state.scrollLeft }
        });
      } else {
        const nextWin = stepMonth(state.win, delta);
        await fetchAndRenderContractCalendar(contractId, {
          from: nextWin.from, to: nextWin.to, view: 'month',
          weekEnding: state.weekEndingWeekday,
          __restoreScroll: { top: state.scrollTop, left: state.scrollLeft }
        });
      }
    },
    onToggleView: async () => {
      const newView = (state.view === 'year') ? 'month' : 'year';
      let win = state.win;
      if (newView === 'year') {
        const y = ymdToDate(state.win.from).getUTCFullYear();
        win = computeYearWindow(y);
      } else {
        const dt = ymdToDate(state.win.from);
        win = computeMonthWindow(dt.getUTCFullYear(), dt.getUTCMonth());
      }
      await fetchAndRenderContractCalendar(contractId, {
        from: win.from, to: win.to, view: newView,
        weekEnding: state.weekEndingWeekday,
        __restoreScroll: { top: state.scrollTop, left: state.scrollLeft }
      });
    },
    onCellContextMenu: (theDate, ev) => {
      if (!window.__calInteractive) return;
      const sel = initSelBucket(`c:${contractId}`).set; const selArr = [...sel];

      const ownedByCurrent = (d) => {
        const arr = itemsByDate.get(d) || [];
        return arr.some(it => String(it.contract_id || '') === String(contractId));
      };
      const occupiedByOtherOnly = (d) => {
        const arr = itemsByDate.get(d) || [];
        return arr.some(it => {
          const cid = String(it.contract_id || '');
          return cid && cid !== String(contractId);
        }) && !ownedByCurrent(d);
      };
      const anyGrey = selArr.some(occupiedByOtherOnly);

      const resolveFinalState = (d) => topState(overlayedMap.get(d) || []);

      const eligibleUnbook = (d) => {
        if (!ownedByCurrent(d)) return false;
        const we = computeWeekEnding(d, state.weekEndingWeekday);
        const w = weekIndex.get(we);
        const st = resolveFinalState(d);
        return st === 'PLANNED' && w && !w.baseHasTs;
      };
      const anyEligible = selArr.some(eligibleUnbook);
      const allEligible = selArr.every(eligibleUnbook);
      const blockMode = isConsecutiveDailyRun(selArr);

      const canBook = selArr.every(d => !ownedByCurrent(d));
      const canUnbook = blockMode ? anyEligible : allEligible;

      const canAddAdditional = selArr.some(d => {
        const st = resolveFinalState(d);
        const we = computeWeekEnding(d, state.weekEndingWeekday);
        const w = weekIndex.get(we);
        return st === 'EMPTY' && w && w.baseHasTs && w.baseWeekId;
      });

      openCalendarContextMenu({
        anchorEl: ev.target,
        bucketKey: `c:${contractId}`,
        selection: selArr,
        capabilities: { canBook, canUnbook, canAddAdditional },
        onAction: async ({ type, selection }) => {
          try {
            if (type === 'book') {
              if (anyGrey) {
                if (!window.confirm('This would clash with an existing contract on some selected dates. Continue?')) return;
              }
              stageContractCalendarBookings(contractId, selection);
            }
            if (type === 'unbook') {
              const toUnbook = selection.filter(eligibleUnbook);
              if (toUnbook.length) stageContractCalendarUnbookings(contractId, toUnbook);
            }
            if (type === 'additional') {
              const byBase = {};
              for (const d of selection) {
                const we = computeWeekEnding(d, state.weekEndingWeekday);
                const wi = weekIndex.get(we);
                if (!wi || !wi.baseWeekId || !wi.baseHasTs) continue;
                (byBase[wi.baseWeekId] ||= []).push(d);
              }
              for (const [baseWeekId, dates] of Object.entries(byBase)) {
                stageContractCalendarAdditional(contractId, baseWeekId, dates);
              }
            }

            try { window.dispatchEvent(new Event('modal-dirty')); } catch {}

            const prevTop  = (byId('__calScroll') || holder).scrollTop  || 0;
            const prevLeft = (byId('__calScroll') || holder).scrollLeft || 0;

            await fetchAndRenderContractCalendar(contractId, {
              from: state.win.from, to: state.win.to, view: state.view,
              weekEnding: state.weekEndingWeekday,
              __restoreScroll: { top: prevTop, left: prevLeft }
            });

          } catch (e) {
            alert(e?.message || e);
          }
        }
      });
    }
  });

  // âœ… Restore scroll AFTER layout settles
  const applyScroll = () => {
    const sb = byId('__calScroll') || holder;
    sb.scrollTop  = state.scrollTop  || 0;
    sb.scrollLeft = state.scrollLeft || 0;
  };
  requestAnimationFrame(() => requestAnimationFrame(applyScroll));
}





async function renderCandidateCalendarTab(candidateId) {
  const holderId = 'candidateCalendarHolder';
  const host = byId(holderId);
  if (!host) return;

  // Compute initial window (year view)
  const y = (new Date()).getUTCFullYear();
  const win = (typeof computeYearWindow === 'function')
    ? computeYearWindow(y)
    : { from: `${y}-01-01`, to: `${y}-12-31` };

  // Build inner scaffold: contracts list + scroll box + grid mount + legend
  host.innerHTML = `
    <div class="tabc" style="display:flex;flex-direction:column;gap:8px;height:calc(72vh);max-height:calc(72vh)">
      <div id="__candCalContracts" style="flex:0 0 auto;border:1px solid var(--line,#e5e5e5);border-radius:8px;padding:8px;"></div>

      <div id="__candCalScroll" style="flex:1;min-height:0;overflow:auto;border:1px solid var(--line,#e5e5e5);border-radius:8px;padding:4px;">
        <div id="__candCal"></div>
      </div>

      <div id="__candCalLegend"></div>
    </div>
  `;

  // Render legend (always overwrite)
  const legendHost = byId('__candCalLegend');
  if (legendHost && typeof renderCalendarLegend === 'function') {
    renderCalendarLegend(legendHost);
  }

  // Draw initial window
  await fetchAndRenderCandidateCalendar(candidateId, { from: win.from, to: win.to, view: 'year' });
}

async function fetchAndRenderCandidateCalendar(candidateId, opts) {
  const LOG_CAL = (typeof window.__LOG_CAL === 'boolean') ? window.__LOG_CAL : true;
  const L = (...a)=> { if (LOG_CAL) console.log('[CAL][candidate]', ...a); };

  window.__calState = window.__calState || {};

  const key = `cand:${candidateId}`;

  // Persist per-view state (candidate-wide)
  const state = (window.__calState[key] ||= {
    view: (opts && typeof opts.view === 'string') ? opts.view : 'year',
    win:  (opts && opts.from && opts.to)
            ? { from: opts.from, to: opts.to }
            : (typeof computeYearWindow === 'function'
                ? computeYearWindow((new Date()).getUTCFullYear())
                : { from: `${(new Date()).getFullYear()}-01-01`, to: `${(new Date()).getFullYear()}-12-31` }),
    scrollTop: 0,

    // NEW:
    filterContractId: null,
    last: null // { items:[], contracts:[] } cache for filter toggles
  });

  // Allow caller to change view/window
  if (opts && typeof opts.view === 'string') state.view = opts.view;
  if (opts && opts.from && opts.to) state.win = { from: opts.from, to: opts.to };

  const holder = byId('candidateCalendarHolder');
  if (!holder) return;

  const scrollBox = byId('__candCalScroll') || holder;

  // Remember scroll
  try { state.scrollTop = (typeof scrollBox.scrollTop === 'number') ? scrollBox.scrollTop : 0; } catch {}

  // Fetch candidate-wide day feed + contract list
  let items = [];
  let contracts = [];

  const reuse = !!(opts && opts._reuseLast);
  if (reuse && state.last) {
    items = Array.isArray(state.last.items) ? state.last.items : [];
    contracts = Array.isArray(state.last.contracts) ? state.last.contracts : [];
  } else {
    try {
      const r = await getCandidateCalendarRange(candidateId, state.win.from, state.win.to, 'day');
      items = Array.isArray(r?.items) ? r.items : [];
      contracts = Array.isArray(r?.contracts) ? r.contracts : [];
      state.last = { items, contracts };
    } catch (e) {
      L('candidate calendar fetch failed', e);
      items = [];
      contracts = [];
      state.last = { items, contracts };
    }
  }

  // Build date index: date â†’ [items]
  const itemsByDate = (typeof buildDateIndex === 'function')
    ? buildDateIndex(items)
    : (() => {
        const m = new Map();
        for (const it of items) {
          if (!it?.date) continue;
          const arr = m.get(it.date) || [];
          arr.push(it);
          m.set(it.date, arr);
        }
        return m;
      })();

  // Build contractMap for the list: Map(contract_id -> {client_name,role,band,from,to,...})
  const contractMap = new Map();
  for (const c of (contracts || [])) {
    const cid = c?.contract_id || c?.id;
    if (!cid) continue;
    contractMap.set(String(cid), c);
  }

  // Render contract list + filter handlers
  const contractsHost = byId('__candCalContracts');
  if (contractsHost && typeof renderCandidateContractList === 'function') {
    renderCandidateContractList(contractsHost, contractMap, {
      onClick: async (cid) => {
        state.filterContractId = String(cid || '');
        await fetchAndRenderCandidateCalendar(candidateId, { from: state.win.from, to: state.win.to, view: state.view, _reuseLast: true });
      },
      onDblClick: (cid) => {
        // Open contract modal (id-only row is fine)
        try {
          if (typeof openContract === 'function') openContract({ id: String(cid) });
        } catch (e) {
          console.warn('[CAL][candidate] openContract failed', e);
        }
      },
      onClear: async () => {
        state.filterContractId = null;
        await fetchAndRenderCandidateCalendar(candidateId, { from: state.win.from, to: state.win.to, view: state.view, _reuseLast: true });
      }
    });
  } else if (contractsHost) {
    // Minimal fallback if renderCandidateContractList is missing
    contractsHost.innerHTML = `<div class="hint">Contracts list renderer not available.</div>`;
  }

  // Render grid (read-only)
  const gridHost = byId('__candCal') || (() => {
    const d = document.createElement('div'); d.id = '__candCal'; holder.appendChild(d); return d;
  })();
  gridHost.innerHTML = '';

  if (typeof renderDayGrid !== 'function') {
    gridHost.innerHTML = `<div class="hint">Calendar renderer not available.</div>`;
    return;
  }

  // IMPORTANT:
  // - unfiltered candidate view: bucketKey stays "cand:<id>" (no greying)
  // - filtered candidate view: bucketKey becomes "c:<contractId>" (contract-centric + greying)
  const bucketKey = state.filterContractId ? `c:${state.filterContractId}` : key;

  renderDayGrid(gridHost, {
    from: state.win.from,
    to:   state.win.to,
    itemsByDate,
    view: state.view,
    bucketKey,                // drives contract-centric behaviour when filtered
    isInteractive: false,      // candidate view is read-only
    onNav: async (delta) => {
      if (state.view === 'year') {
        const y = (new Date(state.win.from)).getUTCFullYear() + delta;
        const nextWin = (typeof computeYearWindow === 'function')
          ? computeYearWindow(y)
          : { from: `${y}-01-01`, to: `${y}-12-31` };
        await fetchAndRenderCandidateCalendar(candidateId, { from: nextWin.from, to: nextWin.to, view: 'year' });
      } else {
        const nextWin = (typeof stepMonth === 'function')
          ? stepMonth(state.win, delta)
          : (function () {
              const d = new Date(state.win.from);
              d.setUTCMonth(d.getUTCMonth() + delta, 1);
              const y = d.getUTCFullYear(), m = d.getUTCMonth();
              return (typeof computeMonthWindow === 'function')
                ? computeMonthWindow(y, m)
                : { from: `${y}-${String(m+1).padStart(2,'0')}-01`, to: `${y}-${String(m+1).padStart(2,'0')}-28` };
            })();
        await fetchAndRenderCandidateCalendar(candidateId, { from: nextWin.from, to: nextWin.to, view: 'month' });
      }
    },
    onToggleView: async () => {
      const newView = (state.view === 'year') ? 'month' : 'year';
      let nextWin;
      if (newView === 'year') {
        const y = (new Date(state.win.from)).getUTCFullYear();
        nextWin = (typeof computeYearWindow === 'function')
          ? computeYearWindow(y)
          : { from: `${y}-01-01`, to: `${y}-12-31` };
      } else {
        const d = new Date(state.win.from);
        const y = d.getUTCFullYear(), m = d.getUTCMonth();
        nextWin = (typeof computeMonthWindow === 'function')
          ? computeMonthWindow(y, m)
          : { from: `${y}-${String(m+1).padStart(2,'0')}-01`, to: `${y}-${String(m+1).padStart(2,'0')}-28` };
      }
      await fetchAndRenderCandidateCalendar(candidateId, { from: nextWin.from, to: nextWin.to, view: newView });
    }
  });

  // Restore scroll
  try { if (typeof scrollBox.scrollTop === 'number') scrollBox.scrollTop = state.scrollTop; } catch {}
}



function renderCandidateContractList(container, contractMap, handlers) {
  container.innerHTML = '';
  const title = document.createElement('div'); title.className='hint'; title.textContent='Contracts in view:'; container.appendChild(title);

  const list = document.createElement('div'); list.className='list';
  contractMap.forEach((v, cid) => {
    const row = document.createElement('div'); row.className='row item'; row.tabIndex = 0;
    row.innerHTML = `
      <span class="txt">${(v.client_name || 'Client')} â€¢ ${(v.role||'Role')}${v.band?` â€¢ ${v.band}`:''} â€¢ ${v.from} â†’ ${v.to}</span>
      <span class="act"><button data-act="filter">Show only</button> <button data-act="open">Open</button></span>`;
    row.querySelector('[data-act="filter"]')?.addEventListener('click', () => handlers.onClick && handlers.onClick(cid));
    row.querySelector('[data-act="open"]')?.addEventListener('click', () => handlers.onDblClick && handlers.onDblClick(cid));
    row.addEventListener('dblclick', () => handlers.onDblClick && handlers.onDblClick(cid));
    list.appendChild(row);
  });
  container.appendChild(list);

  if (!contractMap.size) {
    const none = document.createElement('div'); none.className='hint'; none.textContent='No contracts in this window.'; container.appendChild(none);
  }

  const clear = document.createElement('div'); clear.className='actions';
  clear.innerHTML = `<button id="candClearFilter">Clear filter</button>`; container.appendChild(clear);
  clear.querySelector('#candClearFilter')?.addEventListener('click', () => handlers.onClear && handlers.onClear());
}


// =================== MOUNT CLIENT RATES TAB (unchanged glue) ===================
async function mountClientRatesTab() {
  const LOG_RATES = !!window.__LOG_RATES;
  const DBG = (...a)=> { if (LOG_RATES) console.log('[RATES][mountClientRatesTab]', ...a); };

  const ctx = window.modalCtx; // use canonical context
  DBG('ENTRY', { ctxEntity: ctx?.entity, ctxId: ctx?.data?.id });

  // render uses ctx.ratesState directly; no args needed
  try { await renderClientRatesTable(); DBG('renderClientRatesTable done'); } catch (e) { DBG('renderClientRatesTable error', e); }

  // Always resolve a real client id before opening the modal
  const btn = byId('btnAddClientRate');
  if (btn) {
    btn.onclick = () => {
      const cid = (ctx && ctx.data && (ctx.data.id || ctx.data.client_id)) || null;
      DBG('openClientRateModal from button', { cid });
      return openClientRateModal(cid);
    };
    DBG('wired btnAddClientRate');
  } else {
    DBG('btnAddClientRate not present');
  }
}



// =================== MOUNT HOSPITALS TAB (unchanged glue) ===================
function mountClientHospitalsTab() {
  const ctx = window.modalCtx; // ðŸ”§ use canonical context
  const H = ctx.hospitalsState || (ctx.hospitalsState = { existing: [], stagedNew: [], stagedEdits: {}, stagedDeletes: new Set() });

  // â¬‡ï¸ Key change: normalise stagedDeletes as a Set on mount (handles JSON-cloned arrays)
  if (!(H.stagedDeletes instanceof Set)) {
    H.stagedDeletes = new Set(Array.isArray(H.stagedDeletes) ? H.stagedDeletes : Object.keys(H.stagedDeletes || {}));
  }

  renderClientHospitalsTable();

  const addBtn = byId('btnAddClientHospital');
  if (addBtn) addBtn.onclick = () => openClientHospitalModal(ctx.data?.id);

  const wrap = byId('clientHospitals');
  if (wrap && !wrap.__wiredDelete) {
    wrap.addEventListener('click', (ev) => {
      const t = ev.target;
      const el = t && (t.closest('[data-action="delete"]') || t.closest('.btnDelHospital'));
      if (!el) return;

      const hid = el.getAttribute('data-hid') || el.getAttribute('data-id');
      if (!hid) return;

      // â¬‡ï¸ Ensure Set semantics before use
      if (!(H.stagedDeletes instanceof Set)) {
        H.stagedDeletes = new Set(Array.isArray(H.stagedDeletes) ? H.stagedDeletes : Object.keys(H.stagedDeletes || {}));
      }
      H.stagedDeletes.add(String(hid));

      try { window.dispatchEvent(new CustomEvent('modal-dirty')); } catch {}
      renderClientHospitalsTable();
    }, true);
    wrap.__wiredDelete = true;
  }
}


async function openClientRateModal(client_id, existing) {
  const parentFrame = _currentFrame();
  const parentEditable = parentFrame && (parentFrame.mode === 'edit' || parentFrame.mode === 'create');
  const APILOG = (typeof window !== 'undefined' && !!window.__LOG_API) || (typeof __LOG_API !== 'undefined' && !!__LOG_API);
  const LOG_RATES = !!window.__LOG_RATES;
  const DBG = (...a)=> { if (LOG_RATES) console.log('[RATES][openClientRateModal]', ...a); };

  const ctx = window.modalCtx || {};
  const resolvedClientId =
    client_id ||
    (existing && existing.client_id) ||
    (ctx && ctx.data && (ctx.data.id || ctx.data.client_id)) ||
    null;

  if (APILOG) console.log('[openClientRateModal] resolvedClientId', resolvedClientId, { passed: client_id, existing });
  DBG('ENTRY', { parentEditable, hasExisting: !!existing, resolvedClientId, ctxEntity: ctx?.entity, ctxId: ctx?.data?.id });

  const globalRoles = await loadGlobalRoleOptions();
  const roleOptions = globalRoles.map(r => `<option value="${r}">${r}</option>`).join('') + `<option value="__OTHER__">+ Add new roleâ€¦</option>`;
  DBG('loaded role options', { count: globalRoles.length });

  const ex  = existing || {};
  const who = ex.disabled_by_name || '';
  const when = ex.disabled_at_utc ? formatIsoToUk(String(ex.disabled_at_utc).slice(0,10)) : '';
  const isDisabled = !!ex.disabled_at_utc;
  DBG('existing status', { isDisabled, who, when, id: ex.id });

  const statusBlock = `
    <div class="row" id="cl_status_row" style="align-items:center; gap:8px;">
      <div>
        ${isDisabled ? `
          <span class="pill tag-fail" id="cl_status_pill">âŒ Disabled</span>
          <div class="hint" id="cl_status_meta">${who ? `by ${escapeHtml(who)}` : ''} ${when ? `on ${escapeHtml(when)}` : ''}</div>`
      : `
          <span class="pill tag-ok" id="cl_status_pill">âœ“ Active</span>
          <div class="hint" id="cl_status_meta">&nbsp;</div>`}
      </div>
      ${parentEditable && ex.id ? `<div><button id="cl_toggle_btn" class="btn btn-outline btn-sm">${isDisabled ? 'Enable' : 'Disable'}</button></div>` : ''}
    </div>`;

  function sameRow(a, b) {
    const eq = !!(a && b && ((a === b) || (a.id && b.id && String(a.id) === String(b.id)) || (a.__localKey && b.__localKey && String(a.__localKey) === String(b.__localKey))));
    if (LOG_RATES) console.log('[RATES][sameRow]', { aId:a?.id, bId:b?.id, aKey:a?.__localKey, bKey:b?.__localKey, eq });
    return eq;
  }

  // INLINE panel for client-rate warnings/fixes
  const formHtml = html(`
    <div class="form" id="clientRateForm">
      ${statusBlock}
      <div class="row">
        <label>Role (required)</label>
        <select name="role" id="cl_role" required ${parentEditable ? '' : 'disabled'}>
          <option value="">Select roleâ€¦</option>
          ${roleOptions}
        </select>
      </div>
      <div class="row" id="cl_role_new_row" style="display:none">
        <label>New role code</label>
        <input type="text" id="cl_role_new" placeholder="e.g. RMN-Lead" ${parentEditable ? '' : 'disabled'} />
        <div class="hint">Uppercase letters/numbers/[-_/ ] recommended.</div>
      </div>
      <div class="row"><label>VBR5809: Band (optional)</label>
        <input type="text" name="band" id="cl_band" value="${ex.band ?? ''}" ${parentEditable ? '' : 'disabled'} />
      </div>
      <div class="row"><label>Effective from (DD/MM/YYYY)</label>
        <input type="text" name="date_from" id="cl_date_from" placeholder="DD/MM/YYYY" ${parentEditable ? '' : 'disabled'} />
      </div>
      <div class="row"><label>Effective to (optional, DD/MM/YYYY)</label>
        <input type="text" name="date_to" id="cl_date_to" placeholder="DD/MM/YYYY" ${parentEditable ? '' : 'disabled'} />
      </div>
      <div class="row" style="grid-column: 1 / -1">
        <table class="grid" style="width:100%;border-collapse:collapse">
          <thead><tr><th>Bucket</th><th>PAYE pay</th><th>Umbrella pay</th><th>Charge</th></tr></thead>
          <tbody>
            ${['day','night','sat','sun','bh'].map(b => `
              <tr>
                <td style="white-space:nowrap">${b.toUpperCase()}</td>
                <td><input type="number" step="0.01" name="paye_${b}" ${parentEditable ? '' : 'disabled'} /></td>
                <td><input type="number" step="0.01" name="umb_${b}"  ${parentEditable ? '' : 'disabled'} /></td>
                <td><input type="number" step="0.01" name="charge_${b}" ${parentEditable ? '' : 'disabled'} /></td>
              </tr>`).join('')}
          </tbody>
        </table>
      </div>
      <div class="row" style="grid-column:1 / -1; margin-top:10px">
        <table class="grid" id="cl_margins_tbl" style="width:100%">
          <thead><tr><th>Bucket</th><th>PAYE margin</th><th>Umbrella margin</th></tr></thead>
          <tbody>
            ${['day','night','sat','sun','bh'].map(b=>`
              <tr><td>${b.toUpperCase()}</td><td><span id="m_paye_${b}">â€”</span></td><td><span id="m_umb_${b}">â€”</span></td></tr>`).join('')}
          </tbody>
        </table>
        <div class="hint" id="cl_delete_hint" style="display:none;margin-top:6px"></div>
      </div>

      <div id="cl_err_panel" style="grid-column:1/-1; margin-top:10px; display:none; border:1px solid #7f1d1d; background:rgba(239,68,68,.08); color:#fecaca; padding:10px; border-radius:8px"></div>
    </div>
  `);

    // ERNI
  // UPDATED:
  // - getSettingsCached() returns { settings, finance_windows }
  // - ERNI is selected by date:
  //     ongoing (date_to empty or date_to >= today) -> today
  //     finished (date_to < today) -> date_from
  async function _erniMultiplier(fromIso, toIso){
    // Today (Europe/London)
    const todayIso = (() => {
      try {
        const s = new Intl.DateTimeFormat('en-GB', {
          timeZone: 'Europe/London',
          year:'numeric', month:'2-digit', day:'2-digit'
        }).format(new Date());
        const [dd, mm, yyyy] = s.split('/');
        return `${yyyy}-${mm}-${dd}`;
      } catch {
        const d = new Date(); const y = d.getFullYear(), m = String(d.getMonth()+1).padStart(2,'0'), day = String(d.getDate()).padStart(2,'0');
        return `${y}-${m}-${day}`;
      }
    })();

    const asYmd = (v) => {
      if (!v) return null;
      const ss = String(v).slice(0, 10);
      return /^\d{4}-\d{2}-\d{2}$/.test(ss) ? ss : null;
    };

    const fIso = asYmd(fromIso) || null;
    const tIso = asYmd(toIso)   || null;

    // Rule: finished -> start date, else today
    const finished = !!(tIso && tIso < todayIso);
    const anchorYmd = (finished && fIso) ? fIso : todayIso;

    // Cache by anchor date (prevents repeated lookups while typing)
    window.__ERNI_MULT_BY_DATE__ = window.__ERNI_MULT_BY_DATE__ || Object.create(null);
    if (typeof window.__ERNI_MULT_BY_DATE__[anchorYmd] === 'number' && window.__ERNI_MULT_BY_DATE__[anchorYmd] > 0) {
      window.__ERNI_MULT__ = window.__ERNI_MULT_BY_DATE__[anchorYmd]; // keep legacy cache aligned
      return window.__ERNI_MULT_BY_DATE__[anchorYmd];
    }

    try {
      if (typeof getSettingsCached === 'function') {
        const s = await getSettingsCached();

        // New shape: { settings: {...}, finance_windows: [...] }
        const fws = Array.isArray(s?.finance_windows) ? s.finance_windows : [];

        // Pick finance window in-scope for anchorYmd (prefer latest date_from)
        let chosen = null;
        for (const w of fws) {
          const df = asYmd(w?.date_from);
          const dt = asYmd(w?.date_to);
          if (!df) continue;
          if (df > anchorYmd) continue;
          if (dt && dt < anchorYmd) continue;

          if (!chosen) {
            chosen = w;
          } else {
            const cdf = asYmd(chosen?.date_from);
            if (cdf && df > cdf) chosen = w;
          }
        }

        // ERNI pct from finance window (preferred), else legacy fallbacks
        let p = chosen?.erni_pct ?? null;
        if (p == null) p = s?.settings?.erni_pct ?? null;
        if (p == null) p = s?.erni_pct ?? null;
        if (p == null) p = s?.employers_ni_percent ?? null;
        if (p == null) p = 0;

        p = Number(p) || 0;
        if (p > 1) p = p/100;

        let mult = 1 + p;
        if (!Number.isFinite(mult) || mult <= 0) mult = 1;

        window.__ERNI_MULT_BY_DATE__[anchorYmd] = mult;
        window.__ERNI_MULT__ = mult;

        return mult;
      }
    } catch {}

    window.__ERNI_MULT_BY_DATE__[anchorYmd] = 1;
    window.__ERNI_MULT__ = 1;
    return 1;
  }


  function setApplyEnabled(enabled){
    if (LOG_RATES) console.log('[RATES][setApplyEnabled]', { enabled });
    try {
      const btn = document.querySelector('#modal .btn-save, #modal .actions .primary, #modal .actions .btn-primary, .modal .btn-save');
      if (btn) { btn.disabled = !enabled; btn.classList.toggle('disabled', !enabled); }
    } catch (e) { if (LOG_RATES) console.warn('[RATES][setApplyEnabled] button toggle failed', e); }
    // Inform parent showModal so child Save can proceed
    try { window.dispatchEvent(new CustomEvent('modal-apply-enabled', { detail: { enabled } })); } catch (e) { if (LOG_RATES) console.warn('[RATES][setApplyEnabled] dispatch failed', e); }
  }
  const numOrNull = v => { if (v===undefined||v===null) return null; if (typeof v === 'string' && v.trim()==='') return null; const n=Number(v); return Number.isFinite(n) ? n : null; };
  const fmt = v => (v==null || Number.isNaN(v)) ? 'â€”' : (Math.round(v*100)/100).toFixed(2);

  function showClientInlineError(html){
    const p = byId('cl_err_panel');
    if (!p) return;
    if (html && String(html).trim() !== '') {
      p.innerHTML = html;
      p.style.display = '';
    } else {
      p.innerHTML = '';
      p.style.display = 'none';
    }
  }
  function isoMinusOneDay(iso){
    if (!iso) return null;
    const d = new Date(iso + 'T00:00:00Z');
    d.setUTCDate(d.getUTCDate() - 1);
    const y = d.getUTCFullYear();
    const m = String(d.getUTCMonth()+1).padStart(2,'0');
    const dd= String(d.getUTCDate()).padStart(2,'0');
    return `${y}-${m}-${dd}`;
  }
  function rangesOverlap(a0,a1,b0,b1){
    const A0 = a0 || '0000-01-01', A1 = a1 || '9999-12-31';
    const B0 = b0 || '0000-01-01', B1 = b1 || '9999-12-31';
    return !(A1 < B0 || B1 < A0);
  }

  // Gate inputs + margins + Apply + overlap inline fixes
   // Gate inputs + margins + Apply + overlap inline fixes
  async function recomputeClientState(){
    const roleVal = (byId('cl_role')?.value || '').trim();
    const fromIso = parseUkDateToIso(byId('cl_date_from')?.value || '');
    const toIso   = parseUkDateToIso(byId('cl_date_to')?.value || '');

    const mult = await _erniMultiplier(fromIso, toIso);


    DBG('recomputeClientState: ENTRY', { roleVal, fromIso, toIso, exId: ex?.id });

    const getIn = sel => document.querySelector(sel);
    const payeInputs = ['day','night','sat','sun','bh'].map(b => getIn(`#clientRateForm input[name="paye_${b}"]`));
    const umbInputs  = ['day','night','sat','sun','bh'].map(b => getIn(`#clientRateForm input[name="umb_${b}"]`));
    const chgInputs  = ['day','night','sat','sun','bh'].map(b => getIn(`#clientRateForm input[name="charge_${b}"]`));
    const allInputs  = [...payeInputs, ...umbInputs, ...chgInputs].filter(Boolean);

    let canApply = true;
    showClientInlineError('');

    if (!roleVal || !fromIso) {
      DBG('recomputeClientState: NOT_READY', { roleVal, fromIso });
      allInputs.forEach(inp => { inp.disabled = true; });
      // clear preview
      ['day','night','sat','sun','bh'].forEach(b=>{
        const spP = byId(`m_paye_${b}`), spU = byId(`m_umb_${b}`);
        if (spP) spP.textContent = 'â€”';
        if (spU) spU.textContent = 'â€”';
      });
      setApplyEnabled(false);
      return;
    }

    // keep inputs enabled
    allInputs.forEach(inp => { inp.disabled = true === false; });

    // Compute & render margins preview (2dp), while validating
    let hasNegative = false;
    const fmt2 = (v) => (v==null || Number.isNaN(v)) ? 'â€”' : (Math.round(v*100)/100).toFixed(2);

    ['day','night','sat','sun','bh'].forEach(bucket=>{
      const paye = numOrNull(getIn(`#clientRateForm input[name="paye_${bucket}"]`)?.value);
      const umb  = numOrNull(getIn(`#clientRateForm input[name="umb_${bucket}"]`)?.value);
      const chg  = numOrNull(getIn(`#clientRateForm input[name="charge_${bucket}"]`)?.value);

  const nOrNull = (x) => {
  const n = Number(x);
  return Number.isFinite(n) ? n : null;
};

const payeN = nOrNull(paye);
const umbN  = nOrNull(umb);
const chgN  = nOrNull(chg);

// âœ… Hourly margins
// PAYE margin includes employer NI multiplier
const payeMargin = (payeN != null && chgN != null) ? (chgN - (payeN * mult)) : null;
// Umbrella margin is straight charge - pay
const umbMargin  = (umbN  != null && chgN != null) ? (chgN - umbN)          : null;



      const spP = byId(`m_paye_${bucket}`), spU = byId(`m_umb_${bucket}`);
      if (spP) spP.textContent = fmt2(payeMargin);
      if (spU) spU.textContent = fmt2(umbMargin);

      if ((payeMargin != null && payeMargin < 0) || (umbMargin != null && umbMargin < 0)) hasNegative = true;
    });

    if (hasNegative) { canApply = false; showClientInlineError('One or more buckets would have a negative margin. Adjust pay/charge.'); }

    // Overlap detection + Fix buttons
    const staged = Array.isArray(ctx.ratesState) ? ctx.ratesState.slice() : [];
    const sameCat  = r => String(r.role||'') === roleVal && String(r.band??'') === String((byId('cl_band')?.value||'').trim()||'');
    const isSelf   = r => existing ? sameRow(r, existing) : false;

    const conflicts = staged
      .filter(r => !r.disabled_at_utc && sameCat(r) && !isSelf(r))
      .filter(r => rangesOverlap(r.date_from||null, r.date_to||null, fromIso, toIso||null));

    if (conflicts.length) {
      canApply = false;
      const ov = conflicts[0];
      const overlapStart = (fromIso > (ov.date_from||'0000-01-01')) ? fromIso : (ov.date_from||'');
      const overlapEnd   = ((toIso||'9999-12-31') < (ov.date_to||'9999-12-31')) ? (toIso||'') : (ov.date_to||'');
      const cutThis      = isoMinusOneDay(ov.date_from||'');
      const cutOther     = isoMinusOneDay(fromIso);

      let fixButtons = '';
      if (cutThis && (!fromIso || cutThis >= fromIso)) {
        fixButtons += `<button id="cl_fix_this" class="btn" style="margin-right:8px">Fix: Shorten <b>THIS</b> to ${formatIsoToUk(cutThis)}</button>`;
      }
      if (cutOther && (!ov.date_from || cutOther >= (ov.date_from))) {
        fixButtons += `<button id="cl_fix_other" class="btn">Fix: Shorten <b>OTHER</b> to ${formatIsoToUk(cutOther)}</button>`;
      }

      const msg = `
        <div style="font-weight:700;margin-bottom:6px">Overlap detected</div>
        <div style="margin-bottom:6px">
          Another client-default window exists for <b>${escapeHtml(roleVal)}</b>${(byId('cl_band')?.value||'').trim()?` / <b>${escapeHtml((byId('cl_band')?.value||'').trim())}</b>`:''}.<br/>
          <span class="hint" style="color:#fecaca">Overlap span:</span> <b>${formatIsoToUk(overlapStart)} â€“ ${formatIsoToUk(overlapEnd)}</b>.
        </div>
        <div style="margin-bottom:8px">To proceed, adjust dates, or use a Fix:</div>
        <div>${fixButtons || '<i>No safe automatic fix available. Please adjust dates.</i>'}</div>
      `;
      showClientInlineError(msg);

      setTimeout(() => {
        const fromEl = byId('cl_date_from');
        const toEl   = byId('cl_date_to');
        const fixThis = byId('cl_fix_this');
        if (fixThis && cutThis) fixThis.onclick = () => {
          try { toEl.value = formatIsoToUk(cutThis); recomputeClientState(); } catch {}
        };
        const fixOther = byId('cl_fix_other');
        if (fixOther && cutOther) fixOther.onclick = () => {
          try {
            // stage OTHER truncate (stays staged until parent Save)
            if (ov.id) {
              const idx = staged.findIndex(r => r.id === ov.id);
              if (idx >= 0) ctx.ratesState[idx] = { ...ctx.ratesState[idx], date_to: cutOther };
            } else if (ov.__localKey) {
              const idx = staged.findIndex(r => r.__localKey === ov.__localKey);
              if (idx >= 0) ctx.ratesState[idx] = { ...ctx.ratesState[idx], date_to: cutOther };
            }
            try { renderClientRatesTable(); } catch {}
            recomputeClientState();
          } catch {}
        };
      }, 0);
    }

    DBG('recomputeClientState: EXIT', { canApply });
    setApplyEnabled(canApply);
  }

  const formTabLabel = `Form â€” ${isDisabled ? 'Inactive' : 'Active'}`;

  // showModal (child) â€” persist staged edits only; no popups for errors
  showModal(
    existing ? 'Edit Client Default Window' : 'Add/Upsert Client Default Window',
    [{ key:'form', label: formTabLabel }],
    () => formHtml,
    async () => {
      const stack = window.__modalStack || [];
      const pf = stack.length > 1 ? stack[stack.length - 2] : null;
      DBG('onSave ENTRY', { stackLen: stack.length, hasParent: !!pf, parentMode: pf?.mode });

      if (!pf || (pf.mode !== 'edit' && pf.mode !== 'create')) {
        DBG('onSave BLOCKED: parent not editable');
        return false;
      }

      // Re-validate live state; rely on validation result (do not read DOM disabled state)
      await recomputeClientState();
      DBG('onSave proceeding after recompute');

      const raw = collectForm('#clientRateForm');
      DBG('onSave collected', { raw });

      let role = (raw.role || '').trim();
      const newRole = (document.getElementById('cl_role_new')?.value || '').trim();
      if (role === '__OTHER__') {
        if (!newRole) { showClientInlineError('Enter a new role code.'); setApplyEnabled(false); DBG('onSave BLOCKED: newRole missing'); return false; }
        role = newRole.toUpperCase();
        if (typeof invalidateGlobalRoleOptionsCache === 'function') {
          try { invalidateGlobalRoleOptionsCache(); window.dispatchEvent(new CustomEvent('global-roles-updated')); } catch {}
        }
      }
      if (!role) { showClientInlineError('Role is required.'); setApplyEnabled(false); DBG('onSave BLOCKED: role missing'); return false; }

      const isoFrom = parseUkDateToIso(raw.date_from);
      if (!isoFrom) { showClientInlineError('Invalid â€œEffective fromâ€ date.'); setApplyEnabled(false); DBG('onSave BLOCKED: date_from invalid'); return false; }
      let isoTo = null;
      if (raw.date_to) {
        isoTo = parseUkDateToIso(raw.date_to);
        if (!isoTo) { showClientInlineError('Invalid â€œEffective toâ€ date.'); setApplyEnabled(false); DBG('onSave BLOCKED: date_to invalid'); return false; }
        if (isoTo < isoFrom) { showClientInlineError('â€œEffective toâ€ cannot be before â€œEffective fromâ€.'); setApplyEnabled(false); DBG('onSave BLOCKED: date order invalid'); return false; }
      }

      const staged = {
        id: existing?.id || undefined,
        client_id: resolvedClientId,
        role,
        band: (raw.band || '').trim() || null,
        date_from: isoFrom,
        date_to:   isoTo,

        charge_day  : raw['charge_day']  !== '' ? Number(raw['charge_day'])  : null,
        charge_night: raw['charge_night']!== '' ? Number(raw['charge_night']) : null,
        charge_sat  : raw['charge_sat']  !== '' ? Number(raw['charge_sat'])  : null,
        charge_sun  : raw['charge_sun']  !== '' ? Number(raw['charge_sun'])  : null,
        charge_bh   : raw['charge_bh']   !== '' ? Number(raw['charge_bh'])   : null,

        paye_day    : raw['paye_day']    !== '' ? Number(raw['paye_day'])    : null,
        paye_night  : raw['paye_night']  !== '' ? Number(raw['paye_night'])  : null,
        paye_sat    : raw['paye_sat']    !== '' ? Number(raw['paye_sat'])    : null,
        paye_sun    : raw['paye_sun']    !== '' ? Number(raw['paye_sun'])    : null,
        paye_bh     : raw['paye_bh']     !== '' ? Number(raw['paye_bh'])     : null,

        umb_day     : raw['umb_day']     !== '' ? Number(raw['umb_day'])     : null,
        umb_night   : raw['umb_night']   !== '' ? Number(raw['umb_night'])   : null,
        umb_sat     : raw['umb_sat']     !== '' ? Number(raw['umb_sat'])     : null,
        umb_sun     : raw['umb_sun']     !== '' ? Number(raw['umb_sun'])     : null,
        umb_bh      : raw['umb_bh']      !== '' ? Number(raw['umb_bh'])      : null,

        // carry through disabled status + pending toggle marker (for UI/meta)
        disabled_at_utc : ex.disabled_at_utc ?? null,
        disabled_by_name: ex.disabled_by_name ?? null,
        __toggle        : ex.__toggle || undefined,
        __localKey      : existing?.__localKey || undefined,
        __delete        : existing?.__delete || false
      };

      if (ex.__toggle === 'enable') {
        staged.disabled_at_utc = null;
      } else if (ex.__toggle === 'disable') {
        staged.disabled_at_utc = staged.disabled_at_utc || new Date().toISOString().slice(0,10);
      }

      // Stage only (persist on parent Save)
      const before = { len: Array.isArray(ctx.ratesState) ? ctx.ratesState.length : 0 };
      ctx.ratesState = Array.isArray(ctx.ratesState) ? ctx.ratesState : [];
      if (existing) {
        const idx = ctx.ratesState.findIndex(r => sameRow(r, existing));
        if (idx >= 0) ctx.ratesState[idx] = staged; else ctx.ratesState.push(staged);
      } else {
        const already = ctx.ratesState.findIndex(r => sameRow(r, staged));
        if (already >= 0) ctx.ratesState[already] = staged; else ctx.ratesState.push(staged);
      }
      const after = { len: ctx.ratesState.length };
      DBG('onSave STAGED', { before, after, stagedId: staged.id, stagedRole: staged.role, toggle: staged.__toggle });

      try { const parent = _currentFrame(); if (parent && typeof parent.setTab === 'function') { parent.currentTabKey = 'rates'; parent.setTab('rates'); DBG('onSave: parent.setTab(rates)'); } } catch{}
      try { window.dispatchEvent(new CustomEvent('modal-dirty')); DBG('onSave: dispatched modal-dirty'); } catch {}
      try { await renderClientRatesTable(); DBG('onSave: renderClientRatesTable done'); } catch (e) { DBG('onSave: renderClientRatesTable error', e); }

      DBG('onSave EXIT ok=true');
      return true;
    },
    false,
    () => {
      const parent = _currentFrame();
      if (parent) { parent.currentTabKey = 'rates'; parent.setTab('rates'); DBG('onReturn: parent.setTab(rates)'); }
    },
    { kind: 'client-rate' }
  );

  // Hydrate & wire listeners
  const roleSel   = byId('cl_role');
  const roleNew   = byId('cl_role_new');
  const roleNewRow= byId('cl_role_new_row');
  const bandEl    = byId('cl_band');
  const fromEl    = byId('cl_date_from');
  const toEl      = byId('cl_date_to');

  attachUkDatePicker(fromEl); attachUkDatePicker(toEl);
  if (existing?.date_from) fromEl.value = formatIsoToUk(existing.date_from);
  if (existing?.date_to)   toEl.value   = formatIsoToUk(existing.date_to);

  if (existing?.role) {
    if (globalRoles.includes(existing.role)) {
      roleSel.value = existing.role;
      roleNewRow.style.display = 'none';
      roleNew.value = '';
    } else {
      roleSel.value = '__OTHER__';
      roleNewRow.style.display = '';
      roleNew.value = existing.role;
    }
  } else {
    roleNewRow.style.display = 'none';
  }

  // ===== Prefill with two-decimal rendering (no other changes) =====
  ['day','night','sat','sun','bh'].forEach(b=>{
    const set = (name, val) => {
      const el = document.querySelector(`#clientRateForm input[name="${name}_${b}"]`);
      if (el && typeof val !== 'undefined' && val !== null) {
        const num = Number(val);
        el.value = Number.isFinite(num) ? (Math.round(num*100)/100).toFixed(2) : String(val);
      }
    };
    set('paye',   existing?.[`paye_${b}`]);
    set('umb',    existing?.[`umb_${b}`]);
    set('charge', existing?.[`charge_${b}`]);
  });

  // Recompute once on mount
  DBG('mount: recomputeClientState');
  await recomputeClientState();

  roleSel.addEventListener('change', async ()=>{
    DBG('EVENT: role change', { value: roleSel.value });
    if (roleSel.value === '__OTHER__') { roleNewRow.style.display = ''; }
    else { roleNewRow.style.display = 'none'; roleNew.value=''; }
    await recomputeClientState();
  });
  bandEl.addEventListener('input',  () => { DBG('EVENT: band input', { value: bandEl.value }); recomputeClientState(); });
  fromEl.addEventListener('change', () => { DBG('EVENT: date_from change', { value: fromEl.value }); recomputeClientState(); });
  toEl.addEventListener('change',   () => { DBG('EVENT: date_to change', { value: toEl.value }); recomputeClientState(); });
  ['day','night','sat','sun','bh'].forEach(b=>{
    ['paye','umb','charge'].forEach(kind=>{
      const el = document.querySelector(`#clientRateForm input[name="${kind}_${b}"]`);
      if (el) el.addEventListener('input', () => { DBG('EVENT: pay input', { kind, bucket: b, value: el.value }); recomputeClientState(); });
    });
  });

  // Wire the Active/Inactive toggle button
  (function wireToggleButton(){
    const btn = byId('cl_toggle_btn');
    if (!btn || !parentEditable || !ex || !ex.id) return;
    DBG('wireToggleButton: ready', { id: ex.id, disabled: !!ex.disabled_at_utc });
    btn.onclick = () => {
      const pill = byId('cl_status_pill');
      const meta = byId('cl_status_meta');
      const currentlyDisabled = !!ex.disabled_at_utc;

      if (currentlyDisabled) {
        ex.__toggle = 'enable';
        ex.disabled_at_utc = null;
        if (pill) { pill.textContent = 'âœ“ Active'; pill.className = 'pill tag-ok'; }
        if (meta) meta.innerHTML = '&nbsp;';
        btn.textContent = 'Disable';
      } else {
        ex.__toggle = 'disable';
        ex.disabled_at_utc = new Date().toISOString().slice(0,10);
        if (pill) { pill.textContent = 'âŒ Disabled'; pill.className = 'pill tag-fail'; }
        if (meta) meta.textContent = 'pending save';
        btn.textContent = 'Enable';
      }
      DBG('toggle clicked', { newToggle: ex.__toggle, newDisabledAt: ex.disabled_at_utc });
      setApplyEnabled(true);
    };
  })();

  // DELETE button logic (unchanged; staged delete until parent Save)
  (async function wireDeleteButton(){
    const delBtn = byId('btnDelete');
    if (!delBtn) return;
    if (!existing || !existing.id) { delBtn.style.display='none'; return; }

    const today = new Date(); const yyyy = today.getFullYear(); const mm = String(today.getMonth()+1).padStart(2,'0'); const dd = String(today.getDate()).padStart(2,'0');
    const todayIso = `${yyyy}-${mm}-${dd}`;
    const isFutureOrToday = !!existing.date_from && String(existing.date_from) >= todayIso;

    let deletable = isFutureOrToday;
    let reason = '';
    if (!deletable) {
      deletable = true; // allow delete in UI; real guard happens on Save server-side
      reason = '';
    }

    delBtn.style.display = '';
    delBtn.disabled = false;
    delBtn.onclick = () => {
      try {
        existing.__delete = true;
        DBG('delete staged', { id: existing.id });
        if (window.modalCtx && window.modalCtx.ratesStagedDeletes instanceof Set && existing.id) {
          window.modalCtx.ratesStagedDeletes.add(String(existing.id));
        }
        try { renderClientRatesTable(); } catch {}
        try { window.dispatchEvent(new CustomEvent('modal-dirty')); } catch {}
        const closeBtn = byId('btnCloseModal'); if (closeBtn) closeBtn.click();
      } catch (e) { DBG('delete stage failed', e); }
    };
  })();
}


// === UPDATED: Client Default Rate modal (Role dropdown + new-role option; UK dates; date_to) ===
// ======================== openClientRateModal (FIXED) ========================
// =================== CLIENT DEFAULT RATE MODAL (UPDATED) ===================
// âœ… UPDATED â€” unified 3Ã—5 grid (PAYE | Umbrella | Charge), date prefill, staged Nâˆ’1 truncation of incumbent window

// ============================================================================
// CLIENT RATE MODAL (child) â€” adds status block + enable/disable button;
// overlap/rollback logic now IGNORES disabled rows
// ============================================================================

// ========== CLIENT DEFAULT RATES ==========

async function renderClientRatesTable() {
  const LOG_RATES = !!window.__LOG_RATES;
  const DBG = (...a)=> { if (LOG_RATES) console.log('[RATES][renderClientRatesTable]', ...a); };

  const div = byId('clientRates');
  if (!div) { DBG('no #clientRates host, bail'); return; }

  // âœ… force full-width even if the parent tab is a 2-col grid
  try {
    div.style.gridColumn = '1 / -1';
    div.style.width = '100%';
    div.style.minWidth = '0';
  } catch {}

  const ctx = window.modalCtx || {};
  const staged = Array.isArray(ctx.ratesState) ? ctx.ratesState : [];
  const frame = _currentFrame();
  const parentEditable = frame && (frame.mode === 'edit' || frame.mode === 'create');

  DBG('ENTRY', { stagedLen: staged.length, parentEditable, ctxEntity: ctx?.entity });

  // ERNI multiplier for PAYE margins
  // UPDATED:
  // - getSettingsCached() returns { settings, finance_windows }
  // - choose ERNI by date:
  //     ongoing (date_to empty or date_to >= today) -> today
  //     finished (date_to < today) -> date_from
  async function _erniMultiplier(fromIso, toIso){
    // Today (Europe/London)
    const todayIso = (() => {
      try {
        const s = new Intl.DateTimeFormat('en-GB', { timeZone: 'Europe/London', year:'numeric', month:'2-digit', day:'2-digit' }).format(new Date());
        const [dd, mm, yyyy] = s.split('/');
        return `${yyyy}-${mm}-${dd}`;
      } catch {
        const d = new Date(); const y = d.getFullYear(), m = String(d.getMonth()+1).padStart(2,'0'), day = String(d.getDate()).padStart(2,'0');
        return `${y}-${m}-${day}`;
      }
    })();

    const asYmd = (v) => {
      if (!v) return null;
      const ss = String(v).slice(0, 10);
      return /^\d{4}-\d{2}-\d{2}$/.test(ss) ? ss : null;
    };

    const fIso = asYmd(fromIso) || null;
    const tIso = asYmd(toIso)   || null;

    // Rule: finished -> start date, else today
    const finished = !!(tIso && tIso < todayIso);
    const anchorYmd = (finished && fIso) ? fIso : todayIso;

    // Cache by anchor date
    window.__ERNI_MULT_BY_DATE__ = window.__ERNI_MULT_BY_DATE__ || Object.create(null);
    if (typeof window.__ERNI_MULT_BY_DATE__[anchorYmd] === 'number' && window.__ERNI_MULT_BY_DATE__[anchorYmd] > 0) {
      window.__ERNI_MULT__ = window.__ERNI_MULT_BY_DATE__[anchorYmd]; // keep legacy cache aligned
      return window.__ERNI_MULT_BY_DATE__[anchorYmd];
    }

    try {
      if (typeof getSettingsCached === 'function') {
        const s = await getSettingsCached();

        // New shape: { settings: {...}, finance_windows: [...] }
        const fws = Array.isArray(s?.finance_windows) ? s.finance_windows : [];

        // Pick finance window in-scope for anchorYmd (prefer latest date_from)
        let chosen = null;
        for (const w of fws) {
          const df = asYmd(w?.date_from);
          const dt = asYmd(w?.date_to);
          if (!df) continue;
          if (df > anchorYmd) continue;
          if (dt && dt < anchorYmd) continue;

          if (!chosen) {
            chosen = w;
          } else {
            const cdf = asYmd(chosen?.date_from);
            if (cdf && df > cdf) chosen = w;
          }
        }

        let p = chosen?.erni_pct ?? null;
        if (p == null) p = s?.settings?.erni_pct ?? null;
        if (p == null) p = s?.erni_pct ?? null;
        if (p == null) p = s?.employers_ni_percent ?? null;
        if (p == null) p = 0;

        p = Number(p) || 0;
        if (p > 1) p = p / 100;

        let mult = 1 + p;
        if (!Number.isFinite(mult) || mult <= 0) mult = 1;

        window.__ERNI_MULT_BY_DATE__[anchorYmd] = mult;
        window.__ERNI_MULT__ = mult;

        return mult;
      }
    } catch {}

    window.__ERNI_MULT_BY_DATE__[anchorYmd] = 1;
    window.__ERNI_MULT__ = 1;
    return 1;
  }

  // Formatters
  const fmt2 = (v) => (v==null || Number.isNaN(v)) ? 'â€”' : (Math.round(Number(v)*100)/100).toFixed(2);

  // âœ… FIX: Client rates are HOURLY â€” margin must be HOURLY
  // PAYE margin includes ERNI multiplier: charge - (pay * erniMult)
  // UMB margin: charge - pay
  const calcMargin = ({ charge, pay, method, erniMult }) => {
    const ch = (charge == null ? null : Number(charge));
    const py = (pay    == null ? null : Number(pay));
    if (!Number.isFinite(ch) || !Number.isFinite(py)) return null;

    const m = String(method || '').toUpperCase();
    if (m === 'PAYE') return ch - (py * (Number(erniMult) || 1));
    return ch - py; // UMBRELLA
  };

  div.innerHTML = '';

  // Empty state
  if (!staged.length) {
    DBG('no staged rows â†’ show empty state');
    div.innerHTML = `
      <div class="hint" style="margin-bottom:8px">No client default windows yet.</div>
      <div class="actions">
        <button id="btnAddClientRate" class="btn mini"${parentEditable ? '' : ' disabled'}>
          Add / Upsert client window
        </button>
        ${parentEditable
          ? '<span class="hint">Changes are staged. Click â€œSaveâ€ in the main dialog to persist.</span>'
          : '<span class="hint">Read-only. Click â€œEditâ€ in the main dialog to add/modify windows.</span>'}
      </div>
    `;
    const addBtn = byId('btnAddClientRate');
    if (addBtn && parentEditable) {
      addBtn.onclick = () => {
        const cid = (ctx && ctx.data && (ctx.data.id || ctx.data.client_id)) || null;
        return openClientRateModal(cid);
      };
    }
    return;
  }

  // âœ… SECTION-PER-WINDOW LAYOUT (Role/Band/From/To header + 5-row table)
  const SHIFT_LABELS = [
    ['day',   'Day'],
    ['night', 'Night'],
    ['sat',   'Sat'],
    ['sun',   'Sun'],
    ['bh',    'BH']
  ];

  // Group by window keys (role+band+date_from+date_to)
  const keyFor = (r) => [
    String(r.role || ''),
    String(r.band ?? ''),
    String(r.date_from || ''),
    String(r.date_to || '')
  ].join('|');

  const groups = new Map();
  for (const r of staged) {
    if (!r) continue;
    if (r.__delete) continue; // hide pending deletes from main view (your prior preference)
    const k = keyFor(r);
    if (!groups.has(k)) groups.set(k, r);
  }

  const groupRows = Array.from(groups.values()).sort((a, b) => {
    const ar = String(a.role || ''), br = String(b.role || '');
    if (ar !== br) return ar.localeCompare(br);
    const ad = String(a.date_from || ''), bd = String(b.date_from || '');
    return ad.localeCompare(bd);
  });

  const wrap = document.createElement('div');
  wrap.style.display = 'flex';
  wrap.style.flexDirection = 'column';
  wrap.style.gap = '12px';
  wrap.style.width = '100%';
  wrap.style.minWidth = '0';

  // âœ… IMPORTANT: use for..of so we can await per-window ERNI multiplier
  for (const r of groupRows) {
    const roleText = String(r.role || '').trim();
    const bandText = (r.band ?? null) ? String(r.band) : '';
    const fromText = r.date_from ? formatIsoToUk(String(r.date_from)) : '';
    const toText   = r.date_to   ? formatIsoToUk(String(r.date_to))   : 'Open-ended';

    const card = document.createElement('div');
    card.className = 'card';
    card.style.padding = '12px';
    card.style.border = '1px solid var(--line)';
    card.style.borderRadius = '12px';
    card.style.background = '#0c172d';
    card.style.width = '100%';
    card.style.minWidth = '0';

    // Header (Role/Band/From/To + Edit)
    const header = document.createElement('div');
    header.style.display = 'flex';
    header.style.alignItems = 'flex-start';
    header.style.justifyContent = 'space-between';
    header.style.gap = '12px';
    header.style.marginBottom = '10px';

    const left = document.createElement('div');
    left.style.minWidth = '0';
    left.innerHTML = `
      <div style="display:flex;flex-wrap:wrap;gap:8px;align-items:center;">
        <div style="font-weight:800;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">
          ${escapeHtml(roleText || 'â€”')}
        </div>
        ${bandText ? `<span class="pill">${escapeHtml(bandText)}</span>` : ``}
        ${r.disabled_at_utc ? `<span class="pill tag-fail">Disabled</span>` : `<span class="pill tag-ok">Active</span>`}
      </div>
      <div class="hint" style="margin-top:4px;">
        <span style="opacity:.9">From:</span> ${escapeHtml(fromText || 'â€”')}
        <span style="opacity:.6"> Â· </span>
        <span style="opacity:.9">To:</span> ${escapeHtml(toText)}
      </div>
    `;

    const right = document.createElement('div');
    right.style.flex = '0 0 auto';

    if (parentEditable) {
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'btn mini';
      btn.textContent = 'Edit';
      btn.setAttribute('data-edit-client-rate', String(r.id || r.__localKey || ''));
      right.appendChild(btn);
    }

    header.appendChild(left);
    header.appendChild(right);

    // Table for this window: Shift + PAYE + Umb + Charge + PAYE Margin + Umb Margin
    const tbl = document.createElement('table');
    tbl.className = 'grid';
    tbl.style.width = '100%';
    tbl.style.tableLayout = 'auto';

    const thead = document.createElement('thead');
    thead.innerHTML = `
      <tr>
        <th style="min-width:110px">Shift type</th>
        <th style="min-width:130px">PAYE pay</th>
        <th style="min-width:150px">Umbrella pay</th>
        <th style="min-width:170px">Total charge (ex VAT)</th>
        <th style="min-width:140px">Margin (PAYE)</th>
        <th style="min-width:160px">Margin (Umbrella)</th>
      </tr>
    `;
    tbl.appendChild(thead);

    const tb = document.createElement('tbody');

    // âœ… compute ERNI multiplier ONCE per window (ongoing->today, finished->date_from)
    const erniMultForThisWindow = await _erniMultiplier(r.date_from || null, r.date_to || null);

    SHIFT_LABELS.forEach(([bucket, label]) => {
      const tr = document.createElement('tr');

      const paye   = r[`paye_${bucket}`];
      const umb    = r[`umb_${bucket}`];
      const charge = r[`charge_${bucket}`];

      const mPaye = calcMargin({ charge, pay: paye, method: 'PAYE',     erniMult: erniMultForThisWindow });
      const mUmb  = calcMargin({ charge, pay: umb,  method: 'UMBRELLA', erniMult: erniMultForThisWindow });

      const tdShift = document.createElement('td');
      tdShift.textContent = label;
      tr.appendChild(tdShift);

      const tdPaye = document.createElement('td');
      tdPaye.textContent = fmt2(paye);
      tr.appendChild(tdPaye);

      const tdUmb = document.createElement('td');
      tdUmb.textContent = fmt2(umb);
      tr.appendChild(tdUmb);

      const tdCharge = document.createElement('td');
      tdCharge.textContent = fmt2(charge);
      tr.appendChild(tdCharge);

      const tdMPaye = document.createElement('td');
      tdMPaye.textContent = fmt2(mPaye);
      tr.appendChild(tdMPaye);

      const tdMUmb = document.createElement('td');
      tdMUmb.textContent = fmt2(mUmb);
      tr.appendChild(tdMUmb);

      tb.appendChild(tr);
    });

    tbl.appendChild(tb);

    card.appendChild(header);
    card.appendChild(tbl);
    wrap.appendChild(card);
  }

  div.appendChild(wrap);

  // Actions footer
  const actions = document.createElement('div');
  actions.className = 'actions';
  actions.innerHTML = `
    <button id="btnAddClientRate" class="btn mini"${parentEditable ? '' : ' disabled'}>
      Add / Upsert client window
    </button>
    ${parentEditable ? '' : '<span class="hint">Read-only. Click â€œEditâ€ in the main dialog to add/modify windows.</span>'}
  `;
  div.appendChild(actions);

  // Wire Add
  const addBtn = byId('btnAddClientRate');
  if (addBtn && parentEditable) {
    addBtn.onclick = () => {
      const cid = (ctx && ctx.data && (ctx.data.id || ctx.data.client_id)) || null;
      return openClientRateModal(cid);
    };
  }

  // Wire Edit (one per window)
  if (parentEditable) {
    div.querySelectorAll('button[data-edit-client-rate]').forEach(btn => {
      if (btn.__wired) return;
      btn.__wired = true;
      btn.onclick = () => {
        const cid = (ctx && ctx.data && (ctx.data.id || ctx.data.client_id)) || null;
        const idOrKey = btn.getAttribute('data-edit-client-rate');
        const row =
          staged.find(x => x && x.id && String(x.id) === String(idOrKey)) ||
          staged.find(x => x && x.__localKey && String(x.__localKey) === String(idOrKey)) ||
          null;
        if (cid && row) openClientRateModal(cid, row);
      };
    });
  }

  DBG('EXIT render', { groups: groupRows.length, stagedLen: staged.length });
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Global margin helpers (safe, contracts-only consumers can use immediately)
// - calcDailyMargin({ bucket, charge, pay, method, erniMultiplier? }) -> number|null
// - calcDailyMarginsForBuckets({ method, charge:{...}, pay:{...}, erniMultiplier? }) -> {day,night,sat,sun,bh}
// - ensureErniMultiplier() -> Promise<number>  (optional bootstrap to memoise ERNI)
// Notes:
//   â€¢ Pure calc (ex-VAT). No rounding, no styling. Callers format to 2dp.
//   â€¢ For PAYE, margin = charge âˆ’ (pay Ã— ERNI_MULTIPLIER). For Umbrella, margin = charge âˆ’ pay.
//   â€¢ If any operand is missing/NaN returns null.
//   â€¢ Respects existing memo: window.__ERNI_MULT__ (fallback 1.0). Does not force async lookups.
//   â€¢ Non-breaking: only defines helpers if not already present.
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Global margin helpers (safe, consumers can use immediately)
// - calcDailyMargin({ bucket, charge, pay, method, erniMultiplier? }) -> number|null
// - calcDailyMarginsForBuckets({ method, charge:{...}, pay:{...}, erniMultiplier? }) -> {day,night,sat,sun,bh}
// - ensureErniMultiplier(fromIso?, toIso?) -> Promise<number>  (optional bootstrap to memoise ERNI)
// Notes:
//   â€¢ Pure calc (ex-VAT). No rounding, no styling. Callers format to 2dp.
//   â€¢ For PAYE, margin = charge âˆ’ (pay Ã— ERNI_MULTIPLIER). For Umbrella, margin = charge âˆ’ pay.
//   â€¢ If any operand is missing/NaN returns null.
//   â€¢ Respects memo: window.__ERNI_MULT__ / window.__ERNI_MULT_BY_DATE__ (fallback 1.0).
//   â€¢ Non-breaking: only defines helpers if not already present.
//   â€¢ Updated settings logic: getSettingsCached() now returns { settings, finance_windows } and ERNI is chosen from
//     finance_windows in-scope for an anchor date.
//     Anchor rule (when dates provided):
//       - ongoing (toIso empty or toIso >= today UK) -> today UK
//       - finished (toIso < today UK) -> fromIso
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
(() => { 
  const W = (typeof window !== 'undefined') ? window : globalThis;

  // Normalise to number or null (treat '', undefined, NaN as null)
  const toNum = (v) => {
    if (v === '' || v === null || v === undefined) return null;
    const n = Number(v);
    return Number.isFinite(n) ? n : null;
  };

  // Today (Europe/London) as YYYY-MM-DD
  const todayUkYmd = () => {
    try {
      const s = new Intl.DateTimeFormat('en-GB', {
        timeZone: 'Europe/London',
        year: 'numeric',
        month: '2-digit',
        day: '2-digit'
      }).format(new Date());
      const [dd, mm, yyyy] = s.split('/');
      return `${yyyy}-${mm}-${dd}`;
    } catch {
      const d = new Date();
      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, '0');
      const day = String(d.getDate()).padStart(2, '0');
      return `${y}-${m}-${day}`;
    }
  };

  const asYmd = (v) => {
    if (!v) return null;
    const s = String(v).trim();
    if (!s) return null;
    // Accept YYYY-MM-DD or ISO datetime; keep YYYY-MM-DD
    const ymd = s.slice(0, 10);
    return /^\d{4}-\d{2}-\d{2}$/.test(ymd) ? ymd : null;
  };

  const pctToMultiplier = (pctMaybe) => {
    let p = Number(pctMaybe);
    if (!Number.isFinite(p) || p <= 0) return 1;
    if (p > 1) p = p / 100; // support 15 vs 0.15
    const m = 1 + p;
    return (Number.isFinite(m) && m > 0) ? m : 1;
  };

  const pickFinanceWindowForDate = (finance_windows, anchorYmd) => {
    const fws = Array.isArray(finance_windows) ? finance_windows : [];
    let chosen = null;

    for (const w of fws) {
      const df = asYmd(w?.date_from);
      const dt = asYmd(w?.date_to);
      if (!df) continue;
      if (df > anchorYmd) continue;
      if (dt && dt < anchorYmd) continue;

      if (!chosen) {
        chosen = w;
      } else {
        const cdf = asYmd(chosen?.date_from);
        if (cdf && df > cdf) chosen = w;
      }
    }
    return chosen;
  };

  // Optional async bootstrap to memoise finance globals once (erni+vat) for a chosen anchor date.
  // Updated: supports force-refresh so opening a contract can always pull current values (in case another admin changed them).
  if (typeof W.ensureErniMultiplier !== 'function') {
    W.ensureErniMultiplier = async function ensureErniMultiplier(fromIso = null, toIso = null, forceRefresh = false) {
      const todayIso = todayUkYmd();

      // Determine anchor date:
      // - ongoing -> today
      // - finished -> fromIso
      const fIso = asYmd(fromIso);
      const tIso = asYmd(toIso);
      const finished = !!(tIso && tIso < todayIso);
      const anchorYmd = (finished && fIso) ? fIso : todayIso;

      // Cache by date (prevents repeat lookups) unless forceRefresh=true
      W.__FINANCE_BY_DATE__ = W.__FINANCE_BY_DATE__ || Object.create(null);
      if (!forceRefresh) {
        const cached = W.__FINANCE_BY_DATE__[anchorYmd];
        if (cached && typeof cached === 'object') {
          const mult = Number(cached.erni_mult);
          if (Number.isFinite(mult) && mult > 0) {
            W.__ERNI_MULT__ = mult;
            W.__ERNI_MULT_BY_DATE__ = W.__ERNI_MULT_BY_DATE__ || Object.create(null);
            W.__ERNI_MULT_BY_DATE__[anchorYmd] = mult;
            return mult;
          }
        }
      }

      let financeWindow = null;

      // 0) If backend already injected finance into the current modal, prefer it (fresh per open)
      try {
        const mc = W.modalCtx || null;
        const direct = mc?.finance_window || mc?.finance?.window || mc?.finance?.finance_window || null;
        if (direct && typeof direct === 'object') {
          // If it looks like a window row, accept it
          if (direct.vat_rate_pct != null || direct.erni_pct != null || direct.date_from != null) {
            financeWindow = direct;
          }
        }
      } catch {}

      // 1) Try a dedicated backend picker endpoint (recommended):
      //    GET /api/settings/finance-pick?date=YYYY-MM-DD  -> { finance_window: {...} }
      //    (If you named it differently, adjust the URL here.)
      if (!financeWindow) {
        try {
          if (typeof W.authFetch === 'function' && typeof W.API === 'function') {
            const url = W.API(`/api/settings/finance-pick?date=${encodeURIComponent(anchorYmd)}`);
            const r = await W.authFetch(url);
            if (r && r.ok) {
              const j = await r.json().catch(() => null);
              if (j && typeof j === 'object') {
                financeWindow = j.finance_window || j.financeWindow || j.window || null;
              }
            }
          }
        } catch {}
      }

      // 2) Fall back to getSettingsCached (support both old & new shapes)
      if (!financeWindow) {
        try {
          if (typeof W.getSettingsCached === 'function') {
            const sRaw = await W.getSettingsCached();

            // Support both shapes:
            // - { settings, finance_windows }
            // - legacy where getSettingsCached returned just settings object
            const settingsObj = (sRaw && typeof sRaw === 'object' && sRaw.settings && typeof sRaw.settings === 'object')
              ? sRaw.settings
              : (sRaw && typeof sRaw === 'object' ? sRaw : {});

            const finance_windows =
              Array.isArray(sRaw?.finance_windows) ? sRaw.finance_windows
              : Array.isArray(settingsObj?.finance_windows) ? settingsObj.finance_windows
              : [];

            financeWindow = pickFinanceWindowForDate(finance_windows, anchorYmd);

            // If still missing, try a single finance_window field (some handlers return this)
            if (!financeWindow) {
              const single = sRaw?.finance_window || settingsObj?.finance_window || null;
              if (single && typeof single === 'object') financeWindow = single;
            }

            // If STILL missing, synthesize from legacy fields if present (last resort)
            if (!financeWindow) {
              financeWindow = {
                vat_rate_pct: settingsObj?.vat_rate_pct ?? sRaw?.vat_rate_pct ?? null,
                erni_pct: settingsObj?.erni_pct ?? sRaw?.erni_pct ?? settingsObj?.employers_ni_percent ?? null,
                apply_erni_to: settingsObj?.apply_erni_to ?? sRaw?.apply_erni_to ?? 'PAYE_ONLY'
              };
            }
          }
        } catch {}
      }

      // Parse ERNI % and VAT % (store both for future use)
      let erniPct = financeWindow?.erni_pct ?? 0;
      let vatPct  = financeWindow?.vat_rate_pct ?? 0;

      const erniMult = pctToMultiplier(erniPct);
      const vatMult  = pctToMultiplier(vatPct);

      // Persist caches (and keep your legacy global aligned)
      W.__FINANCE_BY_DATE__[anchorYmd] = {
        anchor_ymd: anchorYmd,
        erni_pct: Number(erniPct) || 0,
        erni_mult: erniMult,
        apply_erni_to: String(financeWindow?.apply_erni_to || 'PAYE_ONLY').toUpperCase(),
        vat_rate_pct: Number(vatPct) || 0,
        vat_mult: vatMult,
        window: financeWindow || null
      };

      W.__ERNI_MULT_BY_DATE__ = W.__ERNI_MULT_BY_DATE__ || Object.create(null);
      W.__ERNI_MULT_BY_DATE__[anchorYmd] = erniMult;
      W.__ERNI_MULT__ = erniMult;

      return erniMult;
    };
  }

  // Core per-bucket margin calculator (synchronous)
  if (typeof W.calcDailyMargin !== 'function') {
    /**
     * @param {Object} args
     * @param {'day'|'night'|'sat'|'sun'|'bh'} [args.bucket]
     * @param {number|null} args.charge
     * @param {number|null} args.pay    // PAYE pay or Umbrella pay for the bucket
     * @param {'PAYE'|'UMBRELLA'|string} args.method
     * @param {number} [args.erniMultiplier] // optional override; otherwise uses window.__ERNI_MULT__||1
     * @returns {number|null}
     */
    W.calcDailyMargin = function calcDailyMargin({ bucket, charge, pay, method, erniMultiplier } = {}) {
      const ch = toNum(charge);
      const py = toNum(pay);
      if (ch === null || py === null) return null;

      const m = (typeof erniMultiplier === 'number')
        ? erniMultiplier
        : (typeof W.__ERNI_MULT__ === 'number' ? W.__ERNI_MULT__ : 1);

      const meth = (method || 'PAYE').toString().toUpperCase();
      if (meth === 'PAYE') {
        return ch - (py * m);
      } else if (meth === 'UMBRELLA') {
        return ch - py;
      }
      // Unknown method â†’ treat like Umbrella (no ERNI)
      return ch - py;
    };
  }

  // Convenience: compute margins for all five buckets in one call
  if (typeof W.calcDailyMarginsForBuckets !== 'function') {
    /**
     * @param {Object} args
     * @param {'PAYE'|'UMBRELLA'|string} args.method
     * @param {Object} args.charge  // {day,night,sat,sun,bh}
     * @param {Object} args.pay     // {day,night,sat,sun,bh}  (PAYE pay or Umbrella pay)
     * @param {number} [args.erniMultiplier]
     * @returns {{day:number|null,night:number|null,sat:number|null,sun:number|null,bh:number|null}}
     */
    W.calcDailyMarginsForBuckets = function calcDailyMarginsForBuckets({ method, charge = {}, pay = {}, erniMultiplier } = {}) {
      const buckets = ['day','night','sat','sun','bh'];
      const out = {};
      const meth = (method || 'PAYE').toString().toUpperCase();
      const m = (typeof erniMultiplier === 'number')
        ? erniMultiplier
        : (typeof W.__ERNI_MULT__ === 'number' ? W.__ERNI_MULT__ : 1);

      buckets.forEach(b => {
        out[b] = W.calcDailyMargin({
          bucket: b,
          charge: charge[b],
          pay:    pay[b],
          method: meth,
          erniMultiplier: m
        });
      });
      return out;
    };
  }
})();   


// NEW
async function endContractSafely(contractId, desiredEnd) {
  const LOGC = (typeof window !== 'undefined' && window.__IS_TESTING_LOG) || (typeof window !== 'undefined' && !!window.__LOG_CONTRACTS);
  const url   = `${window.BROKER_BASE_URL}/api/contracts/${encodeURIComponent(String(contractId))}/truncate-tail`;
  const body  = { id: String(contractId), desired_end: String(desiredEnd) };

  if (LOGC) {
    console.groupCollapsed('[TRIM_CALL][frontend] dispatch');
    console.log('request', { url, body, hasAuthFetch: typeof window !== 'undefined' && typeof window.authFetch === 'function' });
  }

  let result;
  try {
    if (typeof window !== 'undefined' && typeof window.authFetch === 'function') {
      const resp = await window.authFetch({
        url,
        method: 'POST',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify(body)
      });
      // normalise possible shapes from authFetch
      if (resp && typeof resp === 'object' && 'ok' in resp && 'json' in resp && typeof resp.json === 'function') {
        const json = await resp.json().catch(() => null);
        result = (json && typeof json === 'object') ? { ...json } : { ok: !!resp.ok, status: resp.status ?? 200 };
      } else {
        result = resp;
      }
    } else {
      const r = await fetch(url, {
        method: 'POST',
        headers: { 'content-type': 'application/json', ...(window?.sbHeaders || {}) },
        body: JSON.stringify(body)
      });
      const data = await r.json().catch(() => null);
      if (!r.ok) {
        const msg = (data && (data.error || data.message)) || `HTTP ${r.status}`;
        throw new Error(msg);
      }
      result = data ?? { ok: true };
    }

    if (LOGC) console.log('response', result);
    return result;
  } catch (err) {
    if (LOGC) console.warn('[TRIM_CALL][frontend] error', err);
    throw err;
  } finally {
    if (LOGC) console.groupEnd?.();
  }
}

// Ensure a window-bound handle exists even when this file is bundled as an ES module
if (typeof window !== 'undefined') {
  if (typeof window.endContractScrub === 'function' && !window.endContractSafely) {
    // legacy alias safeguard if you had a prior name
    window.endContractSafely = window.endContractScrub;
  } else if (typeof window.endContractSafely !== 'function') {
    window.endContractSafely = endContractSafely;
  }
}

// NEW
async function refetchContract(id) {
  const url = `${window.BROKER_BASE_URL}/api/contracts/${encodeURIComponent(id)}`;
  if (typeof authFetch === 'function') {
    const res = await authFetch({ url, method: 'GET', headers: { 'content-type': 'application/json' } });
    return res?.contract || res || null;
  }
  const r = await fetch(url, { headers: { ...(window.sbHeaders || {}) } });
  if (!r.ok) return null;
  const j = await r.json().catch(() => null);
  return j?.contract || j || null;
}

// NEW
function updateContractsListCache(id, row) {
  try {
    if (Array.isArray(window.currentRows)) {
      const i = window.currentRows.findIndex(x => String(x.id) === String(id));
      if (i >= 0) window.currentRows[i] = row;
      (window.__lastSavedAtById ||= {})[String(id)] = Date.now();
    }
  } catch {}
}

// NEW
function showTailClampWarning(safeEnd, desiredEnd) {
  const msg = `End date adjusted to ${safeEnd} due to existing timesheet(s). (Requested ${desiredEnd})`;
  if (typeof showModalHint === 'function') showModalHint(msg, 'warn');
  try { window.__toast?.(msg); } catch {}
}

// NEW
function clearCloneIntent() {
  try {
    const token = window.modalCtx?.openToken || null;
    if (window.modalCtx && window.modalCtx.__cloneIntent) delete window.modalCtx.__cloneIntent;
    if (token && window.__cloneIntents) delete window.__cloneIntents[token];
  } catch {}
}
// NEW
async function refreshOldContractAfterTruncate(oldContractId) {
  const LOGC = (typeof window.__LOG_CONTRACTS === 'boolean') ? window.__LOG_CONTRACTS : true;
  const row = await refetchContract(oldContractId);
  if (!row) return;

  updateContractsListCache(oldContractId, row);

  try {
    const fr = (typeof window.__getModalFrame === 'function') ? window.__getModalFrame() : null;
    if (fr && window.modalCtx && window.modalCtx.entity === 'contracts' && String(window.modalCtx?.data?.id || '') === String(oldContractId)) {
      window.modalCtx.data = { ...(window.modalCtx.data || {}), ...row };
      try { window.dispatchEvent(new Event('contracts-main-rendered')); } catch {}
    }
  } catch {}

  try {
    const st = (window.__calState || {})[oldContractId];
    const win = st && st.win ? st.win : null;
    if (typeof fetchAndRenderContractCalendar === 'function') {
      if (win) {
        await fetchAndRenderContractCalendar(oldContractId, { from: win.from, to: win.to, view: st.view });
      } else {
        const y = (new Date()).getUTCFullYear();
        const def = (typeof computeYearWindow === 'function') ? computeYearWindow(y) : { from: `${y}-01-01`, to: `${y}-12-31` };
        await fetchAndRenderContractCalendar(oldContractId, { from: def.from, to: def.to, view: 'year' });
      }
    }
  } catch (e) {
    if (LOGC) console.warn('[CONTRACTS] refreshOldContractAfterTruncate calendar refresh failed', e);
  }
}


function canonicalizeClientSettings(input) {
  const cs = { ...(input || {}) };

  const toBool = (v, def = false) => {
    if (typeof v === 'boolean') return v;
    if (v === 'on' || v === 'true' || v === true || v === 1 || v === '1') return true;
    if (v === 'false' || v === false || v === 0 || v === '0' || v == null || v === '') return false;
    return def;
  };

  const up = (v) => String(v || '').trim().toUpperCase();

  // âœ… Preserve + canonicalise "Auto-invoice by default" across all mode branches
  const autoInvDefault = toBool(cs.auto_invoice_default, false);

  // âœ… NEW: Client invoicing consolidation mode (DB-backed)
  // Allowed: NONE | BY_WEEK | ANY_WEEK  (UI may send "ALL" -> ANY_WEEK)
  let invConsol = up(cs.invoice_consolidation_mode);
  if (invConsol === 'ALL') invConsol = 'ANY_WEEK';
  if (invConsol !== 'NONE' && invConsol !== 'BY_WEEK' && invConsol !== 'ANY_WEEK') invConsol = 'NONE';

  // âœ… NEW: Reference numbers required to ISSUE invoice (DB-backed)
  const refToIssue = toBool(cs.reference_number_required_to_issue_invoice, false);

  // Determine weekly mode (UI helper first; else derive from legacy flags)
  let weeklyMode = up(cs.weekly_mode);
  if (!weeklyMode) {
    if (toBool(cs.is_nhsp, false)) weeklyMode = 'NHSP';
    else if (toBool(cs.autoprocess_hr, false)) weeklyMode = 'HEALTHROSTER';
    else weeklyMode = 'NONE';
  }
  if (weeklyMode !== 'NHSP' && weeklyMode !== 'HEALTHROSTER') weeklyMode = 'NONE';

  // Determine HR behaviour when weeklyMode=HEALTHROSTER
  let hrBehaviour = up(cs.hr_weekly_behaviour);
  if (!hrBehaviour) {
    hrBehaviour = toBool(cs.no_timesheet_required, false) ? 'CREATE' : 'VERIFY';
  }
  if (hrBehaviour !== 'CREATE') hrBehaviour = 'VERIFY';

  // Base booleans (defaults)
  const payRef    = toBool(cs.pay_reference_required, false);
  const invRef    = toBool(cs.invoice_reference_required, false);
  const selfBill  = toBool(cs.self_bill_no_invoices_sent, false);
  const dailyInv  = toBool(cs.daily_calc_of_invoices, false);
  const groupNsb  = toBool(cs.group_nightsat_sunbh, false);

  // Attach defaults: historically default true if unset, but mode rules can override
  let hrAttach = toBool(cs.hr_attach_to_invoice, true);
  let tsAttach = toBool(cs.ts_attach_to_invoice, true);

  // Apply gated rules
  if (weeklyMode === 'NHSP') {
    cs.is_nhsp = true;

    cs.autoprocess_hr = false;
    cs.requires_hr = false;
    cs.no_timesheet_required = false;

    // âœ… NEW: NHSP does not use HR validation
    cs.hr_validation_required = false;

    cs.pay_reference_required = false;
    cs.invoice_reference_required = false;

    cs.self_bill_no_invoices_sent = true;
    cs.daily_calc_of_invoices = true;
    cs.group_nightsat_sunbh = false;

    cs.hr_attach_to_invoice = false;
    cs.ts_attach_to_invoice = false;

    cs.weekly_mode = 'NHSP';
    cs.hr_weekly_behaviour = ''; // irrelevant in NHSP

    // âœ… keep (client-level)
    cs.auto_invoice_default = autoInvDefault;
    cs.invoice_consolidation_mode = invConsol;
    cs.reference_number_required_to_issue_invoice = refToIssue;

    return cs;
  }


   if (weeklyMode === 'NONE') {
    cs.is_nhsp = false;

    cs.autoprocess_hr = false;
    cs.requires_hr = false;
    cs.no_timesheet_required = false;

    // âœ… NEW: manual weekly source does not use HR validation
    cs.hr_validation_required = false;

    // Manual: keep these user-configurable defaults (false if unset)
    cs.pay_reference_required = payRef;
    cs.invoice_reference_required = invRef;
    cs.self_bill_no_invoices_sent = selfBill;
    cs.daily_calc_of_invoices = dailyInv;
    cs.group_nightsat_sunbh = groupNsb;

    // Manual: forced
    cs.hr_attach_to_invoice = false;
    cs.ts_attach_to_invoice = true;

    cs.weekly_mode = 'NONE';
    cs.hr_weekly_behaviour = ''; // irrelevant

    // âœ… keep (client-level)
    cs.auto_invoice_default = autoInvDefault;
    cs.invoice_consolidation_mode = invConsol;
    cs.reference_number_required_to_issue_invoice = refToIssue;

    return cs;
  }


  // HEALTHROSTER
  cs.is_nhsp = false;
  cs.autoprocess_hr = true;
  if (hrBehaviour === 'CREATE') {
    cs.requires_hr = false;
    cs.no_timesheet_required = true;

    // âœ… NEW: CREATE mode means we do NOT require HR validation
    cs.hr_validation_required = false;

    // Hidden + forced
    cs.pay_reference_required = false;
    cs.invoice_reference_required = false;

    // Attachments: HR attachment user choice, TS attachment forced off
    cs.hr_attach_to_invoice = hrAttach;
    cs.ts_attach_to_invoice = false;

    cs.weekly_mode = 'HEALTHROSTER';
    cs.hr_weekly_behaviour = 'CREATE';

    // âœ… keep (client-level)
    cs.auto_invoice_default = autoInvDefault;
    cs.invoice_consolidation_mode = invConsol;
    cs.reference_number_required_to_issue_invoice = refToIssue;

    return cs;
  }
  // VERIFY
  cs.requires_hr = true;
  cs.no_timesheet_required = false;

  // âœ… NEW: VERIFY mode means HR validation IS required
  cs.hr_validation_required = true;

  // Hidden + forced
  cs.pay_reference_required = false;
  cs.invoice_reference_required = false;

  // Attachments: both user choice
  cs.hr_attach_to_invoice = hrAttach;
  cs.ts_attach_to_invoice = tsAttach;

  // Keep other flags as-is (still meaningful operationally)
  cs.self_bill_no_invoices_sent = selfBill;
  cs.daily_calc_of_invoices = dailyInv;
  cs.group_nightsat_sunbh = groupNsb;

  cs.weekly_mode = 'HEALTHROSTER';
  cs.hr_weekly_behaviour = 'VERIFY';

  // âœ… keep (client-level)
  cs.auto_invoice_default = autoInvDefault;
  cs.invoice_consolidation_mode = invConsol;
  cs.reference_number_required_to_issue_invoice = refToIssue;

  return cs;

}

async function handleInvoiceDelete(modalCtx) {
  const mc = modalCtx || {};

  // Prefer canonical invoice/items from the same source your invoice modal uses
  let invoice = null;
  let items = [];

  try {
    if (typeof invoiceModalGetInvoiceData === 'function') {
      const d = invoiceModalGetInvoiceData(mc) || {};
      invoice = d.invoice || null;
      items = Array.isArray(d.items) ? d.items : [];
    }
  } catch {}

  // Fallbacks (defensive)
  if (!invoice) {
    const det = mc.invoiceDetail || mc.dataLoaded || mc.data || null;
    invoice =
      (det && typeof det === 'object' && (det.invoice || det.invoice_row || det.invoiceRow))
        ? (det.invoice || det.invoice_row || det.invoiceRow)
        : det;
  }

  if (!items.length) {
    items =
      (Array.isArray(mc.invoiceDetail?.items) ? mc.invoiceDetail.items : []) ||
      (Array.isArray(mc.dataLoaded?.items) ? mc.dataLoaded.items : []) ||
      (Array.isArray(mc.data?.items) ? mc.data.items : []);
  }

  const invoiceId = String(invoice?.id || '').trim();
  if (!invoiceId) { alert('Invoice id missing'); return; }

  const status = String(invoice?.status || '').toUpperCase();

  // âœ… Align with â€œdelete only after unissue + remove all lines + Saveâ€
  // i.e. unissued + unpaid + empty
  const can =
    (invoice?.paid_at_utc == null) &&
    (invoice?.issued_at_utc == null) &&
    (status === 'DRAFT' || status === 'ON_HOLD') &&
    (items.length === 0);

  if (!can) {
    alert('Delete is only available for empty, unissued (DRAFT/ON_HOLD), unpaid invoices.');
    return;
  }

  const ok = window.confirm('Delete this invoice? This cannot be undone.');
  if (!ok) return;

  const res = await authFetch(API(`/api/invoices/${encodeURIComponent(invoiceId)}`), { method: 'DELETE' });
  if (!res.ok) {
    const t = await res.text().catch(()=> '');
    alert(t || `Delete failed (${res.status})`);
    return;
  }

  window.__toast && window.__toast('Invoice deleted.');

  // close modal
  try { byId('btnCloseModal').click(); } catch {}

  // refresh invoice summary if currently open
  try {
    if (currentSection === 'invoices') {
      const data = await loadSection();
      renderSummary(data);
    }
  } catch {}
}


async function handleInvoiceRenderPdf(modalCtx) {
  const mc = modalCtx || {};
  const invoiceId =
    String(mc?.invoiceId || mc?.dataLoaded?.invoice?.id || mc?.dataLoaded?.invoice_row?.id || mc?.data?.id || '').trim();

  if (!invoiceId) { alert('Invoice id missing'); return; }

  const safeJson = async (res) => { try { return await res.json(); } catch { return null; } };

  // âœ… Match the timesheet viewer flow:
  //   1) Render invoice bundle server-side (ensures PDF exists in R2)
  //   2) Presign download using /api/files/presign-download (POST { key })
  //   3) Open viewer with the signed URL
  let pdfKey = null;

  try {
    const res = await authFetch(API(`/api/invoices/${encodeURIComponent(invoiceId)}/render`), {
      method: 'POST',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify({})
    });

    const j = await safeJson(res);

    if (!res.ok) {
      const t = await res.text().catch(()=> '');
      const msg = (j && (j.error || j.message)) ? (j.error || j.message) : (t || `Render failed (${res.status})`);
      throw new Error(String(msg || 'Render failed'));
    }

    // Preferred: backend explicitly returns pdf_key (future-proof)
    const k1 = (j && typeof j.pdf_key === 'string') ? j.pdf_key.trim() : '';
    const k2 = (j && typeof j.key === 'string') ? j.key.trim() : '';
    pdfKey = (k1 || k2) ? String(k1 || k2).replace(/^\/+/, '') : null;

    // Fallback deterministic key (kept for safety)
    if (!pdfKey) {
      pdfKey = `docs-pdf/invoices/invoice_${invoiceId}.pdf`;
    }
  } catch (e) {
    alert(String(e?.message || e || 'Failed to render invoice PDF'));
    return;
  }

  // Presign download (exactly like timesheet evidence/timesheet PDF viewers)
  let signedUrl = null;
  try {
    const cleanKey = String(pdfKey || '').trim().replace(/^\/+/, '');
    const presRes = await authFetch(API('/api/files/presign-download'), {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ key: cleanKey })
    });

    const text = await presRes.text().catch(() => '');
    if (!presRes.ok) throw new Error(text || 'Failed to presign download URL');

    const json = text ? JSON.parse(text) : {};
    signedUrl = String(json.url || json.signed_url || json.download_url || '').trim();
    if (!signedUrl) throw new Error('No URL returned from presign-download');
  } catch (e) {
    alert(String(e?.message || e || 'Failed to presign invoice PDF download'));
    return;
  }

  const invNo =
    String(mc?.dataLoaded?.invoice?.invoice_no || mc?.dataLoaded?.invoice_row?.invoice_no || '').trim() ||
    String(invoiceId).slice(0, 8);

  // âœ… Store on existing modalCtx (do NOT clobber window.modalCtx)
  mc.invoiceUi = (mc.invoiceUi && typeof mc.invoiceUi === 'object') ? mc.invoiceUi : {};
  mc.invoiceUi.pdf_preview = {
    invoice_id: invoiceId,
    invoice_no: invNo,
    pdf_url: signedUrl,
    pdf_key: String(pdfKey || '').trim(),
    opened_at_utc: new Date().toISOString()
  };

  // Viewer modal (child utility, noParentGate)
  showModal(
    `Invoice ${invNo} â€” PDF Preview`,
    [{ key: 'main', label: 'PDF' }],
    () => {
      const u = String(mc?.invoiceUi?.pdf_preview?.pdf_url || '');
      return `
        <div class="card" style="display:flex;flex-direction:column;gap:10px;min-height:0;">
          <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;">
            <div class="mini" style="opacity:.9;">Preview (rendered PDF bundle)</div>
            <div style="display:flex;gap:8px;flex-wrap:wrap;">
              <a class="btn mini" href="${u}" target="_blank" rel="noopener">Open in new tab</a>
            </div>
          </div>

          <div style="border:1px solid var(--line);border-radius:12px;overflow:hidden;min-height:0;">
            <iframe src="${u}"
              style="width:100%;height:75vh;border:0;background:#000;"
              title="Invoice PDF Preview"></iframe>
          </div>
        </div>
      `;
    },
    null,
    true,
    null,
    {
      kind: 'import-summary-invoice-pdf',
      noParentGate: true,
      // âœ… Clean up preview state on dismiss (prevents stale URL reuse)
      onDismiss: () => {
        try {
          if (mc && mc.invoiceUi && mc.invoiceUi.pdf_preview) {
            delete mc.invoiceUi.pdf_preview;
          }
        } catch {}
      }
    }
  );
}


async function handleInvoiceEmail(modalCtx) {
  const mc = modalCtx || {};
  const inv = mc.invoiceDetail?.invoice || mc.data || null;
  const invoiceId = String(inv?.id || '').trim();
  if (!invoiceId) { alert('Invoice id missing'); return; }

  const safeJson = async (res) => { try { return await res.json(); } catch { return null; } };

  try {
    const res = await authFetch(API(`/api/invoices/${encodeURIComponent(invoiceId)}/email`), {
      method: 'POST',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify({})
    });
    const j = await safeJson(res);

    if (!res.ok) {
      const t = await res.text().catch(()=> '');
      const msg = (j && (j.error || j.message)) ? (j.error || j.message) : (t || `Email failed (${res.status})`);
      throw new Error(String(msg || 'Email failed'));
    }

    const st = String(j?.status || '').toUpperCase();

    if (st === 'ON_HOLD') {
      const reason = j?.on_hold_reason ? String(j.on_hold_reason) : 'Invoice placed ON_HOLD';
      alert(`Invoice moved to ON_HOLD and was not emailed.\n\nReason: ${reason}`);
      // refresh invoice detail so UI reflects server state
      try {
        const r2 = await authFetch(API(`/api/invoices/${encodeURIComponent(invoiceId)}`));
        const d2 = await safeJson(r2);
        if (r2.ok && d2) {
          mc.invoiceDetail = d2;
          mc.data = { ...(d2.invoice || {}), id: invoiceId };
        }
      } catch {}
      try {
        const fr = (typeof window.__getModalFrame === 'function') ? window.__getModalFrame() : null;
        if (fr) {
          fr._suppressDirty = true;
          await fr.setTab(fr.currentTabKey || 'main');
          fr._suppressDirty = false;
          fr._updateButtons && fr._updateButtons();
        }
      } catch {}
      return;
    }

    if (j?.queued === true) {
      const mailId = j?.mail_id ? String(j.mail_id) : '';
      const to = j?.to ? String(j.to) : '';
      window.__toast && window.__toast('Queued email.');
      alert(
        `Queued invoice email.\n\n` +
        (to ? `To: ${to}\n` : '') +
        (mailId ? `Outbox ID: ${mailId}\n\n` : '\n') +
        `You can review outbox status in Audit â†’ mail_outbox.`
      );

      // optional: if audit is open, refresh it
      try {
        if (currentSection === 'audit') {
          const data = await loadSection();
          renderSummary(data);
        }
      } catch {}

      return;
    }

    // Fallback (should not happen, but safe)
    window.__toast && window.__toast('Email request complete.');
  } catch (e) {
    alert(String(e?.message || e || 'Failed to queue invoice email'));
  }
}

async function invoiceModalFetchJson(path, options = {}) {
  const headers = { ...(options.headers || {}), 'Accept': 'application/json' };
  if (options.body !== undefined && options.body !== null && !headers['Content-Type']) {
    headers['Content-Type'] = 'application/json';
  }

  const res = await authFetch(API(path), { ...options, headers });

  let data = null;
  try {
    data = await res.json();
  } catch {
    data = null;
  }

  if (!res.ok) {
    const msg =
      (data && (data.error || data.message)) ? (data.error || data.message)
      : `Request failed (${res.status})`;
    throw new Error(msg);
  }

  return data;
}

function invoiceModalIsEditable(invoice, modalCtx, purpose = 'lines') {
  // purpose:
  //  - 'status' => canToggleStatus (in edit mode, not credit note)
  //  - 'lines'  => canEditLines (only if invoice will be UNISSUED + UNPAID when saving)

  if (!invoice || typeof invoice !== 'object') return false;

  // âœ… If caller didnâ€™t pass modalCtx, use the current invoice modal ctx (avoids false negatives)
  const mc = (modalCtx && typeof modalCtx === 'object')
    ? modalCtx
    : ((window.modalCtx && typeof window.modalCtx === 'object') ? window.modalCtx : null);

  const type = String(invoice.type || '').toUpperCase();
  if (type === 'CREDIT_NOTE') return false;

  const status = String(invoice.status || '').toUpperCase();
  const baseIssued = !!invoice.issued_at_utc || status === 'ISSUED';
  const basePaid   = !!invoice.paid_at_utc   || status === 'PAID';

  const st = (mc && mc.invoiceEdits && mc.invoiceEdits.staged_status && typeof mc.invoiceEdits.staged_status === 'object')
    ? mc.invoiceEdits.staged_status
    : { issued: null, paid: null, on_hold: null };

  const effIssued = (st.issued === null || st.issued === undefined) ? baseIssued : !!st.issued;
  const effPaid   = (st.paid   === null || st.paid   === undefined) ? basePaid   : !!st.paid;

  if (purpose === 'status') {
    // Status pills clickable in edit mode (non-credit notes).
    return !!(mc && mc.isEditing);
  }

  // purpose === 'lines'
  // Lines can only be edited if invoice will be UNISSUED and UNPAID when saved.
  if (effPaid) return false;
  if (effIssued) return false;

  // Safety: allow only known terminal statuses (DRAFT/ON_HOLD ok; ISSUED/PAID ok only if staged to unissue/unpay,
  // which would have already passed effIssued/effPaid checks above).
  if (!(status === 'DRAFT' || status === 'ON_HOLD' || status === 'ISSUED' || status === 'PAID')) return false;

  return true;
}



function invoiceModalResetEdits(modalCtx) {
  if (!modalCtx) return;

  modalCtx.invoiceEdits = {
    remove_invoice_line_ids: new Set(),
    add_timesheet_ids: new Set(),
    add_adjustments: [],

    // segment edit staging (array of { tsfin_id, segment_id })
    remove_segment_refs: [],
    add_segment_refs: [],

    // âœ… References: support BOTH legacy array + new keyed staging model
    reference_updates: [],
    reference_updates_by_key: {},

    // status staging
    staged_status: { issued: null, paid: null, on_hold: null },
    staged_dates:  { issued_at_utc: null, paid_at_utc: null, status_date_utc: null }
  };

  // Keep eligibleTimesheetsCache; itâ€™s still valid across edits.

  // Keep invoiceState pointers/mirror consistent for showModal snapshot/restore.
  try {
    if (modalCtx.invoiceState && typeof modalCtx.invoiceState === 'object') {
      modalCtx.invoiceState.invoiceEdits = modalCtx.invoiceEdits;
      modalCtx.invoiceState.invoiceEdits_json = {
        remove_invoice_line_ids: [],
        add_timesheet_ids: [],
        add_adjustments: [],
        remove_segment_refs: [],
        add_segment_refs: [],
        reference_updates: [],
        reference_updates_by_key: {},
        staged_status: { issued: null, paid: null, on_hold: null },
        staged_dates: { issued_at_utc: null, paid_at_utc: null, status_date_utc: null }
      };
    }
  } catch {}
}
function invoiceModalHasPendingEdits(modalCtx) {
  const e = modalCtx?.invoiceEdits;
  if (!e) return false;

  const st = (e.staged_status && typeof e.staged_status === 'object')
    ? e.staged_status
    : null;

  const hasStagedStatus =
    !!st &&
    (
      (st.issued !== null && st.issued !== undefined) ||
      (st.paid !== null && st.paid !== undefined) ||
      (st.on_hold !== null && st.on_hold !== undefined)
    );

  const nonEmpty = (v) => {
    if (!v) return false;
    if (Array.isArray(v)) return v.length > 0;
    if (v instanceof Set || v instanceof Map) return v.size > 0;
    if (typeof v === 'object') return Object.keys(v).length > 0;
    return false;
  };

  const hasRefs =
    nonEmpty(e.reference_updates_by_key) ||
    nonEmpty(e.reference_updates_map) ||
    nonEmpty(e.reference_updates);

  return (
    hasStagedStatus ||
    (e.remove_invoice_line_ids && e.remove_invoice_line_ids.size > 0) ||
    (e.add_timesheet_ids && e.add_timesheet_ids.size > 0) ||
    (Array.isArray(e.add_adjustments) && e.add_adjustments.length > 0) ||
    nonEmpty(e.remove_segment_refs) ||
    nonEmpty(e.add_segment_refs) ||
    hasRefs
  );
}

function invoiceModalComputePreviewTotals(modalCtx) {
  const invData = invoiceModalGetInvoiceData(modalCtx);
  const { invoice, header_snapshot_json, items } = invData;

  const vatRatePct = invoiceModalGetVatRatePct(invoice, header_snapshot_json);

  const removed = modalCtx?.invoiceEdits?.remove_invoice_line_ids || new Set();
  const stagedAddTs = modalCtx?.invoiceEdits?.add_timesheet_ids || new Set();
  const stagedAdjs = Array.isArray(modalCtx?.invoiceEdits?.add_adjustments) ? modalCtx.invoiceEdits.add_adjustments : [];

  const stagedRemoveSeg = Array.isArray(modalCtx?.invoiceEdits?.remove_segment_refs) ? modalCtx.invoiceEdits.remove_segment_refs : [];
  const stagedAddSeg    = Array.isArray(modalCtx?.invoiceEdits?.add_segment_refs) ? modalCtx.invoiceEdits.add_segment_refs : [];

  let subtotal_ex_vat = 0;
  let vat_amount = 0;
  let total_inc_vat = 0;

  // Base: sum all existing invoice lines that are not staged for removal
  for (const it of (items || [])) {
    const lineId = it?.invoice_line_id;
    if (lineId && removed.has(String(lineId))) continue;

    subtotal_ex_vat += Number(it?.total_charge_ex_vat || 0);
    vat_amount += Number(it?.vat_amount || 0);
    total_inc_vat += Number(it?.total_inc_vat || 0);
  }

  // Add staged adjustments (preview VAT at invoice rate)
  for (const a of stagedAdjs) {
    const ex = Number(a?.amount_ex_vat || 0);
    const vat = ex * (vatRatePct / 100);
    subtotal_ex_vat += ex;
    vat_amount += vat;
    total_inc_vat += (ex + vat);
  }

  // Add staged timesheets using eligible-timesheets cache (segment-aware totals as provided by RPC)
  if (stagedAddTs.size > 0) {
    const cache = modalCtx?.eligibleTimesheetsCache;
    const arr = Array.isArray(cache?.timesheets) ? cache.timesheets : [];
    const byId = new Map(arr.map(t => [String(t?.timesheet_id || ''), t]));

    for (const tsId of stagedAddTs) {
      const t = byId.get(String(tsId));
      if (!t) continue;

      const ex = Number(t?.invoiceable_charge_ex_vat || 0);
      const vat = ex * (vatRatePct / 100);

      subtotal_ex_vat += ex;
      vat_amount += vat;
      total_inc_vat += (ex + vat);
    }
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Segment staging adjustments (remove/add segments)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const key = (tsfinId, segId) => `${String(tsfinId || '')}::${String(segId || '')}`;

  // Build lookup for segments currently on this invoice (manifest)
  const segMap =
    (invData?.segments_on_invoice_by_timesheet && typeof invData.segments_on_invoice_by_timesheet === 'object')
      ? invData.segments_on_invoice_by_timesheet
      : ((invData?.segments_by_timesheet && typeof invData.segments_by_timesheet === 'object')
          ? invData.segments_by_timesheet
          : {});

  const tsfinMap =
    (invData?.tsfin_id_by_timesheet_id && typeof invData.tsfin_id_by_timesheet_id === 'object')
      ? invData.tsfin_id_by_timesheet_id
      : {};

  const invoicedSegByKey = new Map();
  try {
    for (const tsId of Object.keys(segMap || {})) {
      const info = segMap[tsId];
      if (!info || typeof info !== 'object') continue;

      const tsfinId = (info.tsfin_id != null && String(info.tsfin_id).trim())
        ? String(info.tsfin_id)
        : (tsfinMap[tsId] != null ? String(tsfinMap[tsId]) : '');

      const segs = Array.isArray(info.invoiced_segments) ? info.invoiced_segments : [];
      if (!tsfinId || !segs.length) continue;

      for (const s of segs) {
        if (!s || typeof s !== 'object') continue;
        const segId = (s.segment_id != null && String(s.segment_id).trim()) ? String(s.segment_id) : '';
        if (!segId) continue;

        const chg = Number(
          (s.charge_amount != null ? s.charge_amount : (s['charge_amount'] != null ? s['charge_amount'] : 0))
        ) || 0;

        invoicedSegByKey.set(key(tsfinId, segId), { charge_amount: chg });
      }
    }
  } catch {}

  // Build lookup for eligible segments (eligible-timesheets cache)
  const eligibleSegByKey = new Map();
  try {
    const cache = modalCtx?.eligibleTimesheetsCache;
    const arr = Array.isArray(cache?.timesheets) ? cache.timesheets : [];
    for (const t of arr) {
      if (!t || typeof t !== 'object') continue;
      const tsfinId = (t.tsfin_id != null && String(t.tsfin_id).trim()) ? String(t.tsfin_id) : '';
      if (!tsfinId) continue;

      const segs = Array.isArray(t.eligible_segments) ? t.eligible_segments : [];
      for (const s of segs) {
        if (!s || typeof s !== 'object') continue;
        const segId = (s.segment_id != null && String(s.segment_id).trim()) ? String(s.segment_id) : '';
        if (!segId) continue;

        const chg = Number(s.charge_amount || 0) || 0;
        eligibleSegByKey.set(key(tsfinId, segId), { charge_amount: chg });
      }
    }
  } catch {}

  const applyDelta = (chargeEx, sign) => {
    const ex = Number(chargeEx || 0);
    if (!Number.isFinite(ex) || ex === 0) return;

    const vat = ex * (vatRatePct / 100);
    subtotal_ex_vat += sign * ex;
    vat_amount += sign * vat;
    total_inc_vat += sign * (ex + vat);
  };

  // Remove segments staged for removal (subtract their charge)
  for (const r of stagedRemoveSeg) {
    if (!r || typeof r !== 'object') continue;
    const k = key(r.tsfin_id, r.segment_id);
    const seg = invoicedSegByKey.get(k);
    if (!seg) continue;
    applyDelta(seg.charge_amount, -1);
  }

  // Add segments staged for add (add their charge)
  for (const r of stagedAddSeg) {
    if (!r || typeof r !== 'object') continue;
    const k = key(r.tsfin_id, r.segment_id);
    const seg = eligibleSegByKey.get(k);
    if (!seg) continue;
    applyDelta(seg.charge_amount, +1);
  }

  return {
    subtotal_ex_vat: invoiceModalRound2(subtotal_ex_vat),
    vat_amount: invoiceModalRound2(vat_amount),
    total_inc_vat: invoiceModalRound2(total_inc_vat)
  };
}

async function invoiceModalSaveEdits(modalCtx, { rerender, reload }) {
  // âœ… Single Save pipeline:
  //   1) hold/unhold (if staged)
  //   2) issue/unissue (if staged)
  //   3) paid/unpaid (if staged)
  //   4) apply edits (/save-edits) (lines + segments + references)
  //   5) reload + clear staging
  //   6) refresh the summary sheet behind the modal (so totals/columns update immediately)

  const invoiceId = modalCtx?.invoiceId ? String(modalCtx.invoiceId) : '';
  if (!invoiceId) throw new Error('Invoice id missing.');

  // Prefer the loaded invoice payload (openInvoiceModal stores it on dataLoaded)
  const inv =
    modalCtx?.dataLoaded?.invoice ||
    modalCtx?.dataLoaded?.invoice_row ||
    modalCtx?.data?.invoice ||
    null;

  if (!inv || typeof inv !== 'object') {
    throw new Error('Invoice not loaded.');
  }

  const type = String(inv.type || '').toUpperCase();
  if (type === 'CREDIT_NOTE') throw new Error('Credit notes cannot be edited.');

  // Current state
  const curStatus = String(inv.status || '').toUpperCase();
  const curIsHold = (curStatus === 'ON_HOLD');

  // Treat issued as either status ISSUED or issued_at_utc present (defensive)
  const curIsIssued = (curStatus === 'ISSUED') || !!inv.issued_at_utc;
  const curIsPaid = !!inv.paid_at_utc;

  // Staged status toggles
  const stagedStatus = (modalCtx?.invoiceEdits && typeof modalCtx.invoiceEdits === 'object' && modalCtx.invoiceEdits.staged_status && typeof modalCtx.invoiceEdits.staged_status === 'object')
    ? modalCtx.invoiceEdits.staged_status
    : {};

  // Optional legacy reason payload (existing codepath)
  const stagedReason = (modalCtx?.invoiceEdits && typeof modalCtx.invoiceEdits === 'object' && modalCtx.invoiceEdits.staged_reason && typeof modalCtx.invoiceEdits.staged_reason === 'object')
    ? modalCtx.invoiceEdits.staged_reason
    : {};

  const wantHold   = (Object.prototype.hasOwnProperty.call(stagedStatus, 'on_hold') && stagedStatus.on_hold != null) ? !!stagedStatus.on_hold : null;
  const wantIssued = (Object.prototype.hasOwnProperty.call(stagedStatus, 'issued')  && stagedStatus.issued  != null) ? !!stagedStatus.issued  : null;
  const wantPaid   = (Object.prototype.hasOwnProperty.call(stagedStatus, 'paid')    && stagedStatus.paid    != null) ? !!stagedStatus.paid    : null;

  const toast = (msg) => {
    try {
      if (typeof window.toast === 'function') return window.toast(msg);
      if (typeof window.showToast === 'function') return window.showToast(msg);
      if (typeof window.notify === 'function') return window.notify(msg);
      if (typeof window.__toast === 'function') return window.__toast(msg);
      console.log('[INV][TOAST]', msg);
    } catch {}
  };
  // âœ… NEW: Styled modal prompt (not window.confirm)
  // Returns true if user clicks "Yes, send now", otherwise false.
  const promptSendInvoiceEmailNow = async ({ toEmail } = {}) => {
    const to = (typeof toEmail === 'string' && toEmail.trim()) ? toEmail.trim() : '';

    const title = 'Send invoice by email now?';

    const renderTab = () => {
      const recipientLine = to ? `<div class="mini" style="margin-top:6px;"><b>Recipient:</b> ${escapeHtml(to)}</div>` : '';
      return `
        <div style="padding: 6px 2px;">
          <div style="font-size:14px; font-weight:700; margin-bottom:6px;">
            Do you want to send the newly issued invoice to the client by email now?
          </div>
          ${recipientLine}
          <div class="mini" style="margin-top:10px; color:#666;">
            If you choose â€œYesâ€, the email will be queued immediately. The PDF will be generated via the invoice PDF queue if needed.
          </div>

          <div style="display:flex; gap:10px; margin-top:14px;">
            <button id="btnInvSendEmailYes" type="button" class="btn btn-primary">Yes, send now</button>
            <button id="btnInvSendEmailNo"  type="button" class="btn btn-outline">No, not now</button>
          </div>
        </div>
      `;
    };

    return await new Promise((resolve) => {
      let done = false;
      const finish = (v) => {
        if (done) return;
        done = true;
        resolve(!!v);
      };

      // Utility modal: no Save footer, Close works as "No"
      showModal(
        title,
        [{ key: 'confirm', label: 'Confirm' }],
        () => renderTab(),
        null,
        true,
        null,
        {
          kind: 'invoice-send-email-confirm',
          noParentGate: true,
          showSave: false,
          showApply: false,
          onDismiss: () => finish(false)
        }
      );

      const wire = () => {
        const yes = document.getElementById('btnInvSendEmailYes');
        const no  = document.getElementById('btnInvSendEmailNo');

        if (yes && !yes.__wired) {
          yes.__wired = true;
          yes.onclick = () => {
            finish(true);
            try { document.getElementById('btnCloseModal')?.click(); } catch {}
          };
        }

        if (no && !no.__wired) {
          no.__wired = true;
          no.onclick = () => {
            finish(false);
            try { document.getElementById('btnCloseModal')?.click(); } catch {}
          };
        }
      };

      try {
        requestAnimationFrame(() => requestAnimationFrame(wire));
      } catch {
        setTimeout(wire, 0);
      }
    });
  };

  const nonEmpty = (v) => {
    if (!v) return false;
    if (Array.isArray(v)) return v.length > 0;
    if (v instanceof Set || v instanceof Map) return v.size > 0;
    if (typeof v === 'object') return Object.keys(v).length > 0;
    return false;
  };

  // âœ… Refresh the summary sheet behind the modal (best-effort)
  // IMPORTANT: never call renderSummary() with no rows (it expects an array).
  const refreshSummaryBehindModal = async () => {
    try {
      // Prefer captured summary context (set at modal-open in showModal/openInvoiceModal). Fallback to capture now.
      let ctx = (modalCtx && modalCtx.__summaryCtx) ? modalCtx.__summaryCtx : null;
      if (!ctx && typeof captureSummaryContextForModalOpen === 'function') {
        try { ctx = captureSummaryContextForModalOpen(); } catch { ctx = null; }
      }

      // If we have the summary patch pipeline available, use it
      if (typeof summaryFetchCanonicalRow === 'function' && typeof summaryApplySavedRecordToActiveSummary === 'function') {
        let canonical = null;
        try {
          canonical = await summaryFetchCanonicalRow('invoices', invoiceId, ctx);
        } catch {
          canonical = null;
        }

        if (canonical && typeof normalizeSavedRecordForSummary === 'function') {
          try { canonical = normalizeSavedRecordForSummary('invoices', canonical) || canonical; } catch {}
        }

        if (canonical && typeof canonical === 'object') {
          const r = await summaryApplySavedRecordToActiveSummary('invoices', canonical, ctx);
          if (r && r.ok) return;
        }
      }

      // Fallback: only use renderAll (safe full pipeline) â€” do NOT call renderSummary() with no args
      if (typeof window.renderAll === 'function') {
        await window.renderAll();
        return;
      }

      // Last resort: section-specific refresh helper, if you have one
      if (typeof window.refreshCurrentSummary === 'function') {
        await window.refreshCurrentSummary();
        return;
      }

    } catch (e) {
      try { console.warn('[INV][SAVE] summary refresh failed (non-fatal)', e); } catch {}
    }
  };

  // Build payload including only non-empty keys
  const e = (modalCtx?.invoiceEdits && typeof modalCtx.invoiceEdits === 'object') ? modalCtx.invoiceEdits : {};

  const remove_invoice_line_ids = Array.from(e.remove_invoice_line_ids || []);
  const add_timesheet_ids = Array.from(e.add_timesheet_ids || []);

  const add_adjustments = (Array.isArray(e.add_adjustments) ? e.add_adjustments : []).map(a => ({
    client_token: a.client_token,
    description: a.description,
    amount_ex_vat: a.amount_ex_vat
  })).filter(a => (a && (a.amount_ex_vat != null || (a.description && String(a.description).trim()))));

  const normSeg = (r) => {
    if (!r || typeof r !== 'object') return null;
    const tsfin_id = (r.tsfin_id != null) ? String(r.tsfin_id) : '';
    const segment_id = (r.segment_id != null) ? String(r.segment_id) : '';
    if (!tsfin_id || !segment_id) return null;
    return { tsfin_id, segment_id };
  };

  const remove_segment_refs = (Array.isArray(e.remove_segment_refs) ? e.remove_segment_refs : [])
    .map(normSeg)
    .filter(Boolean);

  const add_segment_refs = (Array.isArray(e.add_segment_refs) ? e.add_segment_refs : [])
    .map(normSeg)
    .filter(Boolean);

  // âœ… References: support new keyed staging model (object map) + Map + legacy array
  let reference_updates = [];
  if (nonEmpty(e.reference_updates_by_key)) {
    const keys = Object.keys(e.reference_updates_by_key || {}).sort(); // stable
    reference_updates = keys.map(k => e.reference_updates_by_key[k]).filter(x => x && typeof x === 'object');
  } else if (e.reference_updates_map instanceof Map && e.reference_updates_map.size > 0) {
    reference_updates = Array.from(e.reference_updates_map.values()).filter(x => x && typeof x === 'object');
  } else if (Array.isArray(e.reference_updates)) {
    reference_updates = e.reference_updates.filter(x => x && typeof x === 'object');
  }

  // Require timesheet_id for any ref update
  reference_updates = reference_updates.filter(u => {
    const tsId = (u && u.timesheet_id != null) ? String(u.timesheet_id).trim() : '';
    return !!tsId;
  });

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // âœ… Compile row-level ref edits into DB-applied updates
  // invoice_apply_edits only applies:
  //   reference_number, day_references_json, actual_schedule_json
  // (keyed by timesheet_id). Do NOT send row-level edits to DB.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const compileReferenceUpdatesForDb = (rowLevelUpdates) => {
    if (!Array.isArray(rowLevelUpdates) || rowLevelUpdates.length === 0) return [];

    // Prefer the pre-hydrated maps from invoice manifest/GET (zero extra calls).
    // NOTE: payloads may store these at:
    //  - modalCtx.timesheet_reference_sources_by_id
    //  - modalCtx.dataLoaded.timesheet_reference_sources_by_id
    //  - modalCtx.dataLoaded.manifest.timesheet_reference_sources_by_id
    const sourcesById =
      (modalCtx?.timesheet_reference_sources_by_id && typeof modalCtx.timesheet_reference_sources_by_id === 'object')
        ? modalCtx.timesheet_reference_sources_by_id
        : ((modalCtx?.dataLoaded?.timesheet_reference_sources_by_id && typeof modalCtx.dataLoaded.timesheet_reference_sources_by_id === 'object')
            ? modalCtx.dataLoaded.timesheet_reference_sources_by_id
            : ((modalCtx?.dataLoaded?.manifest?.timesheet_reference_sources_by_id && typeof modalCtx.dataLoaded.manifest.timesheet_reference_sources_by_id === 'object')
                ? modalCtx.dataLoaded.manifest.timesheet_reference_sources_by_id
                : null));

    const rowsByKey =
      (modalCtx?.reference_rows_by_key && typeof modalCtx.reference_rows_by_key === 'object')
        ? modalCtx.reference_rows_by_key
        : ((modalCtx?.dataLoaded?.reference_rows_by_key && typeof modalCtx.dataLoaded.reference_rows_by_key === 'object')
            ? modalCtx.dataLoaded.reference_rows_by_key
            : ((modalCtx?.dataLoaded?.manifest?.reference_rows_by_key && typeof modalCtx.dataLoaded.manifest.reference_rows_by_key === 'object')
                ? modalCtx.dataLoaded.manifest.reference_rows_by_key
                : null));

    if (!sourcesById || typeof sourcesById !== 'object') {
      throw new Error('Reference sources are missing on this invoice payload. Reload the invoice and try again.');
    }

    const normStr = (v) => (v == null ? '' : String(v).trim());
    const upperStr = (v) => normStr(v).toUpperCase();

    const deepClone = (v) => {
      if (v == null) return v;
      try { return JSON.parse(JSON.stringify(v)); } catch { return v; }
    };

    const toRefVal = (v) => {
      const s = normStr(v);
      return s ? s : null;
    };

    const getMeta = (u) => {
      const k = normStr(u?.row_key);
      if (k && rowsByKey && rowsByKey[k] && typeof rowsByKey[k] === 'object') return rowsByKey[k];
      return (u && typeof u === 'object') ? u : {};
    };

    const getTarget = (meta) => {
      return upperStr(meta?.ref_target || meta?.kind || meta?.target);
    };

    const getDay = (meta) => {
      return normStr(meta?.day_ymd || meta?.day_date || meta?.date);
    };

    const getSegId = (meta) => {
      return normStr(meta?.segment_id);
    };

    const getStart = (meta) => {
      return normStr(meta?.start_utc || meta?.start);
    };

    const getEnd = (meta) => {
      return normStr(meta?.end_utc || meta?.end);
    };

    // Group updates per timesheet_id
    const byTs = new Map();
    for (const u of rowLevelUpdates) {
      const tsid = normStr(u?.timesheet_id);
      if (!tsid) continue;
      if (!byTs.has(tsid)) byTs.set(tsid, []);
      byTs.get(tsid).push(u);
    }

    const tsIds = Array.from(byTs.keys()).sort();
    const out = [];

    for (const tsid of tsIds) {
      const base = (sourcesById[tsid] && typeof sourcesById[tsid] === 'object') ? sourcesById[tsid] : {};
      const baseRefNum = toRefVal(base.reference_number);

      const baseDayRefs =
        (base.day_references_json && typeof base.day_references_json === 'object' && !Array.isArray(base.day_references_json))
          ? base.day_references_json
          : null;

      const baseSched =
        Array.isArray(base.actual_schedule_json)
          ? base.actual_schedule_json
          : null;

      let newRefNum = baseRefNum;
      let newDayRefs = baseDayRefs ? deepClone(baseDayRefs) : null;
      let newSched = baseSched ? deepClone(baseSched) : null;

      let changedRefNum = false;
      let changedDayRefs = false;
      let changedSched = false;

      const updates = byTs.get(tsid) || [];

      for (const u of updates) {
        const meta = getMeta(u);
        const target = getTarget(meta);
        const val = toRefVal(u?.current_reference);

        if (target === 'TIMESHEET') {
          const prev = toRefVal(newRefNum);
          const next = toRefVal(val);
          if (prev !== next) {
            newRefNum = next;
            changedRefNum = true;
          }
          continue;
        }

        if (target === 'FREEFORM') {
          const day = getDay(meta);
          if (!day) continue;

          if (!newDayRefs || typeof newDayRefs !== 'object' || Array.isArray(newDayRefs)) {
            newDayRefs = {};
          }

          const prev = toRefVal(newDayRefs[day]);
          const next = toRefVal(val);

          if (next == null) {
            if (Object.prototype.hasOwnProperty.call(newDayRefs, day)) {
              delete newDayRefs[day];
              changedDayRefs = true;
            }
          } else {
            if (prev !== next) {
              newDayRefs[day] = next;
              changedDayRefs = true;
            }
          }

          // collapse empty map to null
          if (newDayRefs && typeof newDayRefs === 'object' && !Array.isArray(newDayRefs)) {
            if (Object.keys(newDayRefs).length === 0) newDayRefs = null;
          }

          continue;
        }

        if (target === 'SEGMENT') {
          // We require a schedule-like array (manual schedule OR TSFIN-derived SEGMENTS schedule from manifest).
          if (!Array.isArray(newSched) || newSched.length === 0) {
            throw new Error(`Cannot update segment reference(s): schedule is missing for timesheet ${tsid}. Reload the invoice and try again.`);
          }

          const segId = getSegId(meta);
          const start = getStart(meta);
          const end = getEnd(meta);

          // 1) Manual weekly index form: segment_id = "ts:<timesheet_id>:<idx>"
          if (segId && segId.startsWith(`ts:${tsid}:`)) {
            const parts = segId.split(':');
            const idxStr = parts[parts.length - 1];
            const idx = Number.parseInt(idxStr, 10);

            if (Number.isFinite(idx) && idx >= 0 && idx < newSched.length) {
              const seg = (newSched[idx] && typeof newSched[idx] === 'object') ? newSched[idx] : {};
              const prev = toRefVal(seg.ref_num);
              const next = toRefVal(val);

              if (prev !== next) {
                seg.ref_num = next;
                newSched[idx] = seg;
                changedSched = true;
              }
              continue;
            }

            throw new Error(`Cannot update segment reference: invalid segment index "${idxStr}" for timesheet ${tsid}.`);
          }

          // 2) Segment-id match (preferred for NHSP/HR/import segments; supports multi-shift/day)
          if (segId) {
            let foundById = -1;
            for (let i = 0; i < newSched.length; i++) {
              const seg = newSched[i];
              if (!seg || typeof seg !== 'object') continue;
              const sid = normStr(seg.segment_id);
              if (sid && sid === segId) { foundById = i; break; }
            }

            if (foundById >= 0) {
              const seg = (newSched[foundById] && typeof newSched[foundById] === 'object') ? newSched[foundById] : {};
              const prev = toRefVal(seg.ref_num);
              const next = toRefVal(val);

              if (prev !== next) {
                seg.ref_num = next;
                newSched[foundById] = seg;
                changedSched = true;
              }
              continue;
            }
          }

          // 3) Match by start/end window (fallback)
          if (!start || !end) {
            throw new Error(`Cannot update segment reference: missing start/end identifiers for timesheet ${tsid}.`);
          }

          let found = -1;
          for (let i = 0; i < newSched.length; i++) {
            const seg = newSched[i];
            if (!seg || typeof seg !== 'object') continue;

            const s1 = normStr(seg.start_utc || seg.start);
            const e1 = normStr(seg.end_utc || seg.end);

            if (s1 === start && e1 === end) {
              found = i;
              break;
            }
          }

          if (found < 0) {
            const sidTxt = segId ? ` seg_id=${segId}` : '';
            throw new Error(`Cannot update segment reference: no matching schedule entry for timesheet ${tsid}${sidTxt} (${start} â†’ ${end}).`);
          }

          const seg = (newSched[found] && typeof newSched[found] === 'object') ? newSched[found] : {};
          const prev = toRefVal(seg.ref_num);
          const next = toRefVal(val);

          if (prev !== next) {
            seg.ref_num = next;
            newSched[found] = seg;
            changedSched = true;
          }

          continue;
        }

        // Unknown target: ignore (defensive)
      }

      if (!changedRefNum && !changedDayRefs && !changedSched) continue;

      const obj = { timesheet_id: tsid };

      if (changedRefNum) obj.reference_number = newRefNum;

      if (changedDayRefs) {
        // If newDayRefs is null we send null (DB converts json null -> SQL null)
        obj.day_references_json = (newDayRefs && typeof newDayRefs === 'object' && !Array.isArray(newDayRefs)) ? newDayRefs : null;
      }

      if (changedSched) {
        // Never null-out schedule here; we only edit ref_num within existing entries
        obj.actual_schedule_json = Array.isArray(newSched) ? newSched : null;
      }

      out.push(obj);
    }

    return out;
  };

  // Compile now (but do NOT mutate staged row-level updates)
  const reference_updates_compiled = compileReferenceUpdatesForDb(reference_updates);

  const payload = {};
  if (remove_invoice_line_ids.length) payload.remove_invoice_line_ids = remove_invoice_line_ids;
  if (add_timesheet_ids.length) payload.add_timesheet_ids = add_timesheet_ids;
  if (add_adjustments.length) payload.add_adjustments = add_adjustments;
  if (remove_segment_refs.length) payload.remove_segment_refs = remove_segment_refs;
  if (add_segment_refs.length) payload.add_segment_refs = add_segment_refs;

  // âœ… Only send DB-applied compiled updates (never row-level edits)
  if (reference_updates_compiled.length) payload.reference_updates = reference_updates_compiled;

  const hasApplyEdits = Object.keys(payload).length > 0;

  // âœ… Confirm dialogs (status changes only)
  // (Do this BEFORE we mark the modal busy)
  if (wantHold !== null && wantHold !== curIsHold) {
    const ok = window.confirm(wantHold ? 'Put this invoice ON HOLD?' : 'Remove ON HOLD from this invoice?');
    if (!ok) return;
  }
  if (wantIssued !== null && wantIssued !== curIsIssued) {
    const ok = window.confirm(wantIssued ? 'Issue this invoice now?' : 'Unissue this invoice? (This will invalidate the PDF)');
    if (!ok) return;
  }
  if (wantPaid !== null && wantPaid !== curIsPaid) {
    const ok = window.confirm(wantPaid ? 'Mark this invoice as PAID?' : 'Mark this invoice as UNPAID?');
    if (!ok) return;
  }

  // âœ… Hard-block issuing while ON_HOLD (unless unhold is staged in this same save)
  if (wantIssued === true) {
    const effHold = (wantHold === null) ? curIsHold : !!wantHold;
    if (effHold) {
      throw new Error('Invoice is ON HOLD. Unhold first.');
    }
  }

  // If there are apply-edits staged, we must ensure invoice will NOT be ISSUED/PAID at apply time.
  if (hasApplyEdits) {
    const willStillBeIssued = (wantIssued == null) ? curIsIssued : wantIssued;
    if (willStillBeIssued) {
      throw new Error('Cannot edit invoice lines/segments/refs while invoice is ISSUED. Unissue first (staged) and Save again.');
    }

    const willStillBePaid = (wantPaid == null) ? curIsPaid : wantPaid;
    if (willStillBePaid) {
      throw new Error('Cannot edit invoice lines/segments/refs while invoice is PAID. Mark unpaid first (staged) and Save again.');
    }
  }

  modalCtx.isBusy = true;
  modalCtx.error = null;
  rerender();

  try {
    // 1) HOLD / UNHOLD
    if (wantHold !== null && wantHold !== curIsHold) {
      if (wantHold) {
        const reason = (typeof stagedReason.on_hold_reason === 'string' && stagedReason.on_hold_reason.trim())
          ? stagedReason.on_hold_reason.trim()
          : null;

        await invoiceModalFetchJson(`/api/invoices/${encodeURIComponent(invoiceId)}/hold`, {
          method: 'POST',
          body: JSON.stringify({ reason })
        });
      } else {
        await invoiceModalFetchJson(`/api/invoices/${encodeURIComponent(invoiceId)}/unhold`, {
          method: 'POST',
          body: JSON.stringify({})
        });
      }
    }

    // 2) ISSUE / UNISSUE
    if (wantIssued !== null && wantIssued !== curIsIssued) {
      if (wantIssued) {
        const issueRes = await invoiceModalFetchJson(`/api/invoices/${encodeURIComponent(invoiceId)}/issue`, {
          method: 'POST',
          body: JSON.stringify({})
        });

        const st2 = String(issueRes?.status || '').toUpperCase();
        if (st2 === 'ON_HOLD') {
          const reasons = Array.isArray(issueRes?.reasons) ? issueRes.reasons : [];
          const msg = reasons.length
            ? `Invoice is ON HOLD and cannot be issued: ${reasons.join(', ')}`
            : 'Invoice is ON HOLD and cannot be issued.';
          throw new Error(msg);
        }
        if (st2 !== 'ISSUED') {
          throw new Error('Failed to issue invoice.');
        }

        // âœ… NEW: Ask whether to email now (only if backend says eligible)
        const emailEligible = (issueRes?.email_eligible === true);

        if (emailEligible) {
          const sendNow = await promptSendInvoiceEmailNow({
            toEmail: issueRes?.email_to_suggest || issueRes?.email_to || null
          });

          if (sendNow) {
            try {
              await invoiceModalFetchJson(`/api/invoices/${encodeURIComponent(invoiceId)}/email`, {
                method: 'POST',
                body: JSON.stringify({})
              });
              toast('Invoice email queued.');
            } catch (err) {
              const msg = String(err?.message || err || 'Failed to queue invoice email.');
              toast(msg);
            }
          }
        }
      } else {
        // âœ… clear_pdf MUST be true on unissue (invalidate bundle)
        await invoiceModalFetchJson(`/api/invoices/${encodeURIComponent(invoiceId)}/unissue`, {
          method: 'POST',
          body: JSON.stringify({ clear_pdf: true })
        });
      }
    }

    // 3) PAID / UNPAID
    if (wantPaid !== null && wantPaid !== curIsPaid) {
      if (wantPaid) {
        const paid_date = (typeof stagedReason.paid_date === 'string' && stagedReason.paid_date.trim())
          ? stagedReason.paid_date.trim()
          : null;

        await invoiceModalFetchJson(`/api/invoices/${encodeURIComponent(invoiceId)}/mark-paid`, {
          method: 'POST',
          body: JSON.stringify(paid_date ? { paid_date } : {})
        });
      } else {
        await invoiceModalFetchJson(`/api/invoices/${encodeURIComponent(invoiceId)}/mark-unpaid`, {
          method: 'POST',
          body: JSON.stringify({})
        });
      }
    }

    // 4) APPLY EDITS (only if there are edits staged)
    if (hasApplyEdits) {
      try {
        const res = await invoiceModalFetchJson(`/api/invoices/${encodeURIComponent(invoiceId)}/save-edits`, {
          method: 'POST',
          body: JSON.stringify(payload)
        });

        const out = (res && typeof res === 'object') ? res : {};
        if (!out.ok) {
          throw new Error(out.error || 'Failed to save edits');
        }

        // invoice content changed â†’ eligibility cache must be treated as stale
        try {
          modalCtx.eligibleTimesheetsCache = null;
          modalCtx.eligibleTimesheetsCacheRev = null;
        } catch {}
      } catch (err) {
        const msg = String(err?.message || err || '');

        if (/Segment already invoiced/i.test(msg) || /already invoiced/i.test(msg) || /no longer available/i.test(msg)) {
          modalCtx.error =
            'This amended invoice cannot be saved because the timesheets you have selected are no longer available to invoice.';
          toast(modalCtx.error);
          rerender();
          throw err;
        }

        if (/Segments cannot be moved when additional rates exist/i.test(msg)) {
          modalCtx.error = 'Cannot move segments because this invoice contains additional rates. Remove additional rates or remove the whole timesheet instead.';
          toast(modalCtx.error);
          rerender();
          throw err;
        }

        if (/Segments cannot be moved when expenses or mileage exist/i.test(msg)) {
          modalCtx.error = 'Cannot move segments because this invoice contains expenses or mileage. Remove expenses/mileage or remove the whole timesheet instead.';
          toast(modalCtx.error);
          rerender();
          throw err;
        }

        modalCtx.error = msg || 'Failed to save invoice edits.';
        toast(modalCtx.error);
        rerender();
        throw err;
      }
    }

    // 5) Clear staged edits + exit edit mode
    invoiceModalResetEdits(modalCtx);
    modalCtx.isEditing = false;

    // Final reload (single source of truth)
    await reload();

    // âœ… Refresh the summary sheet behind the modal so the list updates immediately
    await refreshSummaryBehindModal();

  } finally {
    modalCtx.isBusy = false;
    rerender();
  }
}



function invoiceModalRound2(n) {
  const v = Number(n);
  if (!Number.isFinite(v)) return 0;
  return Math.round(v * 100) / 100;
}

function invoiceModalFmtHours(n) {
  const v = Number(n);
  if (!Number.isFinite(v)) return '0';
  const r = invoiceModalRound2(v);
  // Show up to 2dp, trim trailing .00
  return String(r.toFixed(2)).replace(/\.00$/, '');
}


function invoiceModalGetVatRatePct(invoice, header_snapshot_json) {
  // Prefer explicit invoice.vat_rate_pct if present; fall back to header snapshot VAT if present; else 0.
  const v1 = Number(invoice?.vat_rate_pct);
  if (Number.isFinite(v1)) return v1;

  const v2 = Number(header_snapshot_json?.vat_rate_pct ?? header_snapshot_json?.vat?.rate_pct);
  if (Number.isFinite(v2)) return v2;

  return 0;
}



function invoiceModalLookupEligibleTimesheet(modalCtx, timesheetId) {
  const cache = modalCtx?.eligibleTimesheetsCache;
  const arr = Array.isArray(cache?.timesheets) ? cache.timesheets : [];
  return arr.find(t => String(t?.timesheet_id || '') === String(timesheetId)) || null;
}

function invoiceModalToggleRemoveTimesheet(modalCtx, timesheetId) {
  const invData = invoiceModalGetInvoiceData(modalCtx);
  const { items, tsfin_id_by_timesheet_id, segments_on_invoice_by_timesheet, segments_by_timesheet } = invData;

  if (!modalCtx || !modalCtx.invoiceEdits) return;

  const set = (modalCtx.invoiceEdits.remove_invoice_line_ids instanceof Set)
    ? modalCtx.invoiceEdits.remove_invoice_line_ids
    : (modalCtx.invoiceEdits.remove_invoice_line_ids = new Set());

  const ts = String(timesheetId || '').trim();
  if (!ts) return;

  const lineIds = (items || [])
    .filter(it => String(it?.timesheet_id || '') === ts)
    .map(it => String(it?.invoice_line_id || ''))
    .filter(Boolean);

  if (!lineIds.length) return;

  const allAlready = lineIds.every(id => set.has(id));

  // If currently removed â†’ undo removal (do NOT resurrect any previously cleared segment staging)
  if (allAlready) {
    for (const id of lineIds) set.delete(id);
    return;
  }

  // Toggling removal ON: clear conflicting segment staging for this timesheet (by tsfin_id)
  try {
    const segMap =
      (segments_on_invoice_by_timesheet && typeof segments_on_invoice_by_timesheet === 'object')
        ? segments_on_invoice_by_timesheet
        : ((segments_by_timesheet && typeof segments_by_timesheet === 'object') ? segments_by_timesheet : {});

    const tsfinFromSegMap = (segMap && segMap[ts] && segMap[ts].tsfin_id != null) ? String(segMap[ts].tsfin_id).trim() : '';
    const tsfinFromMap = (tsfin_id_by_timesheet_id && tsfin_id_by_timesheet_id[ts] != null) ? String(tsfin_id_by_timesheet_id[ts]).trim() : '';
    const tsfinId = tsfinFromSegMap || tsfinFromMap;

    if (tsfinId) {
      // add_segment_refs
      if (Array.isArray(modalCtx.invoiceEdits.add_segment_refs)) {
        modalCtx.invoiceEdits.add_segment_refs =
          modalCtx.invoiceEdits.add_segment_refs.filter(r => String(r?.tsfin_id || '').trim() !== tsfinId);
      }

      // remove_segment_refs
      if (Array.isArray(modalCtx.invoiceEdits.remove_segment_refs)) {
        modalCtx.invoiceEdits.remove_segment_refs =
          modalCtx.invoiceEdits.remove_segment_refs.filter(r => String(r?.tsfin_id || '').trim() !== tsfinId);
      }
    }
  } catch {}

  // Stage whole-timesheet removal as before
  for (const id of lineIds) set.add(id);
}

async function invoiceModalReload(modalCtx, opts = {}) {
  const mc = modalCtx;
  if (!mc || typeof mc !== 'object') throw new Error('Missing modal context');

  const invoiceId = String(mc?.invoiceId || mc?.data?.id || '').trim();
  if (!invoiceId) throw new Error('Missing invoiceId');

  const {
    // if true, clear staged edits after reload (e.g., caller indicates Save success)
    clearEdits = false,

    // preserve active tab across reload (default true)
    preserveTab = true,

    // optional rerender callback
    rerender = null
  } = opts || {};

  const prevTab = preserveTab ? String(mc.activeTab || (mc.invoiceUi?.activeTab || 'invoice')) : null;

  mc.isBusy = true;
  mc.error = null;
  try { if (typeof rerender === 'function') rerender(); } catch {}

  try {
    // âœ… Single source of truth: one GET only, no correspondence/history follow-ups
    const payload = await invoiceModalFetchJson(`/api/invoices/${encodeURIComponent(invoiceId)}`);

    mc.dataLoaded = payload;
    mc.invoiceDetail = payload;
    mc.data = { id: invoiceId, ...(payload || {}) };

    // âœ… bump invoice revision (used to invalidate derived caches)
    mc.invoiceRev = Number(mc.invoiceRev || 0) + 1;

    // âœ… invoice has changed â†’ derived eligibility cache must be considered stale
    try {
      mc.eligibleTimesheetsCache = null;
      mc.eligibleTimesheetsCacheRev = null;
    } catch {}

    // Optionally clear staged edits (after successful Save)
    if (clearEdits) {
      invoiceModalResetEdits(mc); // already clears remove/add segment refs + reference_updates (per updated function)
    }

    // Preserve selected tab across reload
    if (preserveTab && prevTab) {
      mc.activeTab = prevTab;
      try {
        mc.invoiceUi = (mc.invoiceUi && typeof mc.invoiceUi === 'object') ? mc.invoiceUi : {};
        mc.invoiceUi.activeTab = prevTab;
      } catch {}
    }

    // Rehydrate through the same normalisation path used on open
    const invData = invoiceModalGetInvoiceData(mc);

    // Store commonly-needed manifest-derived fields onto modalCtx for zero-fetch child modals
    try {
      mc.manifest = invData.manifest;
      mc.segments_on_invoice_by_timesheet = invData.segments_on_invoice_by_timesheet;
      mc.segments_by_timesheet = invData.segments_by_timesheet;
      mc.tsfin_id_by_timesheet_id = invData.tsfin_id_by_timesheet_id;
      mc.history = invData.history;
      mc.reference_rows = invData.reference_rows;
      mc.timesheet_evidence = invData.timesheet_evidence;
      mc.evidence_other = invData.evidence_other;
      mc.evidence = invData.evidence;
      mc.email_summary = invData.email_summary;
      mc.attach_policy = invData.attach_policy;
    } catch {}

  } catch (e) {
    mc.error = String(e?.message || e || 'Failed to reload invoice');
    throw e;
  } finally {
    mc.isBusy = false;
    try { if (typeof rerender === 'function') rerender(); } catch {}
  }
}


function invoiceModalToggleRemoveLine(modalCtx, invoiceLineId) {
  const id = String(invoiceLineId || '').trim();
  if (!id) return;

  const set = modalCtx.invoiceEdits.remove_invoice_line_ids;
  if (set.has(id)) set.delete(id);
  else set.add(id);
}

function invoiceModalToggleAddTimesheet(modalCtx, timesheetId) {
  const id = String(timesheetId || '').trim();
  if (!id) return;

  const set = modalCtx.invoiceEdits.add_timesheet_ids;
  if (set.has(id)) set.delete(id);
  else set.add(id);
}

function invoiceModalRemoveStagedAdjustment(modalCtx, clientToken) {
  const tok = String(clientToken || '').trim();
  if (!tok) return;

  modalCtx.invoiceEdits.add_adjustments =
    (modalCtx.invoiceEdits.add_adjustments || []).filter(a => String(a?.client_token || '') !== tok);
}

function renderInvoiceModalShell(modalCtx) {
  const active = modalCtx.activeTab || 'invoice';

  const tabBtn = (key, label, opts = {}) => {
    const isActive = (key === active);
    const isDisabled = !!opts.disabled;
    const title = (isDisabled && opts.title) ? String(opts.title) : '';

    // IMPORTANT: do NOT use native disabled attribute (per platform rule).
    // Use .disabled / data-disabled="1" and block clicks via delegated handler.
    const cls = [
      'btn',
      'btn-sm',
      isActive ? 'btn-primary' : 'btn-outline-secondary',
      isDisabled ? 'disabled' : ''
    ].filter(Boolean).join(' ');

    return `
      <button type="button"
        class="${cls}"
        data-action="inv-set-tab"
        data-tab="${key}"
        ${isDisabled ? 'data-disabled="1"' : ''}
        ${title ? `title="${escapeHtml(title)}"` : ''}>
        ${label}
      </button>`;
  };

  if (modalCtx.error) {
    return `
      <div class="p-3">
        <div class="alert alert-danger mb-3">${escapeHtml(modalCtx.error)}</div>
        <button type="button" class="btn btn-sm btn-secondary" data-action="inv-close">Close</button>
      </div>`;
  }

  if (modalCtx.isBusy && !(modalCtx.data && modalCtx.data.invoice)) {
    return `<div class="p-3 text-muted">Loading invoiceâ€¦</div>`;
  }

  // Always use the normalised invoice data; renderers should prefer manifest fields.
  const invData = invoiceModalGetInvoiceData(modalCtx);

  const tabs = `
    <div class="d-flex gap-2 mb-3">
      ${tabBtn('invoice', 'Invoice')}
      ${tabBtn('evidence', 'Evidence')}
      ${tabBtn('history', 'Invoice History')}
    </div>`;

  let body = '';

  // Remove any correspondence codepath entirely.
  if (active === 'evidence') {
    // Evidence tab renderer will use invData.* arrays (timesheet_evidence, evidence_other, evidence)
    // If renderer doesn't exist yet, fall back to a friendly placeholder without breaking the modal.
    if (typeof renderInvoiceModalEvidenceTab === 'function') {
      body = renderInvoiceModalEvidenceTab(modalCtx, invData);
    } else {
      body = `<div class="text-muted">Evidence view not implemented yet.</div>`;
    }
  } else if (active === 'history') {
    // History tab renderer uses invData.history (manifest-enriched).
    if (typeof renderInvoiceModalHistoryTab === 'function') {
      body = renderInvoiceModalHistoryTab(modalCtx, invData);
    } else {
      body = `<div class="text-muted">Invoice history view not implemented yet.</div>`;
    }
  } else {
    // Default invoice view (header + lines/etc.) uses the same canonical payload.
    body = renderInvoiceModalContent(modalCtx, invData);
  }

  return `${tabs}${body}`;
}
function attachInvoiceModalDelegatedHandlers(modalCtx, rootEl, deps) {
  // NOTE:
  // - invModalRoot is frequently replaced by showModal.setTab() (modalBody.innerHTML swap)
  // - so binding click handlers to invModalRoot is fragile.
  // FIX:
  // - bind once to #modalBody (stable container) and gate by current frame + modalCtx identity.
  // - store attachment state on modalCtx, not on the DOM node.

  const mc = modalCtx || {};
  const body = document.getElementById('modalBody');

  if (!mc || typeof mc !== 'object') return;
  if (!body) return;

  const nonEmpty = (v) => {
    if (!v) return false;
    if (Array.isArray(v)) return v.length > 0;
    if (v instanceof Set || v instanceof Map) return v.size > 0;
    if (typeof v === 'object') return Object.keys(v).length > 0;
    return false;
  };

  const computePendingEdits = () => {
    try {
      // If a helper exists but hasn't been updated for the new ref-staging shape yet,
      // we must still detect reference edits here to keep Save enabled.
      if (typeof invoiceModalHasPendingEdits === 'function') {
        const r = !!invoiceModalHasPendingEdits(mc);
        if (r) return true;
      }

      // Fallback (also covers the new reference_updates_by_key / Map shape)
      const e = mc.invoiceEdits || {};

      const st = (e.staged_status && typeof e.staged_status === 'object')
        ? e.staged_status
        : { issued: null, paid: null, on_hold: null };

      const hasStatus =
        (st.issued !== null && st.issued !== undefined) ||
        (st.paid !== null && st.paid !== undefined) ||
        (st.on_hold !== null && st.on_hold !== undefined);

      const hasLines =
        (e.remove_invoice_line_ids && e.remove_invoice_line_ids.size > 0) ||
        (e.add_timesheet_ids && e.add_timesheet_ids.size > 0) ||
        (Array.isArray(e.add_adjustments) && e.add_adjustments.length > 0);

      const hasSeg =
        nonEmpty(e.remove_segment_refs) ||
        nonEmpty(e.add_segment_refs);

      // âœ… Support new keyed staging + legacy array (and Map, if used)
      const hasRefs =
        nonEmpty(e.reference_updates_by_key) ||
        nonEmpty(e.reference_updates_map) ||
        nonEmpty(e.reference_updates);

      return !!(hasStatus || hasLines || hasSeg || hasRefs);
    } catch {
      return false;
    }
  };

  const syncFrameDirty = () => {
    try {
      const fr = (typeof window.__getModalFrame === 'function') ? window.__getModalFrame() : null;
      if (!fr || fr.entity !== 'invoices' || fr.kind !== 'invoice-modal') return;
      if (fr._ctxRef !== mc) return;

      fr.isDirty = computePendingEdits();
      fr._updateButtons && fr._updateButtons();
    } catch {}
  };

  // Allow deps to be optional; create safe fallbacks so showModal can call this too.
  const safeRerender = (deps && typeof deps.rerender === 'function')
    ? deps.rerender
    : (() => {
        try {
          const fr = (typeof window.__getModalFrame === 'function') ? window.__getModalFrame() : null;
          if (fr && fr.entity === 'invoices' && fr.kind === 'invoice-modal' && fr._ctxRef === mc) {
            // âœ… Keep dirty state aligned BEFORE repaint (setTab preserves prevDirty)
            fr.isDirty = computePendingEdits();

            fr._suppressDirty = true;
            Promise.resolve(fr.setTab(fr.currentTabKey || 'invoice'))
              .finally(() => {
                fr._suppressDirty = false;
                // âœ… Ensure Save + Close label reflect dirty state
                syncFrameDirty();
              });
          }
        } catch {}
      });

  // âœ… safeReload now uses invoiceModalReload (single GET, preserve tab, no correspondence)
  const safeReload = (deps && typeof deps.reload === 'function')
    ? deps.reload
    : (async (opts = {}) => {
        try {
          // invoiceModalReload is the canonical path
          if (typeof invoiceModalReload === 'function') {
            await invoiceModalReload(mc, {
              clearEdits: !!opts.clearEdits,
              preserveTab: (opts.preserveTab !== false),
              rerender: safeRerender
            });
          } else {
            // Defensive fallback if invoiceModalReload not loaded yet
            const invoiceId = String(mc?.invoiceId || mc?.data?.id || '').trim();
            if (!invoiceId) return;

            const payload = await invoiceModalFetchJson(`/api/invoices/${encodeURIComponent(invoiceId)}`);

            mc.dataLoaded = payload;
            mc.invoiceDetail = payload;
            mc.data = { id: invoiceId, ...(payload || {}) };

            safeRerender();
          }
        } catch (e) {
          mc.error = String(e?.message || e || 'Failed to reload invoice');
          safeRerender();
        }
      });

  // If we previously attached, detach first (defensive, avoids duplicate handlers)
  try {
    if (mc.__invDelegated && mc.__invDelegated.targetEl && mc.__invDelegated.handler) {
      mc.__invDelegated.targetEl.removeEventListener('click', mc.__invDelegated.handler, true);
    }
    if (mc.__invDelegated && mc.__invDelegated.targetEl && mc.__invDelegated.changeHandler) {
      mc.__invDelegated.targetEl.removeEventListener('change', mc.__invDelegated.changeHandler, true);
    }
  } catch {}

  const setStaged = (k, v) => {
    mc.invoiceEdits = mc.invoiceEdits || {};
    mc.invoiceEdits.staged_status = (mc.invoiceEdits.staged_status && typeof mc.invoiceEdits.staged_status === 'object')
      ? mc.invoiceEdits.staged_status
      : { issued: null, paid: null, on_hold: null };

    mc.invoiceEdits.staged_dates = (mc.invoiceEdits.staged_dates && typeof mc.invoiceEdits.staged_dates === 'object')
      ? mc.invoiceEdits.staged_dates
      : { issued_at_utc: null, paid_at_utc: null, status_date_utc: null };

    mc.invoiceEdits.staged_status[k] = v;

    const now = new Date().toISOString();
    if (k === 'issued') mc.invoiceEdits.staged_dates.issued_at_utc = (v === true) ? now : null;
    if (k === 'paid')   mc.invoiceEdits.staged_dates.paid_at_utc   = (v === true) ? now : null;
    if (k === 'on_hold')mc.invoiceEdits.staged_dates.status_date_utc = (v === true) ? now : null;
  };

  const getEffectiveFlags = (invoice) => {
    const status = String(invoice?.status || '').toUpperCase();
    const baseIssued = !!invoice?.issued_at_utc || status === 'ISSUED';
    const basePaid   = !!invoice?.paid_at_utc   || status === 'PAID';
    const baseHold   = (status === 'ON_HOLD');

    const st = (mc?.invoiceEdits?.staged_status && typeof mc.invoiceEdits.staged_status === 'object')
      ? mc.invoiceEdits.staged_status
      : { issued: null, paid: null, on_hold: null };

    const effIssued = (st.issued === null || st.issued === undefined) ? baseIssued : !!st.issued;
    const effPaid   = (st.paid   === null || st.paid   === undefined) ? basePaid   : !!st.paid;
    const effHold   = (st.on_hold === null || st.on_hold === undefined) ? baseHold : !!st.on_hold;

    return { baseIssued, basePaid, baseHold, effIssued, effPaid, effHold };
  };

  const ensureSegArrays = () => {
    mc.invoiceEdits = mc.invoiceEdits || {};
    mc.invoiceEdits.remove_segment_refs = Array.isArray(mc.invoiceEdits.remove_segment_refs) ? mc.invoiceEdits.remove_segment_refs : [];
    mc.invoiceEdits.add_segment_refs = Array.isArray(mc.invoiceEdits.add_segment_refs) ? mc.invoiceEdits.add_segment_refs : [];

    // âœ… References: do NOT clobber the new keyed staging model.
    // Keep legacy array for back-compat if other code still reads it.
    if (!(mc.invoiceEdits.reference_updates instanceof Map) && !Array.isArray(mc.invoiceEdits.reference_updates)) {
      mc.invoiceEdits.reference_updates = [];
    }

    // New canonical keyed container (JSON-safe object map)
    if (!mc.invoiceEdits.reference_updates_by_key || typeof mc.invoiceEdits.reference_updates_by_key !== 'object' || Array.isArray(mc.invoiceEdits.reference_updates_by_key)) {
      mc.invoiceEdits.reference_updates_by_key = {};
    }
  };

  const segKey = (tsfinId, segId) => `${String(tsfinId || '')}::${String(segId || '')}`;

  const stageRemoveSegment = (tsfinId, segId, checked) => {
    ensureSegArrays();
    const tsfin_id = String(tsfinId || '').trim();
    const segment_id = String(segId || '').trim();
    if (!tsfin_id || !segment_id) return;

    const k = segKey(tsfin_id, segment_id);

    // remove existing occurrences
    for (let i = mc.invoiceEdits.remove_segment_refs.length - 1; i >= 0; i--) {
      const r = mc.invoiceEdits.remove_segment_refs[i];
      if (!r || typeof r !== 'object') continue;
      if (segKey(r.tsfin_id, r.segment_id) === k) {
        mc.invoiceEdits.remove_segment_refs.splice(i, 1);
      }
    }

    if (checked) {
      mc.invoiceEdits.remove_segment_refs.push({ tsfin_id, segment_id });
    }
  };

  // âœ… NEW: stage/unstage added segments (inv-toggle-add-segment)
  const stageAddSegment = (tsfinId, segId, tsId, checked) => {
    ensureSegArrays();
    const tsfin_id = String(tsfinId || '').trim();
    const segment_id = String(segId || '').trim();
    const timesheet_id = String(tsId || '').trim();
    if (!tsfin_id || !segment_id) return;

    const k = segKey(tsfin_id, segment_id);

    // remove existing occurrences
    for (let i = mc.invoiceEdits.add_segment_refs.length - 1; i >= 0; i--) {
      const r = mc.invoiceEdits.add_segment_refs[i];
      if (!r || typeof r !== 'object') continue;
      if (segKey(r.tsfin_id, r.segment_id) === k) {
        mc.invoiceEdits.add_segment_refs.splice(i, 1);
      }
    }

    if (checked) {
      // keep timesheet_id for UI merge/highlight; backend ignores extra fields when saving (normaliser strips it)
      mc.invoiceEdits.add_segment_refs.push({ tsfin_id, segment_id, timesheet_id });
    }
  };

  const getTsfinIdForTimesheet = (invData, tsId) => {
    const tid = String(tsId || '').trim();
    if (!tid) return '';

    // Prefer segments_on_invoice_by_timesheet[timesheet_id].tsfin_id
    const segMap =
      (invData?.segments_on_invoice_by_timesheet && typeof invData.segments_on_invoice_by_timesheet === 'object')
        ? invData.segments_on_invoice_by_timesheet
        : ((invData?.segments_by_timesheet && typeof invData.segments_by_timesheet === 'object')
            ? invData.segments_by_timesheet
            : {});
    const info = segMap && typeof segMap === 'object' ? segMap[tid] : null;

    const tsfin1 = (info && typeof info === 'object' && info.tsfin_id != null) ? String(info.tsfin_id).trim() : '';
    if (tsfin1) return tsfin1;

    const tsfinMap = (invData?.tsfin_id_by_timesheet_id && typeof invData.tsfin_id_by_timesheet_id === 'object')
      ? invData.tsfin_id_by_timesheet_id
      : {};
    const tsfin2 = (tsfinMap && tsfinMap[tid] != null) ? String(tsfinMap[tid]).trim() : '';
    return tsfin2 || '';
  };

  const stageRemoveAllSegmentsForTimesheet = (invData, tsId) => {
    const tid = String(tsId || '').trim();
    if (!tid) return;

    const segMap =
      (invData?.segments_on_invoice_by_timesheet && typeof invData.segments_on_invoice_by_timesheet === 'object')
        ? invData.segments_on_invoice_by_timesheet
        : ((invData?.segments_by_timesheet && typeof invData.segments_by_timesheet === 'object')
            ? invData.segments_by_timesheet
            : {});
    const info = segMap && typeof segMap === 'object' ? segMap[tid] : null;
    const segs = (info && typeof info === 'object' && Array.isArray(info.invoiced_segments)) ? info.invoiced_segments : [];
    if (!segs.length) return;

    const tsfinId = getTsfinIdForTimesheet(invData, tid);
    if (!tsfinId) return;

    for (const s of segs) {
      if (!s || typeof s !== 'object') continue;
      const segId = (s.segment_id != null) ? String(s.segment_id).trim() : '';
      if (!segId) continue;
      stageRemoveSegment(tsfinId, segId, true);
    }
  };

  const handler = async (e) => {
    // Gate: only respond when invoice modal is the TOP frame and its ctx is this mc.
    const fr = (typeof window.__getModalFrame === 'function') ? window.__getModalFrame() : null;
    if (!fr || fr.entity !== 'invoices' || fr.kind !== 'invoice-modal') return;
    if (fr._ctxRef !== mc) return;

    // âœ… Keep mc.isEditing consistent with the actual frame mode
    mc.isEditing = (fr.mode === 'edit' || fr.mode === 'create');

    const el = e.target?.closest?.('[data-action]');
    if (!el) return;

    const action = el.getAttribute('data-action');
    if (!action) return;

    // Respect disabled tab convention and general disabled buttons:
    // - DO NOT rely on native disabled for tabs.
    // - Block if data-disabled="1" or has .disabled
    try {
      if (el.getAttribute('data-disabled') === '1' || el.getAttribute('data-disabled') === 'true' || el.classList.contains('disabled')) {
        return;
      }
      if (el.disabled === true) return;
    } catch {}

    e.preventDefault();

    const invData = invoiceModalGetInvoiceData(mc);
    const { invoice, header_snapshot_json, items } = invData;

    try {
      switch (action) {
        case 'inv-close': {
          try { document.getElementById('btnCloseModal')?.click(); } catch {}
          return;
        }

        case 'inv-set-tab': {
          const tab = String(el.getAttribute('data-tab') || 'invoice').trim().toLowerCase();
          const allowed = (tab === 'invoice' || tab === 'evidence' || tab === 'history');
          mc.activeTab = allowed ? tab : 'invoice';

          try {
            mc.invoiceUi = (mc.invoiceUi && typeof mc.invoiceUi === 'object') ? mc.invoiceUi : {};
            mc.invoiceUi.activeTab = mc.activeTab;
          } catch {}

          safeRerender();
          return;
        }

        case 'inv-open-pdf': {
          if (typeof handleInvoiceRenderPdf === 'function') {
            await handleInvoiceRenderPdf(mc, { invoice, header_snapshot_json, items });
          }
          await safeReload();
          return;
        }

        case 'inv-email': {
          if (invoice && invoice.do_not_send === true) {
            mc.error = 'Do not send invoice (closeout).';
            safeRerender();
            return;
          }
          if (typeof handleInvoiceEmail === 'function') {
            await handleInvoiceEmail(mc, { invoice, header_snapshot_json, items });
          }
          await safeReload();
          return;
        }

        case 'inv-open-reference-numbers': {
          if (typeof openInvoiceReferenceNumbersModal === 'function') {
            await openInvoiceReferenceNumbersModal(mc, { rerender: safeRerender });
          }
          syncFrameDirty();
          safeRerender();
          return;
        }

        case 'inv-toggle-expand-timesheet': {
          const tsId = String(el.getAttribute('data-timesheet-id') || '').trim();
          if (!tsId) return;

          mc.invoiceUi = (mc.invoiceUi && typeof mc.invoiceUi === 'object') ? mc.invoiceUi : {};
          mc.invoiceUi.expanded_timesheets = (mc.invoiceUi.expanded_timesheets && typeof mc.invoiceUi.expanded_timesheets === 'object')
            ? mc.invoiceUi.expanded_timesheets
            : {};

          const cur = !!mc.invoiceUi.expanded_timesheets[tsId];
          if (cur) delete mc.invoiceUi.expanded_timesheets[tsId];
          else mc.invoiceUi.expanded_timesheets[tsId] = true;

          safeRerender();
          return;
        }

        case 'inv-toggle-issued': {
          if (!mc.isEditing || !invoiceModalIsEditable(invoice, mc, 'status')) return;

          const { effIssued, effPaid, effHold } = getEffectiveFlags(invoice);

          if (effIssued === true && effPaid === true) {
            mc.error = 'Unpay invoice first (then unissue).';
            safeRerender();
            return;
          }

          const desired = !effIssued;

          // âœ… Hard-block issuing when (effective) ON_HOLD
          if (desired === true && effHold === true) {
            alert('Unhold invoice first.');
            return;
          }

          // âœ… Confirm issue/unissue
          const ok = window.confirm(desired ? 'Are you sure you want to issue this invoice?' : 'Are you sure you want to unissue this invoice?');
          if (!ok) return;

          setStaged('issued', desired);
          syncFrameDirty();
          safeRerender();
          return;
        }

        case 'inv-toggle-paid': {
          if (!mc.isEditing || !invoiceModalIsEditable(invoice, mc, 'status')) return;

          const { effPaid } = getEffectiveFlags(invoice);
          const desired = !effPaid;

          // âœ… Confirm paid/unpaid
          const ok = window.confirm(desired ? 'Are you sure you want to mark this invoice as paid?' : 'Are you sure you want to mark this invoice as unpaid?');
          if (!ok) return;

          setStaged('paid', desired);
          syncFrameDirty();
          safeRerender();
          return;
        }

        case 'inv-toggle-hold': {
          if (!mc.isEditing || !invoiceModalIsEditable(invoice, mc, 'status')) return;

          const { effHold } = getEffectiveFlags(invoice);
          const desired = !effHold;

          // âœ… Confirm hold/unhold
          const ok = window.confirm(desired ? 'Are you sure you want to put this invoice on hold?' : 'Are you sure you want to remove the hold from this invoice?');
          if (!ok) return;

          setStaged('on_hold', desired);
          syncFrameDirty();
          safeRerender();
          return;
        }

        case 'inv-add-timesheets': {
          if (!mc.isEditing) return;
          await openInvoiceAddTimesheetsModal(mc, { rerender: safeRerender });
          syncFrameDirty();
          safeRerender();
          return;
        }

        case 'inv-add-adjustment': {
          if (!mc.isEditing) return;
          await openInvoiceAddAdjustmentModal(mc, { rerender: safeRerender });
          syncFrameDirty();
          safeRerender();
          return;
        }

        case 'inv-toggle-remove-timesheet': {
          if (!mc.isEditing) return;
          if (!invoiceModalIsEditable(invoice, mc, 'lines')) {
            mc.error = 'Unissue and unpay invoice first.';
            safeRerender();
            return;
          }
          const tsId = el.getAttribute('data-timesheet-id');
          invoiceModalToggleRemoveTimesheet(mc, tsId);
          syncFrameDirty();
          safeRerender();
          return;
        }

        case 'inv-toggle-remove-line': {
          if (!mc.isEditing) return;
          if (!invoiceModalIsEditable(invoice, mc, 'lines')) {
            mc.error = 'Unissue and unpay invoice first.';
            safeRerender();
            return;
          }
          const lineId = el.getAttribute('data-invoice-line-id');
          invoiceModalToggleRemoveLine(mc, lineId);
          syncFrameDirty();
          safeRerender();
          return;
        }

        case 'inv-unstage-add-timesheet': {
          if (!mc.isEditing) return;
          const tsId = el.getAttribute('data-timesheet-id');
          invoiceModalToggleAddTimesheet(mc, tsId);
          syncFrameDirty();
          safeRerender();
          return;
        }

        case 'inv-remove-staged-adjustment': {
          if (!mc.isEditing) return;
          const tok = el.getAttribute('data-client-token');
          invoiceModalRemoveStagedAdjustment(mc, tok);
          syncFrameDirty();
          safeRerender();
          return;
        }

        case 'inv-toggle-remove-segment': {
          if (!mc.isEditing) return;
          if (!invoiceModalIsEditable(invoice, mc, 'lines')) {
            mc.error = 'Unissue and unpay invoice first.';
            safeRerender();
            return;
          }
          ensureSegArrays();

          const tsId = String(el.getAttribute('data-timesheet-id') || '').trim();
          const segId = String(el.getAttribute('data-segment-id') || '').trim();
          let tsfinId = String(el.getAttribute('data-tsfin-id') || '').trim();

          if (!tsfinId) {
            tsfinId = getTsfinIdForTimesheet(invData, tsId);
          }

          const inp = e.target && (e.target.matches && e.target.matches('input[type="checkbox"]')) ? e.target : null;
          const checked = inp ? !!inp.checked : true;

          stageRemoveSegment(tsfinId, segId, checked);

          syncFrameDirty();
          safeRerender();
          return;
        }

        // âœ… NEW: allow un-staging staged-added segments from the invoice modal
        case 'inv-toggle-add-segment': {
          if (!mc.isEditing) return;
          if (!invoiceModalIsEditable(invoice, mc, 'lines')) {
            mc.error = 'Unissue and unpay invoice first.';
            safeRerender();
            return;
          }
          ensureSegArrays();

          const tsId = String(el.getAttribute('data-timesheet-id') || '').trim();
          const segId = String(el.getAttribute('data-segment-id') || '').trim();
          let tsfinId = String(el.getAttribute('data-tsfin-id') || '').trim();
          if (!tsfinId) tsfinId = getTsfinIdForTimesheet(invData, tsId);

          // Because click handler uses preventDefault, make checkbox toggle explicit
          const inp = e.target && (e.target.matches && e.target.matches('input[type="checkbox"]')) ? e.target : null;
          const desired = inp ? !inp.checked : true;
          if (inp) inp.checked = desired;

          stageAddSegment(tsfinId, segId, tsId, desired);

          syncFrameDirty();
          safeRerender();
          return;
        }

        case 'inv-stage-remove-selected-segments': {
          if (!mc.isEditing) return;
          if (!invoiceModalIsEditable(invoice, mc, 'lines')) {
            mc.error = 'Unissue and unpay invoice first.';
            safeRerender();
            return;
          }
          ensureSegArrays();

          const tsId = String(el.getAttribute('data-timesheet-id') || '').trim();
          const tsfinFromBtn = String(el.getAttribute('data-tsfin-id') || '').trim();
          const tsfinId = tsfinFromBtn || getTsfinIdForTimesheet(invData, tsId);
          if (!tsId || !tsfinId) return;

          const checks = Array.from(body.querySelectorAll(`input[type="checkbox"][data-action="inv-toggle-remove-segment"][data-timesheet-id="${CSS.escape(tsId)}"]`));
          for (const c of checks) {
            const segId = String(c.getAttribute('data-segment-id') || '').trim();
            if (!segId) continue;
            if (c.checked) stageRemoveSegment(tsfinId, segId, true);
          }

          syncFrameDirty();
          safeRerender();
          return;
        }

        case 'inv-stage-remove-all-segments': {
          if (!mc.isEditing) return;
          if (!invoiceModalIsEditable(invoice, mc, 'lines')) {
            mc.error = 'Unissue and unpay invoice first.';
            safeRerender();
            return;
          }
          ensureSegArrays();

          const tsId = String(el.getAttribute('data-timesheet-id') || '').trim();
          if (!tsId) return;

          stageRemoveAllSegmentsForTimesheet(invData, tsId);

          syncFrameDirty();
          safeRerender();
          return;
        }

        default:
          return;
      }
    } catch (err) {
      const msg = String(err?.message || err || 'Action failed');

      if (/Segments cannot be moved when additional rates exist/i.test(msg)) {
        mc.error = 'Remove additional rates before moving segments.';
      } else if (/Segments cannot be moved when expenses or mileage exist/i.test(msg)) {
        mc.error = 'Remove expenses/mileage before moving segments.';
      } else {
        mc.error = msg;
      }

      safeRerender();
    }
  };

  const changeHandler = async (e) => {
    try {
      const fr = (typeof window.__getModalFrame === 'function') ? window.__getModalFrame() : null;
      if (!fr || fr.entity !== 'invoices' || fr.kind !== 'invoice-modal') return;
      if (fr._ctxRef !== mc) return;

      const target = e.target;
      if (!target) return;

      // remove-segment checkbox
      if (target.matches && target.matches('input[type="checkbox"][data-action="inv-toggle-remove-segment"]')) {
        const invData = invoiceModalGetInvoiceData(mc);
        const { invoice } = invData;

        mc.isEditing = (fr.mode === 'edit' || fr.mode === 'create');

        if (!mc.isEditing) return;
        if (!invoiceModalIsEditable(invoice, mc, 'lines')) return;

        ensureSegArrays();

        const tsId = String(target.getAttribute('data-timesheet-id') || '').trim();
        const segId = String(target.getAttribute('data-segment-id') || '').trim();
        let tsfinId = String(target.getAttribute('data-tsfin-id') || '').trim();
        if (!tsfinId) tsfinId = getTsfinIdForTimesheet(invData, tsId);

        stageRemoveSegment(tsfinId, segId, !!target.checked);

        syncFrameDirty();
        safeRerender();
        return;
      }

      // âœ… NEW: add-segment checkbox (staged add) â†’ unstage/restage
      if (target.matches && target.matches('input[type="checkbox"][data-action="inv-toggle-add-segment"]')) {
        const invData = invoiceModalGetInvoiceData(mc);
        const { invoice } = invData;

        mc.isEditing = (fr.mode === 'edit' || fr.mode === 'create');

        if (!mc.isEditing) return;
        if (!invoiceModalIsEditable(invoice, mc, 'lines')) return;

        ensureSegArrays();

        const tsId = String(target.getAttribute('data-timesheet-id') || '').trim();
        const segId = String(target.getAttribute('data-segment-id') || '').trim();
        let tsfinId = String(target.getAttribute('data-tsfin-id') || '').trim();
        if (!tsfinId) tsfinId = getTsfinIdForTimesheet(invData, tsId);

        stageAddSegment(tsfinId, segId, tsId, !!target.checked);

        syncFrameDirty();
        safeRerender();
        return;
      }
    } catch {}
  };

  body.addEventListener('click', handler, true);
  body.addEventListener('change', changeHandler, true);

  mc.__invDelegated = { targetEl: body, handler, changeHandler };

  try { if (rootEl) rootEl.__invDelegatedAttached = true; } catch {}

  syncFrameDirty();
}


async function openInvoiceModal(row) {
  // Invoice modal (staged edits, no MutationObserver loops)
  const fmtMoney = (n) => {
    const x = round2(Number(n || 0));
    const s = x.toFixed(2);
    return (x > 0 ? `+${s}` : s);
  };

  const invoiceId = row?.invoice_id || row?.id;
  if (!invoiceId) return;

  // Seed modal context BEFORE calling showModal so the frame snapshots it.
  const modalCtx = {
    entity: 'invoices',
    kind: 'invoice-modal',

    // keep stable id for Related menu + general modal framework
    data: { id: invoiceId },

    invoiceId,

    // stable token for modal framework + Related menu
    openToken: `invoice:${String(invoiceId)}:${Date.now()}`,

    activeTab: 'invoice',

    // Keep raw API payload
    dataLoaded: null,

    // âœ… Canonical invoice detail store used by existing helpers (handleInvoiceDelete expects this)
    invoiceDetail: null,

    // Track last-seen json snapshot signature so we can detect showModal restore
    _editsJsonSig: null,

    // Invoice edit staging buckets
    isEditing: false,
  invoiceEdits: {
  remove_invoice_line_ids: new Set(),
  add_timesheet_ids: new Set(),
  add_adjustments: [],

  // âœ… NEW: segment edit staging (array of { tsfin_id, segment_id })
  remove_segment_refs: [],
  add_segment_refs: [],

  // âœ… References: support BOTH legacy array + new keyed staging model
  reference_updates: [],
  reference_updates_by_key: {},

  // âœ… NEW: staged status toggles (null = unchanged, boolean = desired state)
  staged_status: { issued: null, paid: null, on_hold: null },

  // âœ… NEW: staged timestamps for UI preview (populated on click; committed on Save pipeline)
  staged_dates: { issued_at_utc: null, paid_at_utc: null, status_date_utc: null }
},


    // Cached eligible timesheets for Add Timesheet modal + preview totals
    eligibleTimesheetsCache: null,

    // UI state
    isBusy: true,
    error: null
  };

  const cloneJson = (v, fallback) => {
    try {
      return JSON.parse(JSON.stringify(v));
    } catch {
      return fallback;
    }
  };

  // Capture the active Summary context (so we can patch the invoices grid after save)
  try {
    if (typeof captureSummaryContextForModalOpen === 'function') {
      modalCtx.__summaryCtx = cloneJson(captureSummaryContextForModalOpen(), null);
    } else {
      modalCtx.__summaryCtx = null;
    }
  } catch {
    modalCtx.__summaryCtx = null;
  }

 const editsToJson = (e) => {
  const out = {
    remove_invoice_line_ids: [],
    add_timesheet_ids: [],
    add_adjustments: [],
    remove_segment_refs: [],
    add_segment_refs: [],
    reference_updates: [],
    reference_updates_by_key: {},
    staged_status: { issued: null, paid: null, on_hold: null },
    staged_dates: { issued_at_utc: null, paid_at_utc: null, status_date_utc: null }
  };

  if (!e || typeof e !== 'object') return out;

  // Sets â†’ arrays
  try {
    if (e.remove_invoice_line_ids && typeof e.remove_invoice_line_ids.size === 'number') {
      out.remove_invoice_line_ids = Array.from(e.remove_invoice_line_ids);
    }
  } catch {}

  try {
    if (e.add_timesheet_ids && typeof e.add_timesheet_ids.size === 'number') {
      out.add_timesheet_ids = Array.from(e.add_timesheet_ids);
    }
  } catch {}

  // arrays
  out.add_adjustments   = Array.isArray(e.add_adjustments) ? cloneJson(e.add_adjustments, []) : [];
  out.remove_segment_refs = Array.isArray(e.remove_segment_refs) ? cloneJson(e.remove_segment_refs, []) : [];
  out.add_segment_refs  = Array.isArray(e.add_segment_refs) ? cloneJson(e.add_segment_refs, []) : [];
  out.reference_updates = Array.isArray(e.reference_updates) ? cloneJson(e.reference_updates, []) : [];

  // âœ… keyed refs (JSON-safe object map)
  out.reference_updates_by_key =
    (e.reference_updates_by_key && typeof e.reference_updates_by_key === 'object' && !Array.isArray(e.reference_updates_by_key))
      ? cloneJson(e.reference_updates_by_key, {})
      : {};

  // staged objects
  if (e.staged_status && typeof e.staged_status === 'object') {
    out.staged_status = {
      issued: (e.staged_status.issued !== undefined ? e.staged_status.issued : null),
      paid: (e.staged_status.paid !== undefined ? e.staged_status.paid : null),
      on_hold: (e.staged_status.on_hold !== undefined ? e.staged_status.on_hold : null)
    };
  }

  if (e.staged_dates && typeof e.staged_dates === 'object') {
    out.staged_dates = {
      issued_at_utc: (e.staged_dates.issued_at_utc !== undefined ? e.staged_dates.issued_at_utc : null),
      paid_at_utc: (e.staged_dates.paid_at_utc !== undefined ? e.staged_dates.paid_at_utc : null),
      status_date_utc: (e.staged_dates.status_date_utc !== undefined ? e.staged_dates.status_date_utc : null)
    };
  }

  return out;
};


  // Mirror into fields showModal snapshots/restores
  modalCtx.invoiceState = {
    isEditing: false,

    // keep a runtime pointer for any existing code that expects this
    invoiceEdits: modalCtx.invoiceEdits,

    // âœ… JSON-safe mirror to survive showModal snapshot/restore
    invoiceEdits_json: editsToJson(modalCtx.invoiceEdits)
  };
  modalCtx.invoiceUi = {
    activeTab: modalCtx.activeTab,
    // âœ… track expanded rows in a JSON-safe way
    expanded_timesheets: {} // { [timesheet_id]: true }
  };

  // Debug convenience
  window.modalCtx = modalCtx;

  let root = null;

  const resetStagedStatus = () => {
    try {
      if (!modalCtx.invoiceEdits || typeof modalCtx.invoiceEdits !== 'object') return;
      modalCtx.invoiceEdits.staged_status = { issued: null, paid: null, on_hold: null };
      modalCtx.invoiceEdits.staged_dates = { issued_at_utc: null, paid_at_utc: null, status_date_utc: null };
    } catch {}
  };

  const ensureEditsRuntimeFromJson = () => {
    try {
      if (!modalCtx.invoiceState || typeof modalCtx.invoiceState !== 'object') {
        modalCtx.invoiceState = { isEditing: !!modalCtx.isEditing };
      }

      // Ensure json mirror exists (showModal will snapshot/restore this reliably)
      if (!modalCtx.invoiceState.invoiceEdits_json || typeof modalCtx.invoiceState.invoiceEdits_json !== 'object') {
        modalCtx.invoiceState.invoiceEdits_json = editsToJson(modalCtx.invoiceEdits);
      }

      const j = modalCtx.invoiceState.invoiceEdits_json || null;
      let sig = '';
      try { sig = j ? JSON.stringify(j) : ''; } catch { sig = ''; }

      if (!modalCtx.invoiceEdits || typeof modalCtx.invoiceEdits !== 'object') {
       modalCtx.invoiceEdits = {
  remove_invoice_line_ids: new Set(),
  add_timesheet_ids: new Set(),
  add_adjustments: [],
  remove_segment_refs: [],
  add_segment_refs: [],
  reference_updates: [],
  staged_status: { issued: null, paid: null, on_hold: null },
  staged_dates: { issued_at_utc: null, paid_at_utc: null, status_date_utc: null }
};
      }

      const e = modalCtx.invoiceEdits;

      const applyJson = () => {
        // Always rebuild from json mirror when it changes (handles showModal restore)
        e.remove_invoice_line_ids = new Set(Array.isArray(j?.remove_invoice_line_ids) ? j.remove_invoice_line_ids : []);
        e.add_timesheet_ids = new Set(Array.isArray(j?.add_timesheet_ids) ? j.add_timesheet_ids : []);

        e.add_adjustments = Array.isArray(j?.add_adjustments) ? cloneJson(j.add_adjustments, []) : [];
        e.remove_segment_refs = Array.isArray(j?.remove_segment_refs) ? cloneJson(j.remove_segment_refs, []) : [];
        e.add_segment_refs = Array.isArray(j?.add_segment_refs) ? cloneJson(j.add_segment_refs, []) : [];
       // âœ… Rehydrate refs (keyed is canonical; legacy array stays in sync)
const byKey =
  (j?.reference_updates_by_key && typeof j.reference_updates_by_key === 'object' && !Array.isArray(j.reference_updates_by_key))
    ? cloneJson(j.reference_updates_by_key, {})
    : {};

e.reference_updates_by_key = byKey;

if (byKey && typeof byKey === 'object' && Object.keys(byKey).length > 0) {
  const keys = Object.keys(byKey).sort();
  e.reference_updates = keys.map(k => byKey[k]).filter(x => x && typeof x === 'object');
} else {
  e.reference_updates = Array.isArray(j?.reference_updates) ? cloneJson(j.reference_updates, []) : [];
}

        e.staged_status = (j?.staged_status && typeof j.staged_status === 'object')
          ? { issued: j.staged_status.issued ?? null, paid: j.staged_status.paid ?? null, on_hold: j.staged_status.on_hold ?? null }
          : { issued: null, paid: null, on_hold: null };

        e.staged_dates = (j?.staged_dates && typeof j.staged_dates === 'object')
          ? { issued_at_utc: j.staged_dates.issued_at_utc ?? null, paid_at_utc: j.staged_dates.paid_at_utc ?? null, status_date_utc: j.staged_dates.status_date_utc ?? null }
          : { issued_at_utc: null, paid_at_utc: null, status_date_utc: null };
      };

      if (sig && sig !== modalCtx._editsJsonSig) {
        applyJson();
        modalCtx._editsJsonSig = sig;
      } else {
        // Ensure types (defensive) even when no restore occurred
        if (!(e.remove_invoice_line_ids instanceof Set)) {
          e.remove_invoice_line_ids = new Set(Array.isArray(j?.remove_invoice_line_ids) ? j.remove_invoice_line_ids : []);
        }
        if (!(e.add_timesheet_ids instanceof Set)) {
          e.add_timesheet_ids = new Set(Array.isArray(j?.add_timesheet_ids) ? j.add_timesheet_ids : []);
        }
        if (!Array.isArray(e.add_adjustments)) e.add_adjustments = Array.isArray(j?.add_adjustments) ? cloneJson(j.add_adjustments, []) : [];
        if (!Array.isArray(e.remove_segment_refs)) e.remove_segment_refs = Array.isArray(j?.remove_segment_refs) ? cloneJson(j.remove_segment_refs, []) : [];
        if (!Array.isArray(e.add_segment_refs)) e.add_segment_refs = Array.isArray(j?.add_segment_refs) ? cloneJson(j.add_segment_refs, []) : [];
        if (!Array.isArray(e.reference_updates)) e.reference_updates = Array.isArray(j?.reference_updates) ? cloneJson(j.reference_updates, []) : [];
        if (!e.staged_status || typeof e.staged_status !== 'object') {
          e.staged_status = (j?.staged_status && typeof j.staged_status === 'object')
            ? { issued: j.staged_status.issued ?? null, paid: j.staged_status.paid ?? null, on_hold: j.staged_status.on_hold ?? null }
            : { issued: null, paid: null, on_hold: null };
        }
        if (!e.staged_dates || typeof e.staged_dates !== 'object') {
          e.staged_dates = (j?.staged_dates && typeof j.staged_dates === 'object')
            ? { issued_at_utc: j.staged_dates.issued_at_utc ?? null, paid_at_utc: j.staged_dates.paid_at_utc ?? null, status_date_utc: j.staged_dates.status_date_utc ?? null }
            : { issued_at_utc: null, paid_at_utc: null, status_date_utc: null };
        }
      }

      // Keep runtime pointer mirrored for any existing code paths
      modalCtx.invoiceState.invoiceEdits = e;

      // Refresh json mirror so next snapshot is correct
      modalCtx.invoiceState.invoiceEdits_json = editsToJson(e);
      try { modalCtx._editsJsonSig = JSON.stringify(modalCtx.invoiceState.invoiceEdits_json || {}); } catch {}
    } catch {}
  };

  const ensureUiDefaults = () => {
    try {
      if (!modalCtx.invoiceUi || typeof modalCtx.invoiceUi !== 'object') {
        modalCtx.invoiceUi = { activeTab: modalCtx.activeTab, expanded_timesheets: {} };
      }

      // Restore tab state FROM invoiceUi (reverse sync) before rendering
      if (modalCtx.invoiceUi.activeTab) {
        modalCtx.activeTab = modalCtx.invoiceUi.activeTab;
      }

      // Ensure expanded_timesheets is a plain object
      const ex = modalCtx.invoiceUi.expanded_timesheets;
      if (!ex || typeof ex !== 'object' || Array.isArray(ex)) {
        modalCtx.invoiceUi.expanded_timesheets = {};
      }

      // Then push active tab back into invoiceUi for snapshot consistency
      modalCtx.invoiceUi.activeTab = modalCtx.activeTab;
    } catch {}
  };

  const safeHasPendingEdits = () => {
    try {
      if (typeof invoiceModalHasPendingEdits === 'function') {
        return !!invoiceModalHasPendingEdits(modalCtx);
      }
    } catch {}

    const e = modalCtx?.invoiceEdits;
    if (!e) return false;

    const st = e.staged_status || {};
    const hasStagedStatus =
      (st.issued !== null && st.issued !== undefined) ||
      (st.paid !== null && st.paid !== undefined) ||
      (st.on_hold !== null && st.on_hold !== undefined);

  const hasRefStaging =
  (e.reference_updates_by_key && typeof e.reference_updates_by_key === 'object' && !Array.isArray(e.reference_updates_by_key) && Object.keys(e.reference_updates_by_key).length > 0) ||
  (Array.isArray(e.reference_updates) && e.reference_updates.length > 0);

return (
  hasStagedStatus ||
  (e.remove_invoice_line_ids && e.remove_invoice_line_ids.size > 0) ||
  (e.add_timesheet_ids && e.add_timesheet_ids.size > 0) ||
  (Array.isArray(e.add_adjustments) && e.add_adjustments.length > 0) ||
  (Array.isArray(e.remove_segment_refs) && e.remove_segment_refs.length > 0) ||
  (Array.isArray(e.add_segment_refs) && e.add_segment_refs.length > 0) ||
  hasRefStaging
);

  };

  const syncEditingFromFrame = () => {
    try {
      const fr = (typeof window.__getModalFrame === 'function') ? window.__getModalFrame() : null;
      const inEdit = !!(fr && fr.entity === 'invoices' && fr.kind === 'invoice-modal' && (fr.mode === 'edit' || fr.mode === 'create'));
      modalCtx.isEditing = inEdit;
      if (modalCtx.invoiceState && typeof modalCtx.invoiceState === 'object') {
        modalCtx.invoiceState.isEditing = inEdit;
      }
    } catch {}
  };

  const ensureRootAndHandlers = () => {
    const el = document.getElementById('invModalRoot');
    if (!el) return null;

    if (el !== root) {
      root = el;
      try {
        attachInvoiceModalDelegatedHandlers(modalCtx, root, { rerender, reload });
      } catch {}
    } else {
      try {
        attachInvoiceModalDelegatedHandlers(modalCtx, root, { rerender, reload });
      } catch {}
    }
    return root;
  };

  const rerender = () => {
    // Ensure modal UI and edits survive showModal snapshot/restore
    ensureUiDefaults();
    ensureEditsRuntimeFromJson();

    // Keep snapshot mirrors aligned
    try {
      if (modalCtx.invoiceState && typeof modalCtx.invoiceState === 'object') {
        modalCtx.invoiceState.invoiceEdits = modalCtx.invoiceEdits;
        modalCtx.invoiceState.invoiceEdits_json = editsToJson(modalCtx.invoiceEdits);
        try { modalCtx._editsJsonSig = JSON.stringify(modalCtx.invoiceState.invoiceEdits_json || {}); } catch {}
      }
      if (modalCtx.invoiceUi && typeof modalCtx.invoiceUi === 'object') {
        modalCtx.invoiceUi.activeTab = modalCtx.activeTab;
      }
    } catch {}

    syncEditingFromFrame();

    const r = ensureRootAndHandlers();
    if (!r) return;

    r.innerHTML = renderInvoiceModalShell(modalCtx);

    // Keep showModal footer dirty state aligned
    try {
      const fr = (typeof window.__getModalFrame === 'function') ? window.__getModalFrame() : null;
      if (fr && fr.entity === 'invoices' && fr.kind === 'invoice-modal' && (fr.mode === 'edit' || fr.mode === 'create')) {
        fr.isDirty = safeHasPendingEdits();
        fr._updateButtons && fr._updateButtons();
      }
    } catch {}
  };

  // âœ… Reload wrapper wired to invoiceModalReload (single GET, preserve tab, no correspondence)
  const reload = async (opts = {}) => {
    try {
      await invoiceModalReload(modalCtx, {
        clearEdits: !!opts.clearEdits,
        preserveTab: (opts.preserveTab !== false),
        rerender
      });

      // âœ… Keep existing CREDIT_NOTE hard block (front-end only), and ensure staged buckets are cleared too.
      try {
        const inv = modalCtx?.data?.invoice || null;
        const typ = String(inv?.type || '').toUpperCase();
        if (typ === 'CREDIT_NOTE') {
          modalCtx.isEditing = false;
          if (modalCtx.invoiceState && typeof modalCtx.invoiceState === 'object') {
            modalCtx.invoiceState.isEditing = false;
          }
          invoiceModalResetEdits(modalCtx);
          resetStagedStatus();

          // Ensure new staging buckets are also cleared even if reset helper has not been extended yet
          try {
            if (modalCtx.invoiceEdits && typeof modalCtx.invoiceEdits === 'object') {
              if (Array.isArray(modalCtx.invoiceEdits.remove_segment_refs)) modalCtx.invoiceEdits.remove_segment_refs.length = 0;
              else modalCtx.invoiceEdits.remove_segment_refs = [];

              if (Array.isArray(modalCtx.invoiceEdits.add_segment_refs)) modalCtx.invoiceEdits.add_segment_refs.length = 0;
              else modalCtx.invoiceEdits.add_segment_refs = [];

              if (Array.isArray(modalCtx.invoiceEdits.reference_updates)) modalCtx.invoiceEdits.reference_updates.length = 0;
              else modalCtx.invoiceEdits.reference_updates = [];
            }
          } catch {}

          // Keep json mirror aligned after the forced reset
          try {
            if (modalCtx.invoiceState && typeof modalCtx.invoiceState === 'object') {
              modalCtx.invoiceState.invoiceEdits = modalCtx.invoiceEdits;
              modalCtx.invoiceState.invoiceEdits_json = editsToJson(modalCtx.invoiceEdits);
              try { modalCtx._editsJsonSig = JSON.stringify(modalCtx.invoiceState.invoiceEdits_json || {}); } catch {}
            }
          } catch {}
        }
      } catch {}

      rerender();
    } catch (e) {
      modalCtx.error = String(e?.message || e || 'Failed to load invoice');
      rerender();
    }
  };

  showModal(
    'Invoice',
    [{ key: 'invoice', label: 'Invoice' }],
    () => {
      // IMPORTANT: showModal re-renders by calling this function directly after snapshot/restore.
      // So we must ensure UI + edit state are re-synced BEFORE generating HTML.
      ensureUiDefaults();
      ensureEditsRuntimeFromJson();
      syncEditingFromFrame();

      try {
        if (modalCtx.invoiceState && typeof modalCtx.invoiceState === 'object') {
          modalCtx.invoiceState.invoiceEdits = modalCtx.invoiceEdits;
          modalCtx.invoiceState.invoiceEdits_json = editsToJson(modalCtx.invoiceEdits);
          try { modalCtx._editsJsonSig = JSON.stringify(modalCtx.invoiceState.invoiceEdits_json || {}); } catch {}
        }
        if (modalCtx.invoiceUi && typeof modalCtx.invoiceUi === 'object') {
          modalCtx.invoiceUi.activeTab = modalCtx.activeTab;
        }
      } catch {}

      return `
        <div id="invModalRoot">
          ${renderInvoiceModalShell(modalCtx)}
        </div>
      `;
    },
    async () => {
      if (!safeHasPendingEdits()) return true;

      await invoiceModalSaveEdits(modalCtx, { rerender, reload });

      // âœ… Patch the active summary grid row in-place (filter parity + obey sort)
      try {
        const ctx = modalCtx.__summaryCtx || null;

        if (
          ctx &&
          typeof isSummaryContextStillActive === 'function' &&
          typeof summaryFetchCanonicalRow === 'function' &&
          typeof summaryApplySavedRecordToActiveSummary === 'function'
        ) {
          if (isSummaryContextStillActive(ctx)) {
            const invId = (modalCtx?.data?.id || modalCtx?.invoiceId || invoiceId || null);
            if (invId) {
              let canonical = await summaryFetchCanonicalRow('invoices', invId);

              if (canonical && typeof normalizeSavedRecordForSummary === 'function') {
                canonical = normalizeSavedRecordForSummary('invoices', canonical) || canonical;
              }

              if (canonical && typeof canonical === 'object') {
                summaryApplySavedRecordToActiveSummary('invoices', canonical, ctx);
              }
            }
          }
        }
      } catch (e) {
        console.warn('[SUMMARY][INVOICES] summary patch failed (non-fatal)', e);
      }

      return { ok: true };
    },
    true,
    null,
    { kind: 'invoice-modal' }
  );

  ensureRootAndHandlers();
  rerender();

  const onModeChanged = () => {
    try {
      const fr = (typeof window.__getModalFrame === 'function') ? window.__getModalFrame() : null;
      if (!fr || fr.entity !== 'invoices' || fr.kind !== 'invoice-modal') return;
      ensureRootAndHandlers();
      rerender();
    } catch {}
  };
  window.addEventListener('modal-frame-mode-changed', onModeChanged);

  try {
    modalCtx._onDismiss = () => {
      try { window.removeEventListener('modal-frame-mode-changed', onModeChanged); } catch {}
    };
  } catch {}

  await reload();
}


function invoiceModalNewClientToken() {
  try {
    if (typeof crypto !== 'undefined' && crypto?.randomUUID) return crypto.randomUUID();
  } catch {}
  return `tok_${Date.now()}_${Math.random().toString(16).slice(2)}`;
}
async function openInvoiceAddAdjustmentModal(modalCtx, { rerender }) {
  const parentCtx = modalCtx; // âœ… stable reference
  const { invoice } = invoiceModalGetInvoiceData(parentCtx);

  // Ensure showModal uses the invoice modal ctx (shared context across modal stack)
  try { window.modalCtx = parentCtx; } catch {}

  // Determine whether user is allowed to edit lines right now (staging-aware)
  const canEditLines = invoiceModalIsEditable(invoice, parentCtx, 'lines');

  const status = String(invoice?.status || '').toUpperCase();
  const baseIssued = !!invoice?.issued_at_utc || status === 'ISSUED';
  const basePaid = !!invoice?.paid_at_utc || status === 'PAID';

  const st = (parentCtx?.invoiceEdits?.staged_status && typeof parentCtx.invoiceEdits.staged_status === 'object')
    ? parentCtx.invoiceEdits.staged_status
    : { issued: null, paid: null, on_hold: null };

  const effIssued = (st.issued === null || st.issued === undefined) ? baseIssued : !!st.issued;
  const effPaid = (st.paid === null || st.paid === undefined) ? basePaid : !!st.paid;

  let bannerHtml = '';
  if (!canEditLines) {
    if (effPaid) {
      bannerHtml = `
        <div class="alert alert-warning py-2 mb-3">
          <b>Unpay invoice first</b> (then unissue invoice).
        </div>
      `;
    } else if (effIssued) {
      bannerHtml = `
        <div class="alert alert-warning py-2 mb-3">
          <b>Unissue invoice first</b>.
        </div>
      `;
    } else {
      bannerHtml = `
        <div class="alert alert-warning py-2 mb-3">
          <b>Invoice is not editable</b>.
        </div>
      `;
    }
  }

  const disabledAttr = canEditLines ? '' : 'disabled';
  const disabledOpacity = canEditLines ? '' : 'opacity-50';

  const html = `
    <div class="p-3">
      <div class="h6 mb-3">Invoice Adjustment</div>

      ${bannerHtml}

      <div class="mb-2 ${disabledOpacity}">
        <label class="form-label small text-muted">Description</label>
        <input id="invAdjDesc" class="form-control" type="text" placeholder="e.g. Manual correction" ${disabledAttr} />
      </div>

      <div class="mb-2 ${disabledOpacity}">
        <label class="form-label small text-muted">Amount (ex VAT)</label>
        <input id="invAdjAmt" class="form-control" type="number" step="0.01" placeholder="0.00" ${disabledAttr} />
        <div class="text-muted small mt-1">Use a negative number for a credit/discount.</div>
      </div>

      <div class="d-flex justify-content-end gap-2 mt-3">
        <button type="button" class="btn btn-sm btn-secondary" id="invAdjCancel">Cancel</button>
        <button type="button" class="btn btn-sm btn-primary" id="invAdjAdd" ${canEditLines ? '' : 'disabled'}>Add adjustment</button>
      </div>
    </div>
  `;

  showModal(
    'Invoice Adjustment',
    [{ key: 'main', label: 'Adjustment' }],
    () => html,
    null,
    true,
    null,
    { kind: 'invoice-batch-add-adjustment', noParentGate: true, showSave: false, showApply: true }
  );

  const closeTop = () => {
    // Close ONLY the top frame (this child) using the stack-safe close button
    try { document.getElementById('btnCloseModal')?.click(); } catch {}
  };

  const btnCancel = document.getElementById('invAdjCancel');
  const btnAdd = document.getElementById('invAdjAdd');

  if (btnCancel && !btnCancel.__invWired) {
    btnCancel.__invWired = true;
    btnCancel.onclick = (e) => {
      e.preventDefault();
      closeTop();
    };
  }

  if (btnAdd && !btnAdd.__invWired) {
    btnAdd.__invWired = true;
    btnAdd.onclick = (e) => {
      e.preventDefault();

      // If selection is disabled (must unpay/unissue first), do nothing.
      if (!canEditLines) return;

      const desc = String(document.getElementById('invAdjDesc')?.value || '').trim();
      const amtRaw = document.getElementById('invAdjAmt')?.value;
      const amt = Number(amtRaw);

      if (!desc) {
        alert('Adjustment description is required.');
        return;
      }
      if (!Number.isFinite(amt)) {
        alert('Adjustment amount must be a valid number.');
        return;
      }

      // Stage ONLY on confirm
      parentCtx.invoiceEdits = parentCtx.invoiceEdits || {};
      parentCtx.invoiceEdits.add_adjustments = Array.isArray(parentCtx.invoiceEdits.add_adjustments)
        ? parentCtx.invoiceEdits.add_adjustments
        : [];

      parentCtx.invoiceEdits.add_adjustments.push({
        client_token: invoiceModalNewClientToken(),
        description: desc,
        amount_ex_vat: invoiceModalRound2(amt)
      });

      closeTop();

      // Ensure parent invoice modal reflects the staged change immediately
      try { setTimeout(() => { rerender && rerender(); }, 0); } catch {}
    };
  }
}

async function invoiceModalEnsureEligibleTimesheets(modalCtx, opts = {}) {
  const force = !!opts?.force;

  // One-call discipline (but safe invalidation via invoiceRev)
  const curRev = Number(modalCtx?.invoiceRev || 0);
  const cacheRev = Number(modalCtx?.eligibleTimesheetsCacheRev ?? -1);

  if (!force && modalCtx.eligibleTimesheetsCache && cacheRev === curRev) return modalCtx.eligibleTimesheetsCache;

  const invoiceId = modalCtx?.invoiceId;
  if (!invoiceId) throw new Error('Missing invoiceId');

  const res = await invoiceModalFetchJson(`/api/invoices/${encodeURIComponent(invoiceId)}/eligible-timesheets`);

  // Handler returns a JSON object; tolerate array wrapper just in case
  const obj = Array.isArray(res) ? (res[0] ?? {}) : (res ?? {});
  const list = Array.isArray(obj?.timesheets) ? obj.timesheets : [];

  // Build fast lookup maps for segment-level preview totals and UI
  // - byTimesheetId: timesheet_id -> timesheet object
  // - bySegKey: `${tsfin_id}::${segment_id}` -> segment object (from eligible_segments only)
  const byTimesheetId = new Map();
  const bySegKey = new Map();

  for (const t of list) {
    if (!t || typeof t !== 'object') continue;
    const tsId = String(t?.timesheet_id || '').trim();
    if (tsId) byTimesheetId.set(tsId, t);

    const tsfinId = String(t?.tsfin_id || '').trim();
    const segs = Array.isArray(t?.eligible_segments) ? t.eligible_segments : [];
    if (tsfinId && segs.length) {
      for (const s of segs) {
        if (!s || typeof s !== 'object') continue;
        const segId = String(s?.segment_id || '').trim();
        if (!segId) continue;
        bySegKey.set(`${tsfinId}::${segId}`, s);
      }
    }
  }

  // Cache full backend object + fast lookup helpers (no per-timesheet calls)
  obj._byTimesheetId = byTimesheetId;
  obj._bySegKey = bySegKey;

  modalCtx.eligibleTimesheetsCache = obj;
  modalCtx.eligibleTimesheetsCacheRev = curRev;

  return obj;
}

async function openInvoiceAddTimesheetsModal(modalCtx, { rerender }) {
  const parentCtx = modalCtx; // stable reference
  const invData = invoiceModalGetInvoiceData(parentCtx);
  const { invoice, items } = invData;

  try { window.modalCtx = parentCtx; } catch {}

  const fmtMoney = (n) => {
    const x = invoiceModalRound2(Number(n || 0));
    const s = x.toFixed(2);
    return (x > 0 ? `+${s}` : s);
  };

  const fmtHours = (n) => invoiceModalFmtHours(Number(n || 0));

  const canEditLines = invoiceModalIsEditable(invoice, parentCtx, 'lines');

  const status = String(invoice?.status || '').toUpperCase();
  const baseIssued = !!invoice?.issued_at_utc || status === 'ISSUED';
  const basePaid = !!invoice?.paid_at_utc || status === 'PAID';

  const st = (parentCtx?.invoiceEdits?.staged_status && typeof parentCtx.invoiceEdits.staged_status === 'object')
    ? parentCtx.invoiceEdits.staged_status
    : { issued: null, paid: null, on_hold: null };

  const effIssued = (st.issued === null || st.issued === undefined) ? baseIssued : !!st.issued;
  const effPaid = (st.paid === null || st.paid === undefined) ? basePaid : !!st.paid;

  let bannerHtml = '';
  if (!canEditLines) {
    if (effPaid) {
      bannerHtml = `
        <div class="alert alert-warning py-2 mb-3">
          <b>Unpay invoice first</b> (then unissue invoice).
        </div>
      `;
    } else if (effIssued) {
      bannerHtml = `
        <div class="alert alert-warning py-2 mb-3">
          <b>Unissue invoice first</b>.
        </div>
      `;
    } else {
      bannerHtml = `
        <div class="alert alert-warning py-2 mb-3">
          <b>Invoice is not editable</b>.
        </div>
      `;
    }
  }

  const eligible = await invoiceModalEnsureEligibleTimesheets(parentCtx);
  const all = Array.isArray(eligible?.timesheets) ? eligible.timesheets : [];

  const existingTs = new Set((items || []).map(it => String(it?.timesheet_id || '')).filter(Boolean));

  parentCtx.invoiceEdits = parentCtx.invoiceEdits || {};
  parentCtx.invoiceEdits.add_timesheet_ids = (parentCtx.invoiceEdits.add_timesheet_ids instanceof Set)
    ? parentCtx.invoiceEdits.add_timesheet_ids
    : new Set();

  parentCtx.invoiceEdits.add_segment_refs = Array.isArray(parentCtx.invoiceEdits.add_segment_refs)
    ? parentCtx.invoiceEdits.add_segment_refs
    : [];

  const stagedTs = parentCtx.invoiceEdits.add_timesheet_ids;
  const stagedSeg = parentCtx.invoiceEdits.add_segment_refs;

  const segKey = (tsfinId, segId) => `${String(tsfinId || '')}::${String(segId || '')}`;

  const segIsStaged = (tsfinId, segId) => {
    const k = segKey(tsfinId, segId);
    for (const r of stagedSeg) {
      if (!r || typeof r !== 'object') continue;
      if (segKey(r.tsfin_id, r.segment_id) === k) return true;
    }
    return false;
  };

  // NOTE: We stage timesheet_id as well for UI merge/highlight; backend ignores extra fields.
  const stageSeg = (tsfinId, segId, tsId, checked) => {
    const tsfin_id = String(tsfinId || '').trim();
    const segment_id = String(segId || '').trim();
    const timesheet_id = String(tsId || '').trim();
    if (!tsfin_id || !segment_id) return;

    const k = segKey(tsfin_id, segment_id);

    for (let i = stagedSeg.length - 1; i >= 0; i--) {
      const r = stagedSeg[i];
      if (!r || typeof r !== 'object') continue;
      if (segKey(r.tsfin_id, r.segment_id) === k) stagedSeg.splice(i, 1);
    }

    if (checked) stagedSeg.push({ tsfin_id, segment_id, timesheet_id });
  };

  const esc = (typeof escapeHtml === 'function') ? escapeHtml : (s) => String(s == null ? '' : s);

  const fmtDowDmy = (ymd) => {
    const s = String(ymd || '').slice(0, 10);
    const m = s.match(/^(\d{4})-(\d{2})-(\d{2})$/);
    if (!m) return s || 'â€”';
    const [, y, mo, d] = m;
    let dow = '';
    try {
      const dt = new Date(`${s}T00:00:00Z`);
      dow = dt.toLocaleDateString('en-GB', { weekday: 'short', timeZone: 'Europe/London' });
    } catch {}
    return `${dow || ''} ${d}/${mo}/${y}`.trim();
  };

  const isoToHHMM = (iso) => {
    try {
      const d = new Date(String(iso || ''));
      if (Number.isNaN(d.getTime())) return '';
      const t = d.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit', hour12: false, timeZone: 'Europe/London' });
      return String(t || '').replace(':', '');
    } catch { return ''; }
  };

  const isoToDowDmy = (iso) => {
    try {
      const d = new Date(String(iso || ''));
      if (Number.isNaN(d.getTime())) return '';
      const parts = new Intl.DateTimeFormat('en-GB', { timeZone: 'Europe/London', year: 'numeric', month: '2-digit', day: '2-digit', weekday: 'short' }).formatToParts(d);
      const get = (t) => (parts.find(p => p.type === t)?.value || '');
      const dd = get('day'), mm = get('month'), yy = get('year'), wd = get('weekday');
      return `${wd} ${dd}/${mm}/${yy}`.trim();
    } catch { return ''; }
  };

  const sumSegHours = (s) => (
    Number(s?.hours_day || 0) +
    Number(s?.hours_night || 0) +
    Number(s?.hours_sat || 0) +
    Number(s?.hours_sun || 0) +
    Number(s?.hours_bh || 0)
  );

  const rows = all.filter(t => {
    const id = String(t?.timesheet_id || '').trim();
    if (!id) return false;

    const mode = String(t?.invoice_breakdown_mode || '').toUpperCase();
    const isSegments = (mode === 'SEGMENTS');

    if (existingTs.has(id) && !isSegments) return false;

    if (isSegments) {
      const segs = Array.isArray(t?.eligible_segments) ? t.eligible_segments : [];
      if (!segs.length) return false;
    }

    return true;
  });

  // Build groups (one group per timesheet row; rendered as a table with expandable child table)
  const groups = rows.map((t) => {
    const tsId = String(t?.timesheet_id || '').trim();
    const mode = String(t?.invoice_breakdown_mode || '').toUpperCase();
    const isSegments = (mode === 'SEGMENTS');
    const tsfinId = String(t?.tsfin_id || '').trim();

    const candidate = String(t?.candidate_name || t?.candidate_id || '').trim() || 'â€”';
    const weYmd = String(t?.source_week_ending_date || '').trim();
    const weLabel = weYmd ? fmtDowDmy(weYmd) : 'â€”';

    let totalHrs = 0;
    let totalChg = 0;
    let totalPay = 0;

    const segs = Array.isArray(t?.eligible_segments) ? t.eligible_segments.slice() : [];

    if (isSegments) {
      for (const s of segs) {
        totalHrs += sumSegHours(s);
        totalChg += Number(s?.charge_amount || 0);
        totalPay += Number(s?.pay_amount || 0);
      }
    } else {
      totalHrs = Number(t?.invoiceable_hours || 0);
      totalChg = Number(t?.invoiceable_charge_ex_vat || 0);
      totalPay = Number(t?.invoiceable_pay_ex_vat || 0);
    }

    // sort segments by start time (London) / fallback by date
    if (isSegments && segs.length) {
      segs.sort((a, b) => {
        const ta = new Date(String(a?.start_utc || a?.start || '')).getTime();
        const tb = new Date(String(b?.start_utc || b?.start || '')).getTime();
        if (Number.isFinite(ta) && Number.isFinite(tb) && ta !== tb) return ta - tb;

        const da = String(a?.date || '');
        const db = String(b?.date || '');
        if (da && db && da !== db) return da < db ? -1 : 1;
        return 0;
      });
    }

    return {
      tsId,
      tsfinId,
      mode,
      isSegments,
      candidate,
      weLabel,
      totalHrs,
      totalChg,
      totalPay,
      segs,
      blockedByHr: !!t?.blocked_by_hr_validation
    };
  });

  const expanded = Object.create(null); // local state (collapsed by default)

  const groupRowHtml = (g) => {
    const disabled = (!!g.blockedByHr || !canEditLines);
    const disAttr = disabled ? 'disabled' : '';

    const typeLabel = g.isSegments ? 'Segments' : 'Timesheet';
    const hrsTxt = fmtHours(g.totalHrs);
    const chgTxt = fmtMoney(g.totalChg);
    const payTxt = fmtMoney(g.totalPay);

    const expBtn = g.isSegments
      ? `<button type="button" class="btn btn-sm btn-outline-secondary" data-invaddts="toggle" data-tsid="${esc(g.tsId)}">+</button>`
      : `<span class="text-muted">â€”</span>`;

    const allCheckbox = `
      <input type="checkbox"
        class="form-check-input"
        data-invaddts="all"
        data-tsid="${esc(g.tsId)}"
        ${disAttr}
      />
    `;

    return `
      <tr class="${disabled ? 'opacity-50' : ''}">
        <td style="width:36px;" class="text-center">${expBtn}</td>
        <td class="fw-semibold">${esc(g.candidate)}</td>
        <td>${esc(g.weLabel)}</td>
        <td>${esc(typeLabel)}</td>
        <td class="text-end">${esc(String(hrsTxt))}</td>
        <td class="text-end">${esc(String(chgTxt))}</td>
        <td class="text-end">${esc(String(payTxt))}</td>
        <td style="width:140px;" class="text-center">
          <div class="d-flex align-items-center justify-content-center gap-2">
            ${allCheckbox}
            <span class="mini">Add all eligible</span>
          </div>
        </td>
      </tr>
    `;
  };

  const segmentsTableHtml = (g) => {
    if (!g.isSegments) return '';
    const disabled = (!!g.blockedByHr || !canEditLines);
    const disAttr = disabled ? 'disabled' : '';

    const rowsHtml = g.segs.map((s) => {
      const segId = String(s?.segment_id || '').trim();
      const startIso = String(s?.start_utc || s?.start || '').trim();
      const endIso = String(s?.end_utc || s?.end || '').trim();

      const dateLabel = (() => {
        const raw = String(s?.date || '').slice(0, 10);
        if (/^\d{4}-\d{2}-\d{2}$/.test(raw)) return fmtDowDmy(raw);
        const fromIso = isoToDowDmy(startIso);
        return fromIso || 'â€”';
      })();

      const st = isoToHHMM(startIso);
      const en = isoToHHMM(endIso);
      const timeLabel = (st && en) ? `${st}â€“${en}` : 'â€”';

      const hrs = fmtHours(sumSegHours(s));
      const chg = fmtMoney(Number(s?.charge_amount || 0));
      const pay = fmtMoney(Number(s?.pay_amount || 0));
      const ref = String(s?.ref_num || '').trim() || 'â€”';

      const checked = segIsStaged(g.tsfinId, segId) ? 'checked' : '';

      return `
        <tr class="${disabled ? 'opacity-50' : ''}">
          <td style="width:36px;" class="text-center">
            <input type="checkbox"
              class="form-check-input"
              data-kind="seg"
              data-timesheet-id="${esc(g.tsId)}"
              data-tsfin-id="${esc(g.tsfinId)}"
              data-segment-id="${esc(segId)}"
              ${checked}
              ${disAttr}
            />
          </td>
          <td>${esc(dateLabel)}</td>
          <td>${esc(timeLabel)}</td>
          <td>${esc(ref)}</td>
          <td class="text-end">${esc(String(hrs))}</td>
          <td class="text-end">${esc(String(chg))}</td>
          <td class="text-end">${esc(String(pay))}</td>
        </tr>
      `;
    }).join('');

    return `
      <div class="mt-2">
        <table class="grid mini" style="width:100%;">
          <thead>
            <tr>
              <th style="width:36px;"></th>
              <th>Date</th>
              <th>Time</th>
              <th>Ref</th>
              <th class="text-end">Hours</th>
              <th class="text-end">Charge (ex VAT)</th>
              <th class="text-end">Pay (ex VAT)</th>
            </tr>
          </thead>
          <tbody>${rowsHtml}</tbody>
        </table>
      </div>
    `;
  };

  const tableHtml = `
    <table class="grid" style="width:100%;">
      <thead>
        <tr>
          <th style="width:36px;"></th>
          <th>Candidate</th>
          <th>Week ending</th>
          <th>Type</th>
          <th class="text-end">Eligible hours</th>
          <th class="text-end">Eligible charge</th>
          <th class="text-end">Eligible pay</th>
          <th style="width:140px;" class="text-center"></th>
        </tr>
      </thead>
      <tbody>
        ${groups.map(g => {
          const segWrap = g.isSegments ? `
            <tr data-invaddts="wrap" data-tsid="${esc(g.tsId)}" style="display:none;">
              <td colspan="8">
                ${segmentsTableHtml(g)}
              </td>
            </tr>
          ` : '';
          return groupRowHtml(g) + segWrap;
        }).join('')}
      </tbody>
    </table>
  `;

  const html = `
    <div class="p-3">
      <div class="h6 mb-3">Add Timesheets to Invoice</div>

      ${bannerHtml}

      <div class="text-muted small mb-2">
        Tick <b>Add all eligible</b> to add all eligible items in a group, or expand a Segments row to pick individual segments.
      </div>

      <div id="invAddTsTableWrap" class="mt-2">
        ${groups.length ? tableHtml : '<div class="text-muted">No eligible timesheets.</div>'}
      </div>

      <div class="d-flex justify-content-end gap-2 mt-3">
        <button type="button" class="btn btn-sm btn-secondary" id="invAddTsCancel">Cancel</button>
        <button type="button" class="btn btn-sm btn-primary" id="invAddTsConfirm"
          ${groups.length && canEditLines ? '' : 'disabled'}
        >Apply</button>
      </div>
    </div>
  `;

  showModal(
    'Add Timesheets',
    [{ key: 'main', label: 'Timesheets' }],
    () => html,
    null,
    true,
    null,
    { kind: 'invoice-batch-add-timesheets', noParentGate: true, showSave: false, showApply: true }
  );

  const closeTop = () => {
    try { document.getElementById('btnCloseModal')?.click(); } catch {}
  };

  const btnCancel = document.getElementById('invAddTsCancel');
  const btnConfirm = document.getElementById('invAddTsConfirm');

  // Wire expand/collapse + "add all" (DOM-only; staging happens on Apply)
  try {
    const wrap = document.getElementById('invAddTsTableWrap');
    if (wrap && !wrap.__invWired) {
      wrap.__invWired = true;

      wrap.addEventListener('click', (e) => {
        const btn = e.target?.closest?.('[data-invaddts="toggle"]');
        if (!btn) return;
        e.preventDefault();

        const tsId = String(btn.getAttribute('data-tsid') || '').trim();
        if (!tsId) return;

        const row = wrap.querySelector(`tr[data-invaddts="wrap"][data-tsid="${CSS.escape(tsId)}"]`);
        if (!row) return;

        const isOpen = (row.style.display !== 'none');
        row.style.display = isOpen ? 'none' : '';
        btn.textContent = isOpen ? '+' : 'â€“';
      }, true);

      wrap.addEventListener('change', (e) => {
        const c = e.target;
        if (!c || !(c.matches && c.matches('input[type="checkbox"][data-invaddts="all"]'))) return;

        const tsId = String(c.getAttribute('data-tsid') || '').trim();
        if (!tsId) return;

        const checked = !!c.checked;

        // If this is a SEGMENTS group: toggle all segment checkboxes in the wrapped row.
        const segWrap = wrap.querySelector(`tr[data-invaddts="wrap"][data-tsid="${CSS.escape(tsId)}"]`);
        if (segWrap) {
          const segChecks = Array.from(segWrap.querySelectorAll('input[type="checkbox"][data-kind="seg"]'));
          for (const sc of segChecks) {
            if (sc.disabled) continue;
            sc.checked = checked;
          }
          return;
        }

        // Non-segments: we don't render per-seg; treat group checkbox as the timesheet selection
        // by creating/updating an invisible selection input.
        // (Apply uses checkbox scanning; we stage this directly here.)
        if (checked) stagedTs.add(tsId);
        else stagedTs.delete(tsId);
      }, true);
    }
  } catch {}

  if (btnCancel && !btnCancel.__invWired) {
    btnCancel.__invWired = true;
    btnCancel.onclick = (e) => {
      e.preventDefault();
      closeTop();
    };
  }

  if (btnConfirm && !btnConfirm.__invWired) {
    btnConfirm.__invWired = true;
    btnConfirm.onclick = (e) => {
      e.preventDefault();
      if (!canEditLines) return;

      const wrap = document.getElementById('invAddTsTableWrap');
      if (!wrap) {
        closeTop();
        try { setTimeout(() => { rerender && rerender(); }, 0); } catch {}
        return;
      }

      // Stage segment additions from visible segment checkboxes
      const segChecks = Array.from(wrap.querySelectorAll('input[type="checkbox"][data-kind="seg"]'));
      for (const c of segChecks) {
        const tsId = String(c.getAttribute('data-timesheet-id') || '').trim();
        const tsfinId = String(c.getAttribute('data-tsfin-id') || '').trim();
        const segId = String(c.getAttribute('data-segment-id') || '').trim();
        if (!tsfinId || !segId) continue;
        stageSeg(tsfinId, segId, tsId, !!c.checked);
      }

      closeTop();
      try { setTimeout(() => { rerender && rerender(); }, 0); } catch {}
    };
  }
}

function invoiceModalGetInvoiceData(modalCtx) {
  const d = modalCtx?.data || {};

  try {
    if (modalCtx && modalCtx.__invoiceDataCache && modalCtx.__invoiceDataCacheRaw === d) {
      return modalCtx.__invoiceDataCache;
    }
  } catch {}

  const invoice = d.invoice || null;

  const header_snapshot_json =
    (d.header_snapshot_json && typeof d.header_snapshot_json === 'object')
      ? d.header_snapshot_json
      : (invoice?.header_snapshot_json && typeof invoice.header_snapshot_json === 'object' ? invoice.header_snapshot_json : {});

  const items = Array.isArray(d.items) ? d.items : [];

  const manifest =
    (d.manifest && typeof d.manifest === 'object')
      ? d.manifest
      : (invoice?.invoice_render_manifest && typeof invoice.invoice_render_manifest === 'object'
          ? invoice.invoice_render_manifest
          : null);

  let email_summary = null;
  if (d.email_summary && typeof d.email_summary === 'object') {
    email_summary = d.email_summary;
  } else if (manifest && typeof manifest === 'object' && manifest.email_summary && typeof manifest.email_summary === 'object') {
    email_summary = manifest.email_summary;
  }

  const attach_policy =
    (d.attach_policy && typeof d.attach_policy === 'object')
      ? d.attach_policy
      : ((manifest && typeof manifest === 'object' && manifest.attach_policy && typeof manifest.attach_policy === 'object')
          ? manifest.attach_policy
          : null);

  const evidence =
    Array.isArray(d.evidence) ? d.evidence
    : (Array.isArray(manifest?.evidence) ? manifest.evidence : []);

  const timesheet_evidence =
    Array.isArray(d.timesheet_evidence) ? d.timesheet_evidence
    : (Array.isArray(manifest?.timesheet_evidence) ? manifest.timesheet_evidence : []);

  const evidence_other =
    Array.isArray(d.evidence_other) ? d.evidence_other
    : (Array.isArray(manifest?.evidence_other) ? manifest.evidence_other : []);

  const segments_on_invoice_by_timesheet =
    (d.segments_on_invoice_by_timesheet && typeof d.segments_on_invoice_by_timesheet === 'object')
      ? d.segments_on_invoice_by_timesheet
      : ((d.segments_by_timesheet && typeof d.segments_by_timesheet === 'object')
          ? d.segments_by_timesheet
          : ((manifest?.segments_on_invoice_by_timesheet && typeof manifest.segments_on_invoice_by_timesheet === 'object')
              ? manifest.segments_on_invoice_by_timesheet
              : ((manifest?.segments_by_timesheet && typeof manifest.segments_by_timesheet === 'object')
                  ? manifest.segments_by_timesheet
                  : {})));

  const segments_by_timesheet = segments_on_invoice_by_timesheet;

  const history =
    Array.isArray(d.history) ? d.history
    : (Array.isArray(manifest?.history) ? manifest.history : []);

  const tsfin_id_by_timesheet_id =
    (d.tsfin_id_by_timesheet_id && typeof d.tsfin_id_by_timesheet_id === 'object')
      ? d.tsfin_id_by_timesheet_id
      : ((manifest?.tsfin_id_by_timesheet_id && typeof manifest.tsfin_id_by_timesheet_id === 'object')
          ? manifest.tsfin_id_by_timesheet_id
          : {});

  // âœ… NEW: reference source blobs (used by FE to compile DB-applied updates with zero extra calls)
  const timesheet_reference_sources_by_id =
    (d.timesheet_reference_sources_by_id && typeof d.timesheet_reference_sources_by_id === 'object')
      ? d.timesheet_reference_sources_by_id
      : ((manifest?.timesheet_reference_sources_by_id && typeof manifest.timesheet_reference_sources_by_id === 'object')
          ? manifest.timesheet_reference_sources_by_id
          : null);

  const reference_rows_raw =
    Array.isArray(d.reference_rows) ? d.reference_rows
    : (Array.isArray(manifest?.reference_rows) ? manifest.reference_rows : []);

  // âœ… NEW: Normalise reference rows for stable UI identity + correct field names.
  // DB reference rows use: ref_target + day_ymd (+ segment_id/start_utc/end_utc).
  // UI expects: kind + day_date, and needs a stable row_key to avoid collisions.
  const reference_rows_by_key = {};
  const reference_rows = (() => {
    const out = [];
    const seen = new Map();

    const normStr = (v) => (v == null ? '' : String(v).trim());

    const baseKeyOf = (r2) => {
      const tsid = normStr(r2?.timesheet_id);
      const tgt  = normStr(r2?.ref_target || r2?.kind);
      const sid  = normStr(r2?.segment_id);
      const day  = normStr(r2?.day_ymd || r2?.day_date || r2?.date);
      const st   = normStr(r2?.start_utc);
      const en   = normStr(r2?.end_utc);
      // Include all structural identifiers; do NOT include current_reference (it changes on edit).
      return [tsid, tgt, sid, day, st, en].join('::');
    };

    for (let i = 0; i < reference_rows_raw.length; i++) {
      const r = reference_rows_raw[i];
      if (!r || typeof r !== 'object') continue;

      // Shallow clone so we don't mutate raw manifest payload.
      const x = { ...r };

      // Alias fields for existing UI expectations.
      if ((x.kind == null || String(x.kind).trim() === '') && x.ref_target != null) {
        x.kind = String(x.ref_target);
      }
      if ((x.day_date == null || String(x.day_date).trim() === '') && x.day_ymd != null) {
        x.day_date = String(x.day_ymd);
      }
      if ((x.date == null || String(x.date).trim() === '') && x.day_ymd != null) {
        x.date = String(x.day_ymd);
      }

      // Build stable row_key if missing.
      let k =
        (x.row_key != null && String(x.row_key).trim()) ? String(x.row_key).trim()
        : ((x.reference_row_id != null && String(x.reference_row_id).trim()) ? String(x.reference_row_id).trim() : '');

      if (!k) {
        const base = baseKeyOf(x);
        const prev = seen.get(base) || 0;
        const next = prev + 1;
        seen.set(base, next);
        k = (next === 1) ? base : `${base}::${next}`;
      }

      x.row_key = k;

      out.push(x);
      reference_rows_by_key[k] = x;
    }

    return out;
  })();

  const out = {
    invoice,
    header_snapshot_json,
    items,
    email_summary,
    manifest,
    segments_on_invoice_by_timesheet,
    segments_by_timesheet,
    history,
    tsfin_id_by_timesheet_id,

    // âœ… NEW
    timesheet_reference_sources_by_id,

    // âœ… UPDATED (normalised)
    reference_rows,
    reference_rows_by_key,

    timesheet_evidence,
    evidence_other,
    evidence,
    attach_policy,
    raw: d
  };

  try {
    if (modalCtx && typeof modalCtx === 'object') {
      // Keep commonly-needed fields on modalCtx for zero-fetch child modals
      modalCtx.timesheet_reference_sources_by_id = timesheet_reference_sources_by_id;
      modalCtx.reference_rows_by_key = reference_rows_by_key;

      // Cache
      modalCtx.__invoiceDataCache = out;
      modalCtx.__invoiceDataCacheRaw = d;
    }
  } catch {}

  return out;
}

async function openInvoiceReferenceNumbersModal(parentModalCtx, { rerender } = {}) {
  if (!parentModalCtx || typeof parentModalCtx !== 'object') throw new Error('Missing parent modal context.');

  // Ensure showModal uses the invoice modal ctx (shared context across modal stack)
  try { window.modalCtx = parentModalCtx; } catch {}

  // Determine whether invoice is currently editable (source-of-truth = invoice modal frame mode)
  let canEdit = !!parentModalCtx.isEditing;
  try {
    const fr = (typeof window.__getModalFrame === 'function') ? window.__getModalFrame() : null;
    if (fr && fr.kind === 'invoice-modal' && fr.entity === 'invoices' && fr._ctxRef === parentModalCtx) {
      canEdit = (fr.mode === 'edit' || fr.mode === 'create');
      parentModalCtx.isEditing = canEdit;
    }
  } catch {}

  // Source rows must already be present (zero extra calls)
  // Prefer invoiceModalGetInvoiceData() so rows are normalised (row_key/kind/day_date).
  const invData = (typeof invoiceModalGetInvoiceData === 'function') ? invoiceModalGetInvoiceData(parentModalCtx) : null;

  const refRows = Array.isArray(invData?.reference_rows)
    ? invData.reference_rows
    : (Array.isArray(parentModalCtx?.reference_rows) ? parentModalCtx.reference_rows
      : (Array.isArray(parentModalCtx?.data?.reference_rows) ? parentModalCtx.data.reference_rows : []));

  const refRowsByKey = (invData?.reference_rows_by_key && typeof invData.reference_rows_by_key === 'object')
    ? invData.reference_rows_by_key
    : ((parentModalCtx?.reference_rows_by_key && typeof parentModalCtx.reference_rows_by_key === 'object')
        ? parentModalCtx.reference_rows_by_key
        : {});

  // Ensure staging container exists
  parentModalCtx.invoiceEdits = (parentModalCtx.invoiceEdits && typeof parentModalCtx.invoiceEdits === 'object')
    ? parentModalCtx.invoiceEdits
    : {};

  // âœ… Use keyed staging model (JSON-safe) so rows never collide and Save pipeline can serialise deterministically.
  parentModalCtx.invoiceEdits.reference_updates_by_key =
    (parentModalCtx.invoiceEdits.reference_updates_by_key && typeof parentModalCtx.invoiceEdits.reference_updates_by_key === 'object')
      ? parentModalCtx.invoiceEdits.reference_updates_by_key
      : {};

  // Keep legacy array for backward compatibility (some renderers still look at reference_updates[])
  parentModalCtx.invoiceEdits.reference_updates = Array.isArray(parentModalCtx.invoiceEdits.reference_updates)
    ? parentModalCtx.invoiceEdits.reference_updates
    : [];

  const rowKeyOf = (r) => {
    if (!r || typeof r !== 'object') return '';
    const k = (r.row_key != null && String(r.row_key).trim()) ? String(r.row_key).trim() : '';
    if (k) return k;

    // fallback (should be rare if rows are normalised)
    const tsid = (r.timesheet_id != null) ? String(r.timesheet_id) : '';
    const dt = (r.day_date != null) ? String(r.day_date) : (r.day_ymd != null ? String(r.day_ymd) : (r.date != null ? String(r.date) : ''));
    const kind = (r.kind != null) ? String(r.kind) : (r.ref_target != null ? String(r.ref_target) : '');
    const sid = (r.segment_id != null) ? String(r.segment_id) : '';
    const st  = (r.start_utc != null) ? String(r.start_utc) : '';
    const en  = (r.end_utc != null) ? String(r.end_utc) : '';
    return `${tsid}::${kind}::${sid}::${dt}::${st}::${en}`;
  };

  // Existing staged edits map by row key (priority: by_key, else legacy array)
  const stagedByKey = new Map();
  try {
    const byKey = parentModalCtx.invoiceEdits.reference_updates_by_key || {};
    for (const [k, u] of Object.entries(byKey)) {
      if (!k || !u || typeof u !== 'object') continue;
      stagedByKey.set(String(k), u);
    }
  } catch {}

  try {
    if (stagedByKey.size === 0 && Array.isArray(parentModalCtx.invoiceEdits.reference_updates)) {
      for (const u of parentModalCtx.invoiceEdits.reference_updates) {
        if (!u || typeof u !== 'object') continue;
        const k = (u.row_key != null && String(u.row_key).trim()) ? String(u.row_key).trim() : '';
        if (!k) continue;
        stagedByKey.set(k, u);
      }
    }
  } catch {}

  // âœ… UPDATED: do NOT fall back to showing timesheet_id anywhere.
  const fmtRowCandidate = (r) => {
    const name =
      r?.candidate_display ||
      r?.candidate_name ||
      r?.worker_name ||
      '';
    return name ? String(name) : '';
  };

  const fmtRowDate = (r) => {
    const raw =
      r?.day_date ||
      r?.day_ymd ||
      r?.date ||
      r?.week_ending_date ||
      '';
    const s = raw ? String(raw).trim() : '';
    if (/^\d{4}-\d{2}-\d{2}$/.test(s) && typeof formatYmdToNiceDate === 'function') {
      return formatYmdToNiceDate(s);
    }
    return s;
  };

  const initialValueFor = (r) => {
    const k = rowKeyOf(r);
    const staged = stagedByKey.get(k);
    if (staged && staged.current_reference != null) return String(staged.current_reference);
    if (r && r.current_reference != null) return String(r.current_reference);
    return '';
  };

  const disabledAttr = canEdit ? '' : 'disabled';
  const readOnlyAttr = canEdit ? '' : 'readonly';

  const renderTableRows = () => {
    if (!refRows.length) {
      return `<tr><td colspan="5" class="text-muted">No reference rows on this invoice.</td></tr>`;
    }

    return refRows.map((r) => {
      const k = rowKeyOf(r);
      const who = escapeHtml(fmtRowCandidate(r));
      const dt = escapeHtml(fmtRowDate(r));
      const isReq = !!r?.is_required;

      const cur = initialValueFor(r);
      const curTrim = String(cur || '').trim();
      const missing = isReq && !curTrim;

      const reqTxt = isReq ? 'Yes' : 'No';
      const missChip = missing ? `<span class="pill pill-warn">Missing</span>` : '';

      return `
        <tr data-ref-row="${escapeHtml(k)}">
          <td>${who || 'â€”'}</td>
          <td>${dt || 'â€”'}</td>
          <td style="min-width:240px;">
            <input type="text"
              class="form-control form-control-sm"
              data-ref-input="1"
              data-ref-row="${escapeHtml(k)}"
              value="${escapeHtml(cur)}"
              placeholder="Enter reference"
              ${disabledAttr}
              ${readOnlyAttr}
            />
          </td>
          <td>${escapeHtml(reqTxt)}</td>
          <td class="text-end">${missChip}</td>
        </tr>
      `;
    }).join('');
  };

  const hintText = canEdit
    ? `Edit references below. Click <b>Apply</b> to stage changes, then <b>Save</b> the invoice to commit.`
    : `View-only. Click <b>Edit</b> on the invoice to amend reference numbers.`;

  const html = `
    <div class="p-3">
      <div class="h6 mb-3">Reference Numbers</div>

      <div class="text-muted small mb-2">
        ${hintText}
      </div>

      <div class="table-responsive">
        <table class="table table-sm align-middle" style="margin:0;">
          <thead>
            <tr>
              <th>Candidate</th>
              <th>Date</th>
              <th>Reference</th>
              <th>Required</th>
              <th class="text-end"></th>
            </tr>
          </thead>
          <tbody>
            ${renderTableRows()}
          </tbody>
        </table>
      </div>

      ${canEdit ? `
        <div class="d-flex justify-content-end gap-2 mt-3">
          <button type="button" class="btn btn-sm btn-primary" id="invRefApply" ${refRows.length ? '' : 'disabled'}>Apply</button>
        </div>
      ` : ``}
    </div>
  `;

  showModal(
    'Reference Numbers',
    [{ key: 'main', label: 'References' }],
    () => html,
    null,
    true,
    null,
    { kind: 'invoice-reference-numbers', noParentGate: !!canEdit, showSave: false }
  );

  const closeTop = () => {
    try { document.getElementById('btnCloseModal')?.click(); } catch {}
  };

  // View-only: no Apply wiring
  if (!canEdit) return;

  const btnApply = document.getElementById('invRefApply');
  if (btnApply && !btnApply.__invWired) {
    btnApply.__invWired = true;
    btnApply.onclick = (e) => {
      e.preventDefault();

      // Build staged updates (do not submit)
      const listRoot = document.querySelector('#modalBody');
      const inputs = listRoot ? Array.from(listRoot.querySelectorAll('input[data-ref-input="1"]')) : [];

      // Start from existing staged updates, then overwrite with current inputs
      const nextByKey = { ...(parentModalCtx.invoiceEdits.reference_updates_by_key || {}) };

      for (const inp of inputs) {
        const k = String(inp.getAttribute('data-ref-row') || '').trim();
        if (!k) continue;
        const val = String(inp.value || '').trim();

        // Find the source row so we can include stable identifiers for later compilation
        const src =
          (refRowsByKey && refRowsByKey[k]) ? refRowsByKey[k]
          : (refRows.find(r => rowKeyOf(r) === k) || null);

        const upd = {
          row_key: k,

          // Always include the timesheet_id so Save pipeline accepts it.
          timesheet_id: src?.timesheet_id != null ? String(src.timesheet_id) : null,

          // Preserve DB-derived identifiers for later compile step (segment/freeform/timesheet)
          ref_target: src?.ref_target != null ? String(src.ref_target) : (src?.kind != null ? String(src.kind) : null),
          segment_id: src?.segment_id != null ? String(src.segment_id) : null,
          day_ymd: src?.day_ymd != null ? String(src.day_ymd) : (src?.day_date != null ? String(src.day_date) : null),
          start_utc: src?.start_utc != null ? String(src.start_utc) : null,
          end_utc: src?.end_utc != null ? String(src.end_utc) : null,

          // The edited value (still opaque at this stage; compilation happens in Save pipeline)
          current_reference: val
        };

        nextByKey[k] = upd;
      }

      parentModalCtx.invoiceEdits.reference_updates_by_key = nextByKey;

      try {
        const keys = Object.keys(nextByKey).sort();
        parentModalCtx.invoiceEdits.reference_updates = keys.map(k => nextByKey[k]).filter(x => x && typeof x === 'object');
      } catch {}

      try {
        const cloneJsonLocal = (v) => { try { return JSON.parse(JSON.stringify(v)); } catch { return v; } };

        parentModalCtx.invoiceState = (parentModalCtx.invoiceState && typeof parentModalCtx.invoiceState === 'object')
          ? parentModalCtx.invoiceState
          : {};

        parentModalCtx.invoiceState.invoiceEdits = parentModalCtx.invoiceEdits;

        parentModalCtx.invoiceState.invoiceEdits_json =
          (parentModalCtx.invoiceState.invoiceEdits_json && typeof parentModalCtx.invoiceState.invoiceEdits_json === 'object')
            ? parentModalCtx.invoiceState.invoiceEdits_json
            : {};

        parentModalCtx.invoiceState.invoiceEdits_json.reference_updates_by_key = cloneJsonLocal(nextByKey);
        parentModalCtx.invoiceState.invoiceEdits_json.reference_updates = cloneJsonLocal(parentModalCtx.invoiceEdits.reference_updates);

        try { parentModalCtx._editsJsonSig = JSON.stringify(parentModalCtx.invoiceState.invoiceEdits_json || {}); } catch {}
      } catch {}

      closeTop();

      try { window.dispatchEvent(new CustomEvent('modal-dirty')); } catch {}
      try { setTimeout(() => { rerender && rerender(); }, 0); } catch {}
    };
  }
}


function renderInvoiceModalEvidenceTab(modalCtx, invoiceData) {
  const invData = (invoiceData && typeof invoiceData === 'object')
    ? invoiceData
    : invoiceModalGetInvoiceData(modalCtx);

  const pickUrl = (e) => {
    if (!e || typeof e !== 'object') return '';
    return String(
      e.url ||
      e.file_url ||
      e.signed_url ||
      e.download_url ||
      e.public_url ||
      e.link ||
      ''
    ).trim();
  };

  const pickName = (e) => {
    if (!e || typeof e !== 'object') return '';
    return String(
      e.display_name ||
      e.filename ||
      e.file_name ||
      e.name ||
      e.title ||
      e.kind ||
      'Evidence'
    ).trim();
  };

  const pickTs = (e) => {
    if (!e || typeof e !== 'object') return '';
    return String(
      e.created_at ||
      e.uploaded_at ||
      e.ts_utc ||
      e.created_at_utc ||
      ''
    ).trim();
  };

  const fmtTs = (iso) => {
    if (!iso) return 'â€”';
    try { return fmtLondonTs(iso); } catch { return String(iso); }
  };

  const renderList = (arr) => {
    const list = Array.isArray(arr) ? arr : [];
    if (!list.length) return `<div class="text-muted">No evidence attached.</div>`;

    const rows = list.map((e) => {
      const name = pickName(e);
      const ts = fmtTs(pickTs(e));
      const url = pickUrl(e);

      const link = url
        ? `<a href="${escapeHtml(url)}" target="_blank" rel="noopener">Download</a>`
        : `<span class="text-muted">â€”</span>`;

      return `
        <tr>
          <td>${escapeHtml(name)}</td>
          <td class="text-muted small">${escapeHtml(ts)}</td>
          <td class="text-end">${link}</td>
        </tr>
      `;
    }).join('');

    return `
      <div class="table-responsive">
        <table class="table table-sm align-middle" style="margin:0;">
          <thead>
            <tr>
              <th>File</th>
              <th>Uploaded</th>
              <th class="text-end">Link</th>
            </tr>
          </thead>
          <tbody>
            ${rows}
          </tbody>
        </table>
      </div>
    `;
  };

  const tsEvidence = Array.isArray(invData?.timesheet_evidence) ? invData.timesheet_evidence : [];
  const otherEvidence = Array.isArray(invData?.evidence_other) ? invData.evidence_other : [];
  const legacyEvidence = Array.isArray(invData?.evidence) ? invData.evidence : [];

  const hasAny = (tsEvidence.length + otherEvidence.length + legacyEvidence.length) > 0;

  // Fallback: if timesheet_evidence and evidence_other are empty, use legacy evidence as "Timesheet Evidence"
  const useLegacyAsFallback = (!tsEvidence.length && !otherEvidence.length && legacyEvidence.length);

  const blockTimesheet = useLegacyAsFallback ? legacyEvidence : tsEvidence;
  const blockOther = useLegacyAsFallback ? [] : otherEvidence;

  if (!hasAny) {
    return `<div class="text-muted">No evidence attached.</div>`;
  }

  return `
    <div class="p-2">
      <div class="mb-3">
        <div class="fw-semibold mb-2">Timesheet Evidence</div>
        ${renderList(blockTimesheet)}
      </div>

      <div class="mb-2">
        <div class="fw-semibold mb-2">Other Evidence</div>
        ${blockOther.length ? renderList(blockOther) : `<div class="text-muted">No evidence attached.</div>`}
      </div>
    </div>
  `;
}


function renderInvoiceModalHistoryTab(modalCtx, invoiceData) {
  const invData = (invoiceData && typeof invoiceData === 'object')
    ? invoiceData
    : invoiceModalGetInvoiceData(modalCtx);

  const list = Array.isArray(invData?.history) ? invData.history : [];

  const fmtTs = (iso) => {
    if (!iso) return 'â€”';
    try { return fmtLondonTs(iso); } catch { return String(iso); }
  };

  const pickTs = (h) => {
    if (!h || typeof h !== 'object') return '';
    return String(
      h.ts_utc ||
      h.created_at ||
      h.created_at_utc ||
      h.sent_at_utc ||
      h.event_at_utc ||
      h.occurred_at_utc ||
      ''
    ).trim();
  };

  const isEmailEvent = (h) => {
    if (!h || typeof h !== 'object') return false;
    const t = String(h.type || h.kind || h.source || '').toUpperCase();
    // Heuristic: mail/outbox-style events often include to/subject/status
    if (h.to || h.recipient || h.email_to || h.subject || h.status) return true;
    return (t.includes('MAIL') || t.includes('EMAIL') || t.includes('OUTBOX'));
  };

  const actionText = (h) => {
    if (!h || typeof h !== 'object') return '';
    const a =
      h.action ||
      h.event ||
      h.kind ||
      h.type ||
      h.status ||
      '';
    return String(a || '').trim();
  };

  const userText = (h) => {
    if (!h || typeof h !== 'object') return '';
    const u =
      h.actor_display ||
      h.actor_name ||
      h.user_display ||
      h.user_name ||
      h.created_by_display ||
      h.created_by ||
      '';
    return String(u || '').trim();
  };

  const detailsText = (h) => {
    if (!h || typeof h !== 'object') return '';
    const d =
      h.detail ||
      h.details ||
      h.message ||
      h.summary ||
      '';
    return String(d || '').trim();
  };

  const emailInline = (h) => {
    const to = String(h.to || h.recipient || h.email_to || '').trim();
    const subj = String(h.subject || h.email_subject || '').trim();
    const st = String(h.status || h.delivery_status || '').trim();
    const parts = [];
    if (to) parts.push(`To: ${to}`);
    if (subj) parts.push(`Subject: ${subj}`);
    if (st) parts.push(`Status: ${st}`);
    return parts.join(' Â· ');
  };

  const safeJson = (v) => {
    try { return JSON.stringify(v, null, 2); } catch { return ''; }
  };

  if (!list.length) {
    return `<div class="p-2 text-muted">No history.</div>`;
  }

  // Assume newest-first; if not, sort descending by timestamp.
  const sorted = (() => {
    const arr = list.slice();
    try {
      arr.sort((a, b) => {
        const ta = Date.parse(pickTs(a) || '') || 0;
        const tb = Date.parse(pickTs(b) || '') || 0;
        return tb - ta;
      });
    } catch {}
    return arr;
  })();

  const rows = sorted.map((h) => {
    const ts = fmtTs(pickTs(h));
    const isEmail = isEmailEvent(h);

    const action = isEmail ? 'Email' : (actionText(h) || 'Event');
    const user = userText(h) || 'â€”';

    const inline = isEmail ? emailInline(h) : detailsText(h);
    const inlineSafe = inline ? escapeHtml(inline) : 'â€”';

    const raw = safeJson(h);
    const canExpand = !!raw;

    return `
      <tr>
        <td class="text-muted small" style="white-space:nowrap;">${escapeHtml(ts)}</td>
        <td>${escapeHtml(action)}</td>
        <td>${escapeHtml(user)}</td>
        <td>
          <div>${inlineSafe}</div>
          ${canExpand ? `
            <details class="mt-1">
              <summary class="text-muted small" style="cursor:pointer;">Details</summary>
              <pre class="mt-2 p-2 bg-light border rounded" style="white-space:pre-wrap; word-break:break-word; margin:0;">${escapeHtml(raw)}</pre>
            </details>
          ` : ''}
        </td>
      </tr>
    `;
  }).join('');

  return `
    <div class="p-2">
      <div class="table-responsive">
        <table class="table table-sm align-middle" style="margin:0;">
          <thead>
            <tr>
              <th style="width:160px;">Date/Time</th>
              <th style="width:140px;">Action</th>
              <th style="width:180px;">User</th>
              <th>Details</th>
            </tr>
          </thead>
          <tbody>
            ${rows}
          </tbody>
        </table>
      </div>
    </div>
  `;
}


function renderInvoiceModalContent(modalCtx, invoiceData) {
  const fmtMoneyLocal = (n) => {
    const x = invoiceModalRound2(Number(n || 0));
    const s = x.toFixed(2);
    return `Â£${s}`;
  };

  const invData = (invoiceData && typeof invoiceData === 'object')
    ? invoiceData
    : invoiceModalGetInvoiceData(modalCtx);

  const {
    invoice,
    header_snapshot_json,
    items,
    email_summary,
    reference_rows
  } = invData || {};

  if (!invoice) return `<div class="p-3 text-muted">Invoice not found.</div>`;

  const baseStatus = String(invoice.status || '').toUpperCase();
  const baseIsIssued = !!invoice.issued_at_utc;
  const baseIsPaid   = !!invoice.paid_at_utc;
  const baseIsOnHold = (baseStatus === 'ON_HOLD');

  const isEditing = !!modalCtx.isEditing;

  const canToggleStatus = invoiceModalIsEditable(invoice, modalCtx, 'status');
  const canEditLines    = invoiceModalIsEditable(invoice, modalCtx, 'lines');

  const staged = (modalCtx && modalCtx.invoiceEdits && typeof modalCtx.invoiceEdits === 'object') ? modalCtx.invoiceEdits : {};
  const st = (staged.staged_status && typeof staged.staged_status === 'object') ? staged.staged_status : { issued: null, paid: null, on_hold: null };
  const sd = (staged.staged_dates && typeof staged.staged_dates === 'object') ? staged.staged_dates : { issued_at_utc: null, paid_at_utc: null, status_date_utc: null };

  const effIssued = (st.issued === null || st.issued === undefined) ? baseIsIssued : !!st.issued;
  const effPaid   = (st.paid   === null || st.paid   === undefined) ? baseIsPaid   : !!st.paid;
  const effHold   = (st.on_hold=== null || st.on_hold=== undefined) ? baseIsOnHold : !!st.on_hold;

  const dueAt = invoice.due_at_utc ? new Date(invoice.due_at_utc) : null;
  const overdue =
    !!effIssued &&
    !effPaid &&
    dueAt &&
    Number.isFinite(dueAt.getTime()) &&
    (dueAt.getTime() < Date.now());

  const fmtLondonDateOnly = (iso) => {
    const s = String(fmtLondonTs(iso) || '').trim();
    const m = s.match(/^(\d{2}\/\d{2}\/\d{4})/);
    return m ? m[1] : s;
  };

  const displayIssuedAt = (() => {
    if (effIssued) {
      if (invoice.issued_at_utc) return fmtLondonTs(invoice.issued_at_utc);
      if (isEditing && st.issued === true && sd.issued_at_utc) return `${fmtLondonTs(sd.issued_at_utc)} (staged)`;
      return 'â€”';
    }
    if (isEditing && st.issued === false) return 'Will clear';
    return 'â€”';
  })();

  const displayPaidAt = (() => {
    if (effPaid) {
      if (invoice.paid_at_utc) return fmtLondonTs(invoice.paid_at_utc);
      if (isEditing && st.paid === true && sd.paid_at_utc) return `${fmtLondonTs(sd.paid_at_utc)} (staged)`;
      return 'â€”';
    }
    if (isEditing && st.paid === false) return 'Will clear';
    return 'â€”';
  })();

  const displayHoldAt = (() => {
    if (effHold) {
      if (invoice.status_date_utc) return fmtLondonTs(invoice.status_date_utc);
      if (isEditing && st.on_hold === true && sd.status_date_utc) return `${fmtLondonTs(sd.status_date_utc)} (staged)`;
      return 'â€”';
    }
    if (isEditing && st.on_hold === false) return 'Will clear';
    return 'â€”';
  })();

  const clientName =
    header_snapshot_json?.client_name ||
    invoice?.client?.name ||
    (invoiceData && invoiceData.client && invoiceData.client.name) ||
    '';

  const invoiceNo = (invoice.invoice_no != null && String(invoice.invoice_no).trim())
    ? `Invoice #${escapeHtml(String(invoice.invoice_no))}`
    : `Invoice ${escapeHtml(String(invoice.id || ''))}`;

  const invoiceDate = (effIssued && invoice.issued_at_utc) ? fmtLondonDateOnly(invoice.issued_at_utc) : 'â€”';
  const createdDate = invoice.created_at ? fmtLondonTs(invoice.created_at) : 'â€”';

  const hasLineEdits = (() => {
    const e = modalCtx?.invoiceEdits;
    if (!e) return false;
    return (
      (e.remove_invoice_line_ids && e.remove_invoice_line_ids.size > 0) ||
      (e.add_timesheet_ids && e.add_timesheet_ids.size > 0) ||
      (Array.isArray(e.add_adjustments) && e.add_adjustments.length > 0) ||
      (Array.isArray(e.remove_segment_refs) && e.remove_segment_refs.length > 0) ||
      (Array.isArray(e.add_segment_refs) && e.add_segment_refs.length > 0)
    );
  })();

  const hasStatusEdits =
    (st.issued !== null && st.issued !== undefined) ||
    (st.paid !== null && st.paid !== undefined) ||
    (st.on_hold !== null && st.on_hold !== undefined);

const hasRefEdits = (() => {
  const e = modalCtx?.invoiceEdits;
  if (!e) return false;

  if (e.reference_updates_by_key && typeof e.reference_updates_by_key === 'object' && !Array.isArray(e.reference_updates_by_key)) {
    if (Object.keys(e.reference_updates_by_key).length > 0) return true;
  }

  return (Array.isArray(e.reference_updates) && e.reference_updates.length > 0);
})();


  const hasPendingEdits = hasLineEdits || hasStatusEdits || hasRefEdits;

  const currentTotals = {
    subtotal_ex_vat: invoiceModalRound2(invoice.subtotal_ex_vat || 0),
    vat_amount:      invoiceModalRound2(invoice.vat_amount || 0),
    total_inc_vat:   invoiceModalRound2(invoice.total_inc_vat || 0)
  };

  const previewTotals = hasLineEdits ? invoiceModalComputePreviewTotals(modalCtx) : currentTotals;
  const totalsToShow = hasLineEdits ? previewTotals : currentTotals;

  const pillSpan = (text, cls) => `<span class="pill ${cls}">${escapeHtml(text)}</span>`;

  // âœ… Support disabling the Issued pill when invoice is ON_HOLD (must unhold first).
  const pillBtn = (action, text, cls, opts = {}) => {
    const disabled = !!opts.disabled;
    const title = (opts.title != null && String(opts.title).trim()) ? String(opts.title).trim() : '';
    const disAttr = disabled ? 'disabled data-disabled="1"' : '';
    const disCls = disabled ? ' disabled' : '';
    const titleAttr = title ? ` title="${escapeHtml(title)}"` : '';
    return `
      <button type="button" class="pill ${cls}${disCls}" data-action="${action}" ${disAttr}${titleAttr}>
        ${escapeHtml(text)}
      </button>
    `;
  };

  // âœ… Hard-block issuing while ON_HOLD (UI-level): disable Issued toggle when ON_HOLD and currently unissued.
  const blockIssueWhileHold = !!(effHold && !effIssued);
  const issuedPill = canToggleStatus
    ? pillBtn(
        'inv-toggle-issued',
        effIssued ? 'Issued' : 'Unissued',
        effIssued ? 'pill-ok' : 'pill-bad',
        blockIssueWhileHold ? { disabled: true, title: 'Unhold first' } : {}
      )
    : pillSpan(effIssued ? 'Issued' : 'Unissued', effIssued ? 'pill-ok' : 'pill-bad');

  const paidPill = canToggleStatus
    ? pillBtn('inv-toggle-paid', effPaid ? 'Paid' : 'Unpaid', effPaid ? 'pill-ok' : 'pill-bad')
    : pillSpan(effPaid ? 'Paid' : 'Unpaid', effPaid ? 'pill-ok' : 'pill-bad');

  const holdPill = canToggleStatus
    ? pillBtn('inv-toggle-hold', effHold ? 'On hold' : 'Active', effHold ? 'pill-warn' : '')
    : pillSpan(effHold ? 'On hold' : 'Active', effHold ? 'pill-warn' : '');

  const overduePill = overdue ? pillSpan('Overdue', 'pill-bad') : '';

  const emailedOnce = !!email_summary?.emailed_once;
  const emailLabel = emailedOnce ? 'Re-email' : 'Email';

  const doNotSend = !!invoice.do_not_send;
  const emailDisabledAttr = doNotSend ? 'disabled' : '';
  const emailTitle = doNotSend ? 'title="Do not send invoice (closeout)"' : '';

  const hasRefRows = Array.isArray(reference_rows) && reference_rows.length > 0;
  const refDisabledAttr = hasRefRows ? '' : 'disabled';
  const refTitle = hasRefRows ? '' : 'title="No reference rows on this invoice"';

  const addDisabledAttr = canEditLines ? '' : 'disabled';
  const addDisabledTitle = canEditLines ? '' : 'title="Unissue and unpay the invoice first (staged), then you can edit lines."';

  const holdReason = (invoice.on_hold_reason != null && String(invoice.on_hold_reason).trim())
    ? String(invoice.on_hold_reason)
    : '';

  // âœ… Additional user-facing message in edit mode when hold blocks issuing.
  const holdIssueBlockMsg = (isEditing && blockIssueWhileHold) ? `
    <div class="alert alert-warning py-2 px-2 small mb-3">
      <b>On hold:</b> Unhold this invoice before issuing.
    </div>
  ` : '';

  return `
    <div class="p-2">

      ${modalCtx.error ? `<div class="alert alert-danger mb-3">${escapeHtml(modalCtx.error)}</div>` : ''}

      <div class="mb-2 d-flex align-items-start justify-content-between gap-3" style="flex-wrap:wrap;">
        <div>
          <div class="h5 fw-bold mb-1">${invoiceNo}</div>
          <div class="fw-bold" style="font-size:1.05rem;">${escapeHtml(String(clientName || ''))}</div>
        </div>

        <div class="d-flex align-items-center gap-2" style="margin-left:auto; flex-wrap:wrap; justify-content:flex-end;">
          ${issuedPill}
          ${paidPill}
          ${holdPill}
          ${overdue ? overduePill : ''}
        </div>
      </div>

      ${holdIssueBlockMsg}

      ${effHold && holdReason ? `
        <div class="alert alert-warning py-2 px-2 small mb-3">
          <b>On hold:</b> ${escapeHtml(holdReason)}
        </div>
      ` : ''}

      <div class="mb-3">
        <table class="grid mini" style="width:100%;">
          <tbody>
            <tr><td style="width:180px;">Invoice date</td><td class="fw-semibold">${escapeHtml(String(invoiceDate))}</td></tr>
            <tr><td>Created</td><td class="fw-semibold">${escapeHtml(String(createdDate))}</td></tr>
            <tr><td>Amount (ex VAT)</td><td class="fw-semibold">${fmtMoneyLocal(totalsToShow.subtotal_ex_vat)}</td></tr>
            <tr><td>Amount (inc VAT)</td><td class="fw-semibold">${fmtMoneyLocal(totalsToShow.total_inc_vat)}</td></tr>
            <tr><td>Issue Date</td><td class="fw-semibold">${escapeHtml(String(displayIssuedAt))}</td></tr>
            <tr><td>Paid On</td><td class="fw-semibold">${escapeHtml(String(displayPaidAt))}</td></tr>
            <tr><td>On Hold Since</td><td class="fw-semibold">${escapeHtml(String(displayHoldAt))}</td></tr>
          </tbody>
        </table>
      </div>

      <div class="d-flex flex-wrap gap-2 align-items-center mb-3">
        <button type="button" class="btn btn-sm btn-primary" data-action="inv-open-pdf">
          Open invoice PDF
        </button>

        <button type="button" class="btn btn-sm btn-secondary" data-action="inv-email" ${emailDisabledAttr} ${emailTitle}>
          ${escapeHtml(emailLabel)}
        </button>

        <button type="button" class="btn btn-sm btn-outline-secondary" data-action="inv-open-reference-numbers" ${refDisabledAttr} ${refTitle}>
          Reference Numbers
        </button>

        ${isEditing ? `
          <button type="button" class="btn btn-sm btn-outline-secondary" data-action="inv-add-timesheets" ${addDisabledAttr} ${addDisabledTitle}>
            + Add timesheet
          </button>
          <button type="button" class="btn btn-sm btn-outline-secondary" data-action="inv-add-adjustment" ${addDisabledAttr} ${addDisabledTitle}>
            + Add adjustment
          </button>
        ` : ''}
      </div>

      ${isEditing && hasPendingEdits ? `
        <div class="alert alert-warning py-1 px-2 small mb-3">
          You have <b>unsaved changes</b>. Nothing is committed until you press <b>Save</b>.
        </div>
      ` : ''}

      ${renderInvoiceLinesTable(modalCtx, invoiceData, items)}
    </div>
  `;
}



function fmtLondonTs(iso) {
  const s = String(iso || '').trim();
  if (!s) return '';
  try {
    const d = new Date(s);
    if (Number.isNaN(d.getTime())) return s;

    const parts = new Intl.DateTimeFormat('en-GB', {
      timeZone: 'Europe/London',
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      hour12: false
    }).formatToParts(d);

    const get = (t) => (parts.find(p => p.type === t)?.value || '');
    return `${get('day')}/${get('month')}/${get('year')} ${get('hour')}:${get('minute')}:${get('second')}`;
  } catch {
    return s;
  }
}



function renderInvoiceLinesTable(modalCtx, invoiceData, items) {
  const fmtMoneyLocal = (n) => {
    const x = invoiceModalRound2(Number(n || 0));
    return `Â£${x.toFixed(2)}`;
  };

  const invData = (invoiceData && typeof invoiceData === 'object')
    ? invoiceData
    : invoiceModalGetInvoiceData(modalCtx);

  const { invoice, segments_by_timesheet, segments_on_invoice_by_timesheet, tsfin_id_by_timesheet_id } = invData || {};

  const isEditing = !!modalCtx.isEditing;
  const canEditLines = invoiceModalIsEditable(invoice, modalCtx, 'lines');
  const isUnissued = !(invoice && invoice.issued_at_utc);

  const removedSet = modalCtx?.invoiceEdits?.remove_invoice_line_ids || new Set();

  const stagedSegRemoveArr = (modalCtx?.invoiceEdits && Array.isArray(modalCtx.invoiceEdits.remove_segment_refs))
    ? modalCtx.invoiceEdits.remove_segment_refs
    : [];

  const stagedSegAddArr = (modalCtx?.invoiceEdits && Array.isArray(modalCtx.invoiceEdits.add_segment_refs))
    ? modalCtx.invoiceEdits.add_segment_refs
    : [];

  const segKey = (tsfinId, segId) => `${String(tsfinId || '')}::${String(segId || '')}`;

  const stagedSegRemoveSet = (() => {
    const s = new Set();
    for (const r of stagedSegRemoveArr) {
      if (!r || typeof r !== 'object') continue;
      s.add(segKey(r.tsfin_id, r.segment_id));
    }
    return s;
  })();

  const stagedSegAddSet = (() => {
    const s = new Set();
    for (const r of stagedSegAddArr) {
      if (!r || typeof r !== 'object') continue;
      s.add(segKey(r.tsfin_id, r.segment_id));
    }
    return s;
  })();

  modalCtx.invoiceUi = (modalCtx.invoiceUi && typeof modalCtx.invoiceUi === 'object') ? modalCtx.invoiceUi : {};
  modalCtx.invoiceUi.expanded_timesheets = (modalCtx.invoiceUi.expanded_timesheets && typeof modalCtx.invoiceUi.expanded_timesheets === 'object')
    ? modalCtx.invoiceUi.expanded_timesheets
    : {};

  const esc = (typeof escapeHtml === 'function') ? escapeHtml : (s) => String(s == null ? '' : s);

  const fmtDowDmy = (ymd) => {
    const s = String(ymd || '').slice(0, 10);
    const m = s.match(/^(\d{4})-(\d{2})-(\d{2})$/);
    if (!m) return s || 'â€”';
    const [, y, mo, d] = m;
    let dow = '';
    try {
      const dt = new Date(`${s}T00:00:00Z`);
      dow = dt.toLocaleDateString('en-GB', { weekday: 'short', timeZone: 'Europe/London' });
    } catch {}
    return `${dow || ''} ${d}/${mo}/${y}`.trim();
  };

  const isoToHHMM = (iso) => {
    try {
      const d = new Date(String(iso || ''));
      if (Number.isNaN(d.getTime())) return '';
      const t = d.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit', hour12: false, timeZone: 'Europe/London' });
      return String(t || '').replace(':', '');
    } catch { return ''; }
  };

  const isoToDowDmy = (iso) => {
    try {
      const d = new Date(String(iso || ''));
      if (Number.isNaN(d.getTime())) return '';
      const parts = new Intl.DateTimeFormat('en-GB', { timeZone: 'Europe/London', year: 'numeric', month: '2-digit', day: '2-digit', weekday: 'short' }).formatToParts(d);
      const get = (t) => (parts.find(p => p.type === t)?.value || '');
      const dd = get('day'), mm = get('month'), yy = get('year'), wd = get('weekday');
      return `${wd} ${dd}/${mm}/${yy}`.trim();
    } catch { return ''; }
  };

  const asLineType = (it) => {
    const mj = (it && it.meta_json && typeof it.meta_json === 'object') ? it.meta_json : {};
    return String(it?.line_type_norm || mj?.line_type || '').trim().toUpperCase();
  };

  const isExpenseLineType = (lt) => {
    const t = String(lt || '').toUpperCase();
    return (t === 'EXPENSE' || t.startsWith('EXPENSE_') || t === 'TRAVEL' || t === 'ACCOMMODATION' || t === 'OTHER');
  };

  const isMileageLineType = (lt) => String(lt || '').toUpperCase() === 'MILEAGE';

  const isAdditionalRateType = (lt) => {
    const t = String(lt || '').toUpperCase();
    return (t === 'ADDITIONAL_RATE' || t === 'ADDITIONAL' || t === 'ADDITIONAL_RATES' || t.includes('_ADDITIONAL_') || (t.startsWith('TS_') && t.includes('ADDITIONAL')));
  };

  const segmentBlock = (() => {
    let hasAdditional = false;
    let hasExpense = false;
    let hasMileage = false;

    for (const l of (items || [])) {
      const id = String(l?.invoice_line_id || '');
      if (id && removedSet && typeof removedSet.has === 'function' && removedSet.has(id)) continue;

      const lt = asLineType(l);
      if (!hasAdditional && isAdditionalRateType(lt)) hasAdditional = true;
      if (!hasMileage && isMileageLineType(lt)) hasMileage = true;
      if (!hasExpense && isExpenseLineType(lt)) hasExpense = true;

      if (hasAdditional && (hasExpense || hasMileage)) break;
    }

    return { hasAdditional, hasExpense, hasMileage, blocked: (hasAdditional || hasExpense || hasMileage) };
  })();

  const getWeekEndingRaw = (g) => {
    const first = g.lines[0] || {};
    const mj = (first.meta_json && typeof first.meta_json === 'object') ? first.meta_json : {};
    return (mj.week_ending_date || mj.week_ending_date_local || mj.week_ending || mj.week_end_date || '');
  };

  const getWeekEndingLabel = (g) => {
    const raw = String(getWeekEndingRaw(g) || '').slice(0, 10);
    if (/^\d{4}-\d{2}-\d{2}$/.test(raw)) return fmtDowDmy(raw);
    return raw || 'â€”';
  };

  const getCandidate = (g) => {
    const first = g.lines[0] || {};
    const mj = (first.meta_json && typeof first.meta_json === 'object') ? first.meta_json : {};
    return (mj.candidate_display || mj.candidate_name || mj.worker_name || '');
  };

  const sumBucketQty = (it) => {
    const q = it?.qty || {};
    return (Number(q.day || 0) + Number(q.night || 0) + Number(q.sat || 0) + Number(q.sun || 0) + Number(q.bh || 0));
  };

  const sumSegHours = (seg) => (
    Number(seg?.hours_day || 0) +
    Number(seg?.hours_night || 0) +
    Number(seg?.hours_sat || 0) +
    Number(seg?.hours_sun || 0) +
    Number(seg?.hours_bh || 0)
  );

  const groupTotals = (g) => {
    let hrs = 0;
    let ex = 0;
    let inc = 0;
    let margin = 0;
    let expensesEx = 0;
    let additionalHours = 0;

    for (const l of g.lines) {
      const lt = asLineType(l);
      const id = String(l?.invoice_line_id || '');
      const isRemoved = (id && removedSet && typeof removedSet.has === 'function' && removedSet.has(id));
      if (isRemoved) continue;

      const qtyHrs = sumBucketQty(l);
      if (qtyHrs > 0) hrs += qtyHrs;

      ex += Number(l?.total_charge_ex_vat || 0);
      inc += Number(l?.total_inc_vat || 0);
      margin += Number(l?.margin_ex_vat || 0);

      if (isExpenseLineType(lt) && !isMileageLineType(lt)) expensesEx += Number(l?.total_charge_ex_vat || 0);

      if (isAdditionalRateType(lt)) {
        const mj = (l.meta_json && typeof l.meta_json === 'object') ? l.meta_json : {};
        const u = (mj.units && typeof mj.units === 'object') ? mj.units : {};
        const unitName = String(u.unit_name || '').toLowerCase();
        const unitCount = Number(u.unit_count || 0);
        if (unitCount > 0 && unitName && unitName.includes('hour')) additionalHours += unitCount;
      }
    }

    // subtract staged removed segments (keeps preview coherent)
    try {
      const tsId = String(g.timesheet_id || '');
      const segMap = (segments_on_invoice_by_timesheet && typeof segments_on_invoice_by_timesheet === 'object')
        ? segments_on_invoice_by_timesheet
        : ((segments_by_timesheet && typeof segments_by_timesheet === 'object') ? segments_by_timesheet : {});
      const info = (tsId && segMap && typeof segMap === 'object') ? segMap[tsId] : null;

      const invoicedSegs = (info && typeof info === 'object' && Array.isArray(info.invoiced_segments)) ? info.invoiced_segments : null;

      if (invoicedSegs && invoicedSegs.length) {
        const tsfinId = (info && info.tsfin_id) ? String(info.tsfin_id) : (tsfin_id_by_timesheet_id && tsfin_id_by_timesheet_id[tsId] ? String(tsfin_id_by_timesheet_id[tsId]) : '');
        if (tsfinId) {
          let deltaEx = 0;
          let deltaPay = 0;
          let deltaHours = 0;

          for (const seg of invoicedSegs) {
            if (!seg || typeof seg !== 'object') continue;
            const segId = (seg.segment_id != null) ? String(seg.segment_id) : '';
            if (!segId) continue;
            if (stagedSegRemoveSet.has(segKey(tsfinId, segId))) {
              deltaEx += Number(seg.charge_amount || 0);
              deltaPay += Number(seg.pay_amount || 0);
              deltaHours += sumSegHours(seg);
            }
          }

          const vatFactor = (ex && Number(ex) !== 0) ? (Number(inc || 0) / Number(ex || 1)) : 1;
          const deltaInc = deltaEx * vatFactor;
          const deltaMargin = (deltaEx - deltaPay);

          hrs -= deltaHours;
          ex -= deltaEx;
          inc -= deltaInc;
          margin -= deltaMargin;
        }
      }
    } catch {}

    return {
      week: getWeekEndingLabel(g),
      candidate: getCandidate(g),
      totalHours: invoiceModalRound2(hrs),
      additionalHours: invoiceModalRound2(additionalHours),
      expensesEx: invoiceModalRound2(expensesEx),
      ex: invoiceModalRound2(ex),
      inc: invoiceModalRound2(inc),
      margin: invoiceModalRound2(margin)
    };
  };

  const isGroupRemoved = (g) => {
    const ids = g.lines.map(l => String(l?.invoice_line_id || '')).filter(Boolean);
    if (!ids.length) return false;
    return ids.every(id => removedSet.has(id));
  };

  // Group invoice lines by timesheet_id; adjustments separate
  const tsGroups = new Map();
  const adjLines = [];

  for (const it of (items || [])) {
    const tsId = it?.timesheet_id ? String(it.timesheet_id) : null;
    const lt = asLineType(it);

    if (tsId) {
      if (!tsGroups.has(tsId)) tsGroups.set(tsId, { key: tsId, timesheet_id: tsId, lines: [] });
      tsGroups.get(tsId).lines.push(it);
    } else {
      const lid = String(it?.invoice_line_id || '');
      adjLines.push({ key: `adj:${lid}`, invoice_line_id: lid, line: it, line_type: lt, staged: false });
    }
  }

  const tsGroupArr = Array.from(tsGroups.values());

  const segMapForUi = (() => {
    if (segments_on_invoice_by_timesheet && typeof segments_on_invoice_by_timesheet === 'object') return segments_on_invoice_by_timesheet;
    if (segments_by_timesheet && typeof segments_by_timesheet === 'object') return segments_by_timesheet;
    return {};
  })();

  const hasAnySegmentTimesheets = (() => {
    try {
      for (const g of tsGroupArr) {
        const info = segMapForUi[String(g.timesheet_id || '')];
        const segs = (info && typeof info === 'object' && Array.isArray(info.invoiced_segments)) ? info.invoiced_segments : null;
        if (segs && segs.length) return true;
      }
    } catch {}
    return false;
  })();

  // Staged adjustments: render inside Adjustments table (green), not a separate "Pending" block.
  const stagedAdjs = (modalCtx?.invoiceEdits && Array.isArray(modalCtx.invoiceEdits.add_adjustments))
    ? modalCtx.invoiceEdits.add_adjustments
    : [];

  const stagedAdjRows = stagedAdjs.map((a) => {
    const tok = String(a?.client_token || '').trim();
    return {
      key: `staged-adj:${tok}`,
      client_token: tok,
      description: String(a?.description || '').trim() || 'Adjustment',
      ex: invoiceModalRound2(Number(a?.amount_ex_vat || 0)),
      staged: true
    };
  });

  const allocByWeights = (total, weights) => {
    const out = {};
    const keys = Object.keys(weights || {}).filter(k => Number(weights[k] || 0) > 0);
    if (!keys.length) return out;

    const sumW = keys.reduce((s, k) => s + Number(weights[k] || 0), 0);
    if (!(sumW > 0)) return out;

    let used = 0;
    keys.forEach((k) => {
      const w = Number(weights[k] || 0);
      const raw = (total * w) / sumW;
      const val = invoiceModalRound2(raw);
      out[k] = val;
      used += val;
    });

    const remainder = invoiceModalRound2(total - used);
    const lastKey = keys[keys.length - 1];
    out[lastKey] = invoiceModalRound2((out[lastKey] || 0) + remainder);
    return out;
  };

const buildHourBucketRows = (l) => {
  const q = l?.qty || {};
  const pr = l?.pay_rate || {};
  const cr = l?.charge_rate || {};

  const buckets = [['day','Day'],['night','Night'],['sat','Sat'],['sun','Sun'],['bh','BH']];

  const qtyBy = {};
  const wChg = {};
  const wPay = {};

  for (const [k] of buckets) {
    const qty = Number(q?.[k] || 0);
    if (qty > 0) {
      qtyBy[k] = qty;
      const chgR = Number(cr?.[k]);
      const payR = Number(pr?.[k]);
      wChg[k] = (Number.isFinite(chgR) ? (qty * chgR) : qty);
      wPay[k] = (Number.isFinite(payR) ? (qty * payR) : qty);
    }
  }

  const totalPay = invoiceModalRound2(Number(l?.total_pay_ex_vat || 0));
  const totalChg = invoiceModalRound2(Number(l?.total_charge_ex_vat || 0));

  const allocPay = allocByWeights(totalPay, wPay);
  const allocChg = allocByWeights(totalChg, wChg);

  const rows = [];
  for (const [k, label] of buckets) {
    const qty = Number(qtyBy[k] || 0);
    if (!(qty > 0)) continue;

    const payEx = invoiceModalRound2(Number(allocPay[k] || 0));
    const chgEx = invoiceModalRound2(Number(allocChg[k] || 0));

    rows.push({
      unit: label,
      qty: qty,
      pay_ex: payEx,
      chg_ex: chgEx
    });
  }

  return rows;
};

const buildNonHourRow = (l) => {
  const lt = asLineType(l);
  const mj = (l.meta_json && typeof l.meta_json === 'object') ? l.meta_json : {};
  const u = (mj.units && typeof mj.units === 'object') ? mj.units : {};
  const bucket = (mj.bucket && typeof mj.bucket === 'object') ? mj.bucket : {};

  const unitName =
    bucket.name ||
    u.unit_name ||
    ((isExpenseLineType(lt) || isMileageLineType(lt)) ? lt : (lt || (l.description || '')));

  const qty =
    (Number.isFinite(Number(u.unit_count)) && Number(u.unit_count) !== 0)
      ? Number(u.unit_count)
      : null;

  const payEx = invoiceModalRound2(Number(l?.total_pay_ex_vat || 0));
  const chgEx = invoiceModalRound2(Number(l?.total_charge_ex_vat || 0));

  const shouldShow =
    ((isExpenseLineType(lt) || isMileageLineType(lt)) ? (payEx !== 0 || chgEx !== 0) : ((qty && qty !== 0) || payEx !== 0 || chgEx !== 0));

  if (!shouldShow) return null;

  return {
    unit: String(unitName || ''),
    qty: qty,
    pay_ex: payEx,
    chg_ex: chgEx
  };
};


  const lookupEligibleSeg = (tsfinId, segId) => {
    try {
      const obj = modalCtx?.eligibleTimesheetsCache;
      const map = obj?._bySegKey instanceof Map ? obj._bySegKey : null;
      if (!map) return null;
      return map.get(`${String(tsfinId || '')}::${String(segId || '')}`) || null;
    } catch { return null; }
  };

  const renderSegmentsOnInvoiceTable = (g) => {
    const tsId = String(g.timesheet_id || '');
    const info = (segMapForUi && typeof segMapForUi === 'object') ? segMapForUi[tsId] : null;
    const invoicedSegs = (info && typeof info === 'object' && Array.isArray(info.invoiced_segments)) ? info.invoiced_segments : [];

    const tsfinId =
      (info && typeof info === 'object' && info.tsfin_id) ? String(info.tsfin_id)
      : (tsfin_id_by_timesheet_id && tsfin_id_by_timesheet_id[tsId] ? String(tsfin_id_by_timesheet_id[tsId]) : '');

    // staged added segments for this timesheet
    const stagedAddsForTs = (() => {
      const out = [];
      for (const r of stagedSegAddArr) {
        if (!r || typeof r !== 'object') continue;
        const tId = String(r.timesheet_id || '').trim();
        if (tId && tId !== tsId) continue;
        if (!tId) {
          // fallback: infer from segment_id pattern "...:<timesheet_id>:..."
          const sid = String(r.segment_id || '');
          if (sid && tsId && sid.includes(`:${tsId}:`) === false && sid.includes(`:${tsId}`) === false) continue;
        }
        out.push(r);
      }
      return out;
    })();

    const stagedAddSegs = stagedAddsForTs.map(r => {
      const s = lookupEligibleSeg(r.tsfin_id, r.segment_id) || {};
      return {
        __staged_add: true,
        segment_id: String(r.segment_id || ''),
        date: String(s.date || ''),
        start_utc: String(s.start_utc || s.start || ''),
        end_utc: String(s.end_utc || s.end || ''),
        ref_num: String(s.ref_num || ''),
        charge_amount: Number(s.charge_amount || 0),
        pay_amount: Number(s.pay_amount || 0),
        hours_day: Number(s.hours_day || 0),
        hours_night: Number(s.hours_night || 0),
        hours_sat: Number(s.hours_sat || 0),
        hours_sun: Number(s.hours_sun || 0),
        hours_bh: Number(s.hours_bh || 0)
      };
    });

    if (!invoicedSegs.length && !stagedAddSegs.length) return '';

    const uninvoicedCount = (info && typeof info === 'object' && Number.isFinite(Number(info.uninvoiced_segment_count)))
      ? Number(info.uninvoiced_segment_count)
      : 0;

    const lockedElsewhereCount = (info && typeof info === 'object' && Number.isFinite(Number(info.locked_elsewhere_segment_count)))
      ? Number(info.locked_elsewhere_segment_count)
      : 0;

    const canStageSegments =
      !!isEditing &&
      !!canEditLines &&
      !!isUnissued &&
      !segmentBlock.blocked;

    const disabledReason = (() => {
      if (!isEditing) return 'Not in edit mode';
      if (!canEditLines) return 'Invoice lines are not editable';
      if (!isUnissued) return 'Segments can only be changed before issuing';
      if (segmentBlock.hasAdditional) return 'Segments cannot be moved when additional rates exist';
      if (segmentBlock.hasMileage || segmentBlock.hasExpense) return 'Segments cannot be moved when expenses or mileage exist';
      return '';
    })();

    const banner = (!canStageSegments && isEditing && (segmentBlock.blocked || !isUnissued)) ? `
      <div class="alert alert-warning py-2 px-2 small mb-2">
        <b>Segment edits disabled:</b> ${esc(disabledReason || 'Not allowed for this invoice.')}
      </div>
    ` : '';

    const combined = [
      ...invoicedSegs.map(s => ({ ...(s || {}), __staged_add: false })),
      ...stagedAddSegs
    ];

    // sort by start time then date
    combined.sort((a, b) => {
      const ta = new Date(String(a?.start_utc || '')).getTime();
      const tb = new Date(String(b?.start_utc || '')).getTime();
      if (Number.isFinite(ta) && Number.isFinite(tb) && ta !== tb) return ta - tb;

      const da = String(a?.date || '').slice(0,10);
      const db = String(b?.date || '').slice(0,10);
      if (da && db && da !== db) return da < db ? -1 : 1;
      return 0;
    });

    const rows = combined.map(seg => {
      const segId = (seg && typeof seg === 'object' && seg.segment_id != null) ? String(seg.segment_id) : '';
      const startUtc = (seg && typeof seg === 'object' && seg.start_utc != null) ? String(seg.start_utc) : '';
      const endUtc = (seg && typeof seg === 'object' && seg.end_utc != null) ? String(seg.end_utc) : '';

      const dateLabel = (() => {
        const raw = String(seg?.date || '').slice(0, 10);
        if (/^\d{4}-\d{2}-\d{2}$/.test(raw)) return fmtDowDmy(raw);
        const fromIso = isoToDowDmy(startUtc);
        return fromIso || 'â€”';
      })();

      const startHH = isoToHHMM(startUtc);
      const endHH = isoToHHMM(endUtc);

      const refNum = (seg && typeof seg === 'object' && seg.ref_num != null) ? String(seg.ref_num) : '';
      const hrs = invoiceModalRound2(sumSegHours(seg));
      const chg = invoiceModalRound2(Number(seg?.charge_amount || 0));
      const pay = invoiceModalRound2(Number(seg?.pay_amount || 0));

      const k = segKey(tsfinId, segId);
      const stagedRemove = (!!tsfinId && !!segId && stagedSegRemoveSet.has(k));
      const stagedAdd = !!seg.__staged_add;

      const checkbox = stagedAdd
        ? `
          <input type="checkbox"
            class="form-check-input"
            data-action="inv-toggle-add-segment"
            data-timesheet-id="${esc(tsId)}"
            data-tsfin-id="${esc(String(tsfinId || ''))}"
            data-segment-id="${esc(String(segId || ''))}"
            checked
            ${canStageSegments ? '' : 'disabled'}
          />
        `
        : `
          <input type="checkbox"
            class="form-check-input"
            data-action="inv-toggle-remove-segment"
            data-timesheet-id="${esc(tsId)}"
            data-tsfin-id="${esc(String(tsfinId || ''))}"
            data-segment-id="${esc(String(segId || ''))}"
            ${stagedRemove ? 'checked' : ''}
            ${canStageSegments ? '' : 'disabled'}
          />
        `;

      const chip = stagedAdd
        ? `<span class="pill pill-ok">Staged add</span>`
        : (stagedRemove ? `<span class="pill pill-warn">Pending removal</span>` : '');

      const rowStyle = stagedAdd
        ? ` style="background: rgba(46, 204, 113, 0.18);"`
        : (stagedRemove ? ` class="opacity-50"` : '');

      return `
        <tr${rowStyle}>
          <td style="width:32px;">${checkbox}</td>
          <td>${esc(dateLabel)}</td>
          <td>${esc(startHH || 'â€”')}</td>
          <td>${esc(endHH || 'â€”')}</td>
          <td>${esc(refNum || 'â€”')}</td>
          <td class="text-end">${esc(invoiceModalFmtHours(hrs))}</td>
          <td class="text-end">${fmtMoneyLocal(chg)}</td>
          <td class="text-end">${fmtMoneyLocal(pay)}</td>
          <td class="text-end">${chip}</td>
        </tr>
      `;
    }).join('');

     return `
      <div class="mt-3">
        <div class="d-flex align-items-center justify-content-between flex-wrap gap-2 mb-2">
          <div class="fw-semibold">
            Segments
            <span class="text-muted small">
              (${invoicedSegs.length} on invoice, ${uninvoicedCount} uninvoiced, ${lockedElsewhereCount} locked elsewhere)
            </span>
          </div>
        </div>

        ${banner}

        <table class="grid" style="width:100%">
          <thead>
            <tr>
              <th style="width:32px;" class="text-center">
                <input type="checkbox"
                  class="form-check-input"
                  title="Select / deselect all"
                  ${canStageSegments ? '' : 'disabled'}
                  onchange="(function(cb){ try{ var tbl=cb.closest('table'); if(!tbl) return; var qs=tbl.querySelectorAll('tbody input[type=&quot;checkbox&quot;].form-check-input[data-action]'); for (var i=0;i<qs.length;i++){ var x=qs[i]; if(!x || x.disabled) continue; x.checked = cb.checked; try{ x.dispatchEvent(new Event('change',{bubbles:true})); }catch(e){} } }catch(e){} })(this)"
                />
              </th>
              <th>Date</th>
              <th>Start</th>
              <th>End</th>
              <th>Ref</th>
              <th class="text-end">Hours</th>
              <th class="text-end">Charge (ex VAT)</th>
              <th class="text-end">Pay (ex VAT)</th>
              <th class="text-end"></th>
            </tr>
          </thead>
          <tbody>${rows}</tbody>
        </table>
      </div>
    `;

  };

  const renderExpandedTable = (g) => {
    const rows = [];

    for (const l of g.lines) {
      const id = String(l?.invoice_line_id || '');
      if (id && removedSet && typeof removedSet.has === 'function' && removedSet.has(id)) continue;

      const qtyHrs = sumBucketQty(l);

      if (qtyHrs > 0) {
        const parts = buildHourBucketRows(l);
        parts.forEach(r => rows.push(r));
        continue;
      }

      const r = buildNonHourRow(l);
      if (r) rows.push(r);
    }

 const breakdownHtml = (!rows.length)
  ? `<div class="text-muted small">No billable lines.</div>`
  : `
    <div class="mt-2">
      <table class="grid" style="width:100%">
        <thead>
          <tr>
            <th>Unit</th>
            <th class="text-end">Qty</th>
            <th class="text-end">Pay (ex VAT)</th>
            <th class="text-end">Charge (ex VAT)</th>
          </tr>
        </thead>
        <tbody>
          ${rows.map(r => {
            const qtyTxt = (r.qty == null) ? 'â€”' : invoiceModalFmtHours(Number(r.qty || 0));
            return `
              <tr>
                <td>${esc(String(r.unit || ''))}</td>
                <td class="text-end">${esc(String(qtyTxt))}</td>
                <td class="text-end">${fmtMoneyLocal(r.pay_ex)}</td>
                <td class="text-end">${fmtMoneyLocal(r.chg_ex)}</td>
              </tr>
            `;
          }).join('')}
        </tbody>
      </table>
    </div>
  `;


    const segmentsHtml = renderSegmentsOnInvoiceTable(g);

    return `${breakdownHtml}${segmentsHtml}`;
  };

  const renderRemoveBtnForTimesheet = (g, removed) => {
    if (!isEditing) return '';

    if (removed) {
      return `
        <button type="button"
          class="btn btn-sm btn-outline-secondary"
          data-action="inv-toggle-remove-timesheet"
          data-timesheet-id="${esc(g.timesheet_id)}">
          Undo
        </button>
      `;
    }

    if (!canEditLines) return '';

    return `
      <button type="button"
        class="btn btn-sm btn-outline-danger"
        data-action="inv-toggle-remove-timesheet"
        data-timesheet-id="${esc(g.timesheet_id)}">
        Remove
      </button>
    `;
  };

  const stagedBlocks = [];

  if (isEditing && hasAnySegmentTimesheets && (segmentBlock.blocked || !isUnissued)) {
    const reason = segmentBlock.hasAdditional
      ? 'Segments cannot be moved when additional rates exist.'
      : ((segmentBlock.hasMileage || segmentBlock.hasExpense)
          ? 'Segments cannot be moved when expenses or mileage exist.'
          : (!isUnissued ? 'Segments can only be changed before issuing.' : ''));
    stagedBlocks.push(`
      <div class="alert alert-warning py-2 px-2 small mb-3">
        <b>Segment edits disabled:</b> ${esc(reason)}
      </div>
    `);
  }

  const head = `
    <thead>
      <tr>
        <th>Week ending</th>
        <th>Candidate</th>
        <th class="text-end">Total hours</th>
        <th class="text-end">Additional hours</th>
        <th class="text-end">Expenses</th>
        <th class="text-end">Cost (ex VAT)</th>
        <th class="text-end">Cost (inc VAT)</th>
        <th class="text-end">Margin</th>
        ${isEditing ? '<th class="text-end">Actions</th>' : ''}
      </tr>
    </thead>
  `;

  const bodyRows = tsGroupArr.map(g => {
    const totals = groupTotals(g);
    const removed = isGroupRemoved(g);
    const expanded = !!modalCtx.invoiceUi.expanded_timesheets[String(g.timesheet_id)];

    const trMain = `
      <tr data-action="inv-toggle-expand-timesheet" data-timesheet-id="${esc(g.timesheet_id)}" style="cursor:pointer;">
        <td>${esc(String(totals.week || ''))}</td>
        <td>${esc(String(totals.candidate || ''))}</td>
        <td class="text-end">${esc(invoiceModalFmtHours(totals.totalHours))}</td>
        <td class="text-end">${esc(invoiceModalFmtHours(totals.additionalHours))}</td>
        <td class="text-end">${fmtMoneyLocal(totals.expensesEx)}</td>
        <td class="text-end">${fmtMoneyLocal(totals.ex)}</td>
        <td class="text-end">${fmtMoneyLocal(totals.inc)}</td>
        <td class="text-end">${fmtMoneyLocal(totals.margin)}</td>
        ${isEditing ? `<td class="text-end">${renderRemoveBtnForTimesheet(g, removed)}</td>` : ''}
      </tr>
    `;

    const trExpanded = expanded ? `
      <tr>
        <td colspan="${isEditing ? 9 : 8}">
          ${renderExpandedTable(g)}
        </td>
      </tr>
    ` : '';

    return trMain + trExpanded;
  }).join('');

  const adjTable = (() => {
    const allAdj = [...stagedAdjRows, ...adjLines];

    if (!allAdj.length) return '';

    const rows = allAdj.map(a => {
      const isStaged = !!a.staged;

      if (isStaged) {
        const desc = String(a.description || 'Adjustment');
        const ex = invoiceModalRound2(Number(a.ex || 0));

        const btn = (!isEditing)
          ? ''
          : `
            <button type="button" class="btn btn-sm btn-outline-danger"
              data-action="inv-remove-staged-adjustment"
              data-client-token="${esc(String(a.client_token || ''))}">
              Remove
            </button>
          `;

        return `
          <tr style="background: rgba(46, 204, 113, 0.18);">
            <td>${esc(desc)} <span class="pill pill-ok" style="margin-left:6px;">Staged</span></td>
            <td class="text-end">${fmtMoneyLocal(ex)}</td>
            <td class="text-end">â€”</td>
            <td class="text-end">â€”</td>
            ${isEditing ? `<td class="text-end">${btn}</td>` : ''}
          </tr>
        `;
      }

      const l = a.line || {};
      const lid = String(l?.invoice_line_id || a.invoice_line_id || '');
      const desc = String(l?.description || 'Adjustment');
      const ex = invoiceModalRound2(Number(l?.total_charge_ex_vat || 0));
      const inc = invoiceModalRound2(Number(l?.total_inc_vat || 0));
      const margin = invoiceModalRound2(Number(l?.margin_ex_vat || 0));

      const removed = removedSet.has(lid);

      const btn = (!isEditing)
        ? ''
        : (removed
          ? `
            <button type="button"
              class="btn btn-sm btn-outline-secondary"
              data-action="inv-toggle-remove-line"
              data-invoice-line-id="${esc(lid)}">
              Undo
            </button>
          `
          : (canEditLines ? `
            <button type="button"
              class="btn btn-sm btn-outline-danger"
              data-action="inv-toggle-remove-line"
              data-invoice-line-id="${esc(lid)}">
              Remove
            </button>
          ` : '')
        );

      return `
        <tr class="${removed ? 'opacity-50' : ''}">
          <td>${esc(desc)}</td>
          <td class="text-end">${fmtMoneyLocal(ex)}</td>
          <td class="text-end">${fmtMoneyLocal(inc)}</td>
          <td class="text-end">${fmtMoneyLocal(margin)}</td>
          ${isEditing ? `<td class="text-end">${btn}</td>` : ''}
        </tr>
      `;
    }).join('');

    return `
      <div class="mt-3">
        <div class="fw-semibold mb-2">Adjustments</div>
        <table class="grid" style="width:100%">
          <thead>
            <tr>
              <th>Description</th>
              <th class="text-end">Cost (ex VAT)</th>
              <th class="text-end">Cost (inc VAT)</th>
              <th class="text-end">Margin</th>
              ${isEditing ? '<th class="text-end">Actions</th>' : ''}
            </tr>
          </thead>
          <tbody>${rows}</tbody>
        </table>
      </div>
    `;
  })();

  if (!tsGroupArr.length && !adjLines.length && stagedAdjRows.length === 0 && stagedBlocks.length === 0) {
    return `<div class="text-muted">No invoice lines.</div>`;
  }

  return `
    <div>
      ${stagedBlocks.join('')}
      <div class="fw-semibold mb-2">Timesheets</div>
      <table class="grid" style="width:100%">
        ${head}
        <tbody>${bodyRows}</tbody>
      </table>
      ${adjTable}
    </div>
  `;
}


function deriveTimesheetInvoicingDisplay(row) {
  // Prefer new segment-aware fields where present (v_timesheets_summary_base additions),
  // and fall back to legacy locked_by_invoice_id signals for non-segment timesheets.
  const segStage = String(row?.invoice_segment_stage || '').toUpperCase();
  const issueStage = String(row?.invoice_issue_stage || row?.locked_invoice_status || '').toUpperCase();

  const segTotal = Number(row?.invoice_segments_total);
  const hasSegments = Number.isFinite(segTotal) && segTotal > 0;

  if (hasSegments) {
    if (segStage === 'NOT_INVOICED') return 'NOT_INVOICED';
    if (segStage === 'PARTIALLY_INVOICED') return 'PARTIALLY_INVOICED';
    if (segStage === 'FULLY_INVOICED') {
      // If fully invoiced, surface whether the invoice has been issued
      if (issueStage === 'INVOICED_ISSUED') return 'INVOICED_ISSUED';
      if (issueStage === 'INVOICED_NOT_ISSUED') return 'INVOICED_NOT_ISSUED';
      return 'FULLY_INVOICED';
    }
  }

  // Non-segment fallback
  if (!row?.locked_by_invoice_id) return 'NOT_INVOICED';
  if (issueStage === 'INVOICED_ISSUED') return 'INVOICED_ISSUED';
  return 'INVOICED_NOT_ISSUED';
}
function renderTimesheetLinesTab(ctx) {
    const { LOGM, L, GC, GE } = getTsLoggers('[TS][LINES]');
  const { row, details, related, state } = normaliseTimesheetCtx(ctx);


  GC('render');

  const ts      = details.timesheet || {};
  const tsId    = row.timesheet_id || ts.timesheet_id || null;
  const segs    = Array.isArray(details.segments) ? details.segments : [];
  const ib      = details.invoiceBreakdown || null;
  const mode    = ib && typeof ib.mode === 'string' ? ib.mode : null;
  const shifts  = Array.isArray(details.shifts) ? details.shifts : [];
  const isSegments = !!details.isSegmentsMode;

  const sheetScope = (details.sheet_scope || row.sheet_scope || ts.sheet_scope || '').toUpperCase();
  const subMode    = (row.submission_mode || ts.submission_mode || '').toUpperCase();

   const tsfin  = details.tsfin || {};
  const locked = !!(tsfin.locked_by_invoice_id || tsfin.paid_at_utc);
  const basis  = String(tsfin.basis || row.basis || '').toUpperCase();

  // âœ… NEW: invoice_id -> invoice_no lookup (computed ONCE per render)
  // Source of truth is already in modal context (segment-aware):
  // - related.invoice_no_by_invoice_id (preferred)
  // - else build from related.invoices[] (fallback)
  const invoiceNoById = (() => {
    try {
      const r = (related && typeof related === 'object') ? related : {};
      const m0 = (r.invoice_no_by_invoice_id && typeof r.invoice_no_by_invoice_id === 'object')
        ? r.invoice_no_by_invoice_id
        : null;

      const out = Object.create(null);

      if (m0) {
        for (const [k, v] of Object.entries(m0)) {
          const id = String(k || '').trim();
          const no = String(v || '').trim();
          if (id && no) out[id] = no;
        }
      }

      const invs = Array.isArray(r.invoices) ? r.invoices : [];
      for (const inv of invs) {
        if (!inv || typeof inv !== 'object') continue;
        const id =
          String(inv.invoice_id || inv.id || '').trim();
        const no =
          String(inv.invoice_no || '').trim();
        if (id && no && !out[id]) out[id] = no;
      }

      // Back-compat: if older code still sets related.invoice only
      const inv1 = (r.invoice && typeof r.invoice === 'object') ? r.invoice : null;
      if (inv1) {
        const id = String(inv1.invoice_id || inv1.id || '').trim();
        const no = String(inv1.invoice_no || '').trim();
        if (id && no && !out[id]) out[id] = no;
      }

      return out;
    } catch {
      return Object.create(null);
    }
  })();

  const fmtInvoiceHint = (invoiceId) => {
    const iid = String(invoiceId || '').trim();
    if (!iid) return 'âœ… Invoiced';
    const invNo = invoiceNoById[iid] ? String(invoiceNoById[iid]).trim() : '';
    return invNo ? `âœ… Invoiced â€“ ${invNo}` : 'âœ… Invoiced';
  };

  // âœ… NEW: whole-timesheet invoice hint (single invoice id used for all lines)
  // Only show when the timesheet is actually locked to an invoice id.
  const wholeInvoiceId = String(tsfin?.locked_by_invoice_id || '').trim();
  const wholeInvoiceHint = wholeInvoiceId ? fmtInvoiceHint(wholeInvoiceId) : '';

  const isNhspOrHrSelfBillBasis = [
    'NHSP',
    'NHSP_ADJUSTMENT',
    'HEALTHROSTER_SELF_BILL',
    'HEALTHROSTER_ADJUSTMENT'
  ].includes(basis);

  const segTargets = state.segmentInvoiceTargets || {};
  state.segmentInvoiceTargets = segTargets;


  const hasTsfin = !!(
    tsfin && (
      tsfin.timesheet_id ||
      tsfin.total_hours != null ||
      tsfin.total_pay_ex_vat != null ||
      tsfin.processing_status
    )
  );
  const hasContractWeek = !!(details.contract_week_id || row.contract_week_id);
  const isPlannedOnly   = !hasTsfin && hasContractWeek && !tsId;

  L('snapshot', {
    tsId,
    mode,
    segmentsCount: segs.length,
    shiftsCount: shifts.length,
    sheetScope,
    subMode,
    basis,
    hasTsfin,
    hasContractWeek,
    isPlannedOnly,
    locked
  });
  GE();

  const esc = (typeof escapeHtml === 'function')
    ? escapeHtml
    : (s) => String(s == null ? '' : s)
        .replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')
        .replace(/"/g,'&quot;').replace(/'/g,'&#39;');

  // UI helper: YYYY-MM-DD â†’ DD-MM-YYYY
  const fmtYmdDmy = (ymd) => {
    if (!ymd || typeof ymd !== 'string') return ymd || '';
    const m = ymd.match(/^(\d{4})-(\d{2})-(\d{2})$/);
    if (!m) return ymd;
    const [, y, mo, d] = m;
    return `${d}-${mo}-${y}`;
  };

  const toYmd = (d) => {
    const yyyy = d.getUTCFullYear();
    const mm   = String(d.getUTCMonth() + 1).padStart(2, '0');
    const dd   = String(d.getUTCDate()).toString().padStart(2, '0');
    return `${yyyy}-${mm}-${dd}`;
  };

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // SEGMENTS mode (NHSP / HR self-bill) unchanged
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const computeWeekStartFromWeekEnding = (weYmd) => {
    if (!weYmd) return null;
    const d = new Date(`${weYmd}T00:00:00Z`);
    if (Number.isNaN(d.getTime())) return weYmd;
    d.setUTCDate(d.getUTCDate() - 6);
    return toYmd(d);
  };

  // Current invoice week = Monday of "today"
  const computeCurrentWeekStart = () => {
    const now = new Date();
    const base = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));
    const day = base.getUTCDay();      // 0=Sun..6=Sat
    const offset = (day + 6) % 7;      // since Monday
    base.setUTCDate(base.getUTCDate() - offset);
    return toYmd(base);
  };

  const tsWeekEnding     =
    ts.week_ending_date ||
    row.week_ending_date ||
    (details.contract_week && details.contract_week.week_ending_date) ||
    null;

  const naturalWeekStart = tsWeekEnding ? computeWeekStartFromWeekEnding(tsWeekEnding) : null;
  const currentWeekStart = computeCurrentWeekStart();
  const pauseWeekStart   = '2099-01-05'; // "Pause"

  const disabledAttr = locked ? 'disabled' : '';

const buildInvoiceWeekSelectHtml = (seg) => {
  if (!isNhspOrHrSelfBillBasis) return '<span class="mini">â€”</span>';
  const segId = String(seg.segment_id || '');
  if (!segId) return '<span class="mini">â€”</span>';

  const storedTargetRaw = String(seg.invoice_target_week_start || '').trim();
  const lockedInvoiceId = String(seg.invoice_locked_invoice_id || '').trim();

  // âœ… IMPORTANT: staged target must be read by key-presence, not truthiness.
  // This allows an explicit "clear" stage where segTargets[segId] === null.
  const stagedExplicit = Object.prototype.hasOwnProperty.call(segTargets, segId);
  const stagedRaw = stagedExplicit ? segTargets[segId] : undefined;
  const stagedNorm =
    stagedExplicit
      ? (stagedRaw == null ? null : String(stagedRaw).trim())
      : null;

  const hadStagedBefore = stagedExplicit;

  const currentTarget =
    stagedExplicit
      ? (stagedNorm == null ? '' : stagedNorm)
      : (
          storedTargetRaw ||
          naturalWeekStart ||
          currentWeekStart ||
          ''
        );

  const opts = [];
  const seen = new Set();

  if (currentWeekStart) {
    opts.push({ value: currentWeekStart, label: 'This week' });
    seen.add(currentWeekStart);

    const nextDate = new Date(`${currentWeekStart}T00:00:00Z`);
    nextDate.setUTCDate(nextDate.getUTCDate() + 7);
    const nextWeekStart = toYmd(nextDate);
    opts.push({ value: nextWeekStart, label: `Week starting ${fmtYmdDmy(nextWeekStart)}` });
    seen.add(nextWeekStart);

    for (let i = 2; i <= 8; i++) {
      const d = new Date(`${currentWeekStart}T00:00:00Z`);
      d.setUTCDate(d.getUTCDate() + i * 7);
      const ws = toYmd(d);
      if (!seen.has(ws)) {
        opts.push({ value: ws, label: `Week starting ${fmtYmdDmy(ws)}` });
        seen.add(ws);
      }
    }
  }

  if (naturalWeekStart && !seen.has(naturalWeekStart)) {
    opts.push({ value: naturalWeekStart, label: `Natural week (${fmtYmdDmy(naturalWeekStart)})` });
    seen.add(naturalWeekStart);
  }

  if (!seen.has(pauseWeekStart)) {
    opts.push({ value: pauseWeekStart, label: 'Pause (defer)' });
    seen.add(pauseWeekStart);
  }

  let selectedVal = currentTarget || naturalWeekStart || currentWeekStart || '';
  const optionValues = opts.map(o => o.value);
  if (!optionValues.includes(selectedVal)) {
    selectedVal =
      (naturalWeekStart && optionValues.includes(naturalWeekStart)) ? naturalWeekStart :
      (optionValues.includes(currentWeekStart) ? currentWeekStart : pauseWeekStart);
  }

  // helper just for the hint text (DD/MM/YYYY)
  const fmtYmdDmySlash = (ymd) => {
    const s = String(ymd || '').slice(0, 10);
    const m = s.match(/^(\d{4})-(\d{2})-(\d{2})$/);
    if (!m) return s;
    const [, y, mo, d] = m;
    return `${d}/${mo}/${y}`;
  };

  // âœ… Match SQL semantics (and support explicit clear):
  // delayed if:
  //   invoice_locked_invoice_id is null/empty AND
  //   invoice_target_week_start is explicitly present (stored OR staged) AND
  //   invoice_target_week_start !== baseline week start
  //
  // Explicit clear = stagedExplicit && stagedNorm == null  â†’ treated as "no explicit target"
  const hasExplicitTarget = stagedExplicit ? (stagedNorm != null && stagedNorm !== '') : !!storedTargetRaw;
  const targetForDelay =
    stagedExplicit
      ? (stagedNorm == null ? '' : stagedNorm)
      : storedTargetRaw;

  const isPermanentDelay = (targetForDelay === pauseWeekStart);

  const isInvoiceDelayed =
    hasExplicitTarget &&
    !lockedInvoiceId &&
    (
      isPermanentDelay ||
      (!!naturalWeekStart && !!targetForDelay && targetForDelay !== naturalWeekStart)
    );

  const delayHint = isInvoiceDelayed
    ? (isPermanentDelay ? 'Permanently delayed' : `Delayed until ${fmtYmdDmySlash(targetForDelay)}`)
    : '';

  const isSegLocked = !!lockedInvoiceId;

  const invoiceStateHint = isSegLocked
    ? fmtInvoiceHint(lockedInvoiceId)
    : (delayHint ? `â³ ${delayHint}` : 'â—‹ Invoiceable now');

  const disabledAttrSeg = (disabledAttr || isSegLocked) ? 'disabled' : '';

  // âœ… Preferred display: UK date (DD/MM/YYYY) for the picker input
  const toUk = (ymd) => {
    const s = String(ymd || '').slice(0, 10);
    if (!s) return '';
    if (typeof formatIsoToUk === 'function') return formatIsoToUk(s);
    const m = s.match(/^(\d{4})-(\d{2})-(\d{2})$/);
    return m ? `${m[3]}/${m[2]}/${m[1]}` : s;
  };

  // Only show an explicit selected date if it is explicitly stored or explicitly staged
  const storedExplicit = !!storedTargetRaw;

  const explicitTarget =
    stagedExplicit
      ? (stagedNorm == null ? '' : stagedNorm)
      : (storedExplicit ? storedTargetRaw : '');

  const isPaused = (explicitTarget === pauseWeekStart);
  const valueUk  = (!isPaused && explicitTarget) ? toUk(explicitTarget) : '';

  // Disable date input if paused or already invoiced/locked
  const dateDisabled = (disabledAttrSeg || isPaused) ? 'disabled' : '';
  const pauseDisabled = disabledAttrSeg ? 'disabled' : '';

  const pauseChecked = isPaused ? 'checked' : '';

  return `
    <div style="display:flex;flex-direction:column;gap:4px;">
      <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap;">
        <input
          type="text"
          class="input mini"
          name="seg_invoice_week"
          data-segment-id="${segId}"
          placeholder="DD/MM/YYYY"
          value="${valueUk}"
          ${dateDisabled}
        />
        <label class="mini" style="display:flex;gap:6px;align-items:center;user-select:none;">
          <input
            type="checkbox"
            name="seg_invoice_pause"
            data-segment-id="${segId}"
            ${pauseChecked}
            ${pauseDisabled}
          />
          Delay indefinitely
        </label>
      </div>
      <span class="mini">${invoiceStateHint}</span>
    </div>
  `;
};


  if (isSegments && segs.length && isNhspOrHrSelfBillBasis) {
    const headHtml = `
      <thead>
        <tr>
          <th>Date</th>
          <th>Ref / Request</th>
          <th>Source</th>
          <th>Hours</th>
          <th>Pay</th>
          <th>Charge</th>
          <th>Exclude from pay</th>
          <th>Invoice week / Pause</th>
        </tr>
      </thead>
    `;

    const bodyRows = segs.map((seg) => {
      const effOverride = state.segmentOverrides && state.segmentOverrides[seg.segment_id];
      const effExclude  = effOverride && Object.prototype.hasOwnProperty.call(effOverride, 'exclude_from_pay')
        ? !!effOverride.exclude_from_pay
        : !!seg.exclude_from_pay;

      const srcRaw = seg.source_system || (seg.segment_id || '').split(':')[0] || '';
      const src  = srcRaw || '';
      const rawDate = seg.date || seg.work_date || '';
      const displayDate = rawDate ? fmtYmdDmy(rawDate) : '';
      const dateCellHtml = displayDate || '<span class="mini">â€”</span>';

      const hours = seg.total_hours ?? seg.hours_day ?? seg.hours_night ?? seg.hours ?? '';
      const pay   = seg.pay_amount   ?? seg.pay_ex_vat ?? '';
      const charge= seg.charge_amount?? seg.charge_ex_vat ?? '';

      const ref   = seg.ref_num || '';
      const reqId = seg.request_id || '';

 const segId = String(seg.segment_id || '');

// âœ… MUST capture these BEFORE buildInvoiceWeekSelectHtml() mutates segTargets[segId]
const hadStagedBefore = Object.prototype.hasOwnProperty.call(segTargets, segId);
const storedTargetRaw = String(seg.invoice_target_week_start || '').trim();
const lockedInvoiceId = String(seg.invoice_locked_invoice_id || '').trim();

// build HTML (this may write segTargets[segId])
const invoiceWeekCellHtml = buildInvoiceWeekSelectHtml(seg);

// âœ… Determine delay using SQL semantics (explicit stored OR staged-before)
const hasExplicitTarget = hadStagedBefore || !!storedTargetRaw;
const targetForDelay = hadStagedBefore ? String(segTargets[segId] || '').trim() : storedTargetRaw;

const baseline = String(naturalWeekStart || '').trim();
const isPermanentDelay = (targetForDelay === pauseWeekStart);

const isInvoiceDelayed =
  hasExplicitTarget &&
  !lockedInvoiceId &&
  (
    isPermanentDelay ||
    (baseline && targetForDelay && targetForDelay !== baseline)
  );

const rowIsFlagged = !!effExclude || isInvoiceDelayed;
const rowStyle = rowIsFlagged ? ` style="background: rgba(192, 57, 43, 0.18);"` : '';

const disabledExcludeAttr = (disabledAttr || lockedInvoiceId) ? 'disabled' : '';

return `
  <tr data-segment-id="${seg.segment_id}"${rowStyle}>
    <td>${dateCellHtml}</td>
    <td>
      ${ref ? `<span class="mini">Ref: ${esc(ref)}</span>` : ''}
      ${reqId ? `<br><span class="mini">Req: ${esc(reqId)}</span>` : ''}
      ${(!ref && !reqId) ? '<span class="mini">â€”</span>' : ''}
    </td>
    <td>${src ? esc(src) : '<span class="mini">â€”</span>'}</td>
    <td>${hours !== '' ? esc(hours) : '<span class="mini">â€”</span>'}</td>
    <td>${pay   !== '' ? esc(pay)   : '<span class="mini">â€”</span>'}</td>
    <td>${charge!== '' ? esc(charge): '<span class="mini">â€”</span>'}</td>
    <td>
      <input
        type="checkbox"
        name="seg_exclude_from_pay"
        data-segment-id="${seg.segment_id}"
        ${effExclude ? 'checked' : ''}
        ${disabledExcludeAttr}
      />
      <span class="mini">Tick = exclude from pay (staged)</span>
    </td>
    <td>${invoiceWeekCellHtml}</td>
  </tr>
`;

    }).join('');

    return `
      <div class="tabc">
        <div class="card">
          <div class="row">
            <label>Timesheet ID</label>
            <div class="controls">${tsId || '<span class="mini">Unknown</span>'}</div>
          </div>
          <div class="row">
            <label>Mode</label>
            <div class="controls">
              <span class="mini">Invoice breakdown mode: ${esc(mode || 'UNKNOWN')} (basis: ${esc(basis || 'UNKNOWN')})</span>
            </div>
          </div>
        </div>

        <div class="card" style="margin-top:10px;">
          <div class="row">
            <label>Lines</label>
            <div class="controls">
              <div style="max-height:320px;overflow:auto;">
                <table class="grid mini">
                  ${headHtml}
                  <tbody>${bodyRows}</tbody>
                </table>
              </div>
            </div>
          </div>
          <div class="row">
            <label></label>
            <div class="controls">
              <span class="mini">Changes to "Exclude from pay" and "Invoice week / Pause" are staged only. They are applied when you click Save on the Timesheet modal.</span>
            </div>
          </div>
        </div>
      </div>
    `;
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // WEEKLY: shift-line grid (schedule-driven ONLY)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (sheetScope === 'WEEKLY') {
    const frameMode =
      (typeof window.__getModalFrame === 'function' ? window.__getModalFrame()?.mode : null) ||
      'view';

    const isEditMode = (frameMode === 'edit' || frameMode === 'create');
    const canEditSchedule = isEditMode && !locked && subMode === 'MANUAL';

    // Build full 7-day week list (always show all days)
    const dowShort = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
    let weekDays = [];
    if (tsWeekEnding) {
      try {
        const base = new Date(`${tsWeekEnding}T00:00:00Z`);
        for (let offset = 6; offset >= 0; offset--) {
          const d = new Date(base);
          d.setUTCDate(base.getUTCDate() - offset);
          weekDays.push({
            ymd: toYmd(d),
            dow: dowShort[d.getUTCDay()]
          });
        }
      } catch {
        weekDays = [];
      }
    }
    if (!weekDays.length) {
      // still render something rather than crash; schedule editor expects 7 days when week ending exists
      weekDays = [{ ymd: '', dow: '' }];
    }

    // Persist weekDays on state so the window helper can always build/validate
    state.__weekDaysForSchedule = weekDays;

    const tryParse = (src) => {
      if (!src) return null;
      if (Array.isArray(src) || typeof src === 'object') return JSON.parse(JSON.stringify(src));
      if (typeof src === 'string') {
        try {
          const p = JSON.parse(src);
          if (Array.isArray(p) || typeof p === 'object') return p;
        } catch {}
      }
      return null;
    };

    let seedSchedule = null;
    if (Array.isArray(state.schedule) && state.schedule.length) {
      seedSchedule = tryParse(state.schedule);
    } else {
      seedSchedule = tryParse(ts.actual_schedule_json);
      if ((!seedSchedule || !seedSchedule.length) && details && details.contract_week) {
        const cw2 = details.contract_week;
        const src = (cw2.planned_schedule_json != null) ? cw2.planned_schedule_json
                 : (cw2.std_schedule_json != null)     ? cw2.std_schedule_json
                 : null;
        seedSchedule = tryParse(src);
      }
    }
    if (!Array.isArray(seedSchedule)) seedSchedule = [];

    const normDate = (seg) => String(seg?.date || seg?.date_ymd || seg?.work_date || '').trim();

    const asLondonHHMM = (iso) => {
      try {
        const d = new Date(String(iso || ''));
        if (Number.isNaN(d.getTime())) return '';
        return d.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit', hour12: false, timeZone: 'Europe/London' });
      } catch { return ''; }
    };

    const normHHMM = (seg, keyHH, keyIso) => {
      const s = String(seg?.[keyHH] || '').trim();
      if (s) return s;
      const iso = seg?.[keyIso] || null;
      return iso ? asLondonHHMM(iso) : '';
    };

    const segRef = (seg) => {
      const v =
        seg?.ref_num ??
        seg?.reference ??
        seg?.ref ??
        seg?.ref_number ??
        seg?.request_id ??
        '';
      return String(v || '').trim();
    };

    // de-dupe primary break if break_start/break_end also appears in breaks[]
    const segBreaks = (seg) => {
      const out = [];
      const seen = new Set();

      const add = (startRaw, endRaw) => {
        const s = String(startRaw || '').trim();
        const e = String(endRaw   || '').trim();
        if (!s && !e) return;
        const key = `${s}â†’${e}`;
        if (seen.has(key)) return;
        seen.add(key);
        out.push({ start: s, end: e });
      };

      const bArr = Array.isArray(seg?.breaks) ? seg.breaks : [];
      add(seg?.break_start, seg?.break_end);
      bArr.forEach(b => add(b?.start, b?.end));
      return out;
    };

    const parseHHMM = (s) => {
      const m = String(s || '').trim().match(/^(\d{1,2}):(\d{2})$/);
      if (!m) return null;
      const hh = Number(m[1]), mm = Number(m[2]);
      if (!Number.isFinite(hh) || !Number.isFinite(mm)) return null;
      if (hh < 0 || hh > 23 || mm < 0 || mm > 59) return null;
      return hh * 60 + mm;
    };

    const parseBreakMins = (v) => {
      const s = String(v == null ? '' : v).trim();
      if (!s) return 0;
      const m = s.match(/^(\d{1,4})(?:\s*m)?$/i);
      if (!m) return NaN;
      const n = Number(m[1]);
      if (!Number.isFinite(n) || n < 0) return NaN;
      return Math.floor(n);
    };

    // Build default linesByDate from seedSchedule (shift lines + break-only lines)
    // supports schedule seg.break_minutes -> seeds break_mins
    const buildLinesFromSchedule = () => {
      const byDate = {};
      for (const seg of seedSchedule) {
        const ymd = normDate(seg);
        if (!ymd) continue;
        (byDate[ymd] ||= []).push(seg);
      }

      for (const ymd of Object.keys(byDate)) {
        byDate[ymd].sort((a, b) => {
          const sa = parseHHMM(normHHMM(a, 'start', 'start_utc')) ?? -1;
          const sb = parseHHMM(normHHMM(b, 'start', 'start_utc')) ?? -1;
          if (sa !== sb) return sa - sb;
          const ea = parseHHMM(normHHMM(a, 'end', 'end_utc')) ?? -1;
          const eb = parseHHMM(normHHMM(b, 'end', 'end_utc')) ?? -1;
          return ea - eb;
        });
      }

      const linesByDate = {};
      for (const wd of weekDays) {
        const ymd = wd.ymd;
        const segsDay = (ymd && byDate[ymd]) ? byDate[ymd] : [];
        const lines = [];

        for (const seg of segsDay) {
          const breaks = segBreaks(seg);
          const b0 = breaks[0] || { start: '', end: '' };

          const segBreakMinutes =
            (seg && (seg.break_minutes != null || seg.break_mins != null))
              ? (Number(seg.break_minutes ?? seg.break_mins) || 0)
              : 0;

          const useBreakMins = (!breaks.length && segBreakMinutes > 0);

          lines.push({
            ref: segRef(seg),
            start: normHHMM(seg, 'start', 'start_utc'),
            end:   normHHMM(seg, 'end',   'end_utc'),
            break_start: useBreakMins ? '' : String(b0.start || '').trim(),
            break_end:   useBreakMins ? '' : String(b0.end   || '').trim(),
            break_mins:  useBreakMins ? String(Math.round(segBreakMinutes)) : ''
          });

          for (let i = 1; i < breaks.length; i++) {
            const b = breaks[i] || {};
            lines.push({
              ref: '',
              start: '',
              end: '',
              break_start: String(b.start || '').trim(),
              break_end:   String(b.end   || '').trim(),
              break_mins: ''
            });
          }
        }

        if (!lines.length) {
          lines.push({ ref:'', start:'', end:'', break_start:'', break_end:'', break_mins:'' });
        }

        linesByDate[ymd] = lines;
      }

      return linesByDate;
    };

    const stable = (x) => { try { return JSON.stringify(x || null); } catch { return ''; } };

    state.weeklyLinesByDate = (state.weeklyLinesByDate && typeof state.weeklyLinesByDate === 'object') ? state.weeklyLinesByDate : null;
    state.extraShiftCount   = Number.isFinite(Number(state.extraShiftCount)) ? Math.max(0, Number(state.extraShiftCount)) : 0;

    const seedHash  = stable(seedSchedule);
    const priorHash = state.__weeklyLinesSeedHash || '';

    // Only auto-reseed in VIEW mode (never clobber edits)
    if (!state.weeklyLinesByDate || (frameMode === 'view' && priorHash !== seedHash)) {
      state.weeklyLinesByDate = buildLinesFromSchedule();
      state.__weeklyLinesSeedHash = seedHash;

      // derive extraShiftCount so the UI shows all stored lines (including break-only lines)
      let maxLines = 1;
      for (const wd of weekDays) {
        const arr = state.weeklyLinesByDate[wd.ymd] || [];
        if (arr.length > maxLines) maxLines = arr.length;
      }
      state.extraShiftCount = Math.max(0, maxLines - 1);
    }

    // Ensure every day has the same number of visible line slots
    const totalLinesPerDay = Math.max(1, 1 + Number(state.extraShiftCount || 0), (() => {
      let m = 1;
      for (const wd of weekDays) {
        const arr = state.weeklyLinesByDate?.[wd.ymd] || [];
        if (arr.length > m) m = arr.length;
      }
      return m;
    })());

    for (const wd of weekDays) {
      const ymd = wd.ymd;
      const arr = Array.isArray(state.weeklyLinesByDate?.[ymd]) ? state.weeklyLinesByDate[ymd].slice() : [];
      while (arr.length < totalLinesPerDay) arr.push({ ref:'', start:'', end:'', break_start:'', break_end:'', break_mins:'' });
      if (arr.length > totalLinesPerDay) arr.length = totalLinesPerDay;
      state.weeklyLinesByDate[ymd] = arr;
    }

    // Paid hours per shift line (includes break-only lines below it)
    const paidByKey = {};
    for (const wd of weekDays) {
      const ymd = wd.ymd;
      const lines = state.weeklyLinesByDate[ymd] || [];

      let curShiftIdx = null;
      let curShiftStart = null;
      let curShiftEndAdj = null;
      let curBreakMins = 0;

      const diffMins = (a, b) => {
        const am = parseHHMM(a);
        const bm = parseHHMM(b);
        if (am == null || bm == null) return null;
        let d = bm - am;
        if (d < 0) d += 1440;
        return d;
      };

      const addBreakFromLine = (ln) => {
        const bm = parseBreakMins(ln.break_mins);
        const hasMins = Number.isFinite(bm) && bm > 0;
        const hasWin = !!(String(ln.break_start || '').trim() || String(ln.break_end || '').trim());

        if (hasMins) { curBreakMins += bm; return; }
        if (hasWin) {
          const d = diffMins(ln.break_start, ln.break_end);
          if (Number.isFinite(d) && d > 0) curBreakMins += d;
        }
      };

      const finalize = () => {
        if (curShiftIdx == null) return;
        if (curShiftStart == null || curShiftEndAdj == null) {
          paidByKey[`${ymd}:${curShiftIdx}`] = '';
          return;
        }
        const shiftMins = Math.max(0, curShiftEndAdj - curShiftStart);
        const paidMins = Math.max(0, shiftMins - (Number(curBreakMins) || 0));
        paidByKey[`${ymd}:${curShiftIdx}`] = (Math.round((paidMins / 60) * 100) / 100).toFixed(2);
      };

      for (let i = 0; i < lines.length; i++) {
        const ln = lines[i] || {};
        const hasShift = !!(String(ln.start||'').trim() || String(ln.end||'').trim());
        const hasBreakAny =
          !!(String(ln.break_start||'').trim() || String(ln.break_end||'').trim()) ||
          (Number.isFinite(parseBreakMins(ln.break_mins)) && parseBreakMins(ln.break_mins) > 0);

        if (hasShift) {
          finalize();

          const s0 = parseHHMM(ln.start);
          const e0 = parseHHMM(ln.end);

          curShiftIdx = i;
          curBreakMins = 0;

          if (s0 != null && e0 != null && s0 !== e0) {
            curShiftStart = s0;
            curShiftEndAdj = (e0 > s0) ? e0 : (e0 + 1440);
          } else {
            curShiftStart = null;
            curShiftEndAdj = null;
          }

          if (hasBreakAny) addBreakFromLine(ln);
        } else if (hasBreakAny && curShiftIdx != null) {
          addBreakFromLine(ln);
        }
      }
      finalize();
    }

    const disabledAttrManual = (!canEditSchedule) ? 'disabled' : '';

    // Ensure these exist
    state.scheduleErrorsByDate = (state.scheduleErrorsByDate && typeof state.scheduleErrorsByDate === 'object') ? state.scheduleErrorsByDate : {};
    state.scheduleHasErrors = !!state.scheduleHasErrors;

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Uses your NEW global helper: buildWeeklyScheduleFromLinesAndValidate
    // Updates state.schedule + state.scheduleHasErrors + state.scheduleErrorsByDate
    // Also does UI highlighting + dispatch event for Finance tab.
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const applyScheduleFromLines = (st) => {
      if (typeof buildWeeklyScheduleFromLinesAndValidate !== 'function') return null;

      const wd = Array.isArray(st.__weekDaysForSchedule) && st.__weekDaysForSchedule.length
        ? st.__weekDaysForSchedule
        : weekDays;

      const out = buildWeeklyScheduleFromLinesAndValidate(st.weeklyLinesByDate, wd, {
        allowOvernight: true,
        allowBreakMins: true
      });

      st.schedule = Array.isArray(out?.schedule) ? out.schedule : [];
      st.scheduleErrorsByDate = (out?.errorsByDate && typeof out.errorsByDate === 'object') ? out.errorsByDate : {};
      st.scheduleHasErrors = !!out?.hasErrors;
      st.__scheduleUpdatedAt = Date.now();

      // Live highlight: if a date has any errors, mark all inputs for that date
      try {
        const errs = st.scheduleErrorsByDate || {};
        const allDates = new Set(Object.keys(st.weeklyLinesByDate || {}));
        for (const d of allDates) {
          const hasErr = !!errs[d];
          const sel = `#tsWeeklySchedule input[data-date="${CSS.escape(d)}"]`;
          document.querySelectorAll(sel).forEach(inp => {
            if (hasErr) inp.classList.add('is-invalid');
            else inp.classList.remove('is-invalid');
          });
        }
        const banner = document.getElementById('tsWeeklyErrorsBanner');
        if (banner) banner.style.display = st.scheduleHasErrors ? '' : 'none';
      } catch {}

      // Notify other tabs (Finance) that schedule/errors changed
      try {
        window.dispatchEvent(new CustomEvent('ts-weekly-schedule-updated', {
          detail: {
            hasErrors: !!st.scheduleHasErrors,
            errorsByDate: st.scheduleErrorsByDate || {},
            scheduleCount: Array.isArray(st.schedule) ? st.schedule.length : 0
          }
        }));
      } catch {}

      return out;
    };

    // Install helper in THIS TAB (not showModal)
    try {
      if (!window.__tsWeeklyLinesHelper || window.__tsWeeklyLinesHelper.__v !== 4) {
        window.__tsWeeklyLinesHelper = {
          __v: 4,

          _hhmm(raw) {
            let s = String(raw || '').trim();
            if (!s) return '';
            if (/^\d{1,2}:\d{2}$/.test(s)) {
              const [h, m] = s.split(':');
              const hh = String(Number(h) || 0).padStart(2, '0');
              const mm = String(Number(m) || 0).padStart(2, '0');
              return `${hh}:${mm}`;
            }
            s = s.replace(':', '');
            if (!/^\d{1,4}$/.test(s)) return '';
            if (s.length <= 2) {
              const h = Number(s);
              if (!Number.isFinite(h)) return '';
              return `${String(h).padStart(2, '0')}:00`;
            }
            const mm = s.slice(-2);
            const h  = s.slice(0, -2);
            const hh = String(Number(h) || 0).padStart(2, '0');
            const mm2 = String(Number(mm) || 0).padStart(2, '0');
            return `${hh}:${mm2}`;
          },

          _normBreakMins(raw) {
            const s = String(raw == null ? '' : raw).trim();
            if (!s) return '';
            const m = s.match(/^(\d{1,4})(?:\s*m)?$/i);
            if (!m) return '';
            const n = Number(m[1]);
            if (!Number.isFinite(n) || n < 0) return '';
            return String(Math.floor(n));
          },

          _parse(s) {
            const m = String(s || '').trim().match(/^(\d{1,2}):(\d{2})$/);
            if (!m) return null;
            const hh = Number(m[1]), mm = Number(m[2]);
            if (!Number.isFinite(hh) || !Number.isFinite(mm) || hh < 0 || hh > 23 || mm < 0 || mm > 59) return null;
            return hh * 60 + mm;
          },

          _diff(a, b) {
            const am = this._parse(a);
            const bm = this._parse(b);
            if (am == null || bm == null) return null;
            let d = bm - am;
            if (d < 0) d += 1440;
            return d;
          },

          _parseBreakMins(raw) {
            const s = String(raw == null ? '' : raw).trim();
            if (!s) return 0;
            const m = s.match(/^(\d{1,4})(?:\s*m)?$/i);
            if (!m) return NaN;
            const n = Number(m[1]);
            if (!Number.isFinite(n) || n < 0) return NaN;
            return Math.floor(n);
          },

          _getState() {
            const mc = window.modalCtx || {};
            const st = mc.timesheetState || null;
            const fr = (typeof window.__getModalFrame === 'function') ? window.__getModalFrame() : null;
            if (!st) return { st: null, fr: null };

            st.weeklyLinesByDate = (st.weeklyLinesByDate && typeof st.weeklyLinesByDate === 'object') ? st.weeklyLinesByDate : {};
            st.scheduleErrorsByDate = (st.scheduleErrorsByDate && typeof st.scheduleErrorsByDate === 'object') ? st.scheduleErrorsByDate : {};
            st.extraShiftCount = Number.isFinite(Number(st.extraShiftCount)) ? Math.max(0, Number(st.extraShiftCount)) : 0;
            st.scheduleHasErrors = !!st.scheduleHasErrors;

            return { st, fr };
          },

      _ensureLine(st, date, idx) {
  const d = String(date || '');
  const i = Number(idx || 0);
  if (!d || !Number.isFinite(i) || i < 0) return null;

  st.weeklyLinesByDate[d] = Array.isArray(st.weeklyLinesByDate[d]) ? st.weeklyLinesByDate[d] : [];
  while (st.weeklyLinesByDate[d].length <= i) {
    st.weeklyLinesByDate[d].push({ ref:'', start:'', end:'', break_start:'', break_end:'', break_mins:'' });
  }
  st.weeklyLinesByDate[d][i] = st.weeklyLinesByDate[d][i] || { ref:'', start:'', end:'', break_start:'', break_end:'', break_mins:'' };
  if (st.weeklyLinesByDate[d][i].break_mins == null) st.weeklyLinesByDate[d][i].break_mins = '';
  return st.weeklyLinesByDate[d][i];
},

_syncBreakMinsLock(date, idx, ln) {
  try {
    const d = String(date || '');
    const i = Number(idx);
    if (!d || !Number.isFinite(i)) return;

    const hasWindow = !!(String(ln?.break_start || '').trim() || String(ln?.break_end || '').trim());

    const minsEl = document.querySelector(
      `input[data-weekly-field="break_mins"][data-date="${CSS.escape(d)}"][data-line-idx="${i}"]`
    );
    if (!minsEl) return;

    if (hasWindow) {
      minsEl.dataset.breaklock = '1';
      minsEl.disabled = true;
      minsEl.readOnly = true;
      return;
    }

    // Only re-enable if we were the reason it was disabled (avoid fighting global readonly)
    if (minsEl.dataset.breaklock === '1') {
      minsEl.disabled = false;
      minsEl.readOnly = false;
      delete minsEl.dataset.breaklock;
    }
  } catch {}
},

          _recalcPaidForDate(st, date) {
            const d = String(date || '');
            if (!d) return;

            const lines = Array.isArray(st.weeklyLinesByDate[d]) ? st.weeklyLinesByDate[d] : [];
            let curShiftIdx = null;
            let curShiftStart = null;
            let curShiftEndAdj = null;
            let curBreakMins = 0;

            const setPaid = (idx, val) => {
              try {
                const el = document.querySelector(`span.sched-paid-hours[data-date="${CSS.escape(d)}"][data-line-idx="${idx}"]`);
                if (el) el.textContent = (val == null ? '' : String(val));
              } catch {}
            };

            const fin = () => {
              if (curShiftIdx == null) return;
              if (curShiftStart == null || curShiftEndAdj == null) {
                setPaid(curShiftIdx, '');
                return;
              }
              const shiftMins = Math.max(0, curShiftEndAdj - curShiftStart);
              const paidMins  = Math.max(0, shiftMins - (Number(curBreakMins) || 0));
              setPaid(curShiftIdx, (Math.round((paidMins / 60) * 100) / 100).toFixed(2));
            };

            const addBreak = (ln) => {
              const bm = this._parseBreakMins(ln.break_mins);
              const hasMins = Number.isFinite(bm) && bm > 0;
              const hasWin = !!(String(ln.break_start||'').trim() || String(ln.break_end||'').trim());

              if (hasMins) { curBreakMins += bm; return; }
              if (hasWin) {
                const x = this._diff(ln.break_start, ln.break_end);
                if (Number.isFinite(x) && x > 0) curBreakMins += x;
              }
            };

            for (let i = 0; i < lines.length; i++) {
              const ln = lines[i] || {};
              const hasShift = !!(String(ln.start||'').trim() || String(ln.end||'').trim());
              const bm = this._parseBreakMins(ln.break_mins);
              const hasBreak =
                !!(String(ln.break_start||'').trim() || String(ln.break_end||'').trim()) ||
                (Number.isFinite(bm) && bm > 0);

              if (hasShift) {
                fin();

                const s0 = this._parse(ln.start);
                const e0 = this._parse(ln.end);

                curShiftIdx = i;
                curBreakMins = 0;

                if (s0 != null && e0 != null && s0 !== e0) {
                  curShiftStart = s0;
                  curShiftEndAdj = (e0 > s0) ? e0 : (e0 + 1440);
                } else {
                  curShiftStart = null;
                  curShiftEndAdj = null;
                }

                if (hasBreak) addBreak(ln);
              } else if (hasBreak && curShiftIdx != null) {
                addBreak(ln);
              }
            }

            fin();

            // clear paid text for non-shift lines
            for (let i = 0; i < lines.length; i++) {
              const ln = lines[i] || {};
              const hasShift = !!(String(ln.start||'').trim() || String(ln.end||'').trim());
              if (!hasShift) setPaid(i, '');
            }
          },

          _markDirty() {
            try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
          },

          onInput(el) {
            try {
              const { st } = this._getState();
              if (!st || !el) return;

              const date  = String(el.dataset.date || '');
              const idx   = Number(el.dataset.lineIdx || '0');
              const field = String(el.dataset.weeklyField || '');

              if (!date || !Number.isFinite(idx) || idx < 0 || !field) return;

              const ln = this._ensureLine(st, date, idx);
              if (!ln) return;

           ln[field] = String(el.value || '');

// If user is using break start/end on this line:
// - keep break_mins OUT of state (avoid mixing)
// - but auto-populate the break_mins *display* so the user can see the duration
if (field === 'break_start' || field === 'break_end') {
  const bs = String(ln.break_start || '').trim();
  const be = String(ln.break_end   || '').trim();
  const hasWindow = !!(bs || be);

  // Always keep mins empty in state when a window is used
  if (hasWindow) ln.break_mins = '';

  // Auto-fill the UI mins box (read-only/disabled is fine; value still shows)
  try {
    const minsEl = document.querySelector(
      `input[data-weekly-field="break_mins"][data-date="${CSS.escape(date)}"][data-line-idx="${idx}"]`
    );
    if (minsEl) {
      // Only show mins when BOTH start+end are present and valid
      const d = (bs && be) ? this._diff(bs, be) : null; // minutes, supports overnight
      minsEl.value = (Number.isFinite(d) && d >= 0) ? String(d) : '';
    }
  } catch {}

  // âœ… lock/unlock break mins for THIS line only
  this._syncBreakMinsLock(date, idx, ln);
} else {
  // keep existing behaviour for other fields
  this._syncBreakMinsLock(date, idx, ln);
}


// âœ… paid hours updates live, including after tab-away (onBlur calls onInput)
this._recalcPaidForDate(st, date);

// âœ… rebuild + validate schedule on every edit (pre-save Finance preview fix)
applyScheduleFromLines(st);

this._markDirty();

            } catch {}
          },

          onBlur(el) {
            try {
              if (!el) return;
              const field = String(el.dataset.weeklyField || '');
              if (field === 'start' || field === 'end' || field === 'break_start' || field === 'break_end') {
                el.value = this._hhmm(el.value);
              }
              if (field === 'break_mins') {
                el.value = this._normBreakMins(el.value);
              }
              this.onInput(el);
            } catch {}
          },

          addLine() {
            const { st, fr } = this._getState();
            if (!st) return;

            const dates = Object.keys(st.weeklyLinesByDate || {});
            if (!dates.length) return;

            const cur = Number(st.extraShiftCount || 0);
            st.extraShiftCount = (Number.isFinite(cur) ? cur : 0) + 1;

            const wantLen = 1 + st.extraShiftCount;
            for (const d of dates) {
              st.weeklyLinesByDate[d] = Array.isArray(st.weeklyLinesByDate[d]) ? st.weeklyLinesByDate[d] : [];
              while (st.weeklyLinesByDate[d].length < wantLen) {
                st.weeklyLinesByDate[d].push({ ref:'', start:'', end:'', break_start:'', break_end:'', break_mins:'' });
              }
              if (st.weeklyLinesByDate[d].length > wantLen) st.weeklyLinesByDate[d].length = wantLen;
              this._recalcPaidForDate(st, d);
            }

            applyScheduleFromLines(st);
            this._markDirty();

            try {
              if (fr && fr.entity === 'timesheets') {
                fr._suppressDirty = true;
                fr.setTab('lines');
                fr._suppressDirty = false;
                fr._updateButtons && fr._updateButtons();
              }
            } catch {}
          },

          removeLine() {
            const { st, fr } = this._getState();
            if (!st) return;

            const cur = Number(st.extraShiftCount || 0);
            if (!Number.isFinite(cur) || cur <= 0) return;

            const wantLen = 1 + (cur - 1);

            let hasData = false;
            for (const d of Object.keys(st.weeklyLinesByDate || {})) {
              const arr = Array.isArray(st.weeklyLinesByDate[d]) ? st.weeklyLinesByDate[d] : [];
              const last = arr[arr.length - 1] || null;
              if (last) {
                if (
                  String(last.ref || '').trim() ||
                  String(last.start || '').trim() ||
                  String(last.end || '').trim() ||
                  String(last.break_start || '').trim() ||
                  String(last.break_end || '').trim() ||
                  String(last.break_mins || '').trim()
                ) {
                  hasData = true;
                  break;
                }
              }
            }
            if (hasData) {
              const ok = window.confirm('The last shift line contains data on at least one day. Remove it anyway?');
              if (!ok) return;
            }

            st.extraShiftCount = cur - 1;

            for (const d of Object.keys(st.weeklyLinesByDate || {})) {
              const arr = Array.isArray(st.weeklyLinesByDate[d]) ? st.weeklyLinesByDate[d] : [];
              if (arr.length > wantLen) arr.length = wantLen;
              while (arr.length < wantLen) arr.push({ ref:'', start:'', end:'', break_start:'', break_end:'', break_mins:'' });
              st.weeklyLinesByDate[d] = arr;
              this._recalcPaidForDate(st, d);
            }

            applyScheduleFromLines(st);
            this._markDirty();

            try {
              if (fr && fr.entity === 'timesheets') {
                fr._suppressDirty = true;
                fr.setTab('lines');
                fr._suppressDirty = false;
                fr._updateButtons && fr._updateButtons();
              }
            } catch {}
          },

          resetAll() {
            const { st, fr } = this._getState();
            if (!st) return;

            const ok = window.confirm('Reset the weekly schedule grid back to a blank week?');
            if (!ok) return;

            st.extraShiftCount = 0;
            for (const d of Object.keys(st.weeklyLinesByDate || {})) {
              st.weeklyLinesByDate[d] = [{ ref:'', start:'', end:'', break_start:'', break_end:'', break_mins:'' }];
              this._recalcPaidForDate(st, d);
            }

            applyScheduleFromLines(st);
            this._markDirty();

            try {
              if (fr && fr.entity === 'timesheets') {
                fr._suppressDirty = true;
                fr.setTab('lines');
                fr._suppressDirty = false;
                fr._updateButtons && fr._updateButtons();
              }
            } catch {}
          }
        };
      }
    } catch {}

    // Ensure schedule/errors are computed at least once for this render
    try { applyScheduleFromLines(state); } catch {}

   const badgeHtml = (!tsId)
  ? (subMode === 'MANUAL'
      ? '<span class="pill pill-bad">UNPROCESSED (manual)</span>'
      : '<span class="pill pill-info">UNPROCESSED (electronic, read-only)</span>')
  : (subMode === 'MANUAL'
      ? '<span class="pill pill-ok">CONFIRMED HOURS (manual)</span>'
      : '<span class="pill pill-elec">CONFIRMED HOURS (electronic, read-only)</span>');

    const errorsByDate = (state.scheduleErrorsByDate && typeof state.scheduleErrorsByDate === 'object')
      ? state.scheduleErrorsByDate
      : {};

    const hasAnyErrors = !!(state.scheduleHasErrors || Object.keys(errorsByDate).length);

    const rowsHtml = weekDays.map((wd) => {
      const ymd = wd.ymd;
      const dayLines = state.weeklyLinesByDate?.[ymd] || [];
      const displayDate = ymd ? fmtYmdDmy(ymd) : '';
      const dateCellHtml = displayDate || '<span class="mini">â€”</span>';

      const dateHasErr = !!errorsByDate[ymd];
      const errClass = dateHasErr ? ' is-invalid' : '';

      return dayLines.map((ln, lineIdx) => {
        const keyPaid = paidByKey[`${ymd}:${lineIdx}`] || '';
        const lineNo = lineIdx + 1;
       // âœ… compute these OUTSIDE the template string
  const hasBreakWindow = !!(String(ln?.break_start || '').trim() || String(ln?.break_end || '').trim());
  const breakMinsLockAttr = hasBreakWindow ? 'disabled' : '';
  const breakMinsLockData = hasBreakWindow ? 'data-breaklock="1"' : ''; 

        return `
        
          <tr data-weekly-line="1" data-date="${esc(ymd)}" data-line-idx="${lineIdx}">
            <td>${esc(wd.dow || '') || '<span class="mini">â€”</span>'}</td>
            <td>${dateCellHtml}</td>
            <td><span class="mini">#${lineNo}</span></td>

            <td>
              <input type="text"
                     class="input mini${errClass}"
                     name="wl_ref_${esc(ymd)}_${lineIdx}"
                     data-weekly-field="ref"
                     data-date="${esc(ymd)}"
                     data-line-idx="${lineIdx}"
                     value="${esc(ln?.ref || '')}"
                     oninput="window.__tsWeeklyLinesHelper&&window.__tsWeeklyLinesHelper.onInput(this)"
                     ${disabledAttrManual} />
            </td>

            <td>
              <input type="text"
                     class="input${errClass}"
                     name="wl_start_${esc(ymd)}_${lineIdx}"
                     data-weekly-field="start"
                     data-date="${esc(ymd)}"
                     data-line-idx="${lineIdx}"
                     value="${esc(ln?.start || '')}"
                     oninput="window.__tsWeeklyLinesHelper&&window.__tsWeeklyLinesHelper.onInput(this)"
                     onblur="window.__tsWeeklyLinesHelper&&window.__tsWeeklyLinesHelper.onBlur(this)"
                     ${disabledAttrManual} />
            </td>

            <td>
              <input type="text"
                     class="input${errClass}"
                     name="wl_end_${esc(ymd)}_${lineIdx}"
                     data-weekly-field="end"
                     data-date="${esc(ymd)}"
                     data-line-idx="${lineIdx}"
                     value="${esc(ln?.end || '')}"
                     oninput="window.__tsWeeklyLinesHelper&&window.__tsWeeklyLinesHelper.onInput(this)"
                     onblur="window.__tsWeeklyLinesHelper&&window.__tsWeeklyLinesHelper.onBlur(this)"
                     ${disabledAttrManual} />
            </td>

            <td>
              <input type="text"
                     class="input${errClass}"
                     name="wl_break_start_${esc(ymd)}_${lineIdx}"
                     data-weekly-field="break_start"
                     data-date="${esc(ymd)}"
                     data-line-idx="${lineIdx}"
                     value="${esc(ln?.break_start || '')}"
                     oninput="window.__tsWeeklyLinesHelper&&window.__tsWeeklyLinesHelper.onInput(this)"
                     onblur="window.__tsWeeklyLinesHelper&&window.__tsWeeklyLinesHelper.onBlur(this)"
                     ${disabledAttrManual} />
            </td>

            <td>
              <input type="text"
                     class="input${errClass}"
                     name="wl_break_end_${esc(ymd)}_${lineIdx}"
                     data-weekly-field="break_end"
                     data-date="${esc(ymd)}"
                     data-line-idx="${lineIdx}"
                     value="${esc(ln?.break_end || '')}"
                     oninput="window.__tsWeeklyLinesHelper&&window.__tsWeeklyLinesHelper.onInput(this)"
                     onblur="window.__tsWeeklyLinesHelper&&window.__tsWeeklyLinesHelper.onBlur(this)"
                     ${disabledAttrManual} />
            </td>

          <td>
  <input type="text"
         class="input${errClass}"
         name="wl_break_mins_${esc(ymd)}_${lineIdx}"
         data-weekly-field="break_mins"
         data-date="${esc(ymd)}"
         data-line-idx="${lineIdx}"
         ${breakMinsLockData}
         value="${esc(ln?.break_mins || '')}"
         oninput="window.__tsWeeklyLinesHelper&&window.__tsWeeklyLinesHelper.onInput(this)"
         onblur="window.__tsWeeklyLinesHelper&&window.__tsWeeklyLinesHelper.onBlur(this)"
         ${disabledAttrManual} ${breakMinsLockAttr} />
</td>


            <td>
              <span class="mini sched-paid-hours" data-date="${esc(ymd)}" data-line-idx="${lineIdx}">
                ${esc(keyPaid || '')}
              </span>
            </td>
          </tr>
        `;
      }).join('');
    }).join('');

    const resetButtonHtml = (!canEditSchedule)
      ? ''
      : `
        <button type="button"
                class="btn mini"
                data-ts-action="reset-schedule"
                onclick="window.__tsWeeklyLinesHelper&&window.__tsWeeklyLinesHelper.resetAll();return false;">
          Reset timesheet schedule
        </button>
      `;

    const extraLineButtonsHtml = (!canEditSchedule)
      ? ''
      : `
        <button type="button"
                class="btn mini"
                data-ts-action="extra-shift-add"
                onclick="window.__tsWeeklyLinesHelper&&window.__tsWeeklyLinesHelper.addLine();return false;">
          Extra shift lines +
        </button>
        <button type="button"
                class="btn mini"
                data-ts-action="extra-shift-remove"
                onclick="window.__tsWeeklyLinesHelper&&window.__tsWeeklyLinesHelper.removeLine();return false;">
          Extra shift lines -
        </button>
      `;

      const scheduleHelpText = canEditSchedule
      ? 'Each line is either: (1) a shift (fill Ref + Start + End), OR (2) an additional break for the most recent shift above (leave Start/End blank). For breaks you may use either Break start/end OR Break (mins) (do not mix). Save applies changes.'
      : 'Schedule is shown read-only. Multiple shifts on the same day appear as multiple lines.';

    // âœ… NEW: Additional Rates units entry table (weekly manual only, same edit gate as schedule)
    let extrasCardHtml = '';
    try {
      const isWeeklyManualContext = (sheetScope === 'WEEKLY' && subMode === 'MANUAL');
      const canEditExtras = !!canEditSchedule;
      const disabledAttrExtras = canEditExtras ? '' : 'disabled';

      const contract = (related && related.contract) ? related.contract : null;

      let cfgArr = (contract && contract.additional_rates_json != null) ? contract.additional_rates_json : [];
      if (typeof cfgArr === 'string') {
        try { cfgArr = JSON.parse(cfgArr); } catch { cfgArr = []; }
      }
      if (!Array.isArray(cfgArr)) cfgArr = [];

      if (isWeeklyManualContext && cfgArr.length) {
        // BH list is global and supplied on details.policy (openTimesheet planned-week stub now includes it)
        let bhArr = [];
        try {
          const raw = details && details.policy ? details.policy.bh_list : null;
          if (Array.isArray(raw)) bhArr = raw;
          else if (typeof raw === 'string') {
            try {
              const p = JSON.parse(raw || '[]');
              if (Array.isArray(p)) bhArr = p;
            } catch {}
          }
        } catch { bhArr = []; }

        const bhSet = new Set((bhArr || []).map(x => String(x).slice(0, 10)));

        const freqNorm = (raw) => {
          const s = String(raw || '').toUpperCase();
          if (s === 'ONE_PER_WEEK') return 'ONE_PER_WEEK';
          if (s === 'ONE_PER_DAY') return 'ONE_PER_DAY';
          if (s === 'WEEKENDS_AND_BH_ONLY') return 'WEEKENDS_AND_BH_ONLY';
          if (s === 'WEEKDAYS_EXCL_BH_ONLY') return 'WEEKDAYS_EXCL_BH_ONLY';
          return 'ONE_PER_WEEK';
        };

        const weekRangeLabel = (() => {
          if (Array.isArray(weekDays) && weekDays.length === 7 && weekDays[0]?.ymd && weekDays[6]?.ymd) {
            return `${fmtYmdDmy(String(weekDays[0].ymd).slice(0, 10))} â€“ ${fmtYmdDmy(String(weekDays[6].ymd).slice(0, 10))}`;
          }
          if (tsWeekEnding) return fmtYmdDmy(String(tsWeekEnding).slice(0, 10));
          return '';
        })();

        // Current staged values live in state.additionalRates (seeded by openTimesheet)
        const stExtras = (state && state.additionalRates && typeof state.additionalRates === 'object')
          ? state.additionalRates
          : {};

        const getStagedWeekUnits = (code) => {
          const r = stExtras[code];
          if (!r || typeof r !== 'object') return '';
          const v = r.units_week;
          if (v == null) return '';
          return String(v);
        };

        const getStagedDayUnits = (code, ymd) => {
          const r = stExtras[code];
          if (!r || typeof r !== 'object') return '';
          const per = (r.units_per_day && typeof r.units_per_day === 'object') ? r.units_per_day : {};
          const v = per[ymd];
          if (v == null) return '';
          return String(v);
        };

        const rows = [];

        for (let i = 0; i < cfgArr.length; i++) {
          const cfg = cfgArr[i] && typeof cfgArr[i] === 'object' ? cfgArr[i] : {};
          const code = String(cfg.code || '').toUpperCase().trim();
          if (!code) continue;

          const bucketName = String(cfg.bucket_name || code);
          const unitName   = String(cfg.unit_name || '');
          const freq       = freqNorm(cfg.frequency);

          if (freq === 'ONE_PER_WEEK') {
            rows.push({
              dayLabel: 'Week',
              dateLabel: weekRangeLabel,
              code,
              bucketName,
              unitName,
              ymd: '',
              value: getStagedWeekUnits(code)
            });
            continue;
          }

          // Per-day modes always iterate the same 7 day list used by the schedule grid.
          for (const wd of (Array.isArray(weekDays) ? weekDays : [])) {
            const ymd = String(wd?.ymd || '').slice(0, 10);
            const dow = String(wd?.dow || '').trim();
            if (!/^\d{4}-\d{2}-\d{2}$/.test(ymd)) continue;

            const isBh = bhSet.has(ymd);
            const isWeekend = (dow === 'Sat' || dow === 'Sun');
            const isWeekday = (dow === 'Mon' || dow === 'Tue' || dow === 'Wed' || dow === 'Thu' || dow === 'Fri');

            let include = false;
            let dayLabel = dow;

            if (freq === 'ONE_PER_DAY') {
              include = true;
            } else if (freq === 'WEEKENDS_AND_BH_ONLY') {
              include = isWeekend || isBh;
              // âœ… overlap rule: if BH on Sat/Sun, render ONCE but label as BH
              if (include && isBh) dayLabel = 'BH';
            } else if (freq === 'WEEKDAYS_EXCL_BH_ONLY') {
              // âœ… Monâ€“Fri excluding BH weekdays
              include = isWeekday && !isBh;
            }

            if (!include) continue;

            rows.push({
              dayLabel,
              dateLabel: fmtYmdDmy(ymd),
              code,
              bucketName,
              unitName,
              ymd,
              value: getStagedDayUnits(code, ymd)
            });
          }
        }

        const rowsHtml = rows.map(r => {
          const nameAttr = r.ymd
            ? `extra_units_${esc(r.code)}_${esc(r.ymd)}`
            : `extra_units_${esc(r.code)}`;

          const ymdAttr = r.ymd ? `data-extra-ymd="${esc(r.ymd)}"` : '';

          return `
            <tr>
              <td>${esc(r.dayLabel)}</td>
              <td>${esc(r.dateLabel)}</td>
              <td>${esc(r.bucketName)}</td>
              <td>
                <input
                  type="number"
                  min="0"
                  step="0.01"
                  class="input"
                  name="${nameAttr}"
                  data-extra-code="${esc(r.code)}"
                  ${ymdAttr}
                  value="${esc(r.value || '')}"
                  ${disabledAttrExtras}
                />
              </td>
              <td>${esc(r.unitName)}</td>
            </tr>
          `;
        }).join('');

        extrasCardHtml = `
          <div class="card" style="margin-top:10px;">
            <div class="row">
              <label>Additional Rates</label>
              <div class="controls">
                <div style="max-height:260px;overflow:auto;">
                  <table class="grid mini" id="tsWeeklyExtras">
                    <thead>
                      <tr>
                        <th>Day</th>
                        <th>Date</th>
                        <th>Bucket name</th>
                        <th>No. of units</th>
                        <th>Unit name</th>
                      </tr>
                    </thead>
                    <tbody>
                      ${rowsHtml || `<tr><td colspan="5"><span class="mini">No additional rates configured for this contract.</span></td></tr>`}
                    </tbody>
                  </table>
                </div>

                <span class="mini" style="display:block;margin-top:4px;">
                  Editable only when the weekly schedule is editable. Values are saved with the week.
                </span>
              </div>
            </div>
          </div>
        `;
      }
    } catch (e) {
      try { L('weekly extras render failed (non-fatal)', e); } catch {}
      extrasCardHtml = '';
    }

    return `
      <div class="tabc">

               <div class="card">
          <div class="row">
            <label>Status</label>
            <div class="controls">
              ${badgeHtml}
              <span class="mini" style="margin-left:8px;">
                ${(!tsId)
                  ? 'This is a planned week. The grid shows the full week so you can add shifts.'
                  : 'This shows the stored schedule. Multiple shifts per day are supported.'}
              </span>
            </div>
          </div>
          <div class="row">
            <label>Timesheet ID</label>
            <div class="controls">
              ${tsId || '<span class="mini">Not yet created (planned week)</span>'}
            </div>
          </div>

          ${wholeInvoiceHint ? `
            <div class="row">
              <label>Invoice</label>
              <div class="controls">
                <span class="mini">${esc(wholeInvoiceHint)}</span>
              </div>
            </div>
          ` : ''}
        </div>


        <div class="card" style="margin-top:10px;">
          <div class="row">
            <label>Weekly schedule</label>
            <div class="controls">

              <div id="tsWeeklyErrorsBanner"
                   class="hint mini"
                   style="${hasAnyErrors ? '' : 'display:none;'}margin-bottom:6px;">
                Fix the highlighted shift/break times before saving.
              </div>

              <div style="max-height:340px;overflow:auto;">
                <table class="grid mini" id="tsWeeklySchedule">
                  <thead>
                    <tr>
                      <th>Day</th>
                      <th>Date</th>
                      <th>Line</th>
                      <th>Ref #</th>
                      <th>Start</th>
                      <th>End</th>
                      <th>Break start</th>
                      <th>Break end</th>
                      <th>Break (mins)</th>
                      <th>Paid hours</th>
                    </tr>
                  </thead>
                  <tbody>
                    ${rowsHtml}
                  </tbody>
                </table>
              </div>

              <span class="mini" style="display:block;margin-top:4px;">
                ${scheduleHelpText}
              </span>

              ${locked ? '<span class="mini">This timesheet is locked (paid/invoiced); schedule is read-only.</span>' : ''}

              <div style="margin-top:8px;">
                ${resetButtonHtml}
                ${extraLineButtonsHtml}
              </div>
            </div>
          </div>
        </div>

        ${extrasCardHtml}
      </div>
    `;

  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // DAILY (unchanged)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (sheetScope === 'DAILY') {
    const startIso = ts.worked_start_iso || null;
    const endIso   = ts.worked_end_iso   || null;
    const brStartIso = ts.break_start_iso || null;
    const brEndIso   = ts.break_end_iso   || null;
    const brMinsRaw  = ts.break_minutes   != null ? Number(ts.break_minutes) : null;

    const toLocalHHMM = (iso) => {
      if (!iso) return '';
      const d = new Date(iso);
      if (Number.isNaN(d.getTime())) return '';
      try {
        return d.toLocaleTimeString('en-GB', {
          hour: '2-digit',
          minute: '2-digit',
          hour12: false,
          timeZone: 'Europe/London'
        });
      } catch {
        const hh = String(d.getHours()).padStart(2, '0');
        const mm = String(d.getMinutes()).padStart(2, '0');
        return `${hh}:${mm}`;
      }
    };

    const toLocalDateYmd = (iso) => {
      if (!iso) return tsWeekEnding || row.week_ending_date || '';
      const d = new Date(iso);
      if (Number.isNaN(d.getTime())) return tsWeekEnding || row.week_ending_date || '';
      const yyyy = d.getFullYear();
      const mm   = String(d.getMonth() + 1).padStart(2, '0');
      const dd   = String(d.getDate()).toString().padStart(2, '0');
      return `${yyyy}-${mm}-${dd}`;
    };

    const toLocalDowShort = (isoOrYmd) => {
      if (!isoOrYmd) return '';
      let d;
      if (/^\d{4}-\d{2}-\d{2}$/.test(isoOrYmd)) d = new Date(`${isoOrYmd}T00:00:00Z`);
      else d = new Date(isoOrYmd);
      if (Number.isNaN(d.getTime())) return '';
      return d.toLocaleDateString('en-GB', { weekday: 'short', timeZone: 'Europe/London' });
    };

    const dateYmd  = toLocalDateYmd(startIso);
    const dateDmy  = dateYmd ? fmtYmdDmy(dateYmd) : '';
    const dowShort = toLocalDowShort(dateYmd);

    const startHHMM   = toLocalHHMM(startIso);
    const endHHMM     = toLocalHHMM(endIso);
    const brStartHHMM = toLocalHHMM(brStartIso);
    const brEndHHMM   = toLocalHHMM(brEndIso);

    let paidHoursText = '';
    try {
      if (startIso && endIso) {
        const dStart = new Date(startIso);
        const dEnd   = new Date(endIso);
        if (!Number.isNaN(dStart.getTime()) && !Number.isNaN(dEnd.getTime())) {
          let diffMin = (dEnd.getTime() - dStart.getTime()) / 60000;
          if (diffMin < 0) diffMin = 0;
          const brMin = Number.isFinite(brMinsRaw) && brMinsRaw > 0 ? brMinsRaw : 0;
          const paidMin = Math.max(0, diffMin - brMin);
          paidHoursText = paidMin > 0 ? (Math.round((paidMin / 60) * 100) / 100).toFixed(2) : '0.00';
        }
      }
    } catch { paidHoursText = ''; }

    const badgeHtml = `
      <span class="pill pill-elec">Electronic daily shift</span>
      <span class="mini" style="margin-left:8px;">Start/End and break times are shown read-only.</span>
    `;

    return `
      <div class="tabc">
              <div class="card">
          <div class="row">
            <label>Status</label>
            <div class="controls">${badgeHtml}</div>
          </div>
          <div class="row">
            <label>Timesheet ID</label>
            <div class="controls">${tsId || '<span class="mini">Unknown</span>'}</div>
          </div>

          ${wholeInvoiceHint ? `
            <div class="row">
              <label>Invoice</label>
              <div class="controls">
                <span class="mini">${esc(wholeInvoiceHint)}</span>
              </div>
            </div>
          ` : ''}
        </div>


        <div class="card" style="margin-top:10px;">
          <div class="row">
            <label>Shift details</label>
            <div class="controls">
              <div style="max-height:240px;overflow:auto;">
                <table class="grid mini">
                  <thead>
                    <tr>
                      <th>Day</th>
                      <th>Date</th>
                      <th>Start</th>
                      <th>End</th>
                      <th>Break start</th>
                      <th>Break end</th>
                      <th>Break (mins)</th>
                      <th>Paid hours</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>${dowShort || '<span class="mini">â€”</span>'}</td>
                      <td>${dateDmy || '<span class="mini">â€”</span>'}</td>
                      <td>${startHHMM || '<span class="mini">â€”</span>'}</td>
                      <td>${endHHMM   || '<span class="mini">â€”</span>'}</td>
                      <td>${brStartHHMM || '<span class="mini">â€”</span>'}</td>
                      <td>${brEndHHMM   || '<span class="mini">â€”</span>'}</td>
                      <td>${Number.isFinite(brMinsRaw) && brMinsRaw > 0 ? brMinsRaw : 0}</td>
                      <td>${paidHoursText || '<span class="mini">â€”</span>'}</td>
                    </tr>
                  </tbody>
                </table>
              </div>
              <span class="mini" style="display:block;margin-top:4px;">
                Bucketed hours and pay/charge for this shift are shown in the Finance tab.
              </span>
            </div>
          </div>
        </div>
      </div>
    `;
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Fallback
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const fallbackMsg = isPlannedOnly
    ? `
      <span class="mini">
        This is a planned/open week without a financial snapshot yet.
        Once the week is processed, a detailed line breakdown will appear here.
      </span>
    `
    : `
      <span class="mini">
        This timesheet does not have a detailed line breakdown for editing in this view.
      </span>
    `;

  return `
    <div class="tabc">
      <div class="card">
        <div class="row">
          <label>Lines</label>
          <div class="controls">${fallbackMsg}</div>
        </div>
      </div>
    </div>
  `;
}


function renderSummary(rows){
  currentRows = rows;
  currentSelection = null;

  // â”€â”€ paging state (per section)
  window.__listState = window.__listState || {};
  const st = (window.__listState[currentSection] ||= {
    page: 1,
    pageSize: 50,
    total: null,
    hasMore: false,
    filters: null,
    sort: { key: null, dir: 'asc' }
  });

  // Ensure we always have a sort object
  if (!st.sort || typeof st.sort !== 'object') {
    st.sort = { key: null, dir: 'asc' };
  }
  const sortState = st.sort;

  const page     = Number(st.page || 1);
  const pageSize = st.pageSize; // 50 | 100 | 200 | 'ALL'

  // â”€â”€ selection state (per section) â€” explicit IDs only
  window.__selection = window.__selection || {};
  const ensureSel = (section)=>{ const init = { fingerprint:'', ids:new Set() }; return (window.__selection[section] ||= init); };
  const sel = ensureSel(currentSection);

  const isRowSelected = (id)=> sel.ids.has(String(id||''));
  const setRowSelected = (id, selected)=>{
    id = String(id||''); if (!id) return;
    if (selected) sel.ids.add(id); else sel.ids.delete(id);
  };
  const clearSelection = ()=>{ sel.ids.clear(); };

   // Small helper: render red issue badges or green OK for the Issues column
  const renderIssueBadges = (codes) => {
    const wrap = document.createElement('div');
    wrap.className = 'issue-badges';

    const raw = Array.isArray(codes) ? codes.filter(Boolean) : [];
    const arr0 = raw.map(x => String(x || '').trim()).filter(Boolean);

    // âœ… Reference blocker pills (Option A: DB emits exact strings into issue_codes)
    // Ensure we never display more than one, even if legacy data ever contains multiples.
    const REF_ALL = new Set([
      'Refs (Invoicing Blocked)',
      'Refs (Issue Invoice Blocked)',
      'Refs (Invoice and Issue Blocked)'
    ]);

    const REF_PRECEDENCE = [
      'Refs (Invoice and Issue Blocked)',
      'Refs (Invoicing Blocked)',
      'Refs (Issue Invoice Blocked)'
    ];

    let refChosen = '';
    for (const k of REF_PRECEDENCE) {
      if (arr0.includes(k)) { refChosen = k; break; }
    }

    // Keep all other issue codes, but remove any additional ref codes so only one displays.
    const rest = arr0.filter(x => !REF_ALL.has(x));

    // Place the chosen ref pill first (most important blocker), then all other issues.
    const arr = refChosen ? [refChosen, ...rest] : rest;

    if (!arr.length) {
      // No issues â†’ green OK badge
      const ok = document.createElement('span');
      ok.className = 'pill pill-ok';
      ok.textContent = 'OK';
      wrap.appendChild(ok);
      return wrap;
    }

    arr.forEach(code => {
      const span = document.createElement('span');
      const label = String(code || '').trim() || 'Issue';

      // Default: red (issue)
      let cls = 'pill pill-bad';

      // Slightly softer amber for "On hold" / "Validation" / "Authorisation"
      const up = label.toUpperCase();
      if (up === 'ON HOLD' || up === 'VALIDATION' || up === 'AUTHORISATION') {
        cls = 'pill pill-warn';
      }

      span.className = cls;
      span.textContent = label;
      wrap.appendChild(span);
    });

    return wrap;
  };


  // Tie selection to dataset via fingerprint (filters + section)
  const computeFp = ()=> getSummaryFingerprint(currentSection);
  const fp = computeFp();
  if (sel.fingerprint !== fp) { sel.fingerprint = fp; clearSelection(); }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Section-specific pre-formatting / normalisation
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (currentSection === 'candidates') {
    rows.forEach(r => {
      // Rota roles only â€“ do NOT use this for Job Titles
      r.role = (r && Array.isArray(r.roles)) ? formatRolesSummary(r.roles) : '';

      // Ensure job_titles_display exists as a string so the grid
      // can show it via prefs as its own column
      if (r.job_titles_display == null) {
        r.job_titles_display = '';
      } else {
        r.job_titles_display = String(r.job_titles_display);
      }
    });
  } else if (currentSection === 'contracts') {
    rows.forEach(r => {
      const j = r && r.bucket_labels_json;
      if (j && typeof j === 'object') {
        const day   = (j.day   || '').trim();
        const night = (j.night || '').trim();
        const sat   = (j.sat   || '').trim();
        const sun   = (j.sun   || '').trim();
        const bh    = (j.bh    || '').trim();
        const parts = [day,night,sat,sun,bh].filter(Boolean);
        r.bucket_labels_preview = parts.length === 5 ? parts.join('/') : '';
      } else {
        r.bucket_labels_preview = '';
      }
    });
  } else if (currentSection === 'timesheets') {
    // Normalise timesheet rows so they always have a stable id:
    // - real TS â†’ id = timesheet_id
    // - planned/contract_week only â†’ id = contract_week_id
    rows.forEach(r => {
      if (!r || typeof r !== 'object') return;
      const tsId = r.timesheet_id || null;
      const cwId = r.contract_week_id || null;
      const stableId = tsId || cwId || r.id || null;
      if (stableId) {
        r.id = stableId;
      }
    });
  } else if (currentSection === 'invoices') {
    // Flatten joined client name (backend returns client: { name, ... })
    rows.forEach(r => {
      if (!r || typeof r !== 'object') return;
      if (r.client_name == null || r.client_name === '') {
        const cn = r.client && typeof r.client === 'object' ? (r.client.name || '') : '';
        if (cn) r.client_name = cn;
      }
    });

    // Keep UI sort state aligned with backend allowed sorts for /api/invoices
    const INVOICE_SORT_ALLOWED = new Set([
      'issued_at_utc',
      'due_at_utc',
      'created_at',
      'status_date_utc',
      'invoice_no',
      'subtotal_ex_vat',
      'vat_amount',
      'total_inc_vat',
      'status'
    ]);

    if (sortState && sortState.key) {
      const k = String(sortState.key || '');
      if (k && !INVOICE_SORT_ALLOWED.has(k)) {
        // Reset to backend default to avoid "arrow says sorted by X" when backend ignores it
        sortState.key = 'issued_at_utc';
        sortState.dir = 'desc';
        window.__listState[currentSection].sort = sortState;
      }
    }
  }

  const content = byId('content');
  byId('title').textContent = sections.find(s=>s.key===currentSection)?.label || '';

  // Preserve scroll position per section â€” for .summary-body, not #content
  window.__scrollMemory = window.__scrollMemory || {};
  const memKey = `summary:${currentSection}`;
  const prevScrollY = window.__scrollMemory[memKey] ?? 0;

  content.innerHTML = '';
  if (currentSection === 'settings') return renderSettingsPanel(content);
  if (currentSection === 'audit')    return renderAuditTable(content, rows);

  // â”€â”€ top controls â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const topControls = document.createElement('div');
  topControls.style.cssText = 'display:flex;align-items:center;gap:10px;padding:8px 10px;border-bottom:1px solid var(--line);flex-wrap:wrap';

  // Page size
  const sizeLabel = document.createElement('span'); sizeLabel.className = 'mini'; sizeLabel.textContent = 'Page size:';
  const sizeSel = document.createElement('select'); sizeSel.id = 'summaryPageSize';
  sizeSel.classList.add('dark-control');
  ['50','100','200','ALL'].forEach(optVal => {
    const opt = document.createElement('option');
    opt.value = optVal; opt.textContent = (optVal === 'ALL') ? 'All' : `First ${optVal}`;
    if (String(pageSize) === optVal) opt.selected = true;
    sizeSel.appendChild(opt);
  });
  sizeSel.addEventListener('change', async () => {
    const val = sizeSel.value;
    window.__listState[currentSection].pageSize = (val === 'ALL') ? 'ALL' : Number(val);
    window.__listState[currentSection].page = 1;
    const data = await loadSection();
    renderSummary(data);
  });

  topControls.appendChild(sizeLabel);
  topControls.appendChild(sizeSel);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Invoices quick filters row (Status multi + Week ending + Issued + q)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (currentSection === 'invoices') {
    const stFilters = window.__listState[currentSection].filters || {};
    window.__listState[currentSection].filters = stFilters;

    // Default statuses (first entry)
    const curStatus = stFilters.status;
    const hasStatus =
      (Array.isArray(curStatus) && curStatus.length > 0) ||
      (typeof curStatus === 'string' && curStatus.trim().length > 0);
    if (!hasStatus) {
      stFilters.status = ['DRAFT','ON_HOLD','ISSUED','PAID'];
      window.__listState[currentSection].filters = stFilters;
    }

    const applyFilters = async (patch) => {
      const cur = { ...(window.__listState[currentSection].filters || {}) };

      Object.keys(patch || {}).forEach(k => {
        const v = patch[k];
        // normalise empties: delete
        if (v == null) { delete cur[k]; return; }
        if (typeof v === 'string' && v.trim() === '') { delete cur[k]; return; }
        if (Array.isArray(v) && v.length === 0) { delete cur[k]; return; }
        cur[k] = v;
      });

      window.__listState[currentSection].filters = cur;
      window.__listState[currentSection].page = 1;

      const data = await loadSection();
      renderSummary(data);
    };

    // Status multi-select dropdown (checkbox menu)
    const statusLabel = document.createElement('span');
    statusLabel.className = 'mini';
    statusLabel.textContent = 'Status:';

    const statusBtn = document.createElement('button');
    statusBtn.type = 'button';
    statusBtn.style.cssText = 'border:1px solid var(--line);background:#0b152a;color:var(--text);padding:4px 8px;border-radius:8px;cursor:pointer';
    statusBtn.title = 'Filter invoice statuses';

    const getStatusArr = () => {
      let s = (window.__listState[currentSection].filters || {}).status;
      if (typeof s === 'string' && s.trim()) {
        s = s.split(',').map(x => x.trim()).filter(Boolean);
      }
      if (!Array.isArray(s)) s = [];
      return s.map(x => String(x).toUpperCase());
    };

    const setStatusBtnText = () => {
      const arr = getStatusArr();
      statusBtn.textContent = arr.length ? arr.join(', ') : 'Any';
    };
    setStatusBtnText();

    const closeInvStatusMenu = () => {
      const m = document.getElementById('__invStatusMenu');
      if (m) m.remove();
      document.removeEventListener('click', onDocClose, true);
      document.removeEventListener('keydown', onEscClose, true);
    };
    const onDocClose = (e) => {
      const m = document.getElementById('__invStatusMenu');
      if (!m) return;
      if (m.contains(e.target) || statusBtn.contains(e.target)) return;
      closeInvStatusMenu();
    };
    const onEscClose = (e) => { if (e.key === 'Escape') closeInvStatusMenu(); };

    statusBtn.addEventListener('click', (ev) => {
      ev.preventDefault();
      const existing = document.getElementById('__invStatusMenu');
      if (existing) { closeInvStatusMenu(); return; }

      const menu = document.createElement('div');
      menu.id = '__invStatusMenu';
      menu.style.position = 'absolute';
      menu.style.zIndex = '1000';
      menu.style.background = 'var(--panel, #0b1221)';
      menu.style.border = '1px solid var(--line, #334155)';
      menu.style.borderRadius = '10px';
      menu.style.boxShadow = 'var(--shadow, 0 6px 20px rgba(0,0,0,.25))';
      menu.style.padding = '8px';
      menu.style.minWidth = '220px';
      menu.style.userSelect = 'none';

      const opts = ['DRAFT','ON_HOLD','ISSUED','PAID'];
      const selected = new Set(getStatusArr());

      const mkRow = (code) => {
        const lab = document.createElement('label');
        lab.className = 'mini';
        lab.style.display = 'flex';
        lab.style.alignItems = 'center';
        lab.style.gap = '8px';
        lab.style.padding = '6px 6px';
        lab.style.cursor = 'pointer';

        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.checked = selected.has(code);

        cb.addEventListener('change', () => {
          if (cb.checked) selected.add(code);
          else selected.delete(code);
        });

        const txt = document.createElement('span');
        txt.textContent = code;

        lab.appendChild(cb);
        lab.appendChild(txt);
        return lab;
      };

      // header actions
      const actions = document.createElement('div');
      actions.style.cssText = 'display:flex;gap:8px;justify-content:flex-end;margin-bottom:6px;';
      const btnAll = document.createElement('button');
      btnAll.type = 'button';
      btnAll.className = 'btn mini';
      btnAll.textContent = 'All';
      btnAll.addEventListener('click', () => { opts.forEach(o => selected.add(o)); refreshChecks(); });

      const btnNone = document.createElement('button');
      btnNone.type = 'button';
      btnNone.className = 'btn mini';
      btnNone.textContent = 'None';
      btnNone.addEventListener('click', () => { selected.clear(); refreshChecks(); });

      actions.appendChild(btnAll);
      actions.appendChild(btnNone);

      const list = document.createElement('div');
      list.style.cssText = 'display:flex;flex-direction:column;gap:2px;';

      const rowsEls = opts.map(o => mkRow(o));
      rowsEls.forEach(el => list.appendChild(el));

      const refreshChecks = () => {
        rowsEls.forEach((el, idx) => {
          const code = opts[idx];
          const cb = el.querySelector('input[type="checkbox"]');
          if (cb) cb.checked = selected.has(code);
        });
      };

      const footer = document.createElement('div');
      footer.style.cssText = 'display:flex;gap:8px;justify-content:flex-end;margin-top:8px;';
      const applyBtn = document.createElement('button');
      applyBtn.type = 'button';
      applyBtn.className = 'btn btn-primary mini';
      applyBtn.textContent = 'Apply';
      applyBtn.addEventListener('click', async () => {
        closeInvStatusMenu();
        const arr = Array.from(selected);
        await applyFilters({ status: arr });
      });

      footer.appendChild(applyBtn);

      menu.appendChild(actions);
      menu.appendChild(list);
      menu.appendChild(footer);

      document.body.appendChild(menu);
      const r = statusBtn.getBoundingClientRect();
      menu.style.left = `${Math.round(window.scrollX + r.left)}px`;
      menu.style.top  = `${Math.round(window.scrollY + r.bottom + 6)}px`;

      setTimeout(() => {
        document.addEventListener('click', onDocClose, true);
        document.addEventListener('keydown', onEscClose, true);
      }, 0);
    });

    topControls.appendChild(statusLabel);
    topControls.appendChild(statusBtn);

    // Week ending date range (FE sends week_ending_from/to)
    const weLabel = document.createElement('span');
    weLabel.className = 'mini';
    weLabel.textContent = 'Week ending:';

    const weFrom = document.createElement('input');
    weFrom.type = 'date';
    weFrom.className = 'input';
    weFrom.classList.add('dark-control');
    weFrom.style.cssText = 'width:160px;min-width:160px;';
    weFrom.value = String(stFilters.week_ending_from || '');

    const weTo = document.createElement('input');
    weTo.type = 'date';
    weTo.className = 'input';
    weTo.classList.add('dark-control');
    weTo.style.cssText = 'width:160px;min-width:160px;';
    weTo.value = String(stFilters.week_ending_to || '');

    weFrom.addEventListener('change', async () => {
      await applyFilters({ week_ending_from: weFrom.value || null });
    });
    weTo.addEventListener('change', async () => {
      await applyFilters({ week_ending_to: weTo.value || null });
    });

    topControls.appendChild(weLabel);
    topControls.appendChild(weFrom);
    topControls.appendChild(weTo);

    // Issued date range
    const issLabel = document.createElement('span');
    issLabel.className = 'mini';
    issLabel.textContent = 'Issued:';

    const issFrom = document.createElement('input');
    issFrom.type = 'date';
    issFrom.className = 'input';
    issFrom.classList.add('dark-control');
    issFrom.style.cssText = 'width:160px;min-width:160px;';
    issFrom.value = String(stFilters.issued_from || '');

    const issTo = document.createElement('input');
    issTo.type = 'date';
    issTo.className = 'input';
    issTo.classList.add('dark-control');
    issTo.style.cssText = 'width:160px;min-width:160px;';
    issTo.value = String(stFilters.issued_to || '');

    issFrom.addEventListener('change', async () => {
      await applyFilters({ issued_from: issFrom.value || null });
    });
    issTo.addEventListener('change', async () => {
      await applyFilters({ issued_to: issTo.value || null });
    });

    topControls.appendChild(issLabel);
    topControls.appendChild(issFrom);
    topControls.appendChild(issTo);

    // Search box bound to filters.q
    const qLabel = document.createElement('span');
    qLabel.className = 'mini';
    qLabel.textContent = 'Search:';

    const qInp = document.createElement('input');
    qInp.type = 'text';
    qInp.className = 'input';
    qInp.classList.add('dark-control');
    qInp.placeholder = 'Invoice noâ€¦';
    qInp.style.cssText = 'width:220px;min-width:220px;';
    qInp.value = String(stFilters.q || '');

    const applyQ = async () => {
      const v = (qInp.value || '').trim();
      await applyFilters({ q: v || null });
    };
    qInp.addEventListener('keydown', async (e) => {
      if (e.key !== 'Enter') return;
      await applyQ();
    });
    qInp.addEventListener('blur', async () => {
      const cur = String((window.__listState[currentSection].filters || {}).q || '').trim();
      const next = String((qInp.value || '')).trim();
      if (cur !== next) await applyQ();
    });

    topControls.appendChild(qLabel);
    topControls.appendChild(qInp);

    // Refresh status button text if filters changed by defaults
    setStatusBtnText();
  }

  // â”€â”€ Contracts quick Status menu â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let statusSel = null;
  if (currentSection === 'contracts') {
    const stFilters = window.__listState[currentSection].filters || {};

    // Default to "active" if no status has been chosen yet
    if (!('status' in stFilters)) stFilters.status = 'active';
    window.__listState[currentSection].filters = stFilters;

    const statusLabel = document.createElement('span');
    statusLabel.className = 'mini';
    statusLabel.textContent = 'Status:';

    statusSel = document.createElement('select');
    statusSel.classList.add('dark-control');

    [['all','All'], ['active','Active'], ['unassigned','Unassigned'], ['completed','Completed']]
      .forEach(([v, l]) => {
        const o = document.createElement('option');
        o.value = v;
        o.textContent = l;
        if ((stFilters.status || '').toLowerCase() === v) o.selected = true;
        statusSel.appendChild(o);
      });

    statusSel.addEventListener('change', async () => {
      const val = statusSel.value;
      const curFilters = { ...(window.__listState[currentSection].filters || {}) };
      curFilters.status = val;
      window.__listState[currentSection].filters = curFilters;
      window.__listState[currentSection].page = 1;
      const data = await loadSection();
      renderSummary(data);
    });

    topControls.appendChild(statusLabel);
    topControls.appendChild(statusSel);
  }

  // â”€â”€ Timesheets quick filters: Issues / Route / Scope â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (currentSection === 'timesheets') {
    const stFilters = window.__listState[currentSection].filters || {};
    window.__listState[currentSection].filters = stFilters;

    // Back-compat: if old sessions had status_code, migrate to issues_filter once.
    try {
      const hasIssues = Object.prototype.hasOwnProperty.call(stFilters, 'issues_filter');
      const sc = Object.prototype.hasOwnProperty.call(stFilters, 'status_code')
        ? String(stFilters.status_code || '').trim().toUpperCase()
        : '';
      if (!hasIssues && sc) {
        if (sc === 'NO_MATCH_ID') stFilters.issues_filter = 'NO_MATCH_ID';
        else if (sc === 'RATE_MISSING') stFilters.issues_filter = 'RATE_MISSING';
        else if (sc === 'PAY_CHAN_MISS') stFilters.issues_filter = 'PAY_CHAN_MISS';
        else if (sc === 'HR_HOURS_MISMATCH') stFilters.issues_filter = 'HR_HOURS_MISMATCH';
        else if (sc === 'READY_FOR_HR') stFilters.issues_filter = 'AWAITING_HR_VALIDATION';
      }
      if (Object.prototype.hasOwnProperty.call(stFilters, 'status_code')) delete stFilters.status_code;
      if (Object.prototype.hasOwnProperty.call(stFilters, 'processing_status')) delete stFilters.processing_status;
      window.__listState[currentSection].filters = stFilters;
    } catch {}

    // Issues dropdown (canonical; filters by issue type, not by workflow stage)
    const issuesLabel = document.createElement('span');
    issuesLabel.className = 'mini';
    issuesLabel.textContent = 'Issues:';
    const issuesSel = document.createElement('select');
    issuesSel.classList.add('dark-control');

   const issuesOpts = [
  ['ALL',                   'All'],
  ['NO_MATCH_ID',           'No match to Candidate/Client'],
  ['RATE_MISSING',          'Rate missing'],
  ['PAY_CHAN_MISS',         'Pay channel missing'],
  ['AWAITING_HR_VALIDATION','Awaiting HR validation'],
  ['HR_HOURS_MISMATCH',     'Hours mismatch (HealthRoster)'],
  ['HR_HOURS_MISSING',      'HR hours missing'],
  ['DUPLICATE_CONTRACTS',   'Duplicate contracts'],
  ['TIMESHEET_EVIDENCE',    'Timesheet evidence missing'],
  ['EXPENSES_EVIDENCE',     'Expenses evidence missing'],
  ['MILEAGE_EVIDENCE',      'Mileage evidence missing'],
  ['REFERENCE_MISSING',     'Reference missing'],
  ['REFS_PDF_INVALID',      'Refs - Timesheet PDF invalid'],
  ['VALIDATION',            'Validation'],
  ['ON_HOLD',               'On hold'],
  ['AUTHORISATION',         'Awaiting Authorisation'],
  ['QR_NOT_ISSUED',         'QR not issued'],
  ['QR_AWAITING_SIGNATURE', 'QR awaiting signature']
];


    const issuesCur = String(stFilters.issues_filter || 'ALL').toUpperCase();
    issuesOpts.forEach(([v, label]) => {
      const o = document.createElement('option');
      o.value = v;
      o.textContent = label;
      if (issuesCur === v) o.selected = true;
      issuesSel.appendChild(o);
    });

    issuesSel.addEventListener('change', async () => {
      const val = String(issuesSel.value || '').toUpperCase();
      const curFilters = { ...(window.__listState[currentSection].filters || {}) };

      // Remember UI choice (canonical)
      curFilters.issues_filter = val;

      // Ensure legacy/stale keys cannot affect list mode
      if ('status_code' in curFilters) delete curFilters.status_code;
      if ('processing_status' in curFilters) delete curFilters.processing_status;

      // Issues dropdown owns HR mismatch filtering now; clear any explicit hr_issue unless set elsewhere
      if ('hr_issue' in curFilters) delete curFilters.hr_issue;

      window.__listState[currentSection].filters = curFilters;
      window.__listState[currentSection].page = 1;
      const data = await loadSection();
      renderSummary(data);
    });

    topControls.appendChild(issuesLabel);
    topControls.appendChild(issuesSel);

    // Route dropdown
    const routeLabel = document.createElement('span');
    routeLabel.className = 'mini';
    routeLabel.textContent = 'Route:';
    const routeSel = document.createElement('select');
    routeSel.classList.add('dark-control');

    const routeOpts = [
      ['ALL',         'All'],
      ['ELECTRONIC',  'Electronic'],
      ['MANUAL',      'Manual'],
      ['NHSP',        'NHSP'],
      ['HEALTHROSTER','Healthroster'],
      ['QR',          'QR timesheets']
    ];
    const routeCur = (stFilters.route_type || 'ALL').toUpperCase();
    routeOpts.forEach(([v, label]) => {
      const o = document.createElement('option');
      o.value = v;
      o.textContent = label;
      if (routeCur === v) o.selected = true;
      routeSel.appendChild(o);
    });
    routeSel.addEventListener('change', async () => {
      const val = routeSel.value;
      const curFilters = { ...(window.__listState[currentSection].filters || {}) };
      curFilters.route_type = val;
      window.__listState[currentSection].filters = curFilters;
      window.__listState[currentSection].page = 1;
      const data = await loadSection();
      renderSummary(data);
    });
    topControls.appendChild(routeLabel);
    topControls.appendChild(routeSel);

    // Scope dropdown
    const scopeLabel = document.createElement('span');
    scopeLabel.className = 'mini';
    scopeLabel.textContent = 'Type:';
    const scopeSel = document.createElement('select');
    scopeSel.classList.add('dark-control');

    const scopeOpts = [
      ['ALL',    'Both'],
      ['WEEKLY', 'Weekly only'],
      ['DAILY',  'Daily only']
    ];
    const scopeCur = (stFilters.sheet_scope || 'ALL').toUpperCase();
    scopeOpts.forEach(([v, label]) => {
      const o = document.createElement('option');
      o.value = v;
      o.textContent = label;
      if (scopeCur === v) o.selected = true;
      scopeSel.appendChild(o);
    });
    scopeSel.addEventListener('change', async () => {
      const val = scopeSel.value;
      const curFilters = { ...(window.__listState[currentSection].filters || {}) };
      curFilters.sheet_scope = val;
      window.__listState[currentSection].filters = curFilters;
      window.__listState[currentSection].page = 1;
      const data = await loadSection();
      renderSummary(data);
    });
    topControls.appendChild(scopeLabel);
    topControls.appendChild(scopeSel);
  }

  // Columns button (already supports per-column display name overrides via openColumnsDialog)
  const btnCols = document.createElement('button');
  btnCols.textContent = 'Columns';
  btnCols.style.cssText = 'border:1px solid var(--line);background:#0b152a;color:var(--text);padding:4px 8px;border-radius:8px;cursor:pointer';
  btnCols.addEventListener('click', () => openColumnsDialog(currentSection));
  topControls.appendChild(btnCols);

  const spacerTop = document.createElement('div'); spacerTop.style.flex = '1';
  topControls.appendChild(spacerTop);

  // Selected info / clear
  const selInfo = document.createElement('div'); selInfo.className = 'mini';
  const renderSelInfo = ()=>{ selInfo.textContent = (sel.ids.size > 0) ? `${sel.ids.size} selected.` : ''; };
  renderSelInfo();

  const clearBtn = document.createElement('button');
  clearBtn.textContent = 'Clear selection';
  clearBtn.style.cssText = 'border:1px solid var(--line);background:#0b152a;color:var(--text);padding:4px 8px;border-radius:8px;cursor:pointer;display:none';
  clearBtn.onclick = ()=>{
    clearSelection(); renderSelInfo();
    Array.from(document.querySelectorAll('input.row-select')).forEach(cb=>{ cb.checked = false; });
    const hdr = byId('summarySelectAll'); if (hdr) { hdr.checked=false; hdr.indeterminate=false; }
    updateButtons();
  };

  topControls.appendChild(selInfo);
  topControls.appendChild(clearBtn);
  content.appendChild(topControls);

  // â”€â”€ No client-side filtering for timesheets (backend + view handle Tools Stage + Issues) â”€â”€
  let effectiveRows = rows;
  currentRows = effectiveRows;

  // â”€â”€ single table (header + body) inside scroll host â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const bodyWrap = document.createElement('div');
  bodyWrap.className = 'summary-body';
  content.appendChild(bodyWrap);

  const tbl = document.createElement('table');
  tbl.className = 'grid';

  const thead = document.createElement('thead');
  thead.style.borderBottom = '1px solid var(--line)';
  const trh = document.createElement('tr');
  thead.appendChild(trh);
  tbl.appendChild(thead);

  const tb = document.createElement('tbody');
  tbl.appendChild(tb);
  bodyWrap.appendChild(tbl);

  let btnFocus, btnSave, btnResolve;

  const computeHeaderState = ()=>{
    const idsVisible = effectiveRows.map(r => String(r.id || ''));
    const selectedOfVisible = idsVisible.filter(id => sel.ids.has(id)).length;
    const hdrCbEl = byId('summarySelectAll');
    if (hdrCbEl) {
      hdrCbEl.checked = (idsVisible.length > 0 && selectedOfVisible === idsVisible.length);
      hdrCbEl.indeterminate = (selectedOfVisible > 0 && selectedOfVisible < idsVisible.length);
    }
  };

  const updateButtons = ()=>{
    const any = sel.ids.size > 0;
    if (btnFocus)   btnFocus.disabled   = !any;
    if (btnSave)    btnSave.disabled    = !any;
    if (btnResolve) btnResolve.disabled = !any;
    clearBtn.style.display = any ? '' : 'none';
    renderSelInfo();
  };

  // Determine columns (using server prefs)
  const cols = getVisibleColumnsForSection(currentSection, effectiveRows);

  // â”€â”€ Force Issues column into timesheets view â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (currentSection === 'timesheets') {
    if (!cols.includes('issue_codes')) {
      // Put Issues near the left so itâ€™s visible by default
      cols.unshift('issue_codes');
    }
  }

  // Header checkbox (first column)
  const thSel = document.createElement('th');
  thSel.style.width = '40px';
  thSel.style.minWidth = '40px';
  thSel.style.maxWidth = '40px';

  const hdrCb = document.createElement('input'); hdrCb.type='checkbox'; hdrCb.id='summarySelectAll';
  hdrCb.addEventListener('click', (e)=>{
    e.stopPropagation();
    const idsVisible = effectiveRows.map(r => String(r.id || ''));
    const wantOn = !!hdrCb.checked;
    idsVisible.forEach(id => { if (wantOn) sel.ids.add(id); else sel.ids.delete(id); });
    Array.from(document.querySelectorAll('input.row-select')).forEach(cb=>{ cb.checked = wantOn; });
    computeHeaderState();
    updateButtons();
  });
  thSel.appendChild(hdrCb);
  trh.appendChild(thSel);

  // Invoice sortable keys (backend /api/invoices allows only these)
  const INVOICE_SORT_ALLOWED = new Set([
    'issued_at_utc',
    'due_at_utc',
    'created_at',
    'status_date_utc',
    'invoice_no',
    'subtotal_ex_vat',
    'vat_amount',
    'total_inc_vat',
    'status'
  ]);

  // Build header cells with friendly labels, resizer handles, and click-to-sort
  cols.forEach(c=>{
    const th = document.createElement('th');
    th.dataset.colKey = String(c);
    th.style.cursor = 'pointer';

    let label = getFriendlyHeaderLabel(currentSection, c);
    if (currentSection === 'timesheets' && c === 'issue_codes') {
      label = 'Issues';
    }

    // Only show sort arrow for invoice-supported keys when in invoices section
    const isSortable =
      (currentSection !== 'invoices') ? true : INVOICE_SORT_ALLOWED.has(String(c));

    const isActive = isSortable && sortState && sortState.key === c;
    const arrow = isActive ? (sortState.dir === 'asc' ? ' â–²' : ' â–¼') : '';
    th.textContent = label + arrow;

    const res = document.createElement('div');
    res.className = 'col-resizer';
    res.title = 'Drag to resize. Double-click to reset.';
    res.style.cssText = 'position:absolute;right:0;top:0;width:6px;height:100%;cursor:col-resize;user-select:none;';
    th.appendChild(res);

    th.draggable = true;

    th.addEventListener('click', async (ev) => {
      if (ev.target && ev.target.closest && ev.target.closest('.col-resizer')) return;

      const colKey = th.dataset.colKey;
      if (!colKey) return;

      // invoices: only allow backend-supported sort keys (avoid misleading arrows)
      if (currentSection === 'invoices' && !INVOICE_SORT_ALLOWED.has(colKey)) return;

      window.__listState = window.__listState || {};
      const st2 = (window.__listState[currentSection] ||= {
        page: 1,
        pageSize: 50,
        total: null,
        hasMore: false,
        filters: null,
        sort: { key: null, dir: 'asc' }
      });

      if (!st2.sort || typeof st2.sort !== 'object') {
        st2.sort = { key: null, dir: 'asc' };
      }

      const prevDir = (st2.sort && st2.sort.key === colKey) ? st2.sort.dir : null;
      const nextDir = (prevDir === 'asc') ? 'desc' : 'asc';

      st2.sort = { key: colKey, dir: nextDir };
      st2.page = 1;

      try {
        const data = await loadSection();
        renderSummary(data);
      } catch (e) {
        console.error('Failed to apply sort', e);
      }
    });

    trh.appendChild(th);
  });

  // Body rows
  if (currentSection === 'candidates') {
    tbl.style.width = 'auto';
  }

  effectiveRows.forEach(r=>{
    const tr = document.createElement('tr');
    tr.dataset.id = (r && r.id) ? String(r.id) : '';
    tr.dataset.section = currentSection;

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // âœ… UPDATED summary styling rules (Timesheets / Invoices)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    try {
      if (currentSection === 'timesheets') {
        const toolsStage = String(r?.tools_stage || '').trim().toUpperCase();
        const invSegStage   = String(r?.invoice_segment_stage || '').trim().toUpperCase();
        const invIssueStage = String(r?.invoice_issue_stage || '').trim().toUpperCase();

        const isFullyInvoiced      = (invSegStage === 'FULLY_INVOICED');
        const isPaidToCandidate    = !!r?.paid_at_utc;
        const isInvoiceIssued      = (invIssueStage === 'INVOICED_ISSUED');
        const isInvoiceNotIssued   = (invIssueStage === 'INVOICED_NOT_ISSUED');

        // Ready-for-invoice highlight applies only when canonical stage says authorised-for-invoicing
        const isReadyForInvoiceUninvoiced =
          (toolsStage === 'AUTHORISED_FOR_INVOICING');

        // Row rules:
        // - Fully invoiced + Candidate Paid + Invoice issued => deep green row
        // - Fully invoiced but invoice not issued => light green row
        // - Authorised for invoicing => light green row
        if (isFullyInvoiced && isPaidToCandidate && isInvoiceIssued) {
          tr.classList.add('row-deep-green');
        } else if (isFullyInvoiced && isInvoiceNotIssued) {
          tr.classList.add('row-light-green');
        } else if (isReadyForInvoiceUninvoiced) {
          tr.classList.add('row-light-green');
        }
      }

      if (currentSection === 'invoices') {
        const stInv = String(r?.status || '').trim().toUpperCase();
        const isIssued = !!r?.issued_at_utc && (stInv === 'ISSUED' || stInv === 'PAID');

        // Row rule:
        // - Invoiced and issued => deep green row
        if (isIssued) {
          tr.classList.add('row-deep-green');
        }
      }
    } catch {}

    const tdSel = document.createElement('td');
    tdSel.style.width = '40px';
    tdSel.style.minWidth = '40px';
    tdSel.style.maxWidth = '40px';

    const cb = document.createElement('input'); cb.type='checkbox'; cb.className='row-select';
    cb.checked = isRowSelected(tr.dataset.id);
    cb.addEventListener('click', (e)=>{
      e.stopPropagation();
      const id = tr.dataset.id; setRowSelected(id, cb.checked);
      computeHeaderState();
      updateButtons();
    });
    tdSel.appendChild(cb); tr.appendChild(tdSel);

    cols.forEach(c=>{
      const td = document.createElement('td');
      td.dataset.colKey = String(c);
      const v = r[c];

      if (currentSection === 'candidates' && c === 'job_titles_display') {
        const raw = typeof r.job_titles_display === 'string' ? r.job_titles_display : (v || '');
        if (!raw.trim()) {
          td.textContent = '';
        } else {
          const parts = raw.split(';').map(s => s.trim()).filter(Boolean);
          const rest  = parts.slice(1); // drop primary
          td.textContent = rest.join('; ');
        }

      } else if (currentSection === 'timesheets' && c === 'issue_codes') {
        // â”€â”€ Issues column: badges â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        td.classList.add('mini');

        const hasTs = !!r.timesheet_id;
        const codes = Array.isArray(v) ? v.filter(Boolean) : [];

        if (!hasTs) {
          // No timesheet yet (planned week only) â€“ show nothing
          td.textContent = '';
        } else {
          // Timesheet exists â€“ use shared helper (green OK or red/amber badges)
          td.appendChild(renderIssueBadges(codes));
        }

      } else if (currentSection === 'timesheets' && c === 'candidate_name') {
        // Candidate-paid coin in candidate cell
        const txt = String(formatDisplayValue(c, v) ?? '');
        const isPaidToCandidate = !!r?.paid_at_utc;

        if (isPaidToCandidate && txt) {
          const wrap = document.createElement('div');
          wrap.className = 'cell-right-icon';

          const main = document.createElement('span');
          main.className = 'cell-main';
          main.textContent = txt;

          const coin = document.createElement('span');
          coin.className = 'coin-badge';
          coin.textContent = 'Â£';

          wrap.appendChild(main);
          wrap.appendChild(coin);
          td.appendChild(wrap);
        } else {
          td.textContent = txt;
        }

      } else if (currentSection === 'timesheets' && (c === 'processing_status' || c === 'processing_status_display')) {
        // âœ… Processing Status is the canonical display label from the view (never TSFIN raw status)
        const txtBase = String(r?.processing_status_display || '').trim();
        const txt = txtBase || String(formatDisplayValue(c, v) ?? '');

        // Invoice-paid coin (distinct from candidate-paid coin)
        const invoicePaid = (r && (r.invoice_is_paid === true || String(r.invoice_is_paid).toLowerCase() === 'true'));
        const stageNow = String(r?.tools_stage || '').trim().toUpperCase();

        // Show coin only when invoice is actually paid AND row is in the INVOICED stage bucket
        if (invoicePaid && stageNow === 'INVOICED' && txt) {
          const wrap = document.createElement('div');
          wrap.className = 'cell-right-icon';

          const main = document.createElement('span');
          main.className = 'cell-main';
          main.textContent = txt;

          const coin = document.createElement('span');
          coin.className = 'coin-badge';
          coin.textContent = 'Â£';

          wrap.appendChild(main);
          wrap.appendChild(coin);
          td.appendChild(wrap);
        } else {
          td.textContent = txt;
        }

      } else if (currentSection === 'invoices' && c === 'invoice_no') {
        // Paid coin in invoice number cell
        const txt = String(formatDisplayValue(c, v) ?? '');
        const isPaid = !!r?.paid_at_utc;

        if (isPaid && txt) {
          const wrap = document.createElement('div');
          wrap.className = 'cell-right-icon';

          const main = document.createElement('span');
          main.className = 'cell-main';
          main.textContent = txt;

          const coin = document.createElement('span');
          coin.className = 'coin-badge';
          coin.textContent = 'Â£';

          wrap.appendChild(main);
          wrap.appendChild(coin);
          td.appendChild(wrap);
        } else {
          td.textContent = txt;
        }

      } else if (currentSection === 'invoices' && c === 'client_name') {
        // Flattened client name (already set in pre-normalisation)
        td.textContent = String(r.client_name || '');

      } else {
        td.textContent = formatDisplayValue(c, v);
      }

      tr.appendChild(td);
    });

    tb.appendChild(tr);
  });

  // â”€â”€ Apply pending focus (from operations like pay-method change, change rates) â”€â”€
  try {
    if (window.__pendingFocus && window.__pendingFocus.section === currentSection) {
      const pf   = window.__pendingFocus;
      const ids  = Array.isArray(pf.ids) ? pf.ids.map(String) : [];
      const pids = Array.isArray(pf.primaryIds) ? pf.primaryIds.map(String) : [];
      const idSet   = new Set(ids);
      const priSet  = new Set(pids);
      let firstPrimaryRow = null;

      tb.querySelectorAll('tr').forEach(tr => {
        const id = String(tr.dataset.id || '');
        if (idSet.has(id)) {
          tr.classList.add('pending-focus');
          if (priSet.has(id)) tr.classList.add('pending-focus-primary');
          if (!firstPrimaryRow && priSet.has(id)) {
            firstPrimaryRow = tr;
          }
        }
      });

      if (firstPrimaryRow) {
        try {
          firstPrimaryRow.scrollIntoView({ block: 'center', behavior: 'smooth' });
        } catch {}
      }

      window.__pendingFocus = null;
    }
  } catch (e) {
    console.warn('pendingFocus application failed (non-fatal)', e);
  }

  // â”€â”€ NEW: Candidates row context menu (Open / Advances & loans) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (currentSection === 'candidates') {
    if (!window.__ensureCandidateRowMenu) {
      window.__candRowMenuEl = null;
      window.__candRowMenuRow = null;

      window.__hideCandidateRowMenu = function() {
        const el = window.__candRowMenuEl;
        if (el) el.style.display = 'none';
        window.__candRowMenuRow = null;
      };

      window.__ensureCandidateRowMenu = function() {
        if (!window.__candRowMenuEl) {
          const menu = document.createElement('div');
          menu.id = 'candidateRowContextMenu';
          menu.style.position = 'fixed';
          menu.style.zIndex = '9999';
          menu.style.background = '#0b152a';
          menu.style.border = '1px solid var(--line)';
          menu.style.borderRadius = '6px';
          menu.style.minWidth = '180px';
          menu.style.boxShadow = '0 4px 12px rgba(0,0,0,0.5)';
          menu.style.display = 'none';
          menu.innerHTML = `
            <div class="ctx-item" data-action="open" style="padding:6px 10px;cursor:pointer;">Open candidateâ€¦</div>
            <div class="ctx-item" data-action="advances" style="padding:6px 10px;cursor:pointer;border-top:1px solid var(--line);">
              Advances / loansâ€¦
            </div>
          `;
          menu.addEventListener('click', (e) => {
            const item = e.target.closest('.ctx-item');
            if (!item) return;
            const action = item.getAttribute('data-action') || '';
            const row = window.__candRowMenuRow;
            window.__hideCandidateRowMenu();
            if (!row) return;
            if (action === 'open') {
              if (typeof openCandidate === 'function') openCandidate(row);
            } else if (action === 'advances') {
              if (typeof openCandidateAdvancesModal === 'function') openCandidateAdvancesModal(row);
            }
          });
          document.body.appendChild(menu);
          window.__candRowMenuEl = menu;

          document.addEventListener('click', (ev) => {
            const el = window.__candRowMenuEl;
            if (!el || el.style.display === 'none') return;
            if (ev.target && el.contains(ev.target)) return;
            window.__hideCandidateRowMenu();
          }, true);

          document.addEventListener('contextmenu', (ev) => {
            const el = window.__candRowMenuEl;
            if (!el || el.style.display === 'none') return;
            if (ev.target && el.contains(ev.target)) return;
            window.__hideCandidateRowMenu();
          }, true);

          window.addEventListener('scroll', () => window.__hideCandidateRowMenu(), true);
        }
        return window.__candRowMenuEl;
      };
    }

    tb.addEventListener('contextmenu', (ev) => {
      const tr = ev.target && ev.target.closest('tr[data-id]');
      if (!tr) return;
      ev.preventDefault();

      const id = String(tr.dataset.id || '');
      const row = currentRows.find(x => String(x.id || '') === id) || rows.find(x => String(x.id || '') === id);
      if (!row) return;

      window.__candRowMenuRow = row;
      const menu = window.__ensureCandidateRowMenu();
      if (!menu) return;

      const x = ev.clientX;
      const y = ev.clientY;

      menu.style.left = `${x}px`;
      menu.style.top  = `${y}px`;
      menu.style.display = 'block';
    });
  }

  tb.addEventListener('click', (ev) => {
    const tr = ev.target && ev.target.closest('tr'); if (!tr) return;
    if (ev.target && ev.target.classList && ev.target.classList.contains('row-select')) return;
    tb.querySelectorAll('tr.selected').forEach(n => n.classList.remove('selected'));
    tr.classList.add('selected');
    const id = tr.dataset.id;
    currentSelection = currentRows.find(x => String(x.id) === id) || null;
  });

  tb.addEventListener('dblclick', (ev) => {
    const tr = ev.target && ev.target.closest('tr'); if (!tr) return;
    if (!confirmDiscardChangesIfDirty()) return;
    tb.querySelectorAll('tr.selected').forEach(n => n.classList.remove('selected'));
    tr.classList.add('selected');
    const id = tr.dataset.id;
    const row = currentRows.find(x => String(x.id) === id) || null;
    if (!row) return;
    const beforeDepth = (window.__modalStack && window.__modalStack.length) || 0;
    openDetails(row);
    setTimeout(() => {
      const afterDepth = (window.__modalStack && window.__modalStack.length) || 0;
      if (afterDepth > beforeDepth) tb.querySelectorAll('tr.selected').forEach(n => n.classList.remove('selected'));
    }, 0);
  });

  // â”€â”€ Apply widths + wire resize/reorder + header context menu â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  applyUserGridPrefs(currentSection, tbl, cols);
  wireGridColumnResizing(currentSection, tbl);
  wireGridColumnReorder(currentSection, tbl);
  attachHeaderContextMenu(currentSection, tbl);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // âœ… Footer totals block (above Prev/Next)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const totalsBar = document.createElement('div');
  totalsBar.className = 'summary-totals-bar';
  totalsBar.style.cssText = 'display:flex;align-items:center;gap:14px;padding:8px 10px;border-top:1px solid var(--line);background:#081024;flex-wrap:wrap;';

  const fmtGBP = (n) => {
    const x = Number(n || 0);
    const v = Number.isFinite(x) ? x : 0;
    return `Â£${v.toFixed(2)}`;
  };

  const mkTot = (label, value) => {
    const s = document.createElement('span');
    s.className = 'mini';
    s.innerHTML = `<span style="opacity:.85;">${label}:</span> <span style="font-weight:700;">${value}</span>`;
    return s;
  };

  try {
    if (currentSection === 'invoices') {
      const t = (st && st.totals && typeof st.totals === 'object') ? st.totals : null;
      const countAll = Number((t && t.count_all != null) ? t.count_all : (st.total != null ? st.total : 0));

      totalsBar.appendChild(mkTot('Count', String(countAll)));
      totalsBar.appendChild(mkTot('Subtotal ex VAT', fmtGBP(t?.subtotal_ex_vat_sum)));
      totalsBar.appendChild(mkTot('Total inc VAT', fmtGBP(t?.total_inc_vat_sum)));
      totalsBar.appendChild(mkTot('Margin', fmtGBP(t?.margin_ex_vat_sum)));
    }

    if (currentSection === 'timesheets') {
      const t = (st && st.totals && typeof st.totals === 'object') ? st.totals : null;
      const countAll = Number((t && t.count_all != null) ? t.count_all : (st.total != null ? st.total : 0));

      totalsBar.appendChild(mkTot('Count', String(countAll)));
      totalsBar.appendChild(mkTot('Total pay ex VAT', fmtGBP(t?.total_pay_ex_vat_sum)));
      totalsBar.appendChild(mkTot('Margin', fmtGBP(t?.margin_ex_vat_sum)));
    }

    if (currentSection === 'contracts') {
      const countAll = Number(st.total != null ? st.total : 0);
      totalsBar.appendChild(mkTot('Count', String(countAll)));
    }
  } catch {}

  if (totalsBar.childNodes && totalsBar.childNodes.length > 0) {
    content.appendChild(totalsBar);
  }

  // Footer/pager
  const pager = document.createElement('div');
  pager.classList.add('pager');
  pager.style.cssText = 'display:flex;align-items:center;gap:6px;padding:8px 10px;border-top:1px solid var(--line);';
  const info = document.createElement('span'); info.className = 'mini';

  const mkBtn = (label, disabled, onClick, isActive) => {
    const b = document.createElement('button');
    b.textContent = label;
    b.disabled = !!disabled;
    b.classList.add('pager-btn');
    if (isActive) b.classList.add('active');
    b.style.cssText = 'border:1px solid var(--line);background:#0b152a;color:var(--text);padding:4px 8px;border-radius:8px;cursor:pointer';
    if (!disabled && typeof onClick === 'function') b.addEventListener('click', onClick);
    return b;
  };

  const hasMore = !!st.hasMore;
  const totalKnown = (typeof st.total === 'number');
  const current = page;
  let maxPageToShow;
  if (totalKnown && pageSize !== 'ALL') maxPageToShow = Math.max(1, Math.ceil(st.total / Number(pageSize)));
  else if (pageSize === 'ALL') maxPageToShow = 1;
  else maxPageToShow = hasMore ? (current + 1) : current;

  if (pageSize !== 'ALL') {
    const prevBtn = mkBtn('Prev', current <= 1, async () => {
      window.__listState[currentSection].page = Math.max(1, current - 1);
      const data = await loadSection();
      renderSummary(data);
    }, false);
    pager.appendChild(prevBtn);

    const makePageLink = (n) => {
      const isActive = (n === current);
      return mkBtn(String(n), false, isActive ? null : async () => {
        window.__listState[currentSection].page = n;
        const data = await loadSection();
        renderSummary(data);
      }, isActive);
    };

    const pages = [];
    if (maxPageToShow <= 7) { for (let n=1; n<=maxPageToShow; n++) pages.push(n); }
    else {
      pages.push(1);
      if (current > 3) pages.push('â€¦');
      for (let n=Math.max(2, current-1); n<=Math.min(maxPageToShow-1, current+1); n++) pages.push(n);
      if (hasMore || current+1 < maxPageToShow) pages.push('â€¦');
      pages.push(maxPageToShow);
    }
    pages.forEach(pn => {
      if (pn === 'â€¦') { const span = document.createElement('span'); span.textContent = 'â€¦'; span.className = 'mini'; pager.appendChild(span); }
      else pager.appendChild(makePageLink(pn));
    });

    const nextBtn = mkBtn('Next', (!hasMore && (!totalKnown || current >= maxPageToShow)), async () => {
      window.__listState[currentSection].page = current + 1;
      const data = await loadSection();
      renderSummary(data);
    }, false);
    pager.appendChild(nextBtn);
  }

  if (pageSize === 'ALL') info.textContent = `Showing all ${effectiveRows.length} ${currentSection}.`;
  else if (totalKnown) {
    const ps = Number(pageSize);
    const start = (current-1)*ps + 1;
    const end = Math.min(start + effectiveRows.length - 1, st.total || start - 1);
    info.textContent = `Showing ${start}â€“${end}${st.total!=null ? ` of ${st.total}` : ''}`;
  } else {
    const ps = Number(pageSize);
    const start = (current-1)*ps + 1;
    const end = start + effectiveRows.length - 1;
    info.textContent = `Showing ${start}â€“${end}${hasMore ? '+' : ''}`;
  }
  const spacer = document.createElement('div'); spacer.style.flex = '1';
  pager.appendChild(spacer); pager.appendChild(info);
  content.appendChild(pager);

  // Selection toolbar
  const selBar = document.createElement('div');
  selBar.style.cssText = 'display:flex;justify-content:flex-end;gap:8px;padding:6px 10px;border-top:1px dashed var(--line)';
  btnFocus = document.createElement('button');
  btnFocus.title = 'Focus on records';
  btnFocus.textContent = 'ðŸ” Focus';
  btnFocus.style.cssText = 'border:1px solid var(--line);background:#0b152a;color:var(--text);padding:4px 8px;border-radius:8px;cursor:pointer';

  btnSave = document.createElement('button');
  btnSave.title = 'Save selection';
  btnSave.textContent = 'ðŸ” Save';
  btnSave.style.cssText = btnFocus.style.cssText;

  const btnLoad = document.createElement('button');
  btnLoad.title = 'Load selection';
  btnLoad.textContent = 'ðŸ” Load';
  btnLoad.style.cssText = btnFocus.style.cssText;

  btnFocus.addEventListener('click', async () => {
    if (sel.ids.size === 0) return;
    const ids = Array.from(sel.ids);
    try {
      if (typeof applySelectionAsFilter === 'function') {
        await applySelectionAsFilter(currentSection, { ids });
      } else {
        window.__listState = window.__listState || {};
        const st2 = (window.__listState[currentSection] ||= { page:1, pageSize:50, total:null, hasMore:false, filters:null, sort:{ key:null, dir:'asc' } });
        st2.page = 1; st2.filters = { ...(st2.filters||{}), ids };
        const rows2 = await search(currentSection, st2.filters);
        renderSummary(rows2);
      }
    } catch (e) { console.error('Focus failed', e); }
  });

  btnSave.addEventListener('click', async () => {
    if (sel.ids.size === 0) return;
    try { await openSaveSelectionModal ? openSaveSelectionModal(currentSection) : null; } catch {}
  });

  btnLoad.addEventListener('click', async () => {
    try {
      if (typeof openLoadSelectionModal === 'function') await openLoadSelectionModal(currentSection);
    } catch {}
  });

  selBar.appendChild(btnFocus);
  selBar.appendChild(btnSave);
  selBar.appendChild(btnLoad);

  // NEW: Timesheets Resolveâ€¦ button (uses current selection)
  if (currentSection === 'timesheets' && typeof openTimesheetsResolveModal === 'function') {
    btnResolve = document.createElement('button');
    btnResolve.title = 'Resolve candidate/client for selected timesheets';
    btnResolve.textContent = 'Resolveâ€¦';
    btnResolve.style.cssText = btnFocus.style.cssText;
    btnResolve.disabled = sel.ids.size === 0;

    btnResolve.addEventListener('click', () => {
      if (sel.ids.size === 0) return;
      const selectedRows = currentRows.filter(r => sel.ids.has(String(r.id || '')));
      if (!selectedRows.length) return;
      openTimesheetsResolveModal(selectedRows);
    });

    selBar.appendChild(btnResolve);
  }

  content.appendChild(selBar);

  // Restore scroll memory on inner summary-body (data rows only)
  try {
    const scrollHost = content.querySelector('.summary-body');
    if (scrollHost) {
      scrollHost.__activeMemKey = memKey;
      scrollHost.scrollTop = prevScrollY;
      if (!scrollHost.__scrollMemHooked) {
        scrollHost.addEventListener('scroll', () => {
          const k = scrollHost.__activeMemKey || memKey;
          window.__scrollMemory[k] = scrollHost.scrollTop || 0;
        });
        scrollHost.__scrollMemHooked = true;
      }
    }
  } catch {}

  // Initial states
  computeHeaderState();
  updateButtons();

  try { primeSummaryMembership(currentSection, fp); } catch (e) { /* non-blocking */ }
}



async function openInvoiceBatchIssueModal() {
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Batch Issue â€” server authoritative gating
  // - candidates endpoint uses invoice_batch_issue_candidates(p_allow_early, p_limit)
  // - if allow_early=false, future weeks are not returned by server
  // - selection defaults: DRAFT checked; ON_HOLD unchecked & visually red (disabled)
  //
  // âœ… Results MUST render from confirm response:
  //   - invoice_results_enriched[] and invoice_map (no per-invoice follow-ups)
  //   - email_outbox summary from confirm response only
  //   - optional navigation to Invoice Summary (single list reload; never per invoice)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  const API_CANDIDATES = '/api/invoices/batch-issue/candidates';
  const API_CONFIRM    = '/api/invoices/batch-issue/confirm';

  const escapeHtml = (s) => String(s ?? '')
    .replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;')
    .replaceAll('"','&quot;').replaceAll("'","&#39;");

  const fmtMoney = (n) => {
    const x = Number(n || 0);
    const v = Number.isFinite(x) ? x : 0;
    return `Â£${v.toFixed(2)}`;
  };

  const fmtYmd = (ymd) => {
    const s = String(ymd || '').slice(0, 10);
    if (!/^\d{4}-\d{2}-\d{2}$/.test(s)) return String(ymd || '');
    const [Y,M,D] = s.split('-');
    return `${D}/${M}/${Y}`;
  };

  const safeJson = async (res) => { try { return await res.json(); } catch { return null; } };

  const apiGetJson = async (path) => {
    const res = await authFetch(API(path));
    const j = await safeJson(res);
    if (!res.ok) {
      const msg = (j && (j.error || j.message)) ? (j.error || j.message) : (await res.text().catch(()=>'')) || `Request failed (${res.status})`;
      throw new Error(String(msg || 'Request failed'));
    }
    return j;
  };

  const apiPostJsonLocal = async (path, body) => {
    const res = await authFetch(API(path), {
      method: 'POST',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify(body || {})
    });
    const j = await safeJson(res);
    if (!res.ok) {
      const msg = (j && (j.error || j.message)) ? (j.error || j.message) : (await res.text().catch(()=>'')) || `Request failed (${res.status})`;
      throw new Error(String(msg || 'Request failed'));
    }
    return j;
  };

  const state = {
    allowEarly: false,
    limit: 2000,
    groups: [],
    selectedInvoiceIds: new Set(),
    busy: false,
    error: '',
    results: null,
    openClients: new Set(),
    openWeeks: new Set()
  };

  const seedDefaultSelection = () => {
    state.selectedInvoiceIds.clear();
    const groups = Array.isArray(state.groups) ? state.groups : [];
    for (const c of groups) {
      const weeks = Array.isArray(c?.weeks) ? c.weeks : [];
      for (const w of weeks) {
        const invs = Array.isArray(w?.invoices) ? w.invoices : [];
        for (const inv of invs) {
          const id = String(inv?.invoice_id || '').trim();
          const st = String(inv?.status || '').trim().toUpperCase();
          if (!id) continue;
          if (st === 'DRAFT') state.selectedInvoiceIds.add(id);
        }
      }
    }
  };

  const fetchCandidates = async () => {
    state.error = '';
    state.results = null;

    const qs = new URLSearchParams();
    qs.set('allow_early', state.allowEarly ? '1' : '0');
    qs.set('limit', String(state.limit || 2000));

    const j = await apiGetJson(`${API_CANDIDATES}?${qs.toString()}`);
    const groups = Array.isArray(j?.groups) ? j.groups : [];
    state.groups = groups;

    state.openClients.clear();
    state.openWeeks.clear();

    if (groups[0] && groups[0].client_id) {
      const cid = String(groups[0].client_id);
      state.openClients.add(cid);
      const w0 = Array.isArray(groups[0].weeks) ? groups[0].weeks[0] : null;
      if (w0 && (w0.invoice_week_start != null)) {
        state.openWeeks.add(`${cid}|${String(w0.invoice_week_start)}`);
      }
    }

    // Default selection rule
    seedDefaultSelection();
  };

  const refreshInvoiceSummary = async (invoiceIds) => {
    // After batch issue, switch UI to Invoice Summary and filter to invoices touched in this run.
    // NOTE: optional navigation; does not do per-invoice GET calls.
    try {
      const ids = Array.from(new Set((invoiceIds || []).map(String).filter(Boolean)));

      window.__listState = window.__listState || {};
      window.__listState.invoices = window.__listState.invoices || {
        page: 1,
        pageSize: 50,
        total: null,
        hasMore: false,
        filters: null,
        sort: { key: null, dir: 'asc' }
      };

      window.__listState.invoices.page = 1;
      window.__listState.invoices.total = null;
      window.__listState.invoices.hasMore = false;

      window.__listState.invoices.filters = {
        ids,
        include_totals: 1
      };

      try { currentSection = 'invoices'; } catch {}

      // Close the utility modal first (so the user sees the summary immediately)
      try { document.getElementById('btnCloseModal')?.click(); } catch {}

      const data = await loadSection();
      renderSummary(data);
    } catch {}
  };

  const renderSkeleton = () => `
    <div id="invBatchIssueRoot" class="invbatch-root">
      <div class="mini" style="opacity:.95">
        Issue <b>DRAFT</b> invoices and queue emails, grouped by client and week ending.
        <span style="opacity:.85">ON_HOLD invoices remain excluded by default.</span>
      </div>

      <div id="invBatchIssueControls" class="invbatch-controls"></div>
      <div id="invBatchIssueError" class="mini" style="display:none;color:#ffb4b4;"></div>

      <div id="invBatchIssueScroll" class="invbatch-scroll">
        <div id="invBatchIssueBody" class="invbatch-groups"></div>
        <div id="invBatchIssueResults" class="invbatch-results" style="display:none"></div>
      </div>
    </div>
  `;

  const paintResultsFromConfirm = (resEl, out, selectedIds) => {
    resEl.innerHTML = '';

    const invResEnriched = Array.isArray(out?.invoice_results_enriched) ? out.invoice_results_enriched : [];
    const invMap = (out?.invoice_map && typeof out.invoice_map === 'object') ? out.invoice_map : {};

    // Backwards compat: if enriched missing, fall back to raw invoice_results (still no extra fetches)
    const invResRaw = Array.isArray(out?.invoice_results) ? out.invoice_results : [];
    const invRes = invResEnriched.length ? invResEnriched : invResRaw;

    const mails = Array.isArray(out?.email_outbox) ? out.email_outbox : [];
    const maxA = Number(out?.max_attachments_per_email || 0) || null;

    const norm = (x) => String(x || '').trim().toUpperCase();

    const issuedCount = invRes.filter(r => norm(r?.status) === 'ISSUED' && r?.ok === true).length;
    const heldCount   = invRes.filter(r => norm(r?.status) === 'ON_HOLD').length;
    const notDueCount = invRes.filter(r => norm(r?.error) === 'NOT_DUE_YET').length;

    const head = document.createElement('div');
    head.style.fontWeight = '700';
    head.style.marginBottom = '6px';
    head.textContent = `Results â€” Issued ${issuedCount} â€¢ Held ${heldCount} â€¢ Not due yet ${notDueCount} â€¢ Emails queued ${mails.length}${maxA ? ` (max attachments/email ${maxA})` : ''}`;
    resEl.appendChild(head);

    const note = document.createElement('div');
    note.className = 'mini';
    note.style.opacity = '0.9';
    note.textContent = 'Rendered from confirm response only (invoice_results_enriched + invoice_map).';
    resEl.appendChild(note);

    // Optional navigation to summary (single reload; never per invoice)
    const touchedIds = Array.from(new Set(invRes.map(r => String(r?.invoice_id || '').trim()).filter(Boolean)));
    const navIds = touchedIds.length ? touchedIds : (Array.isArray(selectedIds) ? selectedIds : []);

    const actionsRow = document.createElement('div');
    actionsRow.style.display = 'flex';
    actionsRow.style.gap = '8px';
    actionsRow.style.flexWrap = 'wrap';
    actionsRow.style.alignItems = 'center';
    actionsRow.style.marginTop = '10px';

    const btnView = document.createElement('button');
    btnView.type = 'button';
    btnView.className = 'btn btn-sm btn-outline';
    btnView.textContent = `View invoices in summary (${navIds.length})`;
    btnView.disabled = !navIds.length;
    btnView.addEventListener('click', async (ev) => {
      ev.preventDefault();
      await refreshInvoiceSummary(navIds);
    });

    actionsRow.appendChild(btnView);
    resEl.appendChild(actionsRow);

    // Emails summary (confirm response only)
    if (mails.length) {
      const hr0 = document.createElement('div');
      hr0.style.height = '1px';
      hr0.style.background = 'var(--line)';
      hr0.style.margin = '10px 0';
      resEl.appendChild(hr0);

      const t = document.createElement('div');
      t.className = 'mini';
      t.style.opacity = '0.9';
      t.textContent = 'Queued emails (bundled by client/week and split by attachment cap):';
      resEl.appendChild(t);

      const box = document.createElement('div');
      box.style.marginTop = '8px';

      mails.forEach(m => {
        const line = document.createElement('div');
        line.className = 'mini';
        line.style.cssText = 'display:flex;flex-wrap:wrap;gap:8px;align-items:center;padding:6px 0;border-top:1px solid rgba(255,255,255,0.06);';

        const pill = document.createElement('span');
        pill.className = 'pill pill-info';
        pill.textContent = 'QUEUED';

        const to = document.createElement('span');
        to.textContent = `To: ${String(m?.to || '').trim() || 'â€”'}`;

        const subj = document.createElement('span');
        subj.style.opacity = '0.9';
        subj.textContent = `Subject: ${String(m?.subject || '').trim() || 'â€”'}`;

        const ref = document.createElement('span');
        ref.style.opacity = '0.9';
        ref.textContent = `Ref: ${String(m?.reference || '').trim() || 'â€”'}`;

        const id = document.createElement('span');
        id.style.opacity = '0.9';
        id.textContent = `Outbox: ${String(m?.mail_outbox_id || '').trim() || 'â€”'}`;

        line.appendChild(pill);
        line.appendChild(to);
        line.appendChild(subj);
        line.appendChild(ref);
        line.appendChild(id);

        box.appendChild(line);
      });

      resEl.appendChild(box);
    }

    // Invoice outcomes (enriched)
    const hr = document.createElement('div');
    hr.style.cssText = 'height:1px;background:var(--line);margin:10px 0;';
    resEl.appendChild(hr);

    const title = document.createElement('div');
    title.style.fontWeight = '700';
    title.style.marginBottom = '6px';
    title.textContent = 'Invoice outcomes';
    resEl.appendChild(title);

    if (!invRes.length) {
      const empty = document.createElement('div');
      empty.className = 'mini';
      empty.style.opacity = '0.85';
      empty.textContent = 'No invoice results returned.';
      resEl.appendChild(empty);
      return;
    }

    // Group by client_id for readability (no extra fetch; client_name comes from enriched/map)
    const byClient = new Map();
    for (const r of invRes) {
      const iid = String(r?.invoice_id || '').trim();
      const mapRow = iid ? (invMap[iid] || null) : null;

      const clientId = String(r?.client_id || mapRow?.client_id || '').trim();
      if (!byClient.has(clientId)) byClient.set(clientId, []);
      byClient.get(clientId).push({ r, mapRow });
    }

    for (const [clientId, rows] of byClient.entries()) {
      const cName = String(rows[0]?.r?.client_name || rows[0]?.mapRow?.client_name || clientId || 'Client');

      const box = document.createElement('div');
      box.className = 'invbatch-card';
      box.style.background = '#081024';
      box.style.padding = '10px';
      box.style.marginBottom = '10px';

      const h2 = document.createElement('div');
      h2.style.fontWeight = '700';
      h2.style.marginBottom = '6px';
      h2.textContent = cName;
      box.appendChild(h2);

      // Sort: week ending desc, invoice_no
      rows.sort((a, b) => {
        const wa = String(a?.r?.week_ending_date || a?.mapRow?.week_ending_date || '');
        const wb = String(b?.r?.week_ending_date || b?.mapRow?.week_ending_date || '');
        if (wa < wb) return 1;
        if (wa > wb) return -1;
        const na = String(a?.r?.invoice_no || a?.mapRow?.invoice_no || '');
        const nb = String(b?.r?.invoice_no || b?.mapRow?.invoice_no || '');
        return na.localeCompare(nb);
      });

      rows.forEach(({ r, mapRow }) => {
        const iid = String(r?.invoice_id || '').trim();

        const invoiceNo = (r?.invoice_no != null && String(r.invoice_no).trim())
          ? String(r.invoice_no).trim()
          : (mapRow?.invoice_no != null ? String(mapRow.invoice_no).trim() : '');

        const weekEnding = (r?.week_ending_date || mapRow?.week_ending_date)
          ? fmtYmd(String(r.week_ending_date || mapRow.week_ending_date))
          : 'â€”';

        const dns = (r?.do_not_send === true) || (mapRow?.do_not_send === true);

        const candName = (r?.candidate_name != null && String(r.candidate_name).trim())
          ? String(r.candidate_name).trim()
          : (mapRow?.candidate_name != null ? String(mapRow.candidate_name).trim() : '');

        const candDisp = candName ? candName : 'â€”';

        const st = norm(r?.status);
        const ok = (r?.ok === true);
        const err = String(r?.error || '').trim();
        const holdReason = String(r?.on_hold_reason || '').trim();

        // Blocking reason text
        const reasonTxt =
          (err === 'NOT_DUE_YET') ? 'Not due yet'
          : (st === 'ON_HOLD' && holdReason) ? holdReason
          : (err ? err : '');

        const line = document.createElement('div');
        line.className = 'mini';
        line.style.cssText = 'display:flex;flex-wrap:wrap;gap:8px;align-items:center;padding:8px 0;border-top:1px solid rgba(255,255,255,0.06);';

        const pill = document.createElement('span');
        pill.className = 'pill';
        if (err === 'NOT_DUE_YET') pill.classList.add('pill-warn');
        else if (st === 'ON_HOLD') pill.classList.add('pill-bad');
        else if (ok && st === 'ISSUED') pill.classList.add('pill-ok');
        else pill.classList.add('pill-info');

        pill.textContent =
          (err === 'NOT_DUE_YET') ? 'NOT DUE YET' :
          (st ? st : (ok ? 'OK' : 'FAILED'));

        const invTxt = document.createElement('span');
        invTxt.style.fontWeight = '700';
        invTxt.textContent = invoiceNo ? `Invoice ${invoiceNo}` : (iid ? `Invoice ${iid.slice(0, 8)}â€¦` : 'Invoice');

        const meta = document.createElement('span');
        meta.style.opacity = '0.9';
        meta.textContent = `${candDisp} â€¢ Week ending ${weekEnding}`;

        const dnsPill = document.createElement('span');
        dnsPill.className = 'pill';
        dnsPill.classList.add(dns ? 'pill-warn' : 'pill-info');
        dnsPill.textContent = dns ? 'Do not send' : 'Send';
        dnsPill.title = dns ? 'Invoice is marked do_not_send' : '';

        line.appendChild(pill);
        line.appendChild(invTxt);
        line.appendChild(dnsPill);
        line.appendChild(meta);

        if (reasonTxt) {
          const msg = document.createElement('span');
          msg.style.opacity = '0.9';
          msg.style.color = '#ffb4b4';
          msg.textContent = `Reason: ${reasonTxt}`;
          line.appendChild(msg);
        }

        box.appendChild(line);
      });

      resEl.appendChild(box);
    }
  };

  const paint = () => {
    const root = document.getElementById('invBatchIssueRoot');
    if (!root) return;

    const controls = document.getElementById('invBatchIssueControls');
    const bodyEl   = document.getElementById('invBatchIssueBody');
    const errEl    = document.getElementById('invBatchIssueError');
    const resEl    = document.getElementById('invBatchIssueResults');
    const scrollEl = document.getElementById('invBatchIssueScroll');

    if (!controls || !bodyEl || !errEl || !resEl || !scrollEl) return;

    const prevScroll = scrollEl.scrollTop || 0;
    const selectedCount = state.selectedInvoiceIds.size;

    const mkBtn = (label, onClick, opts={}) => {
      const b = document.createElement('button');
      b.type = 'button';
      b.className = ['btn','btn-sm', (opts.primary ? 'btn-primary' : 'btn-outline')].join(' ');
      b.textContent = label;
      if (opts.disabled) {
        b.disabled = true;
        b.style.opacity = '0.6';
        b.style.cursor = 'not-allowed';
      } else {
        b.addEventListener('click', onClick);
      }
      return b;
    };

    // Controls
    controls.innerHTML = '';

    const allowWrap = document.createElement('label');
    allowWrap.className = 'mini';
    allowWrap.style.cssText = 'display:flex;align-items:center;gap:8px;padding:6px 10px;border:1px solid var(--line);border-radius:10px;background:#0b152a;';
    const allowCb = document.createElement('input');
    allowCb.type = 'checkbox';
    allowCb.checked = !!state.allowEarly;
    allowCb.disabled = state.busy;
    const allowTxt = document.createElement('span');
    allowTxt.textContent = 'Batch early';
    allowWrap.appendChild(allowCb);
    allowWrap.appendChild(allowTxt);

    allowCb.addEventListener('change', async () => {
      state.allowEarly = !!allowCb.checked;
      state.busy = true;
      paint();
      try {
        await fetchCandidates();
      } catch (e) {
        state.error = String(e?.message || e);
      } finally {
        state.busy = false;
        paint();
      }
    });

    controls.appendChild(allowWrap);

    controls.appendChild(mkBtn('Refresh', async () => {
      state.busy = true;
      paint();
      try {
        await fetchCandidates();
      } catch (e) {
        state.error = String(e?.message || e);
      } finally {
        state.busy = false;
        paint();
      }
    }, { disabled: state.busy }));

    controls.appendChild(mkBtn('Clear selection', () => {
      state.selectedInvoiceIds.clear();
      paint();
    }, { disabled: state.busy || selectedCount === 0 }));

    controls.appendChild(mkBtn(`Confirm (${selectedCount})`, async () => {
      if (state.busy) return;

      const ids = Array.from(state.selectedInvoiceIds).map(String).filter(Boolean);
      if (!ids.length) {
        alert('Select at least one invoice.');
        return;
      }

      const ok = window.confirm(
        `Issue ${ids.length} invoice(s) now?\n\n` +
        `This will attempt to issue invoices and queue client emails (mail_outbox).`
      );
      if (!ok) return;

      state.busy = true;
      state.error = '';
      state.results = null;
      paint();

      try {
        const out = await apiPostJsonLocal(API_CONFIRM, {
          allow_early: !!state.allowEarly,
          invoice_ids: ids
        });

        state.results = out || {};
        window.__toast && window.__toast('Batch issue complete.');
      } catch (e) {
        state.error = String(e?.message || e);
      } finally {
        state.busy = false;
        paint();
      }
    }, { primary: true, disabled: state.busy || selectedCount === 0 }));

    const selInfo = document.createElement('div');
    selInfo.className = 'mini';
    selInfo.style.opacity = '0.9';
    selInfo.textContent = state.busy ? 'Workingâ€¦' : (selectedCount ? `${selectedCount} selected` : '');
    controls.appendChild(selInfo);

    // Error
    if (state.error) {
      errEl.style.display = '';
      errEl.textContent = state.error;
    } else {
      errEl.style.display = 'none';
      errEl.textContent = '';
    }

    // Body
    bodyEl.innerHTML = '';

    const groups = Array.isArray(state.groups) ? state.groups : [];
    if (!groups.length && !state.busy) {
      const empty = document.createElement('div');
      empty.className = 'mini';
      empty.style.opacity = '0.85';
      empty.textContent = 'No draft/held invoices found for issuing.';
      bodyEl.appendChild(empty);
    }

    const selectIdsFrom = (invoices, wantDraftOnly) => {
      const ids = [];
      for (const inv of (invoices || [])) {
        const id = String(inv?.invoice_id || '').trim();
        if (!id) continue;
        const st = String(inv?.status || '').trim().toUpperCase();
        if (wantDraftOnly && st !== 'DRAFT') continue;
        // Disabled: ON_HOLD is intentionally not selectable
        if (st === 'ON_HOLD') continue;
        // Optional future flags (not provided by RPC, but safe if added later)
        if (inv?.blocked_by_hr_validation === true) continue;
        if (state.allowEarly === false && inv?.not_due_yet === true) continue;
        ids.push(id);
      }
      return ids;
    };

    groups.forEach((c) => {
      const clientId = String(c?.client_id || '');
      const clientName = String(c?.client_name || clientId || 'Client');
      const weeks = Array.isArray(c?.weeks) ? c.weeks : [];

      const allClientSelectable = [];
      for (const w of weeks) {
        const invs = Array.isArray(w?.invoices) ? w.invoices : [];
        allClientSelectable.push(...selectIdsFrom(invs, true)); // draft only
      }
      const clientSelectedCount = allClientSelectable.filter(id => state.selectedInvoiceIds.has(id)).length;

      const clientDetails = document.createElement('details');
      clientDetails.className = 'invbatch-card';
      clientDetails.open = state.openClients.has(clientId) || false;
      clientDetails.addEventListener('toggle', () => {
        if (clientDetails.open) state.openClients.add(clientId);
        else state.openClients.delete(clientId);
      });

      const sum = document.createElement('summary');
      sum.className = 'invbatch-card-head';
      sum.style.listStyle = 'none';

      const left = document.createElement('div');
      left.style.display = 'flex';
      left.style.flexDirection = 'column';
      left.style.gap = '2px';
      left.innerHTML = `
        <div style="font-weight:700;">${escapeHtml(clientName)}</div>
        <div class="mini" style="opacity:.85;">${weeks.length} week group(s)</div>
      `;

      const right = document.createElement('div');
      right.style.display = 'flex';
      right.style.alignItems = 'center';
      right.style.gap = '8px';

      const badge = document.createElement('span');
      badge.className = 'mini invbatch-badge';
      badge.textContent = clientSelectedCount ? `${clientSelectedCount} selected` : '';
      if (!clientSelectedCount) badge.style.opacity = '0.5';

      const btnSelClient = mkBtn('Select all DRAFT in client', (ev) => {
        ev.preventDefault(); ev.stopPropagation();
        for (const id of allClientSelectable) state.selectedInvoiceIds.add(id);
        paint();
      }, { disabled: state.busy || allClientSelectable.length === 0 });

      const btnDeselClient = mkBtn('Deselect client', (ev) => {
        ev.preventDefault(); ev.stopPropagation();
        for (const id of allClientSelectable) state.selectedInvoiceIds.delete(id);
        paint();
      }, { disabled: state.busy || clientSelectedCount === 0 });

      right.appendChild(badge);
      right.appendChild(btnSelClient);
      right.appendChild(btnDeselClient);

      sum.appendChild(left);
      sum.appendChild(right);
      clientDetails.appendChild(sum);

      const clientInner = document.createElement('div');
      clientInner.style.display = 'flex';
      clientInner.style.flexDirection = 'column';
      clientInner.style.gap = '8px';
      clientInner.style.padding = '10px 6px 6px 6px';

      weeks.forEach((w) => {
        const wkStart = (w?.invoice_week_start == null) ? '' : String(w.invoice_week_start);
        const wkEnd   = (w?.week_ending_date == null) ? '' : String(w.week_ending_date);
        const wkKey   = `${clientId}|${wkStart}`;

        const invs = Array.isArray(w?.invoices) ? w.invoices : [];

        const weekSelectable = selectIdsFrom(invs, true); // draft only
        const weekSelectedCount = weekSelectable.filter(id => state.selectedInvoiceIds.has(id)).length;

        const weekDetails = document.createElement('details');
        weekDetails.className = 'invbatch-card';
        weekDetails.open = state.openWeeks.has(wkKey) || false;
        weekDetails.addEventListener('toggle', () => {
          if (weekDetails.open) state.openWeeks.add(wkKey);
          else state.openWeeks.delete(wkKey);
        });

        const wkSum = document.createElement('summary');
        wkSum.className = 'invbatch-card-head invbatch-week-head';
        wkSum.style.listStyle = 'none';

        const wkLeft = document.createElement('div');
        wkLeft.style.display = 'flex';
        wkLeft.style.flexDirection = 'column';
        wkLeft.style.gap = '2px';

        const subtotalSum = fmtMoney(w?.subtotal_ex_vat_sum);
        const incSum = fmtMoney(w?.total_inc_vat_sum);

        wkLeft.innerHTML = `
          <div style="font-weight:700;">Week ending ${escapeHtml(wkEnd ? fmtYmd(wkEnd) : 'â€”')}</div>
          <div class="mini" style="opacity:.85;">Week start ${escapeHtml(wkStart ? fmtYmd(wkStart) : 'â€”')} â€¢ Subtotal ${escapeHtml(subtotalSum)} â€¢ Total ${escapeHtml(incSum)}</div>
        `;

        const wkRight = document.createElement('div');
        wkRight.style.display = 'flex';
        wkRight.style.alignItems = 'center';
        wkRight.style.gap = '8px';

        const wkBadge = document.createElement('span');
        wkBadge.className = 'mini invbatch-badge';
        wkBadge.textContent = weekSelectedCount ? `${weekSelectedCount} selected` : '';
        if (!weekSelectedCount) wkBadge.style.opacity = '0.5';

        const btnSelWeek = mkBtn('Select all DRAFT in week', (ev) => {
          ev.preventDefault(); ev.stopPropagation();
          for (const id of weekSelectable) state.selectedInvoiceIds.add(id);
          paint();
        }, { disabled: state.busy || weekSelectable.length === 0 });

        const btnDeselWeek = mkBtn('Deselect week', (ev) => {
          ev.preventDefault(); ev.stopPropagation();
          for (const id of weekSelectable) state.selectedInvoiceIds.delete(id);
          paint();
        }, { disabled: state.busy || weekSelectedCount === 0 });

        wkRight.appendChild(wkBadge);
        wkRight.appendChild(btnSelWeek);
        wkRight.appendChild(btnDeselWeek);

        wkSum.appendChild(wkLeft);
        wkSum.appendChild(wkRight);
        weekDetails.appendChild(wkSum);

        const list = document.createElement('div');
        list.style.display = 'flex';
        list.style.flexDirection = 'column';
        list.style.gap = '6px';
        list.style.padding = '10px 6px 6px 6px';

        invs.forEach(inv => {
          const invId = String(inv?.invoice_id || '').trim();
          const invNo = (inv?.invoice_no != null) ? String(inv.invoice_no).trim() : '';
          const st = String(inv?.status || '').trim().toUpperCase();
          const holdReason = String(inv?.on_hold_reason || '').trim();
          const isSelfBill = inv?.is_self_bill === true;

          const row = document.createElement('div');
          row.className = 'invbatch-row';
          row.style.border = '1px solid var(--line)';
          row.style.borderRadius = '12px';
          row.style.background = '#0b1427';

          const cb = document.createElement('input');
          cb.type = 'checkbox';
          cb.checked = !!(invId && state.selectedInvoiceIds.has(invId));

          const disabled = state.busy || !invId || (st === 'ON_HOLD');
          cb.disabled = !!disabled;

          cb.addEventListener('change', () => {
            if (!invId) return;
            if (cb.checked) state.selectedInvoiceIds.add(invId);
            else state.selectedInvoiceIds.delete(invId);
            paint();
          });

          const main = document.createElement('div');
          main.style.display = 'flex';
          main.style.flexDirection = 'column';
          main.style.gap = '3px';
          main.style.flex = '1';
          main.style.minWidth = '0';

          const line1 = document.createElement('div');
          line1.style.display = 'flex';
          line1.style.alignItems = 'center';
          line1.style.gap = '8px';
          line1.style.flexWrap = 'wrap';

          const name = document.createElement('div');
          name.style.fontWeight = '700';
          name.textContent = invNo ? `Invoice ${invNo}` : (invId ? `Invoice ${invId.slice(0, 8)}â€¦` : 'Invoice');
          line1.appendChild(name);

          const pill = document.createElement('span');
          pill.className = 'pill';

          if (st === 'ON_HOLD') {
            pill.classList.add('pill-bad');
            pill.textContent = 'ON HOLD';
          } else {
            pill.classList.add('pill-info');
            pill.textContent = 'DRAFT';
          }
          line1.appendChild(pill);

          if (isSelfBill) {
            const sb = document.createElement('span');
            sb.className = 'pill pill-warn';
            sb.textContent = 'SELF-BILL';
            line1.appendChild(sb);
          }

          main.appendChild(line1);

          if (holdReason) {
            const line2 = document.createElement('div');
            line2.className = 'mini';
            line2.style.opacity = '0.9';
            line2.textContent = `Reason: ${holdReason}`;
            main.appendChild(line2);
          }

          const right = document.createElement('div');
          right.className = 'mini invbatch-right';

          const a = document.createElement('div');
          a.textContent = fmtMoney(inv?.subtotal_ex_vat);

          const b = document.createElement('div');
          b.style.opacity = '0.9';
          b.textContent = `VAT ${fmtMoney(inv?.vat_amount)} â€¢ Total ${fmtMoney(inv?.total_inc_vat)}`;

          right.appendChild(a);
          right.appendChild(b);

          row.appendChild(cb);
          row.appendChild(main);
          row.appendChild(right);

          if (st === 'ON_HOLD') {
            row.style.borderColor = 'rgba(248,113,113,.55)';
            row.style.background = 'rgba(58,18,20,.35)';
          }

          list.appendChild(row);
        });

        weekDetails.appendChild(list);
        clientInner.appendChild(weekDetails);
      });

      clientDetails.appendChild(clientInner);
      bodyEl.appendChild(clientDetails);
    });

    // Results (confirm response only)
    if (state.results) {
      resEl.style.display = '';
      resEl.innerHTML = '';
      paintResultsFromConfirm(resEl, state.results || {}, Array.from(state.selectedInvoiceIds).map(String).filter(Boolean));
    } else {
      resEl.style.display = 'none';
      resEl.innerHTML = '';
    }

    scrollEl.scrollTop = prevScroll;
  };

  // Seed modalCtx and open modal
  window.modalCtx = {
    entity: 'invoices',
    openToken: `invoice-batch-issue:${Date.now()}:${Math.random().toString(36).slice(2)}`,
    data: {}
  };

  showModal(
    'Batch Issue â€” Invoices',
    [{ key: 'main', label: 'Batch Issue' }],
    () => renderSkeleton(),
    null,
    true,
    null,
    {
      kind: 'import-summary-invoice-batch-issue',
      noParentGate: true,
      onDismiss: () => {
        try {
          const modalNode = document.getElementById('modal');
          if (modalNode) {
            modalNode.classList.remove('invbatch-modal');
            modalNode.classList.remove('invbatch-issue-modal');
          }
        } catch {}
      }
    }
  );

  // Apply styling hooks even before showModal wiring is added
  try {
    const modalNode = document.getElementById('modal');
    if (modalNode) {
      modalNode.classList.add('invbatch-modal');
      modalNode.classList.add('invbatch-issue-modal');
    }
  } catch {}

  state.busy = true;
  paint();

  try {
    await fetchCandidates();
  } catch (e) {
    state.error = String(e?.message || e);
  } finally {
    state.busy = false;
    paint();
  }
}


async function openInvoiceBatchGenerateModal() {
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Batch Generate (Invoices)
  //
  // âœ… Server is source-of-truth for â€œnot due yetâ€ / week-ended gating:
  //    - When allow_early=false, the RPC MUST NOT return future weeks (it doesnâ€™t).
  //    - UI does NOT compute â€œfutureâ€ or hide/show based on local date.
  //
  // âœ… Results UI renders ONLY from confirm response out.results_invoices[].
  //    No per-invoice GET calls.
  //
  // âœ… Styling: uses existing modal shell + existing .btn/.mini styles.
  //    We add modal classes so index.html CSS can:
  //      - widen/tall the modal for batch lists
  //      - disable outer .modal-b scrolling (avoid double scrollbars)
  //      - make only the inner list scroll
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  const API_CANDIDATES = '/api/invoices/batch-generate/candidates';
  const API_CONFIRM    = '/api/invoices/batch-generate/confirm';

  const state = {
    allowEarly: false,
    limit: 5000,

    groups: [],              // RPC JSON: [{ client_id, client_name, weeks:[...] }]
    selected: new Set(),     // timesheet_id strings

    busy: false,
    error: '',
    results: null,           // confirm response

    openClients: new Set(),  // client_id strings
    openWeeks: new Set()     // `${client_id}|${invoice_week_start}`

    // Results expanders
    ,openResultClients: new Set() // client_id strings
  };

  const fmtMoney = (n) => {
    const x = Number(n || 0);
    const v = Number.isFinite(x) ? x : 0;
    return `Â£${v.toFixed(2)}`;
  };

  const ymdToDMY = (ymd) => {
    const s = String(ymd || '').slice(0, 10);
    if (!/^\d{4}-\d{2}-\d{2}$/.test(s)) return String(ymd || '');
    const [Y, M, D] = s.split('-');
    return `${D}/${M}/${Y}`;
  };

  const safeJson = async (res) => {
    try { return await res.json(); } catch { return null; }
  };

  const apiGetJson = async (path) => {
    const res = await authFetch(API(path));
    const j = await safeJson(res);
    if (!res.ok) {
      const msg = (j && (j.error || j.message)) ? (j.error || j.message) : `Request failed (${res.status})`;
      throw new Error(msg);
    }
    return j;
  };

  const apiPostJsonLocal = async (path, body) => {
    const res = await authFetch(API(path), {
      method: 'POST',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify(body || {})
    });
    const j = await safeJson(res);
    if (!res.ok) {
      const msg = (j && (j.error || j.message)) ? (j.error || j.message) : `Request failed (${res.status})`;
      throw new Error(msg);
    }
    return j;
  };

  const clearSelection = () => state.selected.clear();

  const buildRowsPayload = () => {
    // Server expects:
    // [
    //   { client_id, invoice_week_start: "YYYY-MM-DD", timesheet_ids:[uuid...] },
    //   ...
    // ]
    const map = new Map(); // key -> {client_id, invoice_week_start, timesheet_ids:[]}

    (state.groups || []).forEach(c => {
      const clientId = String(c?.client_id || '').trim();
      if (!clientId) return;

      const weeks = Array.isArray(c?.weeks) ? c.weeks : [];
      weeks.forEach(w => {
        const wkStart = String(w?.invoice_week_start || '').slice(0, 10);
        if (!wkStart) return;

        const key = `${clientId}|${wkStart}`;
        const tss = Array.isArray(w?.timesheets) ? w.timesheets : [];

        const picked = [];
        tss.forEach(t => {
          const id = String(t?.timesheet_id || '').trim();
          if (!id) return;
          if (!state.selected.has(id)) return;

          // Never send blocked rows (server will also validate)
          if (t?.blocked_by_hr_validation === true) return;

          picked.push(id);
        });

        if (!picked.length) return;

        const row = map.get(key) || { client_id: clientId, invoice_week_start: wkStart, timesheet_ids: [] };
        row.timesheet_ids.push(...picked);
        map.set(key, row);
      });
    });

    const out = [];
    for (const r of map.values()) {
      r.timesheet_ids = Array.from(new Set((r.timesheet_ids || []).map(String).filter(Boolean)));
      if (r.timesheet_ids.length) out.push(r);
    }
    return out;
  };

  const fetchCandidates = async () => {
    state.error = '';
    state.results = null;
    clearSelection();

    const qs = new URLSearchParams();
    qs.set('allow_early', state.allowEarly ? '1' : '0');
    qs.set('limit', String(state.limit || 5000));

    const j = await apiGetJson(`${API_CANDIDATES}?${qs.toString()}`);
    state.groups = Array.isArray(j?.groups) ? j.groups : [];

    // Default expand: first client + first week
    state.openClients.clear();
    state.openWeeks.clear();
    const g0 = state.groups[0];
    if (g0 && g0.client_id) {
      const cid = String(g0.client_id);
      state.openClients.add(cid);
      const w0 = Array.isArray(g0.weeks) ? g0.weeks[0] : null;
      if (w0 && w0.invoice_week_start) {
        state.openWeeks.add(`${cid}|${String(w0.invoice_week_start)}`);
      }
    }
  };

  const refreshSummariesAfterSuccess = async (invoiceIds) => {
    // After batch generate, switch UI to Invoice Summary and filter to invoices from this run.
    // NOTE: optional navigation; does not do per-invoice GET calls.
    try {
      const ids = Array.from(new Set((invoiceIds || []).map(String).filter(Boolean)));

      window.__listState = window.__listState || {};
      window.__listState.invoices = window.__listState.invoices || {
        page: 1,
        pageSize: 50,
        total: null,
        hasMore: false,
        filters: null,
        sort: { key: null, dir: 'asc' }
      };

      window.__listState.invoices.page = 1;
      window.__listState.invoices.total = null;
      window.__listState.invoices.hasMore = false;

      window.__listState.invoices.filters = {
        ids,
        include_totals: 1
      };

      try { currentSection = 'invoices'; } catch {}

      try { document.getElementById('btnCloseModal')?.click(); } catch {}

      const data = await loadSection();
      renderSummary(data);
    } catch {}
  };

  const renderSkeleton = () => {
    return `
      <div id="invBatchGenRoot" class="invbatch-root">
        <div class="mini" style="opacity:.95">
          Create draft invoices for <b>READY_FOR_INVOICE</b> timesheets, grouped by client and week.
        </div>

        <div id="invBatchGenControls" class="invbatch-controls"></div>

        <div id="invBatchGenError" class="mini" style="display:none;color:#ffb4b4;"></div>

        <div id="invBatchGenScroll" class="invbatch-scroll">
          <div id="invBatchGenBody" class="invbatch-groups"></div>
          <div id="invBatchGenResults" class="invbatch-results" style="display:none"></div>
        </div>
      </div>
    `;
  };

  const paintResultsFromConfirm = (resEl, out) => {
    const results = Array.isArray(out?.results_invoices) ? out.results_invoices : [];
    const invoiceIds = Array.isArray(out?.invoice_ids) ? out.invoice_ids : [];

    resEl.innerHTML = '';

    const wrap = document.createElement('div');

    const h = document.createElement('div');
    h.style.fontWeight = '700';
    h.style.marginBottom = '6px';
    h.textContent = `Results â€” Enqueued ${Number(out?.enqueued || 0)} â€¢ Generated ${Number(out?.generated || 0)}`;
    wrap.appendChild(h);

    const note = document.createElement('div');
    note.className = 'mini';
    note.style.opacity = '0.9';
    note.textContent = 'Rendered from confirm response only (no per-invoice fetch).';
    wrap.appendChild(note);

    const actionsRow = document.createElement('div');
    actionsRow.style.display = 'flex';
    actionsRow.style.gap = '8px';
    actionsRow.style.flexWrap = 'wrap';
    actionsRow.style.alignItems = 'center';
    actionsRow.style.marginTop = '10px';

    const btnView = document.createElement('button');
    btnView.type = 'button';
    btnView.className = 'btn btn-sm btn-outline';
    btnView.textContent = `View invoices in summary (${invoiceIds.length})`;
    btnView.disabled = !invoiceIds.length;
    btnView.addEventListener('click', async (ev) => {
      ev.preventDefault();
      await refreshSummariesAfterSuccess(invoiceIds);
    });

    actionsRow.appendChild(btnView);
    wrap.appendChild(actionsRow);

    const hr = document.createElement('div');
    hr.style.height = '1px';
    hr.style.background = 'var(--line)';
    hr.style.margin = '10px 0';
    wrap.appendChild(hr);

    if (!results.length) {
      const empty = document.createElement('div');
      empty.className = 'mini';
      empty.textContent = 'No invoices returned.';
      wrap.appendChild(empty);
      resEl.appendChild(wrap);
      return;
    }

    // Group by client_id
    const byClient = new Map();
    for (const r of results) {
      const cid = String(r?.client_id || '');
      if (!byClient.has(cid)) byClient.set(cid, []);
      byClient.get(cid).push(r);
    }

    // Render grouped sections
    for (const [cid, arr] of byClient.entries()) {
      const clientName = String(arr[0]?.client_name || cid || 'Client');

      const details = document.createElement('details');
      details.className = 'invbatch-card';
      details.open = state.openResultClients.has(cid) || false;

      details.addEventListener('toggle', () => {
        if (details.open) state.openResultClients.add(cid);
        else state.openResultClients.delete(cid);
      });

      const sum = document.createElement('summary');
      sum.className = 'invbatch-card-head';
      sum.style.listStyle = 'none';

      const left = document.createElement('div');
      left.style.display = 'flex';
      left.style.flexDirection = 'column';
      left.style.gap = '2px';

      const t = document.createElement('div');
      t.style.fontWeight = '700';
      t.textContent = clientName;

      const sub = document.createElement('div');
      sub.className = 'mini';
      sub.style.opacity = '0.85';
      sub.textContent = `${arr.length} invoice(s)`;

      left.appendChild(t);
      left.appendChild(sub);

      sum.appendChild(left);
      details.appendChild(sum);

      const inner = document.createElement('div');
      inner.style.display = 'flex';
      inner.style.flexDirection = 'column';
      inner.style.gap = '8px';
      inner.style.padding = '10px 6px 6px 6px';

      // Sort by week_ending_date then invoice_no
      arr.sort((a, b) => {
        const wa = String(a?.week_ending_date || '');
        const wb = String(b?.week_ending_date || '');
        if (wa < wb) return -1;
        if (wa > wb) return 1;
        const na = String(a?.invoice_no || '');
        const nb = String(b?.invoice_no || '');
        return na.localeCompare(nb);
      });

      for (const r of arr) {
        const invoiceNo = (r?.invoice_no != null && String(r.invoice_no).trim()) ? String(r.invoice_no) : 'â€”';
        const cand = (r?.candidate_name != null && String(r.candidate_name).trim())
          ? String(r.candidate_name)
          : (Array.isArray(r?.candidate_names) && r.candidate_names.length ? 'Multiple' : 'â€”');

        const we = r?.week_ending_date ? `Week ending ${ymdToDMY(r.week_ending_date)}` : 'Week ending â€”';
        const dns = (r?.do_not_send === true);

        const ok = (r?.ok === true);
        const warnings = Array.isArray(r?.warnings) ? r.warnings : (r?.warnings ? [r.warnings] : []);
        const warnTxt = warnings.length ? warnings.map(w => {
          try { return (typeof w === 'string') ? w : JSON.stringify(w); } catch { return String(w); }
        }).join(' | ') : '';

        const card = document.createElement('div');
        card.className = 'invbatch-row';
        card.style.border = '1px solid var(--line)';
        card.style.borderRadius = '12px';
        card.style.background = '#0b1427';
        card.style.display = 'flex';
        card.style.flexWrap = 'wrap';
        card.style.gap = '10px';
        card.style.alignItems = 'center';
        card.style.justifyContent = 'space-between';

        const leftBox = document.createElement('div');
        leftBox.style.display = 'flex';
        leftBox.style.flexDirection = 'column';
        leftBox.style.gap = '2px';
        leftBox.style.minWidth = '0';
        leftBox.style.flex = '1';

        const line1 = document.createElement('div');
        line1.style.display = 'flex';
        line1.style.gap = '8px';
        line1.style.flexWrap = 'wrap';
        line1.style.alignItems = 'center';

        const pill = document.createElement('span');
        pill.className = 'mini invbatch-badge';
        pill.style.borderColor = ok ? '#2d6' : '#a33';
        pill.style.background  = ok ? '#0f2a1b' : '#3a1214';
        pill.style.color       = ok ? '#bfffe0' : '#ffb4b4';
        pill.textContent = ok ? 'OK' : 'FAILED';

        const invTxt = document.createElement('span');
        invTxt.style.fontWeight = '700';
        invTxt.textContent = `INV ${invoiceNo}`;

        const dnsPill = document.createElement('span');
        dnsPill.className = 'mini invbatch-badge';
        dnsPill.style.opacity = dns ? '1' : '0.3';
        dnsPill.textContent = dns ? 'Do not send' : 'Send';

        line1.appendChild(pill);
        line1.appendChild(invTxt);
        line1.appendChild(dnsPill);

        const line2 = document.createElement('div');
        line2.className = 'mini';
        line2.style.opacity = '0.9';
        line2.textContent = `${cand} â€¢ ${we}`;

        leftBox.appendChild(line1);
        leftBox.appendChild(line2);

        if (warnTxt) {
          const line3 = document.createElement('div');
          line3.className = 'mini';
          line3.style.opacity = '0.9';
          line3.style.color = '#ffb4b4';
          line3.textContent = `Notes: ${warnTxt}`;
          leftBox.appendChild(line3);
        }

        card.appendChild(leftBox);
        inner.appendChild(card);
      }

      details.appendChild(inner);
      wrap.appendChild(details);
    }

    resEl.appendChild(wrap);
  };

  const paint = () => {
    const root = document.getElementById('invBatchGenRoot');
    if (!root) return;

    const controls = document.getElementById('invBatchGenControls');
    const bodyEl   = document.getElementById('invBatchGenBody');
    const errEl    = document.getElementById('invBatchGenError');
    const resEl    = document.getElementById('invBatchGenResults');
    const scrollEl = document.getElementById('invBatchGenScroll');

    if (!controls || !bodyEl || !errEl || !resEl || !scrollEl) return;

    const prevScroll = scrollEl.scrollTop || 0;

    const selectedCount = state.selected.size;

    const mkBtn = (label, onClick, opts={}) => {
      const b = document.createElement('button');
      b.type = 'button';
      b.textContent = label;

      const cls = ['btn', 'btn-sm'];
      if (opts.primary) cls.push('btn-primary');
      else cls.push('btn-outline');
      if (opts.warn) cls.push('btn-warn');
      b.className = cls.join(' ');

      b.disabled = !!opts.disabled;
      if (!opts.disabled) b.addEventListener('click', onClick);
      return b;
    };

    // â”€â”€ controls â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    controls.innerHTML = '';

    const allowWrap = document.createElement('label');
    allowWrap.className = 'mini';
    allowWrap.style.display = 'flex';
    allowWrap.style.alignItems = 'center';
    allowWrap.style.gap = '8px';

    const allowCb = document.createElement('input');
    allowCb.type = 'checkbox';
    allowCb.checked = !!state.allowEarly;
    allowCb.disabled = state.busy;

    const allowTxt = document.createElement('span');
    allowTxt.textContent = 'Batch early';

    allowWrap.appendChild(allowCb);
    allowWrap.appendChild(allowTxt);

    allowCb.addEventListener('change', async () => {
      state.allowEarly = !!allowCb.checked;
      state.busy = true;
      paint();
      try {
        await fetchCandidates();
      } catch (e) {
        state.error = String(e?.message || e);
      } finally {
        state.busy = false;
        paint();
      }
    });

    controls.appendChild(allowWrap);

    controls.appendChild(mkBtn('Refresh', async () => {
      state.busy = true;
      paint();
      try {
        await fetchCandidates();
      } catch (e) {
        state.error = String(e?.message || e);
      } finally {
        state.busy = false;
        paint();
      }
    }, { disabled: state.busy }));

    controls.appendChild(mkBtn('Clear selection', () => {
      clearSelection();
      paint();
    }, { disabled: state.busy || selectedCount === 0 }));

    controls.appendChild(mkBtn(`Confirm (${selectedCount})`, async () => {
      if (state.busy) return;

      const rowsPayload = buildRowsPayload();
      if (!rowsPayload.length) {
        alert('Select at least one eligible timesheet.');
        return;
      }

      const ok = window.confirm(
        `Generate draft invoices for ${selectedCount} timesheet(s)?\n\n` +
        `This will enqueue BY_WEEK jobs and generate invoices immediately.`
      );
      if (!ok) return;

      state.busy = true;
      state.error = '';
      state.results = null;
      paint();

      try {
        const out = await apiPostJsonLocal(API_CONFIRM, {
          allow_early: !!state.allowEarly,
          rows: rowsPayload
        });

        state.results = out || {};
        window.__toast && window.__toast(`Batch generate complete (generated: ${Number(out?.generated || 0)}).`);
      } catch (e) {
        state.error = String(e?.message || e);
      } finally {
        state.busy = false;
        paint();
      }
    }, { primary: true, disabled: state.busy || selectedCount === 0 }));

    const selInfo = document.createElement('div');
    selInfo.className = 'mini';
    selInfo.style.opacity = '0.9';
    selInfo.textContent = state.busy ? 'Workingâ€¦' : (selectedCount ? `${selectedCount} selected` : '');
    controls.appendChild(selInfo);

    // â”€â”€ error â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if (state.error) {
      errEl.style.display = '';
      errEl.textContent = state.error;
    } else {
      errEl.style.display = 'none';
      errEl.textContent = '';
    }

    // â”€â”€ groups (candidate selection) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    bodyEl.innerHTML = '';
    const groups = Array.isArray(state.groups) ? state.groups : [];

    if (!groups.length && !state.busy) {
      const empty = document.createElement('div');
      empty.className = 'mini';
      empty.style.opacity = '0.85';
      empty.textContent = 'No candidates found (nothing ready to invoice).';
      bodyEl.appendChild(empty);
    }

    groups.forEach((c) => {
      const clientId = String(c?.client_id || '');
      const clientName = String(c?.client_name || clientId || 'Client');
      const weeks = Array.isArray(c?.weeks) ? c.weeks : [];

      // Collect selectable timesheets for this client (skip blocked_by_hr_validation)
      const selectableClientIds = [];
      weeks.forEach(w => {
        const tss = Array.isArray(w?.timesheets) ? w.timesheets : [];
        tss.forEach(t => {
          const id = String(t?.timesheet_id || '');
          if (!id) return;
          if (t?.blocked_by_hr_validation === true) return;
          selectableClientIds.push(id);
        });
      });

      const clientSelectedCount = selectableClientIds.filter(id => state.selected.has(id)).length;

      const clientDetails = document.createElement('details');
      clientDetails.className = 'invbatch-card';
      clientDetails.open = state.openClients.has(clientId) || false;

      clientDetails.addEventListener('toggle', () => {
        if (clientDetails.open) state.openClients.add(clientId);
        else state.openClients.delete(clientId);
      });

      const sum = document.createElement('summary');
      sum.className = 'invbatch-card-head';
      sum.style.listStyle = 'none';

      const left = document.createElement('div');
      left.style.display = 'flex';
      left.style.flexDirection = 'column';
      left.style.gap = '2px';

      const title = document.createElement('div');
      title.style.fontWeight = '700';
      title.textContent = clientName;

      const sub = document.createElement('div');
      sub.className = 'mini';
      sub.style.opacity = '0.85';
      sub.textContent = `${weeks.length} week group(s)`;

      left.appendChild(title);
      left.appendChild(sub);

      const right = document.createElement('div');
      right.style.display = 'flex';
      right.style.alignItems = 'center';
      right.style.gap = '8px';

      const badge = document.createElement('span');
      badge.className = 'mini invbatch-badge';
      badge.textContent = clientSelectedCount ? `${clientSelectedCount} selected` : '';
      if (!clientSelectedCount) badge.style.opacity = '0.5';

      const btnSelClient = mkBtn('Select all in client', (ev) => {
        ev.preventDefault(); ev.stopPropagation();
        selectableClientIds.forEach(id => state.selected.add(id));
        paint();
      }, { disabled: state.busy || selectableClientIds.length === 0 });

      const btnDeselClient = mkBtn('Deselect client', (ev) => {
        ev.preventDefault(); ev.stopPropagation();
        selectableClientIds.forEach(id => state.selected.delete(id));
        paint();
      }, { disabled: state.busy || clientSelectedCount === 0 });

      right.appendChild(badge);
      right.appendChild(btnSelClient);
      right.appendChild(btnDeselClient);

      sum.appendChild(left);
      sum.appendChild(right);
      clientDetails.appendChild(sum);

      const clientInner = document.createElement('div');
      clientInner.style.display = 'flex';
      clientInner.style.flexDirection = 'column';
      clientInner.style.gap = '8px';
      clientInner.style.padding = '10px 6px 6px 6px';

      weeks.forEach((w) => {
        const wkStart = String(w?.invoice_week_start || '');
        const wkEnd   = String(w?.week_ending_date || '');
        const wkKey   = `${clientId}|${wkStart}`;

        const subtotal = fmtMoney(w?.subtotal_ex_vat);
        const hours    = Number(w?.total_hours || 0);

        const tss = Array.isArray(w?.timesheets) ? w.timesheets : [];

        const selectableWeekIds = [];
        tss.forEach(t => {
          const id = String(t?.timesheet_id || '');
          if (!id) return;
          if (t?.blocked_by_hr_validation === true) return;
          selectableWeekIds.push(id);
        });

        const weekSelectedCount = selectableWeekIds.filter(id => state.selected.has(id)).length;

        const weekDetails = document.createElement('details');
        weekDetails.className = 'invbatch-card';
        weekDetails.open = state.openWeeks.has(wkKey) || false;

        weekDetails.addEventListener('toggle', () => {
          if (weekDetails.open) state.openWeeks.add(wkKey);
          else state.openWeeks.delete(wkKey);
        });

        const wkSum = document.createElement('summary');
        wkSum.className = 'invbatch-card-head invbatch-week-head';
        wkSum.style.listStyle = 'none';

        const wkLeft = document.createElement('div');
        wkLeft.style.display = 'flex';
        wkLeft.style.flexDirection = 'column';
        wkLeft.style.gap = '2px';

        const wkTitle = document.createElement('div');
        wkTitle.style.fontWeight = '700';
        wkTitle.textContent = `Week ending ${ymdToDMY(wkEnd)}`;

        const wkMeta = document.createElement('div');
        wkMeta.className = 'mini';
        wkMeta.style.opacity = '0.85';
        wkMeta.textContent = `Week start ${ymdToDMY(wkStart)} â€¢ Subtotal ${subtotal} â€¢ Hours ${Number.isFinite(hours) ? hours.toFixed(2) : '0.00'}`;

        wkLeft.appendChild(wkTitle);
        wkLeft.appendChild(wkMeta);

        const wkRight = document.createElement('div');
        wkRight.style.display = 'flex';
        wkRight.style.alignItems = 'center';
        wkRight.style.gap = '8px';

        const wkBadge = document.createElement('span');
        wkBadge.className = 'mini invbatch-badge';
        wkBadge.textContent = weekSelectedCount ? `${weekSelectedCount} selected` : '';
        if (!weekSelectedCount) wkBadge.style.opacity = '0.5';

        const btnSelWeek = mkBtn('Select all in week', (ev) => {
          ev.preventDefault(); ev.stopPropagation();
          selectableWeekIds.forEach(id => state.selected.add(id));
          paint();
        }, { disabled: state.busy || selectableWeekIds.length === 0 });

        const btnDeselWeek = mkBtn('Deselect week', (ev) => {
          ev.preventDefault(); ev.stopPropagation();
          selectableWeekIds.forEach(id => state.selected.delete(id));
          paint();
        }, { disabled: state.busy || weekSelectedCount === 0 });

        wkRight.appendChild(wkBadge);
        wkRight.appendChild(btnSelWeek);
        wkRight.appendChild(btnDeselWeek);

        wkSum.appendChild(wkLeft);
        wkSum.appendChild(wkRight);
        weekDetails.appendChild(wkSum);

        const list = document.createElement('div');
        list.style.display = 'flex';
        list.style.flexDirection = 'column';
        list.style.gap = '6px';
        list.style.padding = '10px 6px 6px 6px';

        tss.forEach(t => {
          const tsId = String(t?.timesheet_id || '');
          const cand = String(t?.candidate_name || 'Worker');
          const basis = String(t?.basis || '');
          const sm = String(t?.submission_mode || '');
          const vs = String(t?.validation_status || '');

          const charge = fmtMoney(t?.total_charge_ex_vat);
          const hrs = Number(t?.total_hours || 0);

          const hrReq = (t?.hr_validation_required_for_invoice === true);
          const hrBlocked = (t?.blocked_by_hr_validation === true);

          const row = document.createElement('div');
          row.className = 'invbatch-row';
          row.style.border = '1px solid var(--line)';
          row.style.borderRadius = '12px';
          row.style.background = '#0b1427';

          const cb = document.createElement('input');
          cb.type = 'checkbox';
          cb.checked = !!(tsId && state.selected.has(tsId));
          cb.disabled = state.busy || !tsId || hrBlocked;
          cb.addEventListener('change', () => {
            if (!tsId) return;
            if (cb.checked) state.selected.add(tsId);
            else state.selected.delete(tsId);
            paint();
          });

          const main = document.createElement('div');
          main.style.display = 'flex';
          main.style.flexDirection = 'column';
          main.style.gap = '2px';
          main.style.flex = '1';
          main.style.minWidth = '0';

          const line1 = document.createElement('div');
          line1.style.display = 'flex';
          line1.style.alignItems = 'center';
          line1.style.gap = '8px';
          line1.style.flexWrap = 'wrap';

          const name = document.createElement('div');
          name.style.fontWeight = '700';
          name.textContent = cand;
          line1.appendChild(name);

          if (hrReq) {
            const b = document.createElement('span');
            b.className = 'mini invbatch-badge';
            b.textContent = 'HR validation required';
            line1.appendChild(b);
          }

          if (hrBlocked) {
            const b = document.createElement('span');
            b.className = 'mini invbatch-badge invbatch-badge-warn';
            b.textContent = 'Blocked by HR validation';
            line1.appendChild(b);
          }

          const line2 = document.createElement('div');
          line2.className = 'mini';
          line2.style.opacity = '0.9';
          line2.textContent = `${basis}${basis && sm ? ' â€¢ ' : ''}${sm}${(vs ? ` â€¢ Validation: ${vs}` : '')}`;

          main.appendChild(line1);
          main.appendChild(line2);

          const right = document.createElement('div');
          right.className = 'mini invbatch-right';

          const a = document.createElement('div');
          a.textContent = `${charge}`;

          const b2 = document.createElement('div');
          b2.style.opacity = '0.9';
          b2.textContent = `Hours ${Number.isFinite(hrs) ? hrs.toFixed(2) : '0.00'}`;

          right.appendChild(a);
          right.appendChild(b2);

          row.appendChild(cb);
          row.appendChild(main);
          row.appendChild(right);

          list.appendChild(row);
        });

        weekDetails.appendChild(list);
        clientInner.appendChild(weekDetails);
      });

      clientDetails.appendChild(clientInner);
      bodyEl.appendChild(clientDetails);
    });

    // â”€â”€ results (confirm response only) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if (state.results) {
      resEl.style.display = '';
      paintResultsFromConfirm(resEl, state.results || {});
    } else {
      resEl.style.display = 'none';
      resEl.innerHTML = '';
    }

    scrollEl.scrollTop = prevScroll;
  };

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Open modal
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  window.modalCtx = {
    entity: 'invoices',
    openToken: `invoice-batch-generate:${Date.now()}:${Math.random().toString(36).slice(2)}`,
    data: {}
  };

  showModal(
    'Batch Generate â€” Invoices',
    [{ key: 'main', label: 'Batch Generate' }],
    () => renderSkeleton(),
    null,
    true,
    null,
    {
      kind: 'import-summary-invoice-batch-generate',
      noParentGate: true,
      onDismiss: () => {
        try {
          const modalNode = document.getElementById('modal');
          if (modalNode) {
            modalNode.classList.remove('invbatch-modal');
            modalNode.classList.remove('invbatch-generate-modal');
          }
        } catch {}
      }
    }
  );

  try {
    const modalNode = document.getElementById('modal');
    if (modalNode) {
      modalNode.classList.add('invbatch-modal');
      modalNode.classList.add('invbatch-generate-modal');
    }
  } catch {}

  // Initial load + paint
  state.busy = true;
  paint();

  try {
    await fetchCandidates();
  } catch (e) {
    state.error = String(e?.message || e);
  } finally {
    state.busy = false;
    paint();
  }
}


async function openUserManagementModal() {
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // User Management (Admin) â€” Utility modal
  // Tabs:
  //  - Users
  //  - Email Settings (Finance)
  //
  // Uses showModal kind "import-summary-*" so:
  //  - footer Save/Edit hidden
  //  - inputs/buttons remain enabled even in view mode
  //
  // Backend endpoints used:
  //  - GET    /api/users?q=&role=&is_active=
  //  - POST   /api/users
  //  - PATCH  /api/users/:id
  //  - POST   /api/users/:id/reset-password
  //  - GET    /api/settings/defaults
  //  - PUT    /api/settings/defaults
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  if (typeof confirmDiscardChangesIfDirty === 'function') {
    if (!confirmDiscardChangesIfDirty()) return;
  }

  const byIdLocal = (id) => (typeof byId === 'function' ? byId(id) : document.getElementById(id));
  const esc = encodeURIComponent;

  const deepClone = (o) => {
    try { return JSON.parse(JSON.stringify(o || {})); } catch { return (o && typeof o === 'object') ? { ...o } : o; }
  };

  const safeJson = async (res) => { try { return await res.json(); } catch { return null; } };

  const escapeHtml = (s) => String(s ?? '')
    .replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;')
    .replaceAll('"','&quot;').replaceAll("'","&#39;");

  const strongPasswordOk = (pw) => {
    const s = String(pw || '');
    return s.length >= 8 && /[a-z]/.test(s) && /[A-Z]/.test(s) && /[0-9]/.test(s);
  };

  const parseJsonStrict = (txt, label) => {
    const raw = String(txt ?? '').trim();
    if (!raw) return {}; // treat empty as {}
    let parsed = null;
    try { parsed = JSON.parse(raw); } catch {
      throw new Error(`${label} must be valid JSON.`);
    }
    if (!parsed || typeof parsed !== 'object' || Array.isArray(parsed)) {
      throw new Error(`${label} must be a JSON object.`);
    }
    return parsed;
  };

  const fmtBoolPill = (on, txtOn='Yes', txtOff='No') => {
    const cls = on ? 'pill pill-ok' : 'pill pill-warn';
    const txt = on ? txtOn : txtOff;
    return `<span class="${cls}">${escapeHtml(txt)}</span>`;
  };

  const fmtIso = (isoLike) => {
    if (!isoLike) return 'â€”';
    // use your existing helpers if available
    try {
      if (typeof formatUkTimestampFromUtc === 'function') return formatUkTimestampFromUtc(String(isoLike));
    } catch {}
    return String(isoLike);
  };

  const state = {
    tab: 'users',

    busy: false,
    error: '',
    notice: '',

    users: [],
    usersLoaded: false,
    usersLoading: false,

    // client-side filters
    q: '',
    role: '',
    is_active: '',

    // row selection (blue highlight)
    selectedUserId: null,

    // create panel
    createOpen: false,
    creating: false,
    createModel: {
      email: '',
      display_name: '',
      role: 'admin',
      password: '',
      email_settings_text: '{}'
    },

    // edit panel
    editingUserId: null,
    savingEdit: false,
    editModel: {
      id: '',
      email: '',
      display_name: '',
      role: 'admin',
      is_active: true,
      email_settings_text: '{}',
      new_password: '' // optional
    },

    // edit close/discard support
    editBaseline: null,        // snapshot of editModel when opened
    editDirty: false,
    editUserSnapshot: null,    // snapshot of original user row used for discard restore

    // finance settings
    settingsLoaded: false,
    settingsLoading: false,
    savingSettings: false,
    settings: null, // { finance_email, finance_email_settings, max_attachments_per_email, ... }
    financeModel: {
      finance_email: '',
      finance_email_settings_text: '{}',
      max_attachments_per_email: '30'
    }
  };

  const setError = (msg) => { state.error = String(msg || ''); state.notice = ''; };
  const setNotice = (msg) => { state.notice = String(msg || ''); state.error = ''; };

  const apiGetUsers = async (paramsObj = {}) => {
    const qs = new URLSearchParams();
    if (paramsObj.q) qs.set('q', String(paramsObj.q));
    if (paramsObj.role) qs.set('role', String(paramsObj.role));
    if (paramsObj.is_active) qs.set('is_active', String(paramsObj.is_active));
    const url = API(`/api/users${qs.toString() ? `?${qs.toString()}` : ''}`);

    const res = await authFetch(url);
    const j = await safeJson(res);
    if (!res.ok) {
      const t = await res.text().catch(() => '');
      const msg = (j && (j.error || j.message)) ? (j.error || j.message) : (t || `Request failed (${res.status})`);
      throw new Error(String(msg || 'Failed to load users'));
    }
    const users = Array.isArray(j?.users) ? j.users : (Array.isArray(j) ? j : []);
    return users;
  };

  const apiCreateUser = async (payload) => {
    const res = await authFetch(API('/api/users'), {
      method: 'POST',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify(payload || {})
    });
    const j = await safeJson(res);
    if (!res.ok) {
      const t = await res.text().catch(() => '');
      const msg = (j && (j.error || j.message)) ? (j.error || j.message) : (t || `Request failed (${res.status})`);
      throw new Error(String(msg || 'Failed to create user'));
    }
    return j;
  };

  const apiPatchUser = async (userId, patch) => {
    const res = await authFetch(API(`/api/users/${esc(userId)}`), {
      method: 'PATCH',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify(patch || {})
    });
    const j = await safeJson(res);
    if (!res.ok) {
      const t = await res.text().catch(() => '');
      const msg = (j && (j.error || j.message)) ? (j.error || j.message) : (t || `Request failed (${res.status})`);
      throw new Error(String(msg || 'Failed to update user'));
    }
    return j;
  };

  const apiResetUserPassword = async (userId, newPw) => {
    const res = await authFetch(API(`/api/users/${esc(userId)}/reset-password`), {
      method: 'POST',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify({ new_password: String(newPw || '') })
    });
    const j = await safeJson(res);
    if (!res.ok) {
      const t = await res.text().catch(() => '');
      const msg = (j && (j.error || j.message)) ? (j.error || j.message) : (t || `Request failed (${res.status})`);
      throw new Error(String(msg || 'Failed to reset password'));
    }
    return j;
  };

  const apiGetSettingsDefaults = async () => {
    const res = await authFetch(API('/api/settings/defaults'));
    const j = await safeJson(res);
    if (!res.ok) {
      const t = await res.text().catch(() => '');
      const msg = (j && (j.error || j.message)) ? (j.error || j.message) : (t || `Request failed (${res.status})`);
      throw new Error(String(msg || 'Failed to load settings'));
    }
    // backend returns { settings, finance_windows }
    return j?.settings || j?.data?.settings || j?.settings_defaults || j || null;
  };

  const apiPutSettingsDefaults = async (payload) => {
    const res = await authFetch(API('/api/settings/defaults'), {
      method: 'PUT',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify(payload || {})
    });
    const j = await safeJson(res);
    if (!res.ok) {
      const t = await res.text().catch(() => '');
      const msg = (j && (j.error || j.message)) ? (j.error || j.message) : (t || `Request failed (${res.status})`);
      throw new Error(String(msg || 'Failed to save settings'));
    }
    return j?.settings || j?.data?.settings || j || null;
  };

  const syncUsersRowSelection = () => {
    const table = document.getElementById('umUsersTable');
    if (!table) return;
    const rows = table.querySelectorAll('tbody tr[data-uid]');
    rows.forEach(tr => {
      const uid = String(tr.getAttribute('data-uid') || '').trim();
      const on = !!uid && (String(state.selectedUserId || '') === uid);
      if (on) {
        tr.style.background = 'rgba(79,70,229,.18)';
        tr.style.outline = '1px solid rgba(129,140,248,.55)';
      } else {
        tr.style.background = '';
        tr.style.outline = '';
      }
    });
  };

  const computeEditDirty = () => {
    const b = state.editBaseline;
    const m = state.editModel || {};
    if (!b || typeof b !== 'object') {
      state.editDirty = false;
      return false;
    }

    const norm = (v) => String(v ?? '');
    const normTrim = (v) => String(v ?? '').trim();
    const normLowerTrim = (v) => String(v ?? '').trim().toLowerCase();

    let dirty = false;

    if (normLowerTrim(m.email) !== normLowerTrim(b.email)) dirty = true;
    if (normTrim(m.display_name) !== normTrim(b.display_name)) dirty = true;
    if (normLowerTrim(m.role) !== normLowerTrim(b.role)) dirty = true;
    if (!!m.is_active !== !!b.is_active) dirty = true;

    // email settings text: compare trimmed
    if (normTrim(m.email_settings_text) !== normTrim(b.email_settings_text)) dirty = true;

    // new password: any non-empty means dirty
    if (normTrim(m.new_password)) dirty = true;

    state.editDirty = dirty;
    return dirty;
  };

  const syncEditCloseDiscardUi = () => {
    const btn = document.getElementById('umEditCloseBtn');
    if (!btn) return;
    btn.textContent = state.editDirty ? 'Discard' : 'Close';
    btn.setAttribute('title', state.editDirty ? 'Discard changes (keeps panel open)' : 'Close editor');
  };

  const seedEditModel = (user) => {
    const u = user || {};
    state.editModel = {
      id: String(u.id || ''),
      email: String(u.email || ''),
      display_name: String(u.display_name || ''),
      role: String(u.role || 'admin'),
      is_active: !!u.is_active,
      email_settings_text: JSON.stringify((u.email_settings && typeof u.email_settings === 'object') ? u.email_settings : {}, null, 2),
      new_password: ''
    };

    state.editBaseline = deepClone(state.editModel);
    state.editDirty = false;
    state.editUserSnapshot = deepClone(u);

    // best-effort update if button already exists
    try { syncEditCloseDiscardUi(); } catch {}
  };

  const loadUsers = async () => {
    state.usersLoading = true;
    setError('');
    paint();
    try {
      // fetch full list once; filter client-side for fast UX
      const users = await apiGetUsers({});
      state.users = Array.isArray(users) ? users : [];
      state.usersLoaded = true;

      // if selected user vanished, clear selection
      try {
        const sel = String(state.selectedUserId || '');
        if (sel && !(state.users || []).some(u => String(u?.id || '') === sel)) {
          state.selectedUserId = null;
        }
      } catch {}
    } finally {
      state.usersLoading = false;
      paint();
    }
  };

  const loadSettings = async () => {
    state.settingsLoading = true;
    setError('');
    paint();
    try {
      const s = await apiGetSettingsDefaults();
      state.settings = (s && typeof s === 'object') ? s : {};

      const finEmail = (state.settings.finance_email == null) ? '' : String(state.settings.finance_email || '').trim();
      const finSet   = (state.settings.finance_email_settings && typeof state.settings.finance_email_settings === 'object')
        ? state.settings.finance_email_settings
        : {};
      const maxA = (state.settings.max_attachments_per_email == null) ? 30 : Number(state.settings.max_attachments_per_email);

      state.financeModel.finance_email = finEmail;
      state.financeModel.finance_email_settings_text = JSON.stringify(finSet || {}, null, 2);
      state.financeModel.max_attachments_per_email = String(Number.isFinite(maxA) ? Math.trunc(maxA) : 30);

      state.settingsLoaded = true;
    } finally {
      state.settingsLoading = false;
      paint();
    }
  };

  const filteredUsers = () => {
    const q = String(state.q || '').trim().toLowerCase();
    const role = String(state.role || '').trim().toLowerCase();
    const isActive = String(state.is_active || '').trim().toLowerCase();

    return (state.users || []).filter(u => {
      if (!u || typeof u !== 'object') return false;

      if (role) {
        const r = String(u.role || '').toLowerCase();
        if (r !== role) return false;
      }

      if (isActive === 'true' || isActive === 'false') {
        const want = (isActive === 'true');
        if (!!u.is_active !== want) return false;
      }

      if (q) {
        const email = String(u.email || '').toLowerCase();
        const dn = String(u.display_name || '').toLowerCase();
        if (!email.includes(q) && !dn.includes(q)) return false;
      }
      return true;
    });
  };

  const renderSkeleton = (k) => {
    state.tab = (k === 'finance') ? 'finance' : 'users';

    // âœ… IMPORTANT: trigger a single paint after showModal swaps the tab DOM.
    // This replaces the old MutationObserver (which caused an infinite loop).
    setTimeout(() => { try { paint(); } catch {} }, 0);

    return `
      <div id="userMgmtRoot" style="display:flex;flex-direction:column;gap:10px;min-height:0;" data-tab="${escapeHtml(state.tab)}">
        <div class="mini" style="opacity:.95">
          ${
            state.tab === 'users'
              ? 'Admin: manage users (create/edit/disable/reset password) and per-user email settings JSON.'
              : 'Admin: edit global finance email settings (used for finance workflows and attachment bundling).'
          }
        </div>

        <div id="userMgmtError" class="mini" style="display:none;color:#ffb4b4;"></div>
        <div id="userMgmtNotice" class="mini" style="display:none;color:#bbf7d0;"></div>

        <div id="userMgmtBody" style="display:flex;flex-direction:column;gap:10px;min-height:0;"></div>
      </div>
    `;
  };

  const paint = () => {
    const root = document.getElementById('userMgmtRoot');
    if (!root) return;

    const tab = String(root.getAttribute('data-tab') || 'users');

    const errEl = document.getElementById('userMgmtError');
    const okEl  = document.getElementById('userMgmtNotice');
    const body  = document.getElementById('userMgmtBody');

    if (errEl) {
      if (state.error) { errEl.style.display = ''; errEl.textContent = state.error; }
      else { errEl.style.display = 'none'; errEl.textContent = ''; }
    }
    if (okEl) {
      if (state.notice) { okEl.style.display = ''; okEl.textContent = state.notice; }
      else { okEl.style.display = 'none'; okEl.textContent = ''; }
    }
    if (!body) return;

    body.innerHTML = '';

    const mkBtn = (label, onClick, opts = {}) => {
      const b = document.createElement('button');
      b.type = 'button';
      b.className = 'btn mini';
      b.textContent = label;
      if (opts.danger) b.style.background = '#5a1d22';
      if (opts.primary) b.style.background = '#123a66';
      if (opts.disabled) {
        b.disabled = true;
        b.style.opacity = '0.55';
        b.style.cursor = 'not-allowed';
      } else {
        b.addEventListener('click', onClick);
      }
      return b;
    };

    if (tab === 'users') {
      // â”€â”€ Controls â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const controls = document.createElement('div');
      controls.className = 'card';
      controls.style.display = 'flex';
      controls.style.flexWrap = 'wrap';
      controls.style.gap = '10px';
      controls.style.alignItems = 'center';

      const q = document.createElement('input');
      q.className = 'input';
      q.placeholder = 'Search usersâ€¦';
      q.style.maxWidth = '280px';
      q.value = String(state.q || '');
      q.addEventListener('input', () => { state.q = q.value; paint(); });

      const roleSel = document.createElement('select');
      roleSel.className = 'input';
      roleSel.style.maxWidth = '170px';
      roleSel.innerHTML = `
        <option value="">All roles</option>
        <option value="admin">admin</option>
        <option value="user">user</option>
      `;
      roleSel.value = String(state.role || '');
      roleSel.addEventListener('change', () => { state.role = roleSel.value; paint(); });

      const actSel = document.createElement('select');
      actSel.className = 'input';
      actSel.style.maxWidth = '190px';
      actSel.innerHTML = `
        <option value="">All statuses</option>
        <option value="true">Active only</option>
        <option value="false">Inactive only</option>
      `;
      actSel.value = String(state.is_active || '');
      actSel.addEventListener('change', () => { state.is_active = actSel.value; paint(); });

      controls.appendChild(mkBtn('Refresh', async () => {
        setError('');
        setNotice('');
        try { await loadUsers(); setNotice('Users refreshed.'); } catch (e) { setError(e?.message || e); }
      }, { disabled: state.usersLoading || state.creating || state.savingEdit }));

      controls.appendChild(mkBtn(state.createOpen ? 'Close create' : 'Create user', () => {
        state.createOpen = !state.createOpen;
        if (state.createOpen) {
          state.editingUserId = null;
        }
        setError('');
        setNotice('');
        paint();
      }, { primary: true, disabled: state.usersLoading || state.creating || state.savingEdit }));

      controls.appendChild(q);
      controls.appendChild(roleSel);
      controls.appendChild(actSel);

      const meta = document.createElement('div');
      meta.className = 'mini';
      meta.style.opacity = '0.85';
      meta.textContent = state.usersLoading
        ? 'Loadingâ€¦'
        : `${filteredUsers().length} shown / ${Array.isArray(state.users) ? state.users.length : 0} total`;
      controls.appendChild(meta);

      body.appendChild(controls);

      // â”€â”€ Create panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      if (state.createOpen) {
        const card = document.createElement('div');
        card.className = 'card';

        const title = document.createElement('div');
        title.style.fontWeight = '700';
        title.textContent = 'Create user';
        card.appendChild(title);

        const grid = document.createElement('div');
        grid.className = 'form';
        grid.style.marginTop = '10px';

        const mkRow = (label, inputEl) => {
          const r = document.createElement('div');
          r.className = 'row';
          const lab = document.createElement('label');
          lab.textContent = label;
          r.appendChild(lab);
          r.appendChild(inputEl);
          return r;
        };

        const inEmail = document.createElement('input');
        inEmail.className = 'input';
        inEmail.placeholder = 'email@domain.com';
        inEmail.value = state.createModel.email;
        inEmail.addEventListener('input', () => { state.createModel.email = inEmail.value; });

        const inDN = document.createElement('input');
        inDN.className = 'input';
        inDN.placeholder = 'Display name (optional)';
        inDN.value = state.createModel.display_name;
        inDN.addEventListener('input', () => { state.createModel.display_name = inDN.value; });

        const inRole = document.createElement('select');
        inRole.className = 'input';
        inRole.innerHTML = `
          <option value="admin">admin</option>
          <option value="user">user</option>
        `;
        inRole.value = String(state.createModel.role || 'admin');
        inRole.addEventListener('change', () => { state.createModel.role = inRole.value; });

        const inPw = document.createElement('input');
        inPw.className = 'input';
        inPw.type = 'password';
        inPw.placeholder = 'Default password (min 8, upper/lower/digit)';
        inPw.value = state.createModel.password;
        inPw.addEventListener('input', () => { state.createModel.password = inPw.value; });

        const inEmailSettings = document.createElement('textarea');
        inEmailSettings.className = 'input';
        inEmailSettings.style.minHeight = '120px';
        inEmailSettings.value = state.createModel.email_settings_text;
        inEmailSettings.addEventListener('input', () => { state.createModel.email_settings_text = inEmailSettings.value; });

        grid.appendChild(mkRow('Email', inEmail));
        grid.appendChild(mkRow('Display name', inDN));
        grid.appendChild(mkRow('Role', inRole));
        grid.appendChild(mkRow('Default password', inPw));

        const rowJson = document.createElement('div');
        rowJson.className = 'row';
        rowJson.style.gridColumn = '1 / -1';
        const labJson = document.createElement('label');
        labJson.textContent = 'email_settings (JSON object)';
        rowJson.appendChild(labJson);
        rowJson.appendChild(inEmailSettings);
        grid.appendChild(rowJson);

        card.appendChild(grid);

        const actions = document.createElement('div');
        actions.style.display = 'flex';
        actions.style.gap = '8px';
        actions.style.marginTop = '10px';
        actions.style.justifyContent = 'flex-end';

        actions.appendChild(mkBtn('Create', async () => {
          if (state.creating) return;

          setError('');
          setNotice('');

          const email = String(state.createModel.email || '').trim().toLowerCase();
          const dn = String(state.createModel.display_name || '').trim();
          const role = String(state.createModel.role || '').trim().toLowerCase();
          const pw = String(state.createModel.password || '');

          if (!email) { setError('Email is required.'); paint(); return; }
          if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) { setError('Invalid email address.'); paint(); return; }
          if (!(role === 'admin' || role === 'user')) { setError('Role must be admin or user.'); paint(); return; }

          if (!pw) { setError('Password is required.'); paint(); return; }
          if (!strongPasswordOk(pw)) {
            setError('Password must be at least 8 chars and include upper/lower case and a digit.');
            paint();
            return;
          }

          let emailSettingsObj = {};
          try {
            emailSettingsObj = parseJsonStrict(state.createModel.email_settings_text, 'email_settings');
          } catch (e) {
            setError(e?.message || e);
            paint();
            return;
          }

          state.creating = true;
          paint();

          try {
            await apiCreateUser({
              email,
              display_name: dn || null,
              role,
              password: pw,
              email_settings: emailSettingsObj
            });

            setNotice('User created.');
            // reset create form (keep open)
            state.createModel.email = '';
            state.createModel.display_name = '';
            state.createModel.role = 'admin';
            state.createModel.password = '';
            state.createModel.email_settings_text = '{}';

            await loadUsers();
          } catch (e) {
            setError(e?.message || e);
          } finally {
            state.creating = false;
            paint();
          }
        }, { primary: true, disabled: state.creating || state.usersLoading || state.savingEdit }));

        card.appendChild(actions);
        body.appendChild(card);
      }

      // â”€â”€ Edit panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      if (state.editingUserId) {
        const u = (state.users || []).find(x => String(x?.id || '') === String(state.editingUserId)) || null;

        const card = document.createElement('div');
        card.className = 'card';

        // Header row with top-right Close/Discard (as requested)
        const headRow = document.createElement('div');
        headRow.style.display = 'flex';
        headRow.style.alignItems = 'flex-start';
        headRow.style.justifyContent = 'space-between';
        headRow.style.gap = '10px';
        headRow.style.flexWrap = 'wrap';

        const leftHead = document.createElement('div');

        const title = document.createElement('div');
        title.style.fontWeight = '700';
        title.textContent = `Edit user`;
        leftHead.appendChild(title);

        const sub = document.createElement('div');
        sub.className = 'mini';
        sub.style.opacity = '0.9';
        sub.textContent = u ? (String(u.email || '') || String(u.id || '')) : String(state.editingUserId);
        leftHead.appendChild(sub);

        const rightHead = document.createElement('div');
        rightHead.style.display = 'flex';
        rightHead.style.gap = '8px';
        rightHead.style.alignItems = 'center';

        const btnCloseDiscard = document.createElement('button');
        btnCloseDiscard.type = 'button';
        btnCloseDiscard.className = 'btn mini';
        btnCloseDiscard.id = 'umEditCloseBtn';
        btnCloseDiscard.textContent = state.editDirty ? 'Discard' : 'Close';
        btnCloseDiscard.title = state.editDirty ? 'Discard changes (keeps panel open)' : 'Close editor';

        btnCloseDiscard.addEventListener('click', () => {
          // If dirty: Discard -> restore baseline and keep panel open
          if (state.editDirty) {
            const snap = (state.editUserSnapshot && typeof state.editUserSnapshot === 'object') ? state.editUserSnapshot : null;
            if (snap) {
              seedEditModel(snap);
              setError('');
              setNotice('Changes discarded.');
              paint();
            } else {
              // fallback: just close
              state.editingUserId = null;
              state.editBaseline = null;
              state.editDirty = false;
              state.editUserSnapshot = null;
              setError('');
              setNotice('');
              paint();
            }
            return;
          }

          // Not dirty: Close -> exit editor
          state.editingUserId = null;
          state.editBaseline = null;
          state.editDirty = false;
          state.editUserSnapshot = null;
          setError('');
          setNotice('');
          paint();
        });

        rightHead.appendChild(btnCloseDiscard);

        headRow.appendChild(leftHead);
        headRow.appendChild(rightHead);
        card.appendChild(headRow);

        const grid = document.createElement('div');
        grid.className = 'form';
        grid.style.marginTop = '10px';

        const mkRow = (label, inputEl) => {
          const r = document.createElement('div');
          r.className = 'row';
          const lab = document.createElement('label');
          lab.textContent = label;
          r.appendChild(lab);
          r.appendChild(inputEl);
          return r;
        };

        const markDirtyAndSync = () => {
          computeEditDirty();
          syncEditCloseDiscardUi();
        };

        const inEmail = document.createElement('input');
        inEmail.className = 'input';
        inEmail.value = String(state.editModel.email || '');
        inEmail.addEventListener('input', () => { state.editModel.email = inEmail.value; markDirtyAndSync(); });

        const inDN = document.createElement('input');
        inDN.className = 'input';
        inDN.value = String(state.editModel.display_name || '');
        inDN.addEventListener('input', () => { state.editModel.display_name = inDN.value; markDirtyAndSync(); });

        const inRole = document.createElement('select');
        inRole.className = 'input';
        inRole.innerHTML = `
          <option value="admin">admin</option>
          <option value="user">user</option>
        `;
        inRole.value = String(state.editModel.role || 'admin');
        inRole.addEventListener('change', () => { state.editModel.role = inRole.value; markDirtyAndSync(); });

        const inActive = document.createElement('select');
        inActive.className = 'input';
        inActive.innerHTML = `
          <option value="true">Active</option>
          <option value="false">Inactive</option>
        `;
        inActive.value = state.editModel.is_active ? 'true' : 'false';
        inActive.addEventListener('change', () => { state.editModel.is_active = (inActive.value === 'true'); markDirtyAndSync(); });

        const inEmailSettings = document.createElement('textarea');
        inEmailSettings.className = 'input';
        inEmailSettings.style.minHeight = '140px';
        inEmailSettings.value = String(state.editModel.email_settings_text || '{}');
        inEmailSettings.addEventListener('input', () => { state.editModel.email_settings_text = inEmailSettings.value; markDirtyAndSync(); });

        const inNewPw = document.createElement('input');
        inNewPw.className = 'input';
        inNewPw.type = 'password';
        inNewPw.placeholder = 'Set new password (optional)';
        inNewPw.value = String(state.editModel.new_password || '');
        inNewPw.addEventListener('input', () => { state.editModel.new_password = inNewPw.value; markDirtyAndSync(); });

        grid.appendChild(mkRow('Email', inEmail));
        grid.appendChild(mkRow('Display name', inDN));
        grid.appendChild(mkRow('Role', inRole));
        grid.appendChild(mkRow('Status', inActive));

        const rowPw = document.createElement('div');
        rowPw.className = 'row';
        rowPw.style.gridColumn = '1 / -1';
        const labPw = document.createElement('label');
        labPw.textContent = 'New password (optional)';
        rowPw.appendChild(labPw);
        rowPw.appendChild(inNewPw);
        const hintPw = document.createElement('div');
        hintPw.className = 'mini';
        hintPw.style.opacity = '0.85';
        hintPw.textContent = 'If provided, must be 8+ chars and include upper/lower case and a digit.';
        rowPw.appendChild(hintPw);
        grid.appendChild(rowPw);

        const rowJson = document.createElement('div');
        rowJson.className = 'row';
        rowJson.style.gridColumn = '1 / -1';
        const labJson = document.createElement('label');
        labJson.textContent = 'email_settings (JSON object)';
        rowJson.appendChild(labJson);
        rowJson.appendChild(inEmailSettings);
        grid.appendChild(rowJson);

        card.appendChild(grid);

        const actions = document.createElement('div');
        actions.style.display = 'flex';
        actions.style.gap = '8px';
        actions.style.marginTop = '10px';
        actions.style.justifyContent = 'space-between';
        actions.style.flexWrap = 'wrap';

        // Bottom-left Close (kept) â€“ closes editor; if dirty, confirms discard+close
        actions.appendChild(mkBtn('Close', () => {
          if (state.editDirty) {
            const ok = window.confirm('Discard changes and close?');
            if (!ok) return;
          }
          state.editingUserId = null;
          state.editBaseline = null;
          state.editDirty = false;
          state.editUserSnapshot = null;
          setError('');
          setNotice('');
          paint();
        }, { disabled: state.savingEdit || state.usersLoading || state.creating }));

        const rightActions = document.createElement('div');
        rightActions.style.display = 'flex';
        rightActions.style.gap = '8px';
        rightActions.style.flexWrap = 'wrap';

        rightActions.appendChild(mkBtn('Save changes', async () => {
          if (state.savingEdit) return;

          setError('');
          setNotice('');

          const id = String(state.editModel.id || '').trim();
          if (!id) { setError('User id missing.'); paint(); return; }

          const email = String(state.editModel.email || '').trim().toLowerCase();
          const dn = String(state.editModel.display_name || '').trim();
          const role = String(state.editModel.role || '').trim().toLowerCase();
          const isActive = !!state.editModel.is_active;

          if (!email) { setError('Email is required.'); paint(); return; }
          if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) { setError('Invalid email address.'); paint(); return; }
          if (!(role === 'admin' || role === 'user')) { setError('Role must be admin or user.'); paint(); return; }

          let emailSettingsObj = {};
          try {
            emailSettingsObj = parseJsonStrict(state.editModel.email_settings_text, 'email_settings');
          } catch (e) {
            setError(e?.message || e);
            paint();
            return;
          }

          const newPw = String(state.editModel.new_password || '');

          // If password provided, validate client-side too (backend will enforce anyway)
          if (newPw && !strongPasswordOk(newPw)) {
            setError('New password must be 8+ chars and include upper/lower case and a digit.');
            paint();
            return;
          }

          state.savingEdit = true;
          paint();

          try {
            // 1) Patch user fields
            await apiPatchUser(id, {
              email,
              display_name: dn || null,
              role,
              is_active: isActive,
              email_settings: emailSettingsObj
            });

            // 2) Optional password reset
            if (newPw) {
              await apiResetUserPassword(id, newPw);
            }

            setNotice(newPw ? 'User updated and password reset.' : 'User updated.');
            state.editingUserId = null;
            state.editBaseline = null;
            state.editDirty = false;
            state.editUserSnapshot = null;

            await loadUsers();
          } catch (e) {
            setError(e?.message || e);
          } finally {
            state.savingEdit = false;
            paint();
          }
        }, { primary: true, disabled: state.savingEdit || state.usersLoading || state.creating }));

        actions.appendChild(rightActions);

        card.appendChild(actions);
        body.appendChild(card);

        // ensure button label is correct after render
        try { computeEditDirty(); syncEditCloseDiscardUi(); } catch {}
      }

      // â”€â”€ Users table â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const tblCard = document.createElement('div');
      tblCard.className = 'card';

      const hdr = document.createElement('div');
      hdr.style.display = 'flex';
      hdr.style.alignItems = 'center';
      hdr.style.justifyContent = 'space-between';
      hdr.style.gap = '10px';
      hdr.style.flexWrap = 'wrap';

      const t = document.createElement('div');
      t.style.fontWeight = '700';
      t.textContent = 'Users';
      hdr.appendChild(t);

      const hint = document.createElement('div');
      hint.className = 'mini';
      hint.style.opacity = '0.85';
      hint.textContent = 'Click a row to select (blue). Double-click a row to edit. Edit opens a panel above.';
      hdr.appendChild(hint);

      tblCard.appendChild(hdr);

      const wrap = document.createElement('div');
      wrap.style.marginTop = '10px';
      wrap.style.maxHeight = '55vh';
      wrap.style.overflow = 'auto';
      wrap.style.border = '1px solid var(--line)';
      wrap.style.borderRadius = '10px';

      const table = document.createElement('table');
      table.id = 'umUsersTable';
      table.className = 'grid';
      table.style.margin = '0';

      const users = filteredUsers();

      table.innerHTML = `
        <thead>
          <tr>
            <th>Email</th>
            <th>Display name</th>
            <th>Role</th>
            <th>Active</th>
            <th>Last login</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          ${
            users.length
              ? users.map(u => {
                  const id = String(u.id || '');
                  const email = escapeHtml(u.email || '');
                  const dn = escapeHtml(u.display_name || '');
                  const role = escapeHtml(u.role || '');
                  const active = !!u.is_active;
                  const last = fmtIso(u.last_login_at_utc);

                  return `
                    <tr data-uid="${escapeHtml(id)}">
                      <td>${email}</td>
                      <td>${dn || 'â€”'}</td>
                      <td>${role || 'â€”'}</td>
                      <td>${fmtBoolPill(active, 'Active', 'Inactive')}</td>
                      <td>${escapeHtml(last)}</td>
                      <td>
                        <button type="button" class="btn mini" data-um-act="edit" data-uid="${escapeHtml(id)}">Edit</button>
                        <button type="button" class="btn mini" data-um-act="reset" data-uid="${escapeHtml(id)}">Reset password</button>
                      </td>
                    </tr>
                  `;
                }).join('')
              : `<tr><td colspan="6" class="mini" style="opacity:.85;">${state.usersLoading ? 'Loadingâ€¦' : 'No users found.'}</td></tr>`
          }
        </tbody>
      `;

      wrap.appendChild(table);
      tblCard.appendChild(wrap);
      body.appendChild(tblCard);

      // Wire row click + double-click (selection + edit)
      try {
        const tbody = table.querySelector('tbody');
        if (tbody && !tbody.dataset.wired) {
          tbody.dataset.wired = '1';

          tbody.addEventListener('click', (ev) => {
            const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-uid]') : null;
            if (!tr) return;

            // If clicking one of the action buttons, let that handler run
            if (ev.target && ev.target.closest && ev.target.closest('button[data-um-act]')) return;

            const uid = String(tr.getAttribute('data-uid') || '').trim();
            if (!uid) return;

            state.selectedUserId = uid;
            syncUsersRowSelection();
          });

          tbody.addEventListener('dblclick', (ev) => {
            const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-uid]') : null;
            if (!tr) return;

            // Ignore dblclick on buttons (they already have explicit actions)
            if (ev.target && ev.target.closest && ev.target.closest('button[data-um-act]')) return;

            const uid = String(tr.getAttribute('data-uid') || '').trim();
            if (!uid) return;

            const user = (state.users || []).find(x => String(x?.id || '') === uid) || null;
            if (!user) return;

            state.selectedUserId = uid;
            state.editingUserId = uid;
            state.createOpen = false;
            seedEditModel(user);
            setError('');
            setNotice('');
            paint();
          });
        }
      } catch {}

      // Wire table action buttons
      const btns = table.querySelectorAll('button[data-um-act][data-uid]');
      btns.forEach(b => {
        if (b.dataset.wired === '1') return;
        b.dataset.wired = '1';

        b.addEventListener('click', async (ev) => {
          ev.preventDefault();
          ev.stopPropagation();

          const act = String(b.getAttribute('data-um-act') || '');
          const uid = String(b.getAttribute('data-uid') || '').trim();
          if (!uid) return;

          state.selectedUserId = uid;
          syncUsersRowSelection();

          const user = (state.users || []).find(x => String(x?.id || '') === uid) || null;

          if (act === 'edit') {
            if (!user) { setError('User not found.'); paint(); return; }
            state.editingUserId = uid;
            state.createOpen = false;
            seedEditModel(user);
            setError('');
            setNotice('');
            paint();
            return;
          }

          if (act === 'reset') {
            if (!user) { setError('User not found.'); paint(); return; }
            const email = String(user.email || '').trim();

            const pw1 = window.prompt(`Set a new password for ${email}.\n\nMust be 8+ chars and include upper/lower case and a digit.\n\nEnter new password:`, '');
            if (pw1 == null) return; // cancelled
            const pw = String(pw1 || '');

            if (!strongPasswordOk(pw)) {
              alert('Password must be 8+ chars and include upper/lower case and a digit.');
              return;
            }

            const ok = window.confirm(`Reset password for ${email}?`);
            if (!ok) return;

            try {
              await apiResetUserPassword(uid, pw);
              setNotice('Password reset.');
              paint();
            } catch (e) {
              setError(e?.message || e);
              paint();
            }
            return;
          }
        });
      });

      // Apply selection highlight after render
      try { syncUsersRowSelection(); } catch {}

      return;
    }

    // â”€â”€ Finance settings tab â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if (tab === 'finance') {
      const card = document.createElement('div');
      card.className = 'card';

      const title = document.createElement('div');
      title.style.fontWeight = '700';
      title.textContent = 'Email Settings (Finance)';
      card.appendChild(title);

      const desc = document.createElement('div');
      desc.className = 'mini';
      desc.style.opacity = '0.9';
      desc.textContent = 'These values are stored on settings_defaults and are used for finance emailing/bundling.';
      card.appendChild(desc);

      if (state.settingsLoading) {
        const loading = document.createElement('div');
        loading.className = 'mini';
        loading.style.opacity = '0.85';
        loading.style.marginTop = '10px';
        loading.textContent = 'Loadingâ€¦';
        card.appendChild(loading);
        body.appendChild(card);
        return;
      }

      const form = document.createElement('div');
      form.className = 'form';
      form.style.marginTop = '10px';

      const mkRow = (label, inputEl) => {
        const r = document.createElement('div');
        r.className = 'row';
        const lab = document.createElement('label');
        lab.textContent = label;
        r.appendChild(lab);
        r.appendChild(inputEl);
        return r;
      };

      const inEmail = document.createElement('input');
      inEmail.className = 'input';
      inEmail.placeholder = 'finance@domain.com';
      inEmail.value = String(state.financeModel.finance_email || '');
      inEmail.addEventListener('input', () => { state.financeModel.finance_email = inEmail.value; });

      const inMax = document.createElement('input');
      inMax.className = 'input';
      inMax.type = 'number';
      inMax.min = '1';
      inMax.max = '100';
      inMax.value = String(state.financeModel.max_attachments_per_email || '30');
      inMax.addEventListener('input', () => { state.financeModel.max_attachments_per_email = inMax.value; });

      const inJson = document.createElement('textarea');
      inJson.className = 'input';
      inJson.style.minHeight = '160px';
      inJson.value = String(state.financeModel.finance_email_settings_text || '{}');
      inJson.addEventListener('input', () => { state.financeModel.finance_email_settings_text = inJson.value; });

      form.appendChild(mkRow('finance_email', inEmail));
      form.appendChild(mkRow('max_attachments_per_email', inMax));

      const rowJson = document.createElement('div');
      rowJson.className = 'row';
      rowJson.style.gridColumn = '1 / -1';
      const labJson = document.createElement('label');
      labJson.textContent = 'finance_email_settings (JSON object)';
      rowJson.appendChild(labJson);
      rowJson.appendChild(inJson);
      form.appendChild(rowJson);

      card.appendChild(form);

      const actions = document.createElement('div');
      actions.style.display = 'flex';
      actions.style.justifyContent = 'flex-end';
      actions.style.gap = '8px';
      actions.style.marginTop = '10px';

      actions.appendChild(mkBtn('Save finance settings', async () => {
        if (state.savingSettings) return;

        setError('');
        setNotice('');

        const financeEmail = String(state.financeModel.finance_email || '').trim();
        const maxN = Number(state.financeModel.max_attachments_per_email);
        const maxV = Number.isFinite(maxN) ? Math.trunc(maxN) : NaN;

        if (!(maxV >= 1 && maxV <= 100)) {
          setError('max_attachments_per_email must be an integer between 1 and 100.');
          paint();
          return;
        }

        let finSettingsObj = {};
        try {
          finSettingsObj = parseJsonStrict(state.financeModel.finance_email_settings_text, 'finance_email_settings');
        } catch (e) {
          setError(e?.message || e);
          paint();
          return;
        }

        state.savingSettings = true;
        paint();

        try {
          const saved = await apiPutSettingsDefaults({
            finance_email: financeEmail || null,
            finance_email_settings: finSettingsObj,
            max_attachments_per_email: maxV
          });

          // refresh local state from response (source of truth)
          state.settings = (saved && typeof saved === 'object') ? saved : state.settings;

          const finEmail2 = (state.settings.finance_email == null) ? '' : String(state.settings.finance_email || '').trim();
          const finSet2   = (state.settings.finance_email_settings && typeof state.settings.finance_email_settings === 'object')
            ? state.settings.finance_email_settings
            : finSettingsObj;

          const max2 = (state.settings.max_attachments_per_email == null) ? maxV : Number(state.settings.max_attachments_per_email);

          state.financeModel.finance_email = finEmail2;
          state.financeModel.finance_email_settings_text = JSON.stringify(finSet2 || {}, null, 2);
          state.financeModel.max_attachments_per_email = String(Number.isFinite(max2) ? Math.trunc(max2) : maxV);

          setNotice('Finance settings saved.');
        } catch (e) {
          setError(e?.message || e);
        } finally {
          state.savingSettings = false;
          paint();
        }
      }, { primary: true, disabled: state.savingSettings || state.settingsLoading }));

      card.appendChild(actions);
      body.appendChild(card);
      return;
    }
  };

  // âœ… Seed BOTH window.modalCtx and global modalCtx to prevent showModal back-compat clobbering.
  const ctxSeed = {
    entity: 'settings',
    openToken: `user-management:${Date.now()}:${Math.random().toString(36).slice(2)}`,
    data: {}
  };
  window.modalCtx = ctxSeed;
  try { if (typeof modalCtx !== 'undefined') modalCtx = ctxSeed; } catch {}

  // Open modal
  showModal(
    'User Management',
    [
      { key: 'users',   label: 'Users' },
      { key: 'finance', label: 'Email Settings (Finance)' }
    ],
    (k) => renderSkeleton(k),
    null,
    true,
    null,
    {
      kind: 'import-summary-user-management',
      noParentGate: true,
      onDismiss: () => {}
    }
  );

  // Load initial data (users + settings)
  try {
    await Promise.all([
      loadUsers().catch(e => setError(e?.message || e)),
      loadSettings().catch(e => setError(e?.message || e))
    ]);
  } catch {}

  // Initial paint
  try { paint(); } catch {}
}





// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UPDATED: showModal (adds contract-modal class toggling for Contracts dialogs)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function showModal(title, tabs, renderTab, onSave, hasId, onReturn, options) {

  const LOG = (typeof window.__LOG_MODAL === 'boolean') ? window.__LOG_MODAL : true;
  const L  = (...a)=> { if (LOG) console.log('[MODAL]', ...a); };
  const GC = (label)=> { if (LOG) console.groupCollapsed('[MODAL]', label); };
  const GE = ()=> { if (LOG) console.groupEnd(); };

  const stack = () => (window.__modalStack ||= []);
  const currentFrame = () => stack()[stack().length - 1] || null;
  const parentFrame  = () => (stack().length > 1 ? stack()[stack().length - 2] : null);
  const deep = (o) => JSON.parse(JSON.stringify(o));

     let opts = options || {};
  if (onReturn && typeof onReturn === 'object' && options === undefined) { opts = onReturn; onReturn = undefined; }

  // âœ… Force: these invoice child modals must never show the global footer Save button
try {
  const k = (opts && typeof opts.kind === 'string') ? String(opts.kind) : '';
  if (
    k === 'invoice-batch-add-timesheets' ||
    k === 'invoice-batch-add-adjustment' ||
    k === 'invoice-reference-numbers'
  ) {
    opts.showSave = false;
    opts.showApply = true;
  }

  // âœ… NEW: Import summary utility modals must never show global footer Save (belt-and-braces)
  if (k && k.startsWith('import-summary-')) {
    opts.showSave = false;
    opts.showApply = false;
  }
} catch {}



// âœ… Back-compat: if caller seeded global `modalCtx` (legacy) but not `window.modalCtx`,
// adopt it before we snapshot the frame. Uses openToken to avoid clobbering the active ctx.
try {
  if (typeof modalCtx !== 'undefined' && modalCtx && typeof modalCtx === 'object') {
    const w = (window.modalCtx && typeof window.modalCtx === 'object') ? window.modalCtx : null;
    const m = modalCtx;

    const wTok = w ? (w.openToken || null) : null;
    const mTok = m.openToken || null;

    if (mTok && (!wTok || String(wTok) !== String(mTok))) {
      window.modalCtx = m;
    }
  }
} catch {}

const stripEmpty = (obj) => { const out={}; for (const [k,v] of Object.entries(obj||{})) { if (v===''||v==null) continue; out[k]=v; } return out; };

// âœ… Canonical timesheet refresh helper (must exist BEFORE any footer clicks)
function ensureTsRefreshAndRepaintOverview() {
  if (typeof window.__tsRefreshAndRepaintOverview === 'function') {
    return window.__tsRefreshAndRepaintOverview;
  }

  window.__tsRefreshAndRepaintOverview = async function(tsTabKey) {
    const mc = window.modalCtx || {};

    // Capture/retain the summary context for this modal (used for summary patching)
    try {
      if (!mc.__summaryCtx && typeof captureSummaryContextForModalOpen === 'function') {
        mc.__summaryCtx = captureSummaryContextForModalOpen();
      }
    } catch {}

    const idNow   = mc.data?.timesheet_id || null;
    const weekId  = mc.data?.contract_week_id || null;

    let finalTsId   = idNow;
    let finalWeekId = weekId;

    // 1) Refresh details (TS or planned CW)
    try {
      if (idNow && typeof fetchTimesheetDetails === 'function') {
        const fresh = await fetchTimesheetDetails(idNow);

        // âœ… adopt current_timesheet_id if backend returns it
        const movedId = fresh?.current_timesheet_id ? String(fresh.current_timesheet_id) : null;
        if (movedId && String(movedId) !== String(idNow)) {
          mc.data = mc.data || {};
          mc.data.timesheet_id = movedId;
          mc.data.id = movedId;
          mc.timesheetMeta = mc.timesheetMeta || {};
          mc.timesheetMeta.expected_timesheet_id = movedId;

          finalTsId = movedId;
        }

        mc.timesheetDetails = fresh;

        // âœ… keep mc.data aligned for any legacy renderers that read row.submission_mode
        try {
          mc.data = mc.data || {};
          const ts2 = fresh?.timesheet || {};
          const cw2 = fresh?.contract_week || {};

          const subMode = String(ts2.submission_mode || '').toUpperCase();
          if (subMode) mc.data.submission_mode = subMode;

          const snap = String(cw2.submission_mode_snapshot || fresh?.cw_submission_mode_snapshot || '').toUpperCase();
          if (snap) mc.data.submission_mode_snapshot = snap;
        } catch {}

        // âœ… Option A: rebuild timesheetMeta from refreshed details (safe)
        try {
          const prevExpected =
            (mc.timesheetMeta && typeof mc.timesheetMeta === 'object' && mc.timesheetMeta.expected_timesheet_id)
              ? mc.timesheetMeta.expected_timesheet_id
              : null;

          let built = null;

          if (typeof window.buildTimesheetMetaFromDetails === 'function') {
            built = window.buildTimesheetMetaFromDetails(mc, fresh);
          } else if (typeof window.computeTimesheetMeta === 'function') {
            built = window.computeTimesheetMeta(mc, fresh);
          } else if (typeof window.seedTimesheetMetaFromDetails === 'function') {
            built = window.seedTimesheetMetaFromDetails(mc, fresh);
          }

          if (built && typeof built === 'object') {
            mc.timesheetMeta = built;
          } else {
            mc.timesheetMeta = (mc.timesheetMeta && typeof mc.timesheetMeta === 'object') ? mc.timesheetMeta : {};
          }

          const ts    = fresh?.timesheet || {};
          const cw    = fresh?.contract_week || {};
          const tsfin = fresh?.tsfin || {};

          const sheetScope =
            String(fresh?.sheet_scope || ts.sheet_scope || mc.data?.sheet_scope || '').toUpperCase();

          const cwModeSnapshot =
            String(
              cw.submission_mode_snapshot ||
              fresh?.cw_submission_mode_snapshot ||
              mc.data?.submission_mode_snapshot ||
              ''
            ).toUpperCase();

          const hasTsNow = !!(ts.timesheet_id || mc.data?.timesheet_id);

          const subModeTs =
            String(ts.submission_mode || mc.data?.submission_mode || '').toUpperCase();

          const subModeEff =
            hasTsNow ? subModeTs : (cwModeSnapshot || '');

          const hasWeek =
            !!(mc.data?.contract_week_id || cw.id || fresh?.contract_week_id);

          mc.timesheetMeta = (mc.timesheetMeta && typeof mc.timesheetMeta === 'object') ? mc.timesheetMeta : {};
          mc.timesheetMeta.sheetScope = sheetScope;
          mc.timesheetMeta.subMode = subModeEff;
          mc.timesheetMeta.cw_submission_mode_snapshot = cwModeSnapshot;
          mc.timesheetMeta.hasTs = hasTsNow;
          mc.timesheetMeta.isPlannedWeek = (!hasTsNow && hasWeek);

          mc.timesheetMeta.isPaid     = !!(tsfin.paid_at_utc || mc.data?.paid_at_utc);
          mc.timesheetMeta.isInvoiced = !!(tsfin.locked_by_invoice_id || mc.data?.locked_by_invoice_id);

          mc.timesheetMeta.expected_timesheet_id =
            (mc.data && mc.data.timesheet_id) ||
            prevExpected ||
            mc.timesheetMeta.expected_timesheet_id ||
            null;

        } catch (e) {
          console.warn('[TS][REFRESH] timesheetMeta rebuild failed', e);
        }

      } else if (!idNow && weekId) {
        // planned week: refetch contract_week so submission_mode_snapshot etc is current
        try {
          if (typeof authFetch === 'function' && typeof API === 'function') {
            const qs = new URLSearchParams();

            const contractId =
              mc.data?.contract_id ||
              mc.timesheetDetails?.contract_week?.contract_id ||
              null;

            if (contractId) qs.set('contract_id', contractId);

            const we =
              mc.data?.contract_week_ending_date ||
              mc.data?.week_ending_date ||
              mc.timesheetDetails?.contract_week?.week_ending_date ||
              null;

            if (we) {
              qs.set('week_ending_from', we);
              qs.set('week_ending_to', we);
            }

            qs.set('include_plan', 'true');

            const res = await authFetch(API(`/api/contract-weeks?${qs.toString()}`));

            let rows = [];
            try {
              if (typeof toList === 'function') rows = await toList(res);
              else rows = await res.json();
            } catch { rows = []; }

            const cwFound =
              (rows || []).find(w => String(w.id) === String(weekId)) ||
              (rows || [])[0] ||
              null;

            mc.timesheetDetails = mc.timesheetDetails || {};
            if (cwFound) mc.timesheetDetails.contract_week = cwFound;
            mc.timesheetDetails.contract_week_id = weekId;

            finalWeekId = weekId;

            // âœ… Keep modalCtx.data in sync so any legacy callers using mc.data.* aren't stale
            try {
              mc.data = mc.data || {};
              const snap =
                String(
                  cwFound?.submission_mode_snapshot ||
                  mc.timesheetDetails?.contract_week?.submission_mode_snapshot ||
                  mc.data?.submission_mode_snapshot ||
                  ''
                ).toUpperCase();

              if (snap) {
                mc.data.submission_mode_snapshot = snap;
                mc.timesheetDetails = mc.timesheetDetails || {};
                mc.timesheetDetails.cw_submission_mode_snapshot = snap;
              }
            } catch {}

            // âœ… rebuild timesheetMeta for planned weeks too (safe)
            try {
              const prevExpected =
                (mc.timesheetMeta && typeof mc.timesheetMeta === 'object' && mc.timesheetMeta.expected_timesheet_id)
                  ? mc.timesheetMeta.expected_timesheet_id
                  : null;

              const det  = mc.timesheetDetails || {};
              const tsX  = det?.timesheet || {};
              const cwX  = det?.contract_week || {};
              const tsfinX = det?.tsfin || {};

              mc.timesheetMeta = (mc.timesheetMeta && typeof mc.timesheetMeta === 'object') ? mc.timesheetMeta : {};

              const sheetScope =
                String(det.sheet_scope || mc.data?.sheet_scope || tsX.sheet_scope || '').toUpperCase();

              const cwModeSnapshot =
                String(
                  cwX.submission_mode_snapshot ||
                  mc.data?.submission_mode_snapshot ||
                  ''
                ).toUpperCase();

              const hasTsNow =
                !!(tsX.timesheet_id || mc.data?.timesheet_id);

              const hasWeekNow =
                !!(mc.data?.contract_week_id || cwX.id || det.contract_week_id);

              const subModeTs =
                String(tsX.submission_mode || mc.data?.submission_mode || '').toUpperCase();

              const subModeEff =
                hasTsNow ? subModeTs : (cwModeSnapshot || '');

              mc.timesheetMeta.sheetScope = sheetScope;
              mc.timesheetMeta.subMode = subModeEff;
              mc.timesheetMeta.cw_submission_mode_snapshot = cwModeSnapshot;

              mc.timesheetMeta.hasTs = hasTsNow;
              mc.timesheetMeta.isPlannedWeek = (!hasTsNow && hasWeekNow);

              mc.timesheetMeta.isPaid =
                !!(tsfinX.paid_at_utc || mc.data?.paid_at_utc);

              mc.timesheetMeta.isInvoiced =
                !!(tsfinX.locked_by_invoice_id || mc.data?.locked_by_invoice_id);

              mc.timesheetMeta.expected_timesheet_id =
                (mc.data && mc.data.timesheet_id) ||
                prevExpected ||
                mc.timesheetMeta.expected_timesheet_id ||
                null;

            } catch (e) {
              console.warn('[TS][REFRESH] timesheetMeta rebuild failed (planned week)', e);
            }

          }
        } catch {}
      }
    } catch (e) {
      console.warn('[TS][REFRESH] details refresh failed', e);
    }

    // 2) Refresh summary (for TS id only) â€” keeps local summary caches coherent (rotation-safe)
    try {
      const id2 = mc.data?.timesheet_id || null;
      if (id2 && typeof refreshTimesheetsSummaryAfterRotation === 'function') {
        await refreshTimesheetsSummaryAfterRotation(id2);
      }
    } catch {}

    // 2.5) Refresh evidence UI (so Evidence + preview updates right after actions)
    try {
      const id3 = mc.data?.timesheet_id || null;
      if (id3 && typeof refreshTimesheetEvidenceListAndUi === 'function') {
        await refreshTimesheetEvidenceListAndUi(id3);
      }
    } catch {}

     // 3) Update the active Summary grid in-place (filter-parity + obey current sort),
    //    otherwise fall back to a full renderAll() refresh.
    let didSummaryPatch = false;
    try {
      const ctx = mc.__summaryCtx || null;

      if (
        ctx &&
        typeof isSummaryContextStillActive === 'function' &&
        typeof summaryFetchCanonicalRow === 'function' &&
        typeof summaryApplySavedRecordToActiveSummary === 'function'
      ) {
        if (isSummaryContextStillActive(ctx)) {
          const fetchId = (mc.data?.timesheet_id || finalTsId || mc.data?.contract_week_id || finalWeekId || null);

          if (fetchId) {
            let canonical = await summaryFetchCanonicalRow('timesheets', fetchId, ctx);

            if (canonical && typeof normalizeSavedRecordForSummary === 'function') {
              canonical = normalizeSavedRecordForSummary('timesheets', canonical) || canonical;
            }

            if (canonical && typeof canonical === 'object') {
              // Keep modalCtx.data aligned with the canonical summary row shape where possible
              try {
                mc.data = { ...(mc.data || {}), ...(canonical || {}) };
              } catch {}

              const r = await summaryApplySavedRecordToActiveSummary('timesheets', canonical, ctx);
              didSummaryPatch = !!(r && r.ok);
            }
          }
        }
      }
    } catch (e) {
      console.warn('[SUMMARY][TS] summary patch failed (will fall back to renderAll)', e);
      didSummaryPatch = false;
    }

    if (!didSummaryPatch) {
      try { await renderAll(); } catch {}
    }

    // 4) Repaint the current modal tab (or the requested tab)

    try {
      const fr = (typeof window.__getModalFrame === 'function') ? window.__getModalFrame() : null;
      if (fr && fr.entity === 'timesheets') {
        fr.mode = 'view';
        fr._suppressDirty = true;
        const k = tsTabKey || fr.currentTabKey || 'overview';
        await fr.setTab(k);
        fr._suppressDirty = false;
        fr._updateButtons && fr._updateButtons();
      }
    } catch {}
  };

  return window.__tsRefreshAndRepaintOverview;
}

function setFormReadOnly(root, ro) {
  if (!root || !document.contains(root)) { L('setFormReadOnly(skip: invalid root)', { ro }); return; }
  const _allBefore = root.querySelectorAll('input, select, textarea, button');
  const beforeDisabled = Array.from(_allBefore).filter(el => el.disabled).length;

  root.querySelectorAll('input, select, textarea, button').forEach((el) => {
    const isDisplayOnly = el.id === 'tms_ref_display' || el.id === 'cli_ref_display';

    // Always lock display-only fields
    if (isDisplayOnly) {
      el.setAttribute('disabled','true');
      el.setAttribute('readonly','true');
      return;
    }

    // Buttons: in ro mode, keep specific IDs + any timesheet action buttons enabled
    if (el.type === 'button' || el.tagName === 'BUTTON') {
      const allow = new Set([
        'btnCloseModal',
        'btnDelete',
        'btnEditModal',
        'btnSave',
        'btnRelated',

        // âœ… Keep ONLY non-conversion footer actions
        'btnTsDeleteTimesheet',
        'btnTsProcessTimesheet',
        'btnTsUnprocessTimesheet',   // âœ… NEW
        'btnTsAuthorise',
        'btnTsUnauthorise'
      ]);

      // Keep Timesheet action buttons enabled in VIEW only if they are "safe view actions".
      // Do NOT keep weekly schedule edit buttons enabled (reset / add/remove shift lines).
      try {
        const top = (typeof currentFrame === 'function') ? currentFrame() : null;
        const isTimesheetFrame = !!(top && top.entity === 'timesheets');

        const tsAction = (el.getAttribute('data-ts-action') || '').toLowerCase();

        // Evidence table actions (View/Delete) are not data-ts-action
        const hasEvidenceAction =
          !!el.getAttribute('data-evidence-view') ||
          !!el.getAttribute('data-evidence-remove');

        // Actions that must NEVER be clickable in VIEW (schedule-driven weekly grid)
        const scheduleEditActions = new Set([
          'reset-schedule',
          'extra-shift-add',
          'extra-shift-remove',
          'extra-break-add',
          'extra-break-remove'
        ]);

        // Hard block schedule edit actions when read-only
        if (isTimesheetFrame && ro && tsAction && scheduleEditActions.has(tsAction)) {
          el.disabled = true;
          return;
        }

        if (isTimesheetFrame && hasEvidenceAction) {
          el.disabled = false;
          return;
        }

        // Only auto-enable data-ts-action buttons in VIEW if they are NOT schedule edit actions
        if (isTimesheetFrame && ro && tsAction && !scheduleEditActions.has(tsAction)) {
          el.disabled = false;
          return;
        }
      } catch {}

         // âœ… Invoice modal internal buttons must remain clickable in VIEW.
      // This invoice modal uses data-action="inv-*", so we allow only SAFE view actions.
      try {
        const top = (typeof currentFrame === 'function') ? currentFrame() : null;
        const isInvoiceFrame = !!(top && top.entity === 'invoices');

        const act = String(el.getAttribute('data-action') || '').toLowerCase();

           const safeDataActions = new Set([
          'inv-open-pdf',
          'inv-email',
          'inv-open-reference-numbers',
          'inv-set-tab',
          'inv-close',
          'inv-delete-invoice'
        ]);


        if (isInvoiceFrame && ro && act && safeDataActions.has(act)) {
          el.disabled = false;
          return;
        }
      } catch {}


      // In read-only mode, disable everything except allow-listed buttons
      if (ro) {
        el.disabled = !allow.has(el.id);
      } else {
        el.disabled = false;
      }
      return;
    }

    // Non-button inputs/selects/textareas
    if (ro) {
      el.setAttribute('disabled','true');
      el.setAttribute('readonly','true');
    } else {
      el.removeAttribute('disabled');
      el.removeAttribute('readonly');
    }
  });

  const _allAfter = root.querySelectorAll('input, select, textarea, button');
  const afterDisabled = Array.from(_allAfter).filter(el => el.disabled).length;
  try {
    const pc = root.querySelector('#btnPickCandidate');
    const pl = root.querySelector('#btnPickClient');
    L('setFormReadOnly snapshot', {
      ro,
      beforeDisabled,
      afterDisabled,
      picks: {
        btnPickCandidate: { exists: !!pc, disabled: !!(pc && pc.disabled) },
        btnPickClient:    { exists: !!pl, disabled: !!(pl && pl.disabled) }
      }
    });
  } catch {}
}




  function sanitizeModalGeometry() {
    const m = byId('modal');
    if (m) {
      m.classList.remove('dragging');
      const anchor = (window.__modalAnchor || null);
      if (anchor) {
        L('sanitizeModalGeometry: applying saved anchor', anchor);
        m.style.position = 'fixed';
        m.style.left     = anchor.left + 'px';
        m.style.top      = anchor.top  + 'px';
        m.style.right    = 'auto';
        m.style.bottom   = 'auto';
        m.style.transform= 'none';
      } else {
        L('sanitizeModalGeometry: reset to default (no anchor)');
        m.style.position = '';
        m.style.left = '';
        m.style.top = '';
        m.style.right = '';
        m.style.bottom = '';
        m.style.transform = '';
      }
    }
    document.onmousemove = null; document.onmouseup = null;
  }

  const modalEl = byId('modal');
  if (modalEl) {
    modalEl.style.position = ''; modalEl.style.left = ''; modalEl.style.top = '';
    modalEl.style.right = '';    modalEl.style.bottom = '';
    modalEl.style.transform = ''; modalEl.classList.remove('dragging');
    L('showModal: reset #modal initial geometry');
  }

  // Allow staging children (Clone & Extend) to be fully editable regardless of parent mode
  if (opts && opts.kind === 'contract-clone-extend') {
    opts.noParentGate = true;
    if (!opts.forceEdit) opts.forceEdit = true;
    L('showModal(kind=contract-clone-extend): enable noParentGate + forceEdit', { noParentGate: opts.noParentGate, forceEdit: opts.forceEdit });
  }

  // Import summary modals: always behave as independent utility panels
  // - they must NOT gate the parent
  // - they stack under contract edit modals but stay open across navigation
  if (opts && typeof opts.kind === 'string' && opts.kind.startsWith('import-summary-')) {
    opts.noParentGate   = true;
    opts.stayOpenOnSave = false;
    L('showModal(kind=import-summary-*) â†’ utility modal (noParentGate=true)', { kind: opts.kind });
  }

  // Treat the Rate Presets **picker** as a normal, interactive child:
  // - do NOT set noParentGate or _loadOnly here
  // - dirty should propagate to the parent while the picker is open
  if (opts && opts.kind === 'rate-presets-picker') {
    L('showModal(kind=rate-presets-picker): interactive child (noParentGate=false)');
  }
const ctxForFrame = window.modalCtx;

// âœ… Capture the currently-active Summary context at modal-open time
// (section, fingerprint, filters/sort/page, etc). Used to patch Summary in-place after save.
const summaryCtxOnOpen =
  (typeof captureSummaryContextForModalOpen === 'function')
    ? captureSummaryContextForModalOpen()
    : null;

const frame = {
  _token: `f:${Date.now()}:${Math.random().toString(36).slice(2)}`,
  _ctxRef: ctxForFrame,

  // âœ… Summary patch context (used only if still active at save time)
  _summaryCtx: summaryCtxOnOpen,

  title,
  tabs: Array.isArray(tabs) ? tabs.slice() : [],
  renderTab,
  onSave,
  onReturn,
  hasId: !!hasId,
  entity: (ctxForFrame && ctxForFrame.entity) || null,
  _showSave: (opts && Object.prototype.hasOwnProperty.call(opts, 'showSave')) ? !!opts.showSave : null,
  _showApply: (opts && Object.prototype.hasOwnProperty.call(opts, 'showApply')) ? !!opts.showApply : null,



  // NEW: optional dismiss hook (called when user closes the modal via Close/ESC)
  _onDismiss: (opts && typeof opts.onDismiss === 'function') ? opts.onDismiss : null,

  noParentGate: !!opts.noParentGate,
  forceEdit:    !!opts.forceEdit,
  kind:         opts.kind || null,
  stayOpenOnSave: !!opts.stayOpenOnSave,
    currentTabKey: (Array.isArray(tabs) && tabs.length ? tabs[0].key : null),

  mode: (() => {
  if (opts.forceEdit) return 'edit';
  if (!hasId && opts.kind === 'rate-preset') return 'edit';

    // NEW: utility modals â€“ always view-only, no Save/Edit
  const isUtilityKind =
    opts.kind === 'timesheets-resolve' ||
    opts.kind === 'resolve-candidate'  ||
    opts.kind === 'resolve-client'     ||
    opts.kind === 'invoice-reference-numbers' ||
    opts.kind === 'invoice-send-email-confirm' ||
    (typeof opts.kind === 'string' && opts.kind.startsWith('import-summary-')) ||
    (typeof opts.kind === 'string' && opts.kind.startsWith('invoice-batch-')) ||
    (typeof opts.kind === 'string' && opts.kind.startsWith('import-summary-invoice-batch-'));

  if (isUtilityKind) {
    return 'view';
  }





  // Special case: planned timesheet week (no timesheet_id yet)
  const ent = window.modalCtx?.entity || null;
  if (!hasId && ent === 'timesheets') {
    const d = window.modalCtx?.data || {};
    const hasWeek  = !!(d.contract_week_id || d.week_id || d.week_ending_date);
    const hasTsId  = !!d.timesheet_id;
    if (hasWeek && !hasTsId) {
      // Planned weekly/daily stub: open in VIEW mode, require explicit Edit
      return 'view';
    }
  }

  // Default for everything else
  return hasId ? 'view' : 'create';
})(),

    isDirty:false, _snapshot:null, _detachDirty:null, _detachGlobal:null, _hasMountedOnce:false, _wired:false, _closing:false, _saving:false, _confirmingDiscard:false,
    _applyDesired:null,

persistCurrentTabState() {
  L('persistCurrentTabState ENTER', { mode: this.mode, currentTabKey: this.currentTabKey });
  if (!window.modalCtx || this.mode === 'view') { L('persist(skip)', { reason:'mode=view or no modalCtx', mode:this.mode }); return; }

  const sentinel = window.modalCtx?.openToken || null;
  const initial  = (window.modalCtx.data?.id ?? sentinel);
  const fs = window.modalCtx.formState || { __forId: initial, main:{}, pay:{} };
  if (fs.__forId == null) fs.__forId = initial;

  // Preserve schedule inputs even when blank ('') so cleared days don't get dropped
  const keepScheduleBlanks = (obj) => {
    const out = {};
    const days = ['mon','tue','wed','thu','fri','sat','sun'];
    const parts = ['start','end','break'];
    days.forEach(d => {
      parts.forEach(p => {
        const k = `${d}_${p}`;
        if (Object.prototype.hasOwnProperty.call(obj, k)) {
          out[k] = (obj[k] == null ? '' : String(obj[k]));
        }
      });
    });
    return out;
  };

  if (this.currentTabKey === 'main') {
  const sel = byId('tab-main') ? '#tab-main' : (byId('contractForm') ? '#contractForm' : null);
  if (sel) {
    const c = collectForm(sel);

    const merged = { ...stripEmpty(c) };

    // âœ… Preserve GCK (key_norm) even when user clears it ('')
    if (Object.prototype.hasOwnProperty.call(c, 'key_norm')) {
      merged.key_norm = (c.key_norm == null) ? '' : String(c.key_norm);
    }

    const sched  = keepScheduleBlanks(c);
    fs.main = { ...(fs.main||{}), ...merged, ...sched };
  }
}


 if (this.currentTabKey === 'pay' && byId('tab-pay')) {
  const c = collectForm('#tab-pay');
  // For the Pay tab we must preserve blanks so cleared bank/umbrella fields
  // donâ€™t spring back from the DB when hopping between tabs.
  // Do NOT strip empty values here.
  if (LOG) {
    console.log('[MODAL][persistCurrentTabState] PAY TAB collected', {
      raw: { ...c },
      prevPay: { ...(fs.pay || {}) }
    });
  }
  fs.pay = { ...(fs.pay || {}), ...c };
  if (LOG) {
    console.log('[MODAL][persistCurrentTabState] PAY TAB updated fs.pay', {
      payKeys: Object.keys(fs.pay || {}),
      fsPay: { ...fs.pay }
    });
  }
}



  // NEW: capture Care Packages tab (candidates/rates) into main form state
  if (this.entity === 'candidates' && this.currentTabKey === 'rates' && byId('tab-rates')) {
    const c = collectForm('#tab-rates');
    // GCK (key_norm) and any future Care Packages fields are treated
    // as part of the candidate "main" payload
    fs.main = { ...(fs.main || {}), ...stripEmpty(c) };
  }

  // Persist contract-specific state when leaving Rates **or** Additional Rates
if (this.entity === 'contracts' && (this.currentTabKey === 'rates' || this.currentTabKey === 'extras')) {
  try {
    // Only bother capturing the paye/umb/charge_* fields from the Rates tab itself
    if (this.currentTabKey === 'rates') {
      const rt = byId('contractRatesTab');
      if (rt) {
        const rForm = {};
        rt.querySelectorAll('input, select, textarea').forEach(el => {
          if (el.name) {
            rForm[el.name] = (el.type === 'checkbox'
              ? (el.checked ? 'on' : '')
              : el.value);
          }
        });
        const onlyRates = {};
        for (const [k, v] of Object.entries(rForm)) {
          if (/^(paye_|umb_|charge_)/.test(k)) {
            onlyRates[k] = v;
          }
        }
        fs.pay = { ...(fs.pay || {}), ...stripEmpty(onlyRates) };
      }
    }

    // Always collect the full contract form so Main + Additional Rates fields are staged
    const mainSel = byId('contractForm') ? '#contractForm' : null;
    if (mainSel) {
      const m = collectForm(mainSel);
      // keep existing behavior for most fields, then re-add schedule blanks explicitly
      const mergedMain = { ...stripEmpty(m) };
      const sched      = keepScheduleBlanks(m);
      fs.main = { ...(fs.main || {}), ...mergedMain, ...sched };
    }
  } catch (e) {
    L('persistCurrentTabState contracts/rates+extras failed', e);
  }
}
  if (this.entity === 'clients' && this.currentTabKey === 'settings') {
    try {
      const formEl = byId('clientSettingsForm');
      if (formEl && typeof canonicalizeClientSettings === 'function') {
        const vals = collectForm('#clientSettingsForm', false);
        let merged = { ...(window.modalCtx?.clientSettingsState || {}), ...(vals || {}) };

        const wm = formEl.querySelector('input[type="radio"][name="weekly_mode"]:checked');
        const hp = formEl.querySelector('input[type="radio"][name="hr_weekly_behaviour"]:checked');
        if (wm) merged.weekly_mode = String(wm.value || '').trim();
        if (hp) merged.hr_weekly_behaviour = String(hp.value || '').trim();

        // âœ… NEW: capture invoice consolidation mode radio (DB-backed)
        const icm = formEl.querySelector('input[type="radio"][name="invoice_consolidation_mode"]:checked');
        if (icm) merged.invoice_consolidation_mode = String(icm.value || '').trim();

        const BOOL_KEYS = [
          'pay_reference_required',
          'invoice_reference_required',
          'self_bill_no_invoices_sent',
          'daily_calc_of_invoices',
          'group_nightsat_sunbh',
          'hr_attach_to_invoice',
          'ts_attach_to_invoice',
          'auto_invoice_default',
          'send_manual_invoices_to_different_email',

          // âœ… NEW: DB-backed checkbox
          'reference_number_required_to_issue_invoice'
        ];
        for (const key of BOOL_KEYS) {
          const el = formEl.querySelector(`input[type="checkbox"][name="${key}"]`);
          if (el) merged[key] = !!el.checked;
        }

        // Always capture the alt email (may be hidden; preserve blanks safely)
        merged.manual_invoices_alt_email_address = String(merged.manual_invoices_alt_email_address || '').trim();
        if (!merged.send_manual_invoices_to_different_email) {
          merged.manual_invoices_alt_email_address = '';
        }

        // Preserve these keys even if canonicalizeClientSettings strips unknown fields
        const keepAutoInv     = !!merged.auto_invoice_default;
        const keepManualFlag  = !!merged.send_manual_invoices_to_different_email;
        const keepManualEmail = String(merged.manual_invoices_alt_email_address || '').trim();

        // âœ… NEW: preserve DB-backed invoicing keys across canonicalizeClientSettings()
        const keepInvConsol =
          (merged.invoice_consolidation_mode != null) ? String(merged.invoice_consolidation_mode) : '';
        const keepRefToIssue =
          (typeof merged.reference_number_required_to_issue_invoice === 'boolean')
            ? merged.reference_number_required_to_issue_invoice
            : (merged.reference_number_required_to_issue_invoice === '1' || merged.reference_number_required_to_issue_invoice === 1 || merged.reference_number_required_to_issue_invoice === 'true');

        merged = canonicalizeClientSettings(merged);

        merged.auto_invoice_default = keepAutoInv;
        merged.send_manual_invoices_to_different_email = keepManualFlag;
        merged.manual_invoices_alt_email_address = keepManualFlag ? keepManualEmail : '';

        // âœ… restore DB-backed invoicing keys after canonicalize
        if (keepInvConsol != null && String(keepInvConsol).trim() !== '') {
          merged.invoice_consolidation_mode = String(keepInvConsol).trim();
        }
        merged.reference_number_required_to_issue_invoice = !!keepRefToIssue;

        window.modalCtx.clientSettingsState = merged;
      }
    } catch {}
  }


  window.modalCtx.formState = fs;
  L('persistCurrentTabState EXIT', { forId: fs.__forId, mainKeys: Object.keys(fs.main||{}), payKeys: Object.keys(fs.pay||{}) });
},

// inside showModal(...), in the `const frame = { ... }` object:
mergedRowForTab(k) {
  L('mergedRowForTab ENTER', { k });

  const base = { ...(window.modalCtx?.data || {}) };
  const fs   = (window.modalCtx?.formState || {});
  const rid  = window.modalCtx?.data?.id ?? null;
  const fid  = fs.__forId ?? null;
  const sentinel = window.modalCtx?.openToken ?? null;
  const same = (fid === rid) || (rid == null && (fid === sentinel || fid == null));

  const mainStaged = same ? (fs.main || {}) : {};
  const payStaged  = same ? (fs.pay  || {}) : {};

  // Default merge (drops empty strings via stripEmpty)
  const out = { ...base, ...stripEmpty(mainStaged) };

  // âœ… Preserve intentional clears for specific fields (blank string should win over base)
  // Global Candidate Key is stored as candidates.key_norm in your data model.
  try {
    if (this.entity === 'candidates') {
      const PRESERVE_EMPTY_KEYS = new Set(['key_norm']); // add more here only if needed

      for (const key of PRESERVE_EMPTY_KEYS) {
        if (Object.prototype.hasOwnProperty.call(mainStaged, key)) {
          const v = mainStaged[key];
          if (v === '') out[key] = ''; // keep explicit blank
        }
      }
    }
  } catch {}

  // âœ… FIX: when rendering the Pay tab, rehydrate staged pay fields verbatim
  // (do NOT strip empties, otherwise clearing a bank field will snap back)
  if (k === 'pay') {
    for (const [pk, pv] of Object.entries(payStaged || {})) {
      out[pk] = pv;
    }
  }

  // Keep non-DOM baselines visible, but let staged template override base schedule
  try {
    if (mainStaged.__template) {
      out.std_schedule_json = mainStaged.__template;
    }
    if (!out.std_hours_json && mainStaged.__hours) {
      out.std_hours_json = mainStaged.__hours;
    }
    if (Object.prototype.hasOwnProperty.call(mainStaged, '__bucket_labels')) {
      out.bucket_labels_json = mainStaged.__bucket_labels;
    }
  } catch {}

  // âœ¨ Preserve schedule fields even when blank
  try {
    const days = ['mon','tue','wed','thu','fri','sat','sun'];
    const parts = ['start','end','break'];
    days.forEach(d => {
      parts.forEach(p => {
        const key = `${d}_${p}`;
        if (Object.prototype.hasOwnProperty.call(mainStaged, key)) {
          out[key] = mainStaged[key]; // includes ''
        }
      });
    });
  } catch {}

  // Rates: merge staged pay/charge families into view row
  try {
    const mergedRates = { ...(out.rates_json || base.rates_json || {}) };
    for (const [kk, vv] of Object.entries(payStaged)) {
      if (/^(paye_|umb_|charge_)/.test(kk)) mergedRates[kk] = vv;
    }
    out.rates_json = mergedRates;
  } catch (e) {
    L('mergedRowForTab rates merge failed', e);
  }

  L('mergedRowForTab STATE', {
    rid, fid, sentinel, same,
    stagedMainKeys: Object.keys(mainStaged || {}),
    stagedPayKeys: Object.keys(payStaged || {}),
    ratesKeys: Object.keys(out.rates_json || {})
  });

  return out;
},


   _attachDirtyTracker() {
    if (this._detachDirty) { try { this._detachDirty(); } catch {} this._detachDirty = null; }
    const root = byId('modalBody'); if (!root) { L('_attachDirtyTracker(skip: no modalBody)'); return; }
    const onDirty = (ev) => {
      if (ev && !ev.isTrusted) return;

     // Allow presets picker to mark the *parent* dirty (only ignore truly load-only frames)
if (this._loadOnly === true) return;

      const isChild = (stack().length > 1);
      if (isChild) {
        if (this.noParentGate) {
          if (this.mode === 'edit' || this.mode === 'create') {
            this.isDirty = true;
            this._updateButtons && this._updateButtons();
          }
        } else {
          const p = parentFrame();
          if (p && (p.mode === 'edit' || p.mode === 'create')) {
            p.isDirty = true;
            p._updateButtons && p._updateButtons();
          }
        }
      } else {
        if (this.mode === 'edit' || this.mode === 'create') {
          this.isDirty = true;
          this._updateButtons && this._updateButtons();
        }
      }
      try { const t=currentFrame(); if (t && t.entity==='candidates' && t.currentTabKey==='rates') { renderCandidateRatesTable?.(); } } catch {}
    };
    root.addEventListener('input', onDirty, true);
    root.addEventListener('change',onDirty, true);
    this._detachDirty = ()=>{ root.removeEventListener('input',onDirty,true); root.removeEventListener('change',onDirty,true); };
    L('_attachDirtyTracker: attached');
  },

async setTab(k) {
  GC(`setTab(${k})`);
  L('setTab ENTER', {
    k,
    prevKey: this.currentTabKey,
    entity: this.entity,
    mode: this.mode,
    hasMounted: this._hasMountedOnce
  });

  const prevDirty = this.isDirty;
  this._suppressDirty = true;

  const persist = this._hasMountedOnce;
  if (persist) this.persistCurrentTabState();

   const merged = this.mergedRowForTab(k);
  if (this.entity === 'contracts' && k === 'main' && this.mode !== 'edit' && this.mode !== 'create') {
    if (window.modalCtx?.data?.start_date) merged.start_date = window.modalCtx.data.start_date;
    if (window.modalCtx?.data?.end_date)   merged.end_date   = window.modalCtx.data.end_date;
    try {
      const fs = (window.modalCtx.formState ||= {
        __forId: (window.modalCtx?.data?.id || window.modalCtx?.openToken || null),
        main: {},
        pay: {}
      });
      fs.main ||= {};
      if (merged.start_date) fs.main.start_date = merged.start_date;
      if (merged.end_date)   fs.main.end_date   = merged.end_date;
    } catch {}
  }

  byId('modalBody').innerHTML = this.renderTab(k, merged) || '';

// âœ… Invoices: ensure invoice modal delegated handlers survive DOM replacement
if (this.entity === 'invoices' && this.kind === 'invoice-modal') {
  try {
    const mcInv = window.modalCtx || {};
    const invRoot = document.getElementById('invModalRoot');
    if (invRoot && typeof attachInvoiceModalDelegatedHandlers === 'function') {
      // deps optional; attachInvoiceModalDelegatedHandlers has safe fallbacks now
      attachInvoiceModalDelegatedHandlers(mcInv, invRoot, null);
    }
  } catch {}
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Imports: Main tab wiring (dropzones) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if (this.entity === 'imports' && this.kind === 'imports' && k === 'main') {
  try {
    if (typeof wireImportDropzones === 'function') {
      wireImportDropzones();
    }
  } catch (e) {
    console.warn('[IMPORTS][WIRE] wireImportDropzones failed', e);
  }
}


  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Clients: Rates tab wiring â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (this.entity === 'clients' && k === 'rates') {
    try {
      typeof renderClientRatesTable === 'function' && renderClientRatesTable();
    } catch (e) {
      console.warn('[CLIENT][RATES] renderClientRatesTable failed', e);
    }
  }



  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Clients: Settings tab wiring â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (this.entity === 'clients' && k === 'settings') {
    try {
      // Use the actual client settings renderer, seeded from modalCtx
      if (typeof renderClientSettingsUI === 'function') {
        const seed = (window.modalCtx && window.modalCtx.clientSettingsState) || {};
        renderClientSettingsUI(seed);
      }
    } catch (e) {
      console.warn('[CLIENT][SETTINGS] renderClientSettingsUI failed', e);
    }
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Candidates: Main tab wiring (NI / DOB / aliases / job titles) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (this.entity === 'candidates' && k === 'main') {
    try {
      const container = document.getElementById('tab-main');
      if (container && typeof bindCandidateMainFormEvents === 'function') {
        // Ensure we have a candidateMainModel (openCandidate now seeds this)
        if (!window.modalCtx.candidateMainModel || typeof window.modalCtx.candidateMainModel !== 'object') {
          window.modalCtx.candidateMainModel = {};
        }
        bindCandidateMainFormEvents(container, window.modalCtx.candidateMainModel);
      }
    } catch (e) {
      console.warn('[CAND][MAIN] bindCandidateMainFormEvents failed', e);
    }
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Candidates: Bookings tab wiring â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   if (this.entity === 'candidates' && k === 'bookings') {
    try {
      const candId =
        window.modalCtx?.data?.id ||
        merged.id ||
        null;

      if (candId && typeof loadCandidateCalendar === 'function') {
        const holder = document.getElementById('candidateCalendarHolder');
        if (holder) {
          loadCandidateCalendar(holder, candId).catch(err => {
            console.warn('[CAND][BOOKINGS] loadCandidateCalendar failed', err);
            holder.innerHTML = '<span class="mini">Failed to load calendar.</span>';
          });
        }
      }
    } catch (e) {
      console.warn('[CAND][BOOKINGS] wiring failed', e);
    }
  }

   // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Candidates: Pay tab (Advances summary + Umbrella wiring) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (this.entity === 'candidates' && k === 'pay') {
    try {
      // Wire Umbrella input + datalist (searchable picker)
      if (typeof mountCandidatePayTab === 'function') {
        await mountCandidatePayTab();
      }

      const candId =
        window.modalCtx?.data?.id ||
        merged.id ||
        null;

      if (candId) {
        window.appState = window.appState || {};
        const cache = (window.appState.candidateAdvances ||= {});

        if (cache[candId]) {
          // Already cached this session â†’ repaint into fresh DOM
          updateCandidateAdvancesUI(candId);
        } else {
          // First time on this candidate â†’ fetch from backend
          fetchCandidateAdvances(candId).catch(err => {
            console.warn('[CAND][PAY][ADVANCES] fetch failed', err);
          });
        }
        // No button wiring here: this tab is read-only for advances.
        // Editing happens via right-click on the candidate row â†’ openCandidateAdvancesModal.
      }
    } catch (e) {
      console.warn('[CAND][PAY][ADVANCES] wiring failed', e);
    }
  }


  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Candidates: Rates tab (Rota Roles + overrides) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (this.entity === 'candidates' && k === 'rates') {
    try {
      // Rota Roles editor
      const container = document.getElementById('rolesEditor');
      if (container && typeof loadGlobalRoleOptions === 'function' && typeof renderRolesEditor === 'function') {
        const allRoles = await loadGlobalRoleOptions();

        const currentRoles =
          (Array.isArray(window.modalCtx?.rolesState) && window.modalCtx.rolesState.length)
            ? window.modalCtx.rolesState
            : (Array.isArray(window.modalCtx?.data?.roles) ? window.modalCtx.data.roles : []);

        renderRolesEditor(container, currentRoles, allRoles);

        // Optional: keep options fresh if global roles list changes
        if (!window.modalCtx._rolesUpdatedHandler) {
          window.modalCtx._rolesUpdatedHandler = async () => {
            try {
              const updated = await loadGlobalRoleOptions();
              if (container.__rolesEditor && typeof container.__rolesEditor.updateOptions === 'function') {
                container.__rolesEditor.updateOptions(updated);
              }
            } catch {
              // non-fatal
            }
          };
          window.addEventListener('global-roles-updated', window.modalCtx._rolesUpdatedHandler);
        }
      }

      // Candidate-specific rate overrides table
      if (typeof mountCandidateRatesTab === 'function') {
        await mountCandidateRatesTab();
      }
    } catch (e) {
      console.warn('[CAND][RATES] wiring failed', e);
    }
  }



  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Timesheets: Overview tab wiring â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Timesheets: Overview tab wiring â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if (this.entity === 'timesheets' && k === 'overview') {
  const { LOGM, L: LT } = getTsLoggers('[TS][OVERVIEW][WIRE]');
  const root = byId('modalBody');
  if (!root) {
    if (LOGM) LT('no modalBody root, skip wiring');
  } else {
    try {
   const mc    = window.modalCtx || {};
const tsId  = mc.data?.timesheet_id || null;       // REAL timesheet id only (may rotate)
const weekId= mc.data?.contract_week_id || null;   // contract_week id for planned weeks
const mode  = this.mode || 'view';

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Rotation-safety helpers (standalone overview actions)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const tsNow = () => (window.modalCtx?.data?.timesheet_id || null);
const expectedNow = () => (
  window.modalCtx?.timesheetMeta?.expected_timesheet_id ||
  window.modalCtx?.data?.timesheet_id ||
  null
);

// Standard 409 moved handler for ALL overview actions
const handleMoved = async (err, label) => {
  // Global helper (defined below) adopts new id + refreshes details + refreshes summary + repaints
  return await tsHandleMoved409Modal(err, {
    tabKey: 'overview',
    toast: 'This timesheet changed while you were editing; review and try again.',
    label: label || 'timesheet-action'
  });
};

const refreshAndRepaintOverview = ensureTsRefreshAndRepaintOverview();



        if (!tsId && !weekId) {
        if (LOGM) LT('no tsId/contract_week_id on modalCtx.data, skip overview wiring');
      } else {
              const switchManualBtn    = root.querySelector('button[data-ts-action="switch-manual"]');

        const holdOnBtn          = root.querySelector('button[data-ts-action="pay-hold-on"]');
        const holdOffBtn         = root.querySelector('button[data-ts-action="pay-hold-off"]');
        const markPaidBtn        = root.querySelector('button[data-ts-action="mark-paid"]');
    
        const payHoldInput       = root.querySelector('input[name="ts_pay_hold"]');
        const payHoldReasonInput = root.querySelector('input[name="ts_pay_hold_reason"]');
        const markPaidInput      = root.querySelector('input[name="ts_mark_paid"]');

        // Extra action buttons for timesheets
     // Extra action buttons for timesheets
const revertElecBtn   = root.querySelector('button[data-ts-action="revert-electronic"]');
const deleteReopenBtn = root.querySelector('button[data-ts-action="delete-manual-reopen"]');
const deletePermBtn   = root.querySelector('button[data-ts-action="delete-permanent"]');

// âœ… NEW: additional manual adjustment action
const addAdditionalManualBtn = root.querySelector('button[data-ts-action="add-additional-manual"]');

// âœ… Footer-only policy:
// - Unprocess Timesheet lives in footer (btnTsUnprocessTimesheet)
// - Delete permanently lives in footer (btnTsDeleteTimesheet)
// So do NOT show/wire these Overview action buttons even if renderer outputs them.
if (deleteReopenBtn) { deleteReopenBtn.style.display = 'none'; }
if (deletePermBtn)   { deletePermBtn.style.display   = 'none'; }

// â›” Do not attach any click listeners to deleteReopenBtn / deletePermBtn here.


// QR / route action buttons
const qrResendBtn        = root.querySelector('button[data-ts-action="qr-resend"]');
const qrRefuseBtn        = root.querySelector('button[data-ts-action="qr-refuse"]');
const qrReissueReqBtn    = root.querySelector('button[data-ts-action="qr-reissue-request"]');
const qrConvertManualBtn = root.querySelector('button[data-ts-action="qr-convert-manual-only"]');
const qrRestorePendBtn   = root.querySelector('button[data-ts-action="qr-restore-pending"]');
const qrRestoreSignedBtn = root.querySelector('button[data-ts-action="qr-restore-signed"]');
const allowQrAgainBtn    = root.querySelector('button[data-ts-action="allow-qr-again"]');
const allowElecAgainBtn  = root.querySelector('button[data-ts-action="allow-electronic-again"]');

const switchElecPlannedBtn = root.querySelector('button[data-ts-action="switch-electronic-planned"]');


// âœ… REMOVED: planned-only delete button wiring from Overview tab.
// Planned-only weeks are now deleted via the *footer* "Delete timesheet" button (btnTsDeleteTimesheet)
// which routes:
//   - tsId present â†’ deleteTimesheetPermanent(tsId)
//   - tsId null + weekId present â†’ deleteTimesheetPermanent(null, { contractWeekId: weekId })

const det         = mc.timesheetDetails || {};
const ts          = det.timesheet || {};
const tsfin        = det.tsfin || {};
const actionFlags  = (det.action_flags && typeof det.action_flags === 'object') ? det.action_flags : {};

const boolish = (v) => {
  if (v === true) return true;
  if (v === false) return false;
  if (v == null) return false;
  const s = String(v).trim().toLowerCase();
  return (s === 'true' || s === '1' || s === 'yes' || s === 'y' || s === 'on');
};

const isImportAuthoritativeFromSummary = (routeType, noTimesheetRequired) => {
  const rt = String(routeType || '').toUpperCase();
  const noTs = boolish(noTimesheetRequired);
  return (
    rt === 'WEEKLY_NHSP' ||
    rt === 'WEEKLY_NHSP_ADJUSTMENT' ||
    (rt === 'WEEKLY_HEALTHROSTER' && noTs === true)
  );
};

// IMPORTANT: must use the SUMMARY row fields (modalCtx.data)
const baseSummary = (window.modalCtx && window.modalCtx.data) ? window.modalCtx.data : (mc.data || {});
const rt   = String(baseSummary.route_type || '').toUpperCase();
const noTs = boolish(
  (Object.prototype.hasOwnProperty.call(baseSummary, 'client_no_timesheet_required'))
    ? baseSummary.client_no_timesheet_required
    : baseSummary.client_no_timesheet_required
);

// âœ… Single gate youâ€™ll use below (authoritative definition)
const importAuthoritative = isImportAuthoritativeFromSummary(rt, noTs);

// âœ… Defence-in-depth: recompute at click time (modal may have refreshed since wiring)
const importAuthoritativeNow = () => {
  try {
    const d = (window.modalCtx && window.modalCtx.data) ? window.modalCtx.data : {};
    const rtNow = String(d.route_type || '').toUpperCase();
    const noTsNow = boolish(d.client_no_timesheet_required);
    return isImportAuthoritativeFromSummary(rtNow, noTsNow);
  } catch {
    return false;
  }
};
const sheetScope = (det.sheet_scope || mc.data?.sheet_scope || ts.sheet_scope || '').toUpperCase();
const subMode    = (ts.submission_mode || mc.data?.submission_mode || '').toUpperCase();

// contract-week context for weekly manual delete+reopen
const cwId            = det.contract_week_id || mc.data?.contract_week_id || null;
const hasContractWeek = !!cwId;

const isAuthorised = !!ts.authorised_at_server;
const locked       = !!(tsfin.locked_by_invoice_id || tsfin.paid_at_utc);
const alreadyPaid  = !!tsfin.paid_at_utc;

const hasTs    = !!tsId;
const isWeekly = (sheetScope === 'WEEKLY');
const isDaily  = (sheetScope === 'DAILY');

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// âœ… UPDATED: wire â€œAdd additional manual timesheetâ€ pill
// Now calls consolidated createAdditionalManualAdjustmentAndOpen()
// âœ… ALSO: allow WEEKLY planned contract_week stubs (no timesheet_id yet)
// - Weekly: needs contract_week_id
// - Daily:  needs timesheet_id
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if (addAdditionalManualBtn) {
  const showAdd =
    (mode === 'view') &&
    (
      (isWeekly && !!weekId) ||  // âœ… allow planned weekly stubs
      (isDaily  && !!tsId)       // âœ… daily still requires a real timesheet id
    );

  addAdditionalManualBtn.style.display = showAdd ? '' : 'none';

  if (showAdd && !addAdditionalManualBtn.__tsWired) {
    addAdditionalManualBtn.__tsWired = true;

    addAdditionalManualBtn.addEventListener('click', async () => {
      try {
        if (typeof createAdditionalManualAdjustmentAndOpen !== 'function') {
          throw new Error('createAdditionalManualAdjustmentAndOpen is not defined.');
        }
        await createAdditionalManualAdjustmentAndOpen();
      } catch (err) {
        try { if (await handleMoved(err, 'add-additional-manual')) return; } catch {}
        if (LOGM) console.warn('[TS][OVERVIEW] add-additional-manual failed', err);
        alert(err?.message || 'Failed to create additional manual timesheet.');
      }
    });
  }
}



const weeklyElectronicWithTs =
  isWeekly && subMode === 'ELECTRONIC' && hasTs;

const weeklyElectronicPlanned =
  isWeekly && subMode === 'ELECTRONIC' && !hasTs && !!weekId;

const cwModeSnapshot =
  String(
    actionFlags.cw_submission_mode_snapshot ||
    (det.contract_week && det.contract_week.submission_mode_snapshot) ||
    mc.data?.submission_mode_snapshot ||
    ''
  ).toUpperCase();

const weeklyManualPlanned =
  isWeekly && !hasTs && !!weekId && (cwModeSnapshot === 'MANUAL');



        // Prefer backend-computed flags (details.action_flags), fallback to basic checks
        const canRevertElectronic =
          !!tsId && !locked && (
            actionFlags.can_revert_to_electronic === true ||
            subMode === 'MANUAL'
          );

        const canDeleteManualReopen =
          !!tsId && !locked && isWeekly && subMode === 'MANUAL' && hasContractWeek;

        const canDeletePermanent =
          !!tsId && !locked;

        if (LOGM) {
          LT('overview wiring snapshot', {
            tsId,
            weekId,
            mode,
            sheetScope,
            subMode,
            isAuthorised,
            locked,
            weeklyElectronicWithTs,
            weeklyElectronicPlanned,
      
            hasSwitchManual: !!switchManualBtn,
        
            hasPayHoldInput: !!payHoldInput,
            hasMarkPaidInput: !!markPaidInput
          });
        }

        // Action-flag derived enables
        const canRestorePending = !!actionFlags.can_restore_qr_pending;
        const canRestoreSigned  = !!actionFlags.can_restore_qr_signed;
        const canAllowQrAgain   = !!actionFlags.can_allow_qr_again;
        const canAllowElecAgain = !!actionFlags.can_allow_electronic_again;

        const viewEls = root.querySelectorAll('[data-view-only="true"]');
        const editEls = root.querySelectorAll('[data-edit-only="true"]');
        if (mode === 'edit' || mode === 'create') {
          viewEls.forEach(el => { el.style.display = 'none'; });
          editEls.forEach(el => { el.style.display = ''; });
        } else {
          viewEls.forEach(el => { el.style.display = ''; });
          editEls.forEach(el => { el.style.display = 'none'; });
        }

        // Hide legacy buttons
        if (holdOnBtn)   holdOnBtn.style.display  = 'none';
        if (holdOffBtn)  holdOffBtn.style.display = 'none';
        if (markPaidBtn) markPaidBtn.style.display= 'none';

         // â”€â”€ Authorise / Unauthorise â”€â”€
        // These are footer actions: btnTsAuthorise / btnTsUnauthorise (wired in top._updateButtons).


    // â”€â”€ Convert to manual (weekly existing OR weekly planned electronic OR daily existing) â”€â”€
if (switchManualBtn) {
  const showSwitch =
    mode === 'view' &&
    !locked &&
    !importAuthoritative && // âœ… block NHSP + HR CREATE
    (
      (isWeekly && subMode === 'ELECTRONIC' && (!!tsId || !!weekId)) ||
      (isDaily  && subMode === 'ELECTRONIC' && !!tsId)
    );

  switchManualBtn.style.display = showSwitch ? '' : 'none';

  // âœ… Defence-in-depth: only wire when visible/eligible
  if (showSwitch && !switchManualBtn.__tsWired) {
    switchManualBtn.__tsWired = true;
    switchManualBtn.addEventListener('click', async () => {
      // âœ… Defence-in-depth: re-check at click time (state may have changed)
  if (importAuthoritativeNow()) {
  alert('This timesheet is import-authoritative (NHSP / HealthRoster weekly no-timesheets). Conversion actions are disabled.');
  return;
}

      const ok = window.confirm(
        'Convert this timesheet to MANUAL?\n\n' +
        'For existing electronic timesheets, the signed electronic version is preserved as history.\n' +
        'For planned/open weekly slots, the week will be marked MANUAL so you can enter manual hours.'
      );
      if (!ok) return;

      try {
        const mc2     = window.modalCtx || {};
        const tsId2   = mc2.data?.timesheet_id || null;
        const weekId2 = mc2.data?.contract_week_id || null;

        const det2   = mc2.timesheetDetails || {};
        const ts2    = det2.timesheet || {};
        const sheetScope2 = String(det2.sheet_scope || mc2.data?.sheet_scope || ts2.sheet_scope || '').toUpperCase();
        const subMode2    = String(ts2.submission_mode || mc2.data?.submission_mode || '').toUpperCase();

        const isDaily2  = (sheetScope2 === 'DAILY');
        const isWeekly2 = (sheetScope2 === 'WEEKLY');
        const hasTs2    = !!tsId2;

        if (isDaily2 && hasTs2 && subMode2 === 'ELECTRONIC') {
          await switchDailyTimesheetToManual(tsId2);
        } else if (isWeekly2 && hasTs2 && subMode2 === 'ELECTRONIC') {
          await switchTimesheetToManual(tsId2);
        } else if (isWeekly2 && !hasTs2 && !!weekId2 && subMode2 === 'ELECTRONIC') {
          await switchContractWeekToManual(weekId2);
        } else {
          throw new Error('This item is not eligible for Convert to Manual.');
        }

        window.__toast && window.__toast('Converted to MANUAL.');
        await refreshAndRepaintOverview();
      } catch (err) {
        if (await handleMoved(err, 'switch-manual')) return;
        if (LOGM) console.warn('[TS][OVERVIEW] switch to manual failed', err);
        alert(err?.message || 'Failed to switch to manual.');
      }
    });
  }
}



        // â”€â”€ Revert to original electronic (versioned) â€” VIEW mode only â”€â”€
        if (revertElecBtn) {
         revertElecBtn.style.display = (mode === 'view' && canRevertElectronic && !importAuthoritative) ? '' : 'none';

          if (!revertElecBtn.__tsWired) {
            revertElecBtn.__tsWired = true;
            revertElecBtn.addEventListener('click', async () => {
              const ok = window.confirm(
                'Restore the original signed electronic version of this timesheet?\n\n' +
                'Any manual overrides will be kept in history but no longer current.'
              );
              if (!ok) return;
            try {
  await revertTimesheetToElectronic(tsId);
  window.__toast && window.__toast('Original electronic timesheet restored.');
  await refreshAndRepaintOverview();
} catch (err) {
  if (await handleMoved(err, 'revert-electronic')) return;
  if (LOGM) console.warn('[TS][OVERVIEW] revertTimesheetToElectronic failed', err);
  alert(err?.message || 'Failed to restore electronic timesheet.');
}

            });
          }
        }

        // â”€â”€ Delete manual TS & reopen week for e-submission â€” VIEW mode only â”€â”€
      

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // QR / route actions wiring (buttons rendered by renderTimesheetOverviewTab)
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


if (switchElecPlannedBtn) {
  const showSwitchBack =
    mode === 'view' &&
    !locked &&
    !importAuthoritative && // âœ… block NHSP + HR CREATE
    weeklyManualPlanned;

  switchElecPlannedBtn.style.display = showSwitchBack ? '' : 'none';

  // âœ… Defence-in-depth: only wire when visible/eligible
  if (showSwitchBack && !switchElecPlannedBtn.__tsWired) {
    switchElecPlannedBtn.__tsWired = true;
    switchElecPlannedBtn.addEventListener('click', async () => {
      // âœ… Defence-in-depth: re-check at click time (state may have changed)
          if (importAuthoritativeNow()) {
        alert('This timesheet is import-authoritative (NHSP / HealthRoster weekly no-timesheets). Route changes are disabled.');
        return;
      }


      const ok = window.confirm('Switch this planned weekly week back to ELECTRONIC submission?');
      if (!ok) return;

      try {
        const mc2 = window.modalCtx || {};
        const weekId2 = mc2.data?.contract_week_id || null;
        if (!weekId2) throw new Error('Contract week id missing.');

        await switchContractWeekToElectronic(weekId2);
        window.__toast && window.__toast('Week is now ELECTRONIC.');
        await refreshAndRepaintOverview();

      } catch (err) {
        alert(err?.message || 'Failed to switch week back to electronic.');
      }
    });
  }
}






// Send/Resend QR timesheet (label is determined by the renderer)
if (qrResendBtn) {
  qrResendBtn.style.display = (!!tsId && !locked && !importAuthoritative) ? '' : 'none';

  if (!qrResendBtn.__tsWired) {
    qrResendBtn.__tsWired = true;

    qrResendBtn.addEventListener('click', async () => {
      try {
        // âœ… Always use the latest id in case the timesheet rotated
        const idNow = tsNow();
        if (!idNow) throw new Error('Timesheet id missing.');

        // âœ… This helper now:
        //   - handles TIMESHEET_MOVED adoption
        //   - emits correct toast text (Resent / New sent / Reissue required)
        //   - triggers a refresh+repaint
        await resendQrTimesheetEmail(idNow);

        // âœ… Defence-in-depth: ensure Overview repaints even if the helper toast/refresh is suppressed
        await refreshAndRepaintOverview('overview');

      } catch (err) {
        if (await handleMoved(err, 'qr-resend')) return;
        if (LOGM) console.warn('[TS][OVERVIEW] qr-resend failed', err);
        alert(err?.message || 'Failed to send/resend QR timesheet.');
      }
    });
  }
}


// Refuse QR hours (Scenario 2)
if (qrRefuseBtn) {
  qrRefuseBtn.style.display = (!!tsId && !locked && !importAuthoritative) ? '' : 'none';
  if (!qrRefuseBtn.__tsWired) {
    qrRefuseBtn.__tsWired = true;
    qrRefuseBtn.addEventListener('click', async () => {
      try {
        const r = await refuseQrHours(tsId);
        if (r && r.cancelled) return;
        window.__toast && window.__toast('Timesheet refused and candidate notified.');
        await refreshAndRepaintOverview();
      } catch (err) {
        if (await handleMoved(err, 'qr-refuse')) return;
        if (LOGM) console.warn('[TS][OVERVIEW] qr-refuse failed', err);
        alert(err?.message || 'Failed to refuse QR hours.');
      }
    });
  }
}

// Revoke signed QR & request resubmission (Scenario 3) â†’ reissue via Save
if (qrReissueReqBtn) {
  qrReissueReqBtn.style.display = (!!tsId && !locked && !importAuthoritative) ? '' : 'none';
  if (!qrReissueReqBtn.__tsWired) {
    qrReissueReqBtn.__tsWired = true;
    qrReissueReqBtn.addEventListener('click', async () => {
      const ok = window.confirm(
        'Revoke the signed QR submission and request resubmission?\n\n' +
        'This will require a new signature and upload. You will be taken to Edit mode to confirm hours then Save.'
      );
      if (!ok) return;

      try {
        window.modalCtx = window.modalCtx || {};
        window.modalCtx.timesheetState = window.modalCtx.timesheetState || {};
        window.modalCtx.timesheetState.__forceQrActionEnum = 'REISSUE_QR';

        if (typeof window.__getModalFrame === 'function') {
          const fr = window.__getModalFrame();
          if (fr && fr.entity === 'timesheets') {
            fr.mode = 'edit';
            fr._suppressDirty = true;
            fr.setTab('overview');
            fr._suppressDirty = false;
            fr._updateButtons && fr._updateButtons();
          }
        }

        window.__toast && window.__toast('Edit mode enabled. Click Save to reissue a new QR.');
      } catch (err) {
        if (LOGM) console.warn('[TS][OVERVIEW] qr-reissue-request failed', err);
        alert(err?.message || 'Failed to enter reissue flow.');
      }
    });
  }
}

// Convert QR â†’ manual-only
if (qrConvertManualBtn) {
  qrConvertManualBtn.style.display = (!!tsId && !locked && !importAuthoritative) ? '' : 'none';
  if (!qrConvertManualBtn.__tsWired) {
    qrConvertManualBtn.__tsWired = true;
    qrConvertManualBtn.addEventListener('click', async () => {
      const ok = window.confirm(
        'Convert this QR timesheet to manual-only?\n\n' +
        'This disables candidate QR/electronic submission. Admin will manage evidence manually.'
      );
      if (!ok) return;

      try {
        const idNow = tsNow();
        if (!idNow) throw new Error('Timesheet id missing.');

        await apiPostJson(
          `/api/timesheets/${encodeURIComponent(idNow)}/convert-qr-to-manual`,
          { expected_timesheet_id: expectedNow() }
        );

        window.__toast && window.__toast('Converted to manual-only.');
        await refreshAndRepaintOverview();

      } catch (err) {
        if (await handleMoved(err, 'convert-qr-to-manual')) return;
        if (LOGM) console.warn('[TS][OVERVIEW] convert-qr-to-manual failed', err);
        alert(err?.message || 'Failed to convert to manual-only.');
      }
    });
  }
}

// Restore revoked QR (pending)
if (qrRestorePendBtn) {
  qrRestorePendBtn.style.display = (!!tsId && !locked && canRestorePending && !importAuthoritative) ? '' : 'none';
  if (!qrRestorePendBtn.__tsWired) {
    qrRestorePendBtn.__tsWired = true;
    qrRestorePendBtn.addEventListener('click', async () => {
      const ok = window.confirm('Restore the most recently revoked pending QR version?');
      if (!ok) return;
      try {
        await restoreRevokedQr(tsId, 'PENDING');
        window.__toast && window.__toast('Pending QR restored.');
        await refreshAndRepaintOverview();
      } catch (err) {
        if (await handleMoved(err, 'qr-restore-pending')) return;
        if (LOGM) console.warn('[TS][OVERVIEW] restore pending failed', err);
        alert(err?.message || 'Failed to restore pending QR.');
      }
    });
  }
}

// Restore revoked QR (signed)
if (qrRestoreSignedBtn) {
  qrRestoreSignedBtn.style.display = (!!tsId && !locked && canRestoreSigned && !importAuthoritative) ? '' : 'none';
  if (!qrRestoreSignedBtn.__tsWired) {
    qrRestoreSignedBtn.__tsWired = true;
    qrRestoreSignedBtn.addEventListener('click', async () => {
      const ok = window.confirm(
        'Restore the most recently revoked signed QR version?\n\n' +
        'This will restore the signed evidence as current.'
      );
      if (!ok) return;
      try {
        await restoreRevokedQr(tsId, 'SIGNED');
        window.__toast && window.__toast('Signed QR restored.');
        await refreshAndRepaintOverview();
      } catch (err) {
        if (await handleMoved(err, 'qr-restore-signed')) return;
        if (LOGM) console.warn('[TS][OVERVIEW] restore signed failed', err);
        alert(err?.message || 'Failed to restore signed QR.');
      }
    });
  }
}

// Allow QR again
if (allowQrAgainBtn) {
  allowQrAgainBtn.style.display = (!!tsId && !locked && canAllowQrAgain && !importAuthoritative) ? '' : 'none';
  if (!allowQrAgainBtn.__tsWired) {
    allowQrAgainBtn.__tsWired = true;
    allowQrAgainBtn.addEventListener('click', async () => {
      try {
        const r = await allowQrAgain(tsId);
        if (r && r.cancelled) return;
        window.__toast && window.__toast('QR enabled again.');
        await refreshAndRepaintOverview();
      } catch (err) {
        if (await handleMoved(err, 'allow-qr-again')) return;
        if (LOGM) console.warn('[TS][OVERVIEW] allow-qr-again failed', err);
        alert(err?.message || 'Failed to allow QR again.');
      }
    });
  }
}

// Allow electronic again
if (allowElecAgainBtn) {
  allowElecAgainBtn.style.display = (!!tsId && !locked && canAllowElecAgain && !importAuthoritative) ? '' : 'none';
  if (!allowElecAgainBtn.__tsWired) {
    allowElecAgainBtn.__tsWired = true;
    allowElecAgainBtn.addEventListener('click', async () => {
      try {
        const r = await allowElectronicAgain(tsId);
        if (r && r.cancelled) return;
        window.__toast && window.__toast('Electronic enabled again.');
        await refreshAndRepaintOverview();
      } catch (err) {
        if (await handleMoved(err, 'allow-electronic-again')) return;
        if (LOGM) console.warn('[TS][OVERVIEW] allow-electronic-again failed', err);
        alert(err?.message || 'Failed to allow electronic again.');
      }
    });
  }
}

// â”€â”€ Daily QR send button (DAILY, ELECTRONIC, unlocked, VIEW mode) â”€â”€
try {
  const dailyQrBtn = root.querySelector('button[data-ts-action="send-daily-qr"]');

  const canSendDailyQr =
    !!tsId &&
    mode === 'view' &&
    isDaily &&
    subMode === 'ELECTRONIC' &&
    !locked &&
    !importAuthoritative;

  if (dailyQrBtn) {
    dailyQrBtn.style.display = canSendDailyQr ? '' : 'none';

    if (!dailyQrBtn.__tsWired) {
      dailyQrBtn.__tsWired = true;
      dailyQrBtn.addEventListener('click', async () => {
        if (!tsId) {
          alert('Timesheet id missing; cannot generate daily QR timesheet.');
          return;
        }

        const ok = window.confirm(
          'Generate a DAILY QR timesheet for this shift?\n\n' +
          'This will generate a QR-coded PDF and email it to the candidate. ' +
          'Any previous QR for this timesheet will be invalidated.'
        );
        if (!ok) return;

        const encId = encodeURIComponent(tsId);

        try {
          const idNow = tsNow();
          if (!idNow) throw new Error('Timesheet id missing; cannot generate daily QR timesheet.');

          await apiPostJson(
            `/api/timesheets/${encodeURIComponent(idNow)}/daily-qr-printable`,
            { expected_timesheet_id: expectedNow() }
          );

      window.__toast && window.__toast(
  'New daily QR timesheet sent with current hours.'
);

          await refreshAndRepaintOverview();

        } catch (err) {
          if (await handleMoved(err, 'send-daily-qr')) return;
          if (LOGM) console.warn('[TS][OVERVIEW] send-daily-qr failed', err);
          alert(err?.message || 'Failed to generate daily QR timesheet.');
        }
      });
    }
  }
} catch (e) {
  if (LOGM) LT('[TS][OVERVIEW] QR wiring failed (non-fatal)', e);
}


        // â”€â”€ Pay-hold + mark-paid staging in edit/create (unchanged) â”€â”€
        if (mode === 'edit' || mode === 'create') {
          if (!mc.timesheetState || typeof mc.timesheetState !== 'object') {
            mc.timesheetState = {
              reference: '',
              payHoldDesired: null,
              payHoldReason: '',
              markPaid: false,
              segmentOverrides: {},
              segmentInvoiceTargets: {},
              manualHours: {},
              additionalRates: (mc.timesheetState && mc.timesheetState.additionalRates) || {},
              schedule: (mc.timesheetState && mc.timesheetState.schedule) || null
            };
          }
          const state = mc.timesheetState;

          if (payHoldInput && !payHoldInput.__tsWired) {
            payHoldInput.__tsWired = true;
            const currentOnHold = !!(tsfin && tsfin.pay_on_hold);
            if (state.payHoldDesired == null) {
              payHoldInput.checked = currentOnHold;
              state.payHoldDesired = currentOnHold;
            } else {
              payHoldInput.checked = !!state.payHoldDesired;
            }

            payHoldInput.addEventListener('change', () => {
              state.payHoldDesired = !!payHoldInput.checked;
              if (payHoldReasonInput) {
                state.payHoldReason = String(payHoldReasonInput.value || '');
              }
              if (LOGM) {
                LT('pay hold staged', {
                  tsId,
                  payHoldDesired: state.payHoldDesired,
                  payHoldReason: state.payHoldReason
                });
              }
              try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
            });
          }

          if (payHoldReasonInput && !payHoldReasonInput.__tsWired) {
            payHoldReasonInput.__tsWired = true;
            payHoldReasonInput.addEventListener('input', () => {
              if (!mc.timesheetState || typeof mc.timesheetState !== 'object') return;
              mc.timesheetState.payHoldReason = String(payHoldReasonInput.value || '');
              if (LOGM) {
                LT('pay hold reason staged', { tsId, payHoldReason: mc.timesheetState.payHoldReason });
              }
              try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
            });
          }

          if (markPaidInput && !markPaidInput.__tsWired) {
            markPaidInput.__tsWired = true;
            if (alreadyPaid) {
              markPaidInput.checked = true;
              markPaidInput.disabled = true;
            } else {
              markPaidInput.checked = !!state.markPaid;
            }
            markPaidInput.addEventListener('change', () => {
              const alreadyPaidLocal = !!(mc.timesheetDetails && mc.timesheetDetails.tsfin && mc.timesheetDetails.tsfin.paid_at_utc);
              if (alreadyPaidLocal) {
                markPaidInput.checked = true;
                markPaidInput.disabled = true;
                return;
              }
              state.markPaid = !!markPaidInput.checked;
              if (LOGM) LT('mark paid staged', { tsId, markPaid: state.markPaid });
              try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
            });
          }
        } else {
          if (payHoldInput)       payHoldInput.disabled       = true;
          if (payHoldReasonInput) payHoldReasonInput.disabled = true;
          if (markPaidInput)      markPaidInput.disabled      = true;
        }

     
      }
    } catch (err) {
      if ((typeof window.__LOG_MODAL === 'boolean') ? window.__LOG_MODAL : false) {
        console.warn('[TS][OVERVIEW][WIRE] failed', err);
      }
    }
  }
}


 // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Timesheets: Lines tab wiring â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if (this.entity === 'timesheets' && k === 'lines') {
  const { LOGM, L: LT } = getTsLoggers('[TS][LINES][WIRE]');
  const root = byId('modalBody');
  if (!root) {
    if (LOGM) LT('no modalBody root, skip wiring');
  } else {
    try {
      const mc = window.modalCtx || {};
      mc.timesheetState = (mc.timesheetState && typeof mc.timesheetState === 'object') ? mc.timesheetState : {};

      // âœ… Ensure new weekly-lines model containers exist (do NOT seed weekly schedule here)
      mc.timesheetState.weeklyLinesByDate    = (mc.timesheetState.weeklyLinesByDate && typeof mc.timesheetState.weeklyLinesByDate === 'object')
        ? mc.timesheetState.weeklyLinesByDate
        : {};
      mc.timesheetState.extraShiftCount      = Number.isFinite(Number(mc.timesheetState.extraShiftCount)) ? Number(mc.timesheetState.extraShiftCount) : 0;
      mc.timesheetState.scheduleErrorsByDate = (mc.timesheetState.scheduleErrorsByDate && typeof mc.timesheetState.scheduleErrorsByDate === 'object')
        ? mc.timesheetState.scheduleErrorsByDate
        : {};
      mc.timesheetState.scheduleHasErrors    = !!mc.timesheetState.scheduleHasErrors;

      // âœ… SEGMENTS: exclude_from_pay wiring (still needed)
      const checkboxes = root.querySelectorAll('input[name="seg_exclude_from_pay"][data-segment-id]');
      checkboxes.forEach(cb => {
        if (cb.__tsWired) return;
        cb.__tsWired = true;
        cb.addEventListener('change', () => {
          const segId = cb.getAttribute('data-segment-id') || '';
          if (!segId) return;

          const originalSeg =
            (mc.timesheetDetails && Array.isArray(mc.timesheetDetails.segments))
              ? mc.timesheetDetails.segments.find(s => String(s.segment_id) === segId)
              : null;

          const origVal = originalSeg ? !!originalSeg.exclude_from_pay : false;
          const newVal  = !!cb.checked;

          mc.timesheetState.segmentOverrides = (mc.timesheetState.segmentOverrides && typeof mc.timesheetState.segmentOverrides === 'object')
            ? mc.timesheetState.segmentOverrides
            : {};

          if (newVal === origVal) {
            if (mc.timesheetState.segmentOverrides[segId]) delete mc.timesheetState.segmentOverrides[segId];
          } else {
            mc.timesheetState.segmentOverrides[segId] = { exclude_from_pay: newVal };
          }

          try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
        });
      });

           // âœ… SEGMENTS: invoice week input + pause checkbox wiring (still needed)
      // New UI:
      //   - input[name="seg_invoice_week"] (UK date picker)
      //   - input[name="seg_invoice_pause"] (Delay indefinitely â†’ 2099-01-05)
      // Enforces:
      //   - Monday-only
      //   - min Monday = current week start
      // Prevents staging if invoice_locked_invoice_id exists (snap back).
      const weekInputs = root.querySelectorAll('input[name="seg_invoice_week"][data-segment-id]');
      const pauseChecks = root.querySelectorAll('input[name="seg_invoice_pause"][data-segment-id]');

      // Baseline week start (natural week) for this timesheet
      const computeWeekStartFromWeekEnding = (weYmd) => {
        if (!weYmd) return null;
        const d = new Date(`${String(weYmd).slice(0,10)}T00:00:00Z`);
        if (Number.isNaN(d.getTime())) return null;
        d.setUTCDate(d.getUTCDate() - 6);
        const yyyy = d.getUTCFullYear();
        const mm   = String(d.getUTCMonth() + 1).padStart(2, '0');
        const dd   = String(d.getUTCDate()).padStart(2, '0');
        return `${yyyy}-${mm}-${dd}`;
      };

      // Current invoice week start (Monday of "today")
      const computeCurrentWeekStart = () => {
        const now = new Date();
        const base = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));
        const day = base.getUTCDay();      // 0=Sun..6=Sat
        const offset = (day + 6) % 7;      // since Monday
        base.setUTCDate(base.getUTCDate() - offset);
        const yyyy = base.getUTCFullYear();
        const mm   = String(base.getUTCMonth() + 1).padStart(2, '0');
        const dd   = String(base.getUTCDate()).padStart(2, '0');
        return `${yyyy}-${mm}-${dd}`;
      };

      const det = mc.timesheetDetails || {};
      const ts  = det.timesheet || {};
      const tsWeekEnding =
        ts.week_ending_date ||
        mc.data?.week_ending_date ||
        (det.contract_week && det.contract_week.week_ending_date) ||
        null;

      const naturalWeekStart = tsWeekEnding ? computeWeekStartFromWeekEnding(tsWeekEnding) : null;
      const currentWeekStart = computeCurrentWeekStart();
      const pauseWeekStart   = '2099-01-05';

      mc.timesheetState.segmentInvoiceTargets = (mc.timesheetState.segmentInvoiceTargets && typeof mc.timesheetState.segmentInvoiceTargets === 'object')
        ? mc.timesheetState.segmentInvoiceTargets
        : {};

      const isMondayIso = (iso) => {
        try {
          const d = new Date(`${String(iso).slice(0,10)}T00:00:00Z`);
          if (Number.isNaN(d.getTime())) return false;
          return d.getUTCDay() === 1; // Monday
        } catch {
          return false;
        }
      };

  const applyUiFromTarget = (segId, targetIso) => {
  const inEl = root.querySelector(`input[name="seg_invoice_week"][data-segment-id="${CSS.escape(String(segId))}"]`);
  const pEl  = root.querySelector(`input[name="seg_invoice_pause"][data-segment-id="${CSS.escape(String(segId))}"]`);
  if (!inEl || !pEl) return;

  // targetIso can be null to mean "clear"
  const t = (targetIso == null) ? '' : String(targetIso || '').trim();
  const paused = (t === pauseWeekStart);

  pEl.checked = paused;

  if (paused || !t) {
    inEl.value = '';
  } else {
    try {
      inEl.value = (typeof formatIsoToUk === 'function') ? formatIsoToUk(t) : inEl.value;
    } catch {}
  }

  // paused disables date input; otherwise ensure enabled (unless global readonly locks it)
  if (paused) {
    inEl.disabled = true;
  } else {
    try { inEl.disabled = false; } catch {}
  }
};

const stageTargetFromControls = (segId) => {
  const inEl = root.querySelector(`input[name="seg_invoice_week"][data-segment-id="${CSS.escape(String(segId))}"]`);
  const pEl  = root.querySelector(`input[name="seg_invoice_pause"][data-segment-id="${CSS.escape(String(segId))}"]`);
  if (!inEl || !pEl) return;

  const segObj =
    (mc.timesheetDetails && Array.isArray(mc.timesheetDetails.segments))
      ? mc.timesheetDetails.segments.find(s => s && String(s.segment_id || '') === String(segId))
      : null;

  const lockedInvoiceId = segObj ? String(segObj.invoice_locked_invoice_id || '').trim() : '';
  const storedTargetRaw = segObj ? String(segObj.invoice_target_week_start || '').trim() : '';

  // If locked, do not stage anything; snap back to stored and remove staged key if present
  if (lockedInvoiceId) {
    applyUiFromTarget(segId, storedTargetRaw || null);
    if (Object.prototype.hasOwnProperty.call(mc.timesheetState.segmentInvoiceTargets, segId)) {
      delete mc.timesheetState.segmentInvoiceTargets[segId];
    }
    try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
    return;
  }

  // Pause mapping: checkbox wins and maps to sentinel
  if (pEl.checked) {
    inEl.value = '';
    inEl.disabled = true;

    const v = pauseWeekStart;

    // If equals stored value, do not stage
    if (storedTargetRaw && v === storedTargetRaw) {
      if (Object.prototype.hasOwnProperty.call(mc.timesheetState.segmentInvoiceTargets, segId)) {
        delete mc.timesheetState.segmentInvoiceTargets[segId];
      }
      try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
      return;
    }

    mc.timesheetState.segmentInvoiceTargets[segId] = v;
    try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
    return;
  }

  // Not paused: enable date input
  inEl.disabled = false;

  const uk = String(inEl.value || '').trim();
  const iso = uk ? (typeof parseUkDateToIso === 'function' ? parseUkDateToIso(uk) : null) : null;

  // âœ… Empty date now means:
  // - if there IS a stored target (including a stored pause), we must stage an explicit CLEAR (null)
  // - otherwise, remove staging (no-op)
  if (!iso) {
    if (storedTargetRaw) {
      mc.timesheetState.segmentInvoiceTargets[segId] = null;   // explicit clear
      applyUiFromTarget(segId, null);
    } else {
      if (Object.prototype.hasOwnProperty.call(mc.timesheetState.segmentInvoiceTargets, segId)) {
        delete mc.timesheetState.segmentInvoiceTargets[segId];
      }
    }
    try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
    return;
  }

  // Enforce Monday-only
  if (!isMondayIso(iso)) {
    alert('Please select a Monday (week start).');

    // Restore UI from staged (including null) if present, otherwise stored
    const hasStaged = Object.prototype.hasOwnProperty.call(mc.timesheetState.segmentInvoiceTargets, segId);
    const stagedRaw = hasStaged ? mc.timesheetState.segmentInvoiceTargets[segId] : undefined;
    const stagedNorm = hasStaged ? (stagedRaw == null ? null : String(stagedRaw).trim()) : null;

    applyUiFromTarget(segId, hasStaged ? stagedNorm : (storedTargetRaw || null));
    return;
  }

  // Enforce min Monday = current week start
  if (currentWeekStart && iso < currentWeekStart) {
    alert(`You canâ€™t select a week before ${typeof formatIsoToUk === 'function' ? formatIsoToUk(currentWeekStart) : currentWeekStart}.`);

    const hasStaged = Object.prototype.hasOwnProperty.call(mc.timesheetState.segmentInvoiceTargets, segId);
    const stagedRaw = hasStaged ? mc.timesheetState.segmentInvoiceTargets[segId] : undefined;
    const stagedNorm = hasStaged ? (stagedRaw == null ? null : String(stagedRaw).trim()) : null;

    applyUiFromTarget(segId, hasStaged ? stagedNorm : (storedTargetRaw || null));
    return;
  }

  // Baseline selection means "not delayed" â†’ if there was a stored target, stage explicit clear
  if (naturalWeekStart && iso === naturalWeekStart) {
    if (storedTargetRaw) {
      mc.timesheetState.segmentInvoiceTargets[segId] = null; // explicit clear
      applyUiFromTarget(segId, null);
    } else {
      if (Object.prototype.hasOwnProperty.call(mc.timesheetState.segmentInvoiceTargets, segId)) {
        delete mc.timesheetState.segmentInvoiceTargets[segId];
      }
    }
    try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
    return;
  }

  // If equals stored value, do not stage
  if (storedTargetRaw && iso === storedTargetRaw) {
    if (Object.prototype.hasOwnProperty.call(mc.timesheetState.segmentInvoiceTargets, segId)) {
      delete mc.timesheetState.segmentInvoiceTargets[segId];
    }
    try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
    return;
  }

  // Stage explicitly
  mc.timesheetState.segmentInvoiceTargets[segId] = iso;
  try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
};


      // Wire date inputs (attach UK date picker + change handler)
      weekInputs.forEach(inEl => {
        if (!inEl || inEl.__tsWeekWired) return;
        inEl.__tsWeekWired = true;

        const segId = inEl.getAttribute('data-segment-id') || '';
        if (!segId) return;

        // Attach UK date picker with min bound (dynamic safe)
        try {
          if (typeof attachUkDatePicker === 'function') {
            attachUkDatePicker(inEl, { minDate: currentWeekStart });
          }
        } catch {}

        inEl.addEventListener('change', () => {
          stageTargetFromControls(segId);
        });
      });

      // Wire pause checkboxes
      pauseChecks.forEach(pEl => {
        if (!pEl || pEl.__tsPauseWired) return;
        pEl.__tsPauseWired = true;

        const segId = pEl.getAttribute('data-segment-id') || '';
        if (!segId) return;

        pEl.addEventListener('change', () => {
          stageTargetFromControls(segId);
        });
      });


         // âœ… KEEP: Additional Rates weekly extras inputs
      // âœ… EXTEND: support per-day units via data-extra-ymd="YYYY-MM-DD"
      // âœ… UX: Tab cycles leftâ†’right then next row inside the Additional Rates table
      const extraInputs = root.querySelectorAll('input[name^="extra_units_"]');

      const sumPerDay = (m) => {
        if (!m || typeof m !== 'object') return 0;
        let s = 0;
        for (const v of Object.values(m)) {
          const n = Number(v);
          if (Number.isFinite(n) && n > 0) s += n;
        }
        return s;
      };

      const getExtrasInputsInOrder = () => {
        const table = root.querySelector('#tsWeeklyExtras');
        if (!table) return Array.from(extraInputs);
        return Array.from(table.querySelectorAll('input[name^="extra_units_"]'));
      };

      const moveExtrasFocus = (currentEl, dir /* +1 or -1 */) => {
        const list = getExtrasInputsInOrder().filter(el => el && !el.disabled);
        const idx = list.indexOf(currentEl);
        if (idx < 0) return false;

        const nextIdx = idx + dir;

        // If we're at the ends, allow default Tab to leave the table
        if (nextIdx < 0 || nextIdx >= list.length) return false;

        try {
          list[nextIdx].focus();
          list[nextIdx].select && list[nextIdx].select();
        } catch {}
        return true;
      };

      extraInputs.forEach(input => {
        if (input.__tsExtraWired) return;
        input.__tsExtraWired = true;

        const name = String(input.name || '');

        // Prefer explicit code attribute; fallback parses "extra_units_CODE" or "extra_units_CODE_YYYY-MM-DD"
        const codeAttr = String(input.getAttribute('data-extra-code') || '').toUpperCase().trim();
        const tail = name.replace(/^extra_units_/i, '');
        const codeName = String((tail.split('_')[0] || '')).toUpperCase().trim();
        const code = codeAttr || codeName;
        if (!code) return;

        // Optional per-day marker
        const ymdAttr = String(input.getAttribute('data-extra-ymd') || '').slice(0, 10);
        const isPerDay = !!(ymdAttr && /^\d{4}-\d{2}-\d{2}$/.test(ymdAttr));

        mc.timesheetState.additionalRates = (mc.timesheetState.additionalRates && typeof mc.timesheetState.additionalRates === 'object')
          ? mc.timesheetState.additionalRates
          : {};

        // Keydown handler: Tab navigation inside extras table
        if (!input.__tsExtraNavWired) {
          input.__tsExtraNavWired = true;
          input.addEventListener('keydown', (ev) => {
            if (!ev || ev.key !== 'Tab') return;
            const moved = moveExtrasFocus(input, ev.shiftKey ? -1 : +1);
            if (moved) {
              ev.preventDefault();
              ev.stopPropagation();
            }
          });
        }

        input.addEventListener('input', () => {
          const raw = String(input.value || '').trim();
          const units = raw === '' ? 0 : Number(raw);
          const unitsNum = (Number.isFinite(units) && units >= 0) ? units : 0;

          const prev = mc.timesheetState.additionalRates[code] || { code };

          if (isPerDay) {
            const per = (prev.units_per_day && typeof prev.units_per_day === 'object') ? { ...prev.units_per_day } : {};

            if (unitsNum > 0) per[ymdAttr] = unitsNum;
            else delete per[ymdAttr];

            const weekSum = sumPerDay(per);

            mc.timesheetState.additionalRates[code] = {
              ...prev,
              code,
              units_per_day: per,
              units_week: weekSum
            };
          } else {
            mc.timesheetState.additionalRates[code] = {
              ...prev,
              code,
              units_week: unitsNum
            };
          }

          try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
        });
      });


   // âœ… IMPORTANT: do NOT wire weekly schedule grid fields here.
      // âœ… NEW: best-effort schedule rebuild for weekly manual so Finance preview isn't stale
      try {
        const det = mc.timesheetDetails || {};
        const ts  = det.timesheet || {};
        const sheetScope = String(det.sheet_scope || mc.data?.sheet_scope || ts.sheet_scope || '').toUpperCase();
        const subMode    = String(ts.submission_mode || mc.data?.submission_mode || '').toUpperCase();

     const hasLines =
  mc.timesheetState.weeklyLinesByDate &&
  typeof mc.timesheetState.weeklyLinesByDate === 'object' &&
  Object.keys(mc.timesheetState.weeklyLinesByDate).some(d => {
    const arr = mc.timesheetState.weeklyLinesByDate[d];
    return Array.isArray(arr) && arr.some(ln =>
      String(ln?.start || '').trim() ||
      String(ln?.end || '').trim() ||
      String(ln?.break_start || '').trim() ||
      String(ln?.break_end || '').trim() ||
      String(ln?.break_mins || '').trim() ||
      String(ln?.ref || '').trim()
    );
  });


        if (sheetScope === 'WEEKLY' && subMode === 'MANUAL' && hasLines && typeof buildWeeklyScheduleFromLinesAndValidate === 'function') {
          const wd = Array.isArray(mc.timesheetState.__weekDaysForSchedule) && mc.timesheetState.__weekDaysForSchedule.length
            ? mc.timesheetState.__weekDaysForSchedule
            : null;

          const out = buildWeeklyScheduleFromLinesAndValidate(
            mc.timesheetState.weeklyLinesByDate,
            wd || undefined,
            { allowOvernight: true, allowBreakMins: true }
          );

          mc.timesheetState.schedule = Array.isArray(out?.schedule) ? out.schedule : [];
          mc.timesheetState.scheduleErrorsByDate = (out?.errorsByDate && typeof out.errorsByDate === 'object') ? out.errorsByDate : {};
          mc.timesheetState.scheduleHasErrors = !!out?.hasErrors;
        }
      } catch {}
    } catch (err) {
      if ((typeof window.__LOG_MODAL === 'boolean') ? window.__LOG_MODAL : false) {
        console.warn('[TS][LINES][WIRE] failed', err);
      }
    }
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Timesheets: Expenses tab wiring (NEW) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if (this.entity === 'timesheets' && k === 'expenses') {
  const { LOGM, L: LT } = getTsLoggers('[TS][EXPENSES][WIRE]');
  const root = byId('modalBody');

  try {
    const mc = window.modalCtx || {};

    // âœ… If the tab is disabled, do not wire anything (keeps it inert even if called programmatically)
    const enabled = !!mc.expenses_tab_enabled;
    if (!enabled) {
      if (LOGM) LT('expenses tab disabled; skip wiring', { reason: mc.expenses_tab_reason || '' });
    } else if (root) {
      mc.timesheetState = (mc.timesheetState && typeof mc.timesheetState === 'object') ? mc.timesheetState : {};
      mc.timesheetState.expensesDraft = (mc.timesheetState.expensesDraft && typeof mc.timesheetState.expensesDraft === 'object')
        ? mc.timesheetState.expensesDraft
        : {
            mileage_units: 0,
            travel_pay: 0, travel_charge: 0,
            accommodation_pay: 0, accommodation_charge: 0,
            other_pay: 0, other_charge: 0
          };

      const num0 = (v) => {
        const n = Number(v);
        return Number.isFinite(n) ? n : 0;
      };
      const round2 = (n) => Math.round((Number(n) || 0) * 100) / 100;

      const recomputeAndPaint = () => {
        const det = mc.timesheetDetails || {};
        const tf  = det.tsfin || {};

        const d = mc.timesheetState.expensesDraft || {};

        const travelPay = round2(num0(d.travel_pay));
        const travelChg = round2(num0(d.travel_charge));
        const accomPay  = round2(num0(d.accommodation_pay));
        const accomChg  = round2(num0(d.accommodation_charge));
        const otherPay  = round2(num0(d.other_pay));
        const otherChg  = round2(num0(d.other_charge));

        const pr = (tf.mileage_pay_rate    != null) ? Number(tf.mileage_pay_rate) : NaN;
        const cr = (tf.mileage_charge_rate != null) ? Number(tf.mileage_charge_rate) : NaN;

        const ratesOk = Number.isFinite(pr) && Number.isFinite(cr) && pr > 0 && cr > 0;
        const mu = num0(d.mileage_units);

        const mileagePay = ratesOk ? round2(mu * pr) : 0;
        const mileageChg = ratesOk ? round2(mu * cr) : 0;

        const totPay = round2(mileagePay + travelPay + accomPay + otherPay);
        const totChg = round2(mileageChg + travelChg + accomChg + otherChg);

        const setText = (sel, txt) => {
          const el = root.querySelector(sel);
          if (el) el.textContent = String(txt);
        };

        setText('[data-exp-out="mileage_pay"]',   `Â£${mileagePay.toFixed(2)}`);
        setText('[data-exp-out="mileage_charge"]',`Â£${mileageChg.toFixed(2)}`);
        setText('[data-exp-out="total_pay"]',     `Â£${totPay.toFixed(2)}`);
        setText('[data-exp-out="total_charge"]',  `Â£${totChg.toFixed(2)}`);
      };

      const inputs = root.querySelectorAll('input[data-exp-field]');
      inputs.forEach(inp => {
        if (inp.__tsExpWired) return;
        inp.__tsExpWired = true;

        inp.addEventListener('input', () => {
          const field = String(inp.getAttribute('data-exp-field') || '').trim();
          if (!field) return;

          const raw = String(inp.value || '').trim();
          const val = (raw === '') ? 0 : Number(raw);
          const n = Number.isFinite(val) ? val : 0;

          mc.timesheetState.expensesDraft[field] = n;

          // Update computed display cells live (no re-render)
          recomputeAndPaint();

          try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
        });
      });

      // Paint computed fields on tab open
      recomputeAndPaint();

      if (LOGM) LT('expenses wired', { inputCount: inputs.length });
    }
  } catch (e) {
    if (LOGM) LT('expenses wiring failed (non-fatal)', e?.message || e);
  }
}

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Timesheets: Evidence tab (refresh + drop-anywhere + view/delete) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if (this.entity === 'timesheets' && k === 'evidence') {
  const { LOGM, L: LT } = getTsLoggers('[TS][EVIDENCE][WIRE]');
  let root = byId('modalBody');
  if (!root) {
    if (LOGM) LT('no modalBody root, skip wiring');
  } else {
    try {
      const mc  = window.modalCtx || {};
      const tsId = mc.data?.timesheet_id || mc.data?.id || null;

      // 1) Refresh evidence on tab open (source of truth)
      //    Re-render the tab after refresh so the table reflects the latest state.
      if (tsId && typeof refreshTimesheetEvidenceIntoModalState === 'function' && !this.__tsEvidenceRefreshInFlight) {
        this.__tsEvidenceRefreshInFlight = true;
        try {
          await refreshTimesheetEvidenceIntoModalState(tsId);

          // Re-render Evidence tab HTML with updated modalCtx.timesheetState.evidence
          byId('modalBody').innerHTML = this.renderTab('evidence', this.mergedRowForTab('evidence')) || '';
          root = byId('modalBody');
        } catch (e) {
          if (LOGM) console.warn('[TS][EVIDENCE] refresh failed (non-fatal)', e);
        } finally {
          this.__tsEvidenceRefreshInFlight = false;
        }
      }

      if (!root) return;

      const tabRoot =
        root.querySelector('[data-ts-drop-zone-root="evidence"]') ||
        root.querySelector('.ts-evidence-tab') ||
        root;

      // 2) Drop-anywhere wiring (within Evidence tab root)
      if (tabRoot && !tabRoot.__tsEvDropWired) {
        tabRoot.__tsEvDropWired = true;

        const prevent = (ev) => { ev.preventDefault(); ev.stopPropagation(); };

        const isAllowedEvidenceFile = (file) => {
          if (!file) return false;
          const type = String(file.type || '').toLowerCase();
          const name = String(file.name || '').toLowerCase();

          const isPdf = (type === 'application/pdf') || name.endsWith('.pdf');
          const isImg = type.startsWith('image/') || /\.(jpe?g|png|gif|webp|heic|heif)$/i.test(name);
          return isPdf || isImg;
        };

        const onDragOver = (ev) => {
          prevent(ev);
          try { tabRoot.classList.add('ts-drop-hover'); } catch {}
        };

        const onDragLeave = (ev) => {
          prevent(ev);
          try { tabRoot.classList.remove('ts-drop-hover'); } catch {}
        };

        const onDrop = async (ev) => {
          prevent(ev);
          try { tabRoot.classList.remove('ts-drop-hover'); } catch {}

          const files = (ev.dataTransfer && ev.dataTransfer.files) ? Array.from(ev.dataTransfer.files) : [];
          const file  = files[0] || null;
          if (!file) return;

          if (!isAllowedEvidenceFile(file)) {
            alert('Please drop a PDF or an image file (JPEG/PNG/HEIC/etc).');
            return;
          }

          if (typeof openTimesheetEvidenceUploadDialog !== 'function') {
            alert('Upload viewer is not available yet (openTimesheetEvidenceUploadDialog missing).');
            return;
          }

          try {
            await openTimesheetEvidenceUploadDialog(file);
          } catch (err) {
            if (LOGM) console.warn('[TS][EVIDENCE][DROP] upload dialog failed', err);
            alert(err?.message || 'Failed to open upload viewer.');
          }
        };

        tabRoot.addEventListener('dragenter', onDragOver);
        tabRoot.addEventListener('dragover',  onDragOver);
        tabRoot.addEventListener('dragleave', onDragLeave);
        tabRoot.addEventListener('drop',      onDrop);

        if (LOGM) LT('drop-anywhere wired on evidence tab root');
      }

     // 3) Wire View buttons
const viewBtns = root.querySelectorAll('button[data-evidence-view]');
if (LOGM) LT('wiring evidence view buttons', { count: viewBtns.length });

viewBtns.forEach(btn => {
  if (btn.__tsEvViewWired) return;
  btn.__tsEvViewWired = true;

  btn.addEventListener('click', async (ev) => {
    ev.preventDefault();

    const id = btn.getAttribute('data-evidence-view') || '';
    if (!id) return;

    // Find evidence item from modal state
    const list = Array.isArray(window.modalCtx?.timesheetState?.evidence)
      ? window.modalCtx.timesheetState.evidence
      : [];

    let item = list.find(x => x && String(x.id) === String(id)) || null;

    // If not found, attempt a refresh once (best-effort)
    const idNowForRefresh =
      window.modalCtx?.data?.timesheet_id ||
      window.modalCtx?.data?.id ||
      tsId ||
      null;

    if (!item && idNowForRefresh && typeof refreshTimesheetEvidenceIntoModalState === 'function') {
      try {
        await refreshTimesheetEvidenceIntoModalState(idNowForRefresh);
        const list2 = Array.isArray(window.modalCtx?.timesheetState?.evidence)
          ? window.modalCtx.timesheetState.evidence
          : [];
        item = list2.find(x => x && String(x.id) === String(id)) || null;
      } catch {}
    }

    if (!item) {
      alert('Evidence item not found.');
      return;
    }

  // âœ… NEW: branch by preview_mode
const pm = String(item.preview_mode || item.preview_kind || '').trim().toUpperCase();

try {
  if (pm === 'IMPORT_TABLE') {
    // âœ… Route IMPORT_TABLE to the unified viewer (it now handles NHSP pretty + generic fallback)
    if (typeof openTimesheetEvidenceViewerExisting !== 'function') {
      alert('Evidence viewer missing (openTimesheetEvidenceViewerExisting).');
      return;
    }
    await openTimesheetEvidenceViewerExisting(item);
    return;
  }

  if (pm === 'SIGNATURES') {
    if (typeof openTimesheetEvidenceViewerSignatures !== 'function') {
      alert('Signatures viewer missing (openTimesheetEvidenceViewerSignatures).');
      return;
    }
    await openTimesheetEvidenceViewerSignatures(item);
    return;
  }

  // Default: PDF/manual/system evidence
  if (typeof openTimesheetEvidenceViewerExisting !== 'function') {
    alert('Evidence viewer missing (openTimesheetEvidenceViewerExisting).');
    return;
  }
  await openTimesheetEvidenceViewerExisting(item);
} catch (err) {
  if (LOGM) console.warn('[TS][EVIDENCE] view failed', err);
  alert(err?.message || 'Failed to open evidence viewer.');
}

  });
});


      // 4) Wire Delete buttons (user evidence only; system rows should not render delete)
      const removeBtns = root.querySelectorAll('button[data-evidence-remove]');
      if (LOGM) LT('wiring evidence delete buttons', { count: removeBtns.length });

    removeBtns.forEach(btn => {
  if (btn.__tsEvRemoveWired) return;
  btn.__tsEvRemoveWired = true;

  btn.addEventListener('click', async (ev) => {
    ev.preventDefault();

    const tryHandleMoved = async (err) => {
      const st = err?.status ?? null;
      const j  = err?.json || null;

      if (!(st === 409 && j && j.error === 'TIMESHEET_MOVED' && j.current_timesheet_id)) {
        return false;
      }

      const newId = String(j.current_timesheet_id);

      try {
        window.modalCtx ||= {};
        window.modalCtx.data ||= {};
        window.modalCtx.timesheetMeta ||= {};

        window.modalCtx.data.timesheet_id = newId;
        window.modalCtx.data.id = newId;
        window.modalCtx.timesheetMeta.expected_timesheet_id = newId;
      } catch {}

      // refresh details/evidence so UI is coherent
      try { window.modalCtx.timesheetDetails = await fetchTimesheetDetails(newId); } catch {}
      try { await refreshTimesheetEvidenceIntoModalState(newId); } catch {}
      try { refreshTimesheetsSummaryAfterRotation?.(newId); } catch {}

      try { window.__toast && window.__toast('This timesheet changed while you were editing; try again.'); } catch {}
      return true;
    };

    try {
      await handleTimesheetEvidenceRemoveClick(ev);
    } catch (err) {
      // âœ… adopt + retry once if moved
      const moved = await tryHandleMoved(err);
      if (moved) {
        try {
          await handleTimesheetEvidenceRemoveClick(ev);
          return;
        } catch (err2) {
          if (LOGM) console.warn('[TS][EVIDENCE] delete failed after moved retry', err2);
          alert(err2?.message || 'Failed to delete evidence item.');
          return;
        }
      }

      if (LOGM) console.warn('[TS][EVIDENCE] delete failed', err);
      alert(err?.message || 'Failed to delete evidence item.');
    }
  });
});


    } catch (err) {
      if ((typeof window.__LOG_MODAL === 'boolean') ? window.__LOG_MODAL : false) {
        console.warn('[TS][EVIDENCE][WIRE] failed', err);
      }
    }
  }
}

    // Finalise setTab
  this.currentTabKey = k;
  this._attachDirtyTracker();

  const isChild = (stack().length > 1);

  // Utility modals (resolve/import summaries) should keep inner buttons active
   const isUtilityKindForThis =
    this.kind === 'timesheets-resolve' ||
    this.kind === 'resolve-candidate'  ||
    this.kind === 'resolve-client'     ||
    this.kind === 'invoice-reference-numbers' ||
    this.kind === 'invoice-send-email-confirm' ||
    (typeof this.kind === 'string' && this.kind.startsWith('import-summary-')) ||
    (typeof this.kind === 'string' && this.kind.startsWith('invoice-batch-')) ||
    (typeof this.kind === 'string' && this.kind.startsWith('import-summary-invoice-batch-'));

if (this.noParentGate) {
  const ro = isUtilityKindForThis
    ? false
    : (this.mode === 'view' || this.mode === 'saving');
  setFormReadOnly(byId('modalBody'), ro);
} else if (isChild) {
  const p = parentFrame();
  setFormReadOnly(byId('modalBody'), !(p && (p.mode === 'edit' || p.mode === 'create')));
} else {
  setFormReadOnly(byId('modalBody'), (this.mode === 'view' || this.mode === 'saving'));
}


// âœ… TIMESHEETS â†’ LINES: import-authoritative + PROCESSED â†’ allow deferrals, lock hours/schedule/extras
if (this.entity === 'timesheets' && k === 'lines') {
  try {
    const d    = (window.modalCtx && window.modalCtx.data) ? window.modalCtx.data : {};
    const meta = (window.modalCtx && window.modalCtx.timesheetMeta) ? window.modalCtx.timesheetMeta : {};

    const boolish = (v) => {
      if (v === true) return true;
      if (v === false) return false;
      if (v == null) return false;
      const s = String(v).trim().toLowerCase();
      return (s === 'true' || s === '1' || s === 'yes' || s === 'y' || s === 'on');
    };

    const isImportAuthoritativeFromSummary = (routeType, noTimesheetRequired) => {
      const rt = String(routeType || '').toUpperCase();
      const noTs = boolish(noTimesheetRequired);
      return (
        rt === 'WEEKLY_NHSP' ||
        rt === 'WEEKLY_NHSP_ADJUSTMENT' ||
        (rt === 'WEEKLY_HEALTHROSTER' && noTs === true)
      );
    };

    const importAuth = isImportAuthoritativeFromSummary(d.route_type, d.client_no_timesheet_required);

    // "Processed" = has a real timesheet id (NOT a planned week stub)
    const hasRealTs = !!(d.timesheet_id || meta.hasTs);

  // Only apply locks in EDIT/CREATE
const isEditing = (this.mode === 'edit' || this.mode === 'create');

if (isEditing && importAuth && hasRealTs) {
  const root2 = byId('modalBody');
  if (root2) {

       // Allowlist: deferral controls remain editable
     const isDeferralControl = (el) => {
      const nm = String(el?.name || '');
      if (nm !== 'seg_exclude_from_pay' && nm !== 'seg_invoice_week' && nm !== 'seg_invoice_pause') return false;
      if (!el.hasAttribute('data-segment-id')) return false;

      const segId = String(el.getAttribute('data-segment-id') || '').trim();
      if (!segId) return false;

      try {
        const segObj =
          (window.modalCtx && window.modalCtx.timesheetDetails && Array.isArray(window.modalCtx.timesheetDetails.segments))
            ? window.modalCtx.timesheetDetails.segments.find(s => s && String(s.segment_id || '') === segId)
            : null;

        const lockedInvoiceId = segObj ? String(segObj.invoice_locked_invoice_id || '').trim() : '';
        if (lockedInvoiceId) return false;
      } catch {}

      // If the segment is paused (delay indefinitely), keep the DATE input disabled.
      // The pause checkbox itself remains editable.
      try {
        if (nm === 'seg_invoice_week') {
          const pauseEl = root2.querySelector(`input[name="seg_invoice_pause"][data-segment-id="${CSS.escape(segId)}"]`);
          if (pauseEl && pauseEl.checked) return false;
        }
      } catch {}

      return true;
    };


    // Lock ALL inputs/selects/textareas in Lines tab except deferral controls
    root2.querySelectorAll('input, select, textarea').forEach(el => {
      if (isDeferralControl(el)) {
        el.disabled = false;
        try { el.removeAttribute('readonly'); } catch {}
        return;
      }
      el.disabled = true;
      try { el.setAttribute('readonly', 'true'); } catch {}
    });


    // Lock schedule edit buttons
    const scheduleEditActions = new Set([
      'reset-schedule',
      'extra-shift-add',
      'extra-shift-remove',
      'extra-break-add',
      'extra-break-remove'
    ]);
    root2.querySelectorAll('button[data-ts-action]').forEach(btn => {
      const act = String(btn.getAttribute('data-ts-action') || '').toLowerCase();
      if (scheduleEditActions.has(act)) btn.disabled = true;
    });

    // Lock weekly extras inputs
    root2.querySelectorAll('input[name^="extra_units_"]').forEach(inp => {
      inp.disabled = true;
      try { inp.setAttribute('readonly', 'true'); } catch {}
    });

  }
}
} catch {}
}

try {
  const pc = document.getElementById('btnPickCandidate');
  const pl = document.getElementById('btnPickClient');
  L('setTab EXIT snapshot', {
    currentTabKey: this.currentTabKey,
    pickButtons: {
      btnPickCandidate: { exists: !!pc, disabled: !!(pc && pc.disabled) },
      btnPickClient:    { exists: !!pl, disabled: !!(pl && pl.disabled) }
    }
  });
} catch {}

try {
  if (this.entity === 'contracts' && k === 'main') {
    window.dispatchEvent(new Event('contracts-main-rendered'));
  }
} catch {}

this._hasMountedOnce = true;
this._suppressDirty  = false;
this.isDirty         = prevDirty;

if (typeof this._updateButtons === 'function') this._updateButtons();

GE();
}



};
function setFrameMode(frameObj, mode) {
  L('setFrameMode ENTER', {
    prevMode: frameObj.mode,
    nextMode: mode,
    isChild: (stack().length > 1),
    noParentGate: frameObj.noParentGate
  });

  const prev    = frameObj.mode;
  frameObj.mode = mode;

  const isChild = (stack().length > 1);
  const isTop   = (currentFrame && currentFrame() === frameObj);

  // â–¶ Special case: planned timesheet week (no timesheet_id yet, but has a contract_week)
  // We want to allow "view without id" here, so do NOT auto-convert to create/edit.
  let isPlannedTimesheetStub = false;
  try {
    if (frameObj.entity === 'timesheets' && !frameObj.hasId) {
      // Prefer the frame's own ctxRef, then fall back to global modalCtx
      const ctx = frameObj._ctxRef || window.modalCtx || {};
      const d   = ctx.data || {};
      const hasWeek = !!(d.contract_week_id || d.week_id || d.week_ending_date);
      const hasTsId = !!d.timesheet_id;
      if (hasWeek && !hasTsId) {
        isPlannedTimesheetStub = true;
      }
    }
  } catch (e) {
    // Non-fatal; treat as normal frame if detection fails
    isPlannedTimesheetStub = false;
  }

  // â–¶ correct accidental 'view' on brand-new frames (e.g., successor create)
  //    but DO NOT do this for planned timesheet weeks or utility modals where we *want* view+no id.
  const isUtilityKind =
    frameObj.kind === 'timesheets-resolve' ||
    frameObj.kind === 'resolve-candidate'  ||
    frameObj.kind === 'resolve-client'     ||
    (typeof frameObj.kind === 'string' && frameObj.kind.startsWith('import-summary-')) ||
    (typeof frameObj.kind === 'string' && frameObj.kind.startsWith('invoice-batch-')) ||
    (typeof frameObj.kind === 'string' && frameObj.kind.startsWith('import-summary-invoice-batch-'));

  if (!frameObj.hasId && mode === 'view' && !isPlannedTimesheetStub && !isUtilityKind) {
    mode = frameObj.forceEdit ? 'edit' : 'create';
    frameObj.mode = mode;
  }

  // â–¶ Only toggle read-only on the DOM that actually belongs to the top frame.
  //    When updating a non-top frame (e.g., the parent while a picker is open),
  //    do not flip the global #modalBody to avoid UI flicker/regressions.
  if (isTop) {
    const isUtilityKindForFrame =
      frameObj.kind === 'timesheets-resolve' ||
      frameObj.kind === 'resolve-candidate'  ||
      frameObj.kind === 'resolve-client'     ||
      (typeof frameObj.kind === 'string' && frameObj.kind.startsWith('import-summary-')) ||
      (typeof frameObj.kind === 'string' && frameObj.kind.startsWith('invoice-batch-')) ||
      (typeof frameObj.kind === 'string' && frameObj.kind.startsWith('import-summary-invoice-batch-'));

    if (!isChild && (mode === 'create' || mode === 'edit')) {
      setFormReadOnly(byId('modalBody'), false);
    } else if (frameObj.noParentGate) {
      const ro = isUtilityKindForFrame
        ? false
        : (mode === 'view' || mode === 'saving');
      setFormReadOnly(byId('modalBody'), ro);
    } else if (isChild) {
      const p = parentFrame();
      setFormReadOnly(byId('modalBody'), !(p && (p.mode === 'edit' || p.mode === 'create')));
    } else {
      setFormReadOnly(byId('modalBody'), (mode === 'view' || mode === 'saving'));
    }
  } else {
    L('setFrameMode (non-top): skipped read-only toggle to avoid affecting current child');
  }

  if (typeof frameObj._updateButtons === 'function') frameObj._updateButtons();

  try {
    const idx = stack().indexOf(frameObj);
    window.dispatchEvent(new CustomEvent('modal-frame-mode-changed', {
      detail: { frameIndex: idx, mode }
    }));
  } catch {}

  const repaint = !!(frameObj._hasMountedOnce && frameObj.currentTabKey);
  L('setFrameMode', {
    prevMode: prev,
    nextMode: mode,
    _hasMountedOnce: frameObj._hasMountedOnce,
    willRepaint: repaint,
    isPlannedTimesheetStub
  });

  try {
    const pc = document.getElementById('btnPickCandidate');
    const pl = document.getElementById('btnPickClient');
    L('setFrameMode picker snapshot', {
      pickCandidate: { exists: !!pc, disabled: !!(pc && pc.disabled) },
      pickClient:    { exists: !!pl, disabled: !!(pl && pl.disabled) }
    });
  } catch {}

  updateCalendarInteractivity(mode === 'edit' || mode === 'create');

  if (repaint) {
    // âœ… Preserve calendar viewport across mode flips (Viewâ†”Edit) so we don't snap to top/year.
    let vp = null;
    try {
      const isContracts = (frameObj.entity === 'contracts' || frameObj.kind === 'contracts');
      const isCalTab = (frameObj.currentTabKey === 'calendar');
      const cid = window.modalCtx?.data?.id || null;

      if (isContracts && isCalTab && cid) {
        const cal = window.__calState?.[cid] || {};
        const sb  = document.getElementById('__calScroll');

        vp = {
          contract_id: cid,
          view: cal.view || 'year',
          win: (cal.win && cal.win.from && cal.win.to) ? { from: cal.win.from, to: cal.win.to } : null,
          scrollTop: sb ? sb.scrollTop : 0,
          scrollLeft: sb ? sb.scrollLeft : 0
        };

        // keep latest copy on modalCtx as well (handy for other restore points)
        if (window.modalCtx) window.modalCtx.__calViewport = { ...vp };
      }
    } catch {}

    Promise
      .resolve(frameObj.setTab(frameObj.currentTabKey))
      .then(() => {
        if (!vp) return;

        // Restore view/win if they were present
        try {
          const cid = vp.contract_id;
          const st = window.__calState?.[cid];
          if (st) {
            if (vp.view) st.view = vp.view;
            if (vp.win && vp.win.from && vp.win.to) st.win = { from: vp.win.from, to: vp.win.to };
          }
        } catch {}

        // Restore scroll AFTER layout settles
        const applyScroll = () => {
          const sb = document.getElementById('__calScroll');
          if (!sb) return;
          sb.scrollTop  = vp.scrollTop || 0;
          sb.scrollLeft = vp.scrollLeft || 0;
        };
        try { requestAnimationFrame(() => requestAnimationFrame(applyScroll)); } catch { applyScroll(); }
      })
      .catch(() => {});
  }
}

const parentOnOpen = currentFrame();
frame._parentModeOnOpen = parentOnOpen ? parentOnOpen.mode : null;

stack().push(frame);
byId('modalBack').style.display='flex';


function renderTop() {
  const LOG = (typeof window.__LOG_MODAL === 'boolean') ? window.__LOG_MODAL : true;
  const L  = (...a)=> { if (LOG) console.log('[MODAL]', ...a); };
  const GC = (label)=> { if (LOG) console.groupCollapsed('[MODAL]', label); };
  const GE = ()=> { if (LOG) console.groupEnd(); };

  GC('renderTop()');

  const hintEl = document.getElementById('modalHint');
  if (hintEl) {
    hintEl.textContent = '';
    hintEl.removeAttribute('data-tone');
    try { hintEl.classList.remove('ok','warn','err'); } catch {}
  }

   const isChild = (stack().length > 1);
  const top     = currentFrame();
  const parent  = parentFrame();

  // âœ… Force: these invoice child modals must never show the global footer Save button
try {
  const k = (top && typeof top.kind === 'string') ? String(top.kind) : '';
  if (
    k === 'invoice-batch-add-timesheets' ||
    k === 'invoice-batch-add-adjustment' ||
    k === 'invoice-reference-numbers'
  ) {
    top._showSave = false;
    top._showApply = true;
  }
} catch {}

  // restore the parent/owner context for whatever frame is now on top
  if (top && top._ctxRef) window.modalCtx = top._ctxRef;


  if (typeof top._detachGlobal === 'function') { try { top._detachGlobal(); } catch {} top._wired = false; }

  L('renderTop state (global)', { entity: top?.entity, kind: top?.kind, mode: top?.mode, hasId: top?.hasId, currentTabKey: top?.currentTabKey });
  byId('modalTitle').textContent = top.title;

const tabsEl = byId('modalTabs'); tabsEl.innerHTML='';

// âœ… Choose a safe active tab (never start on a disabled tab)
try {
  const list = Array.isArray(top.tabs) ? top.tabs : [];
  const findTab = (k) => list.find(x => String(x?.key || '') === String(k || '')) || null;

  let activeKey = top.currentTabKey || (list[0] ? list[0].key : null);
  const t0 = findTab(activeKey);

  if (t0 && t0.disabled) {
    const firstEnabled = list.find(x => !x?.disabled) || list[0] || null;
    activeKey = firstEnabled ? firstEnabled.key : activeKey;
  }

  top.currentTabKey = activeKey;
} catch {}

(top.tabs||[]).forEach((t,i)=>{
  const b = document.createElement('button');
  b.textContent = t.label || t.title || t.key;

  // âœ… Disabled tab support WITHOUT native disabled (keeps hover/title reliable)
  const isDisabled = !!(t && t.disabled);
  if (isDisabled) {
    b.classList.add('disabled');
    b.dataset.disabled = '1';
    const why = String(t.disabled_reason || window.modalCtx?.expenses_tab_reason || 'This tab is currently unavailable.');
    b.setAttribute('title', why);
  } else {
    b.classList.remove('disabled');
    b.dataset.disabled = '';
    b.removeAttribute('title');
  }

  if (t.key === top.currentTabKey) b.classList.add('active');

  b.onclick = () => {
    if (top.mode === 'saving') return;

    // âœ… Click-block disabled tabs (non-responsive on click)
    if (isDisabled) return;

    tabsEl.querySelectorAll('button').forEach(x => x.classList.remove('active'));
    b.classList.add('active');
    top.setTab(t.key);
  };

  tabsEl.appendChild(b);
});

L('renderTop tabs (global)', { count: (top.tabs||[]).length, active: top.currentTabKey });


  if (top.currentTabKey) top.setTab(top.currentTabKey);
  else if (top.tabs && top.tabs[0]) top.setTab(top.tabs[0].key);
  else byId('modalBody').innerHTML = top.renderTab('form',{})||'';

  const btnSave  = byId('btnSave');
  const btnClose = byId('btnCloseModal');
  const btnDel   = byId('btnDelete');
  const header   = byId('modalDrag');
  const modalNode= byId('modal');

   const LOGC = (typeof window.__LOG_CONTRACTS === 'boolean') ? window.__LOG_CONTRACTS : true;
   if (modalNode) {
    const parentIsContracts =
      !!(parent && ((parent.entity === 'contracts') || (parent.kind === 'contracts')));
    const isContracts =
      (top.entity === 'contracts') ||
      (top.kind === 'contracts')  ||
      parentIsContracts;

    // Import summary utility panels must not be styled as "contract" modals,
    // even if opened from Contracts.
    const isImportSummary =
      typeof top.kind === 'string' && top.kind.startsWith('import-summary-');

    modalNode.classList.toggle('contract-modal', !!(isContracts && !isImportSummary));
    if (LOGC && isContracts && !isImportSummary) {
      console.log('[CONTRACTS][MODAL] contract-modal class applied to #modal (inherited:', parentIsContracts, ')');
    }
   // Job Titles: apply narrower modal sizing
const isJobTitles = (top.kind === 'job-titles');
modalNode.classList.toggle('jobtitles-modal', !!isJobTitles);

// Evidence replace: temporarily use a larger modal footprint
const isEvidenceReplace = (top.kind === 'timesheet-evidence-replace');
modalNode.classList.toggle('evidence-modal', !!isEvidenceReplace);

// Candidate Advances: use a slightly wider modal footprint
const isAdvances = (top.kind === 'candidate-advances');
modalNode.classList.toggle('advances-modal', !!isAdvances);

// âœ… Resolve Timesheets: larger/taller footprint (kills the unnecessary scrollbar)
const isResolve = (top.kind === 'timesheets-resolve');
modalNode.classList.toggle('resolve-modal', !!isResolve);

// âœ… Invoice batch modals (Generate/Issue): larger + no outer modal scrollbar (CSS handles overflow)
const isInvBatch =
  (typeof top.kind === 'string' && top.kind.startsWith('invoice-batch-')) ||
  (typeof top.kind === 'string' && top.kind.startsWith('import-summary-invoice-batch-'));

modalNode.classList.toggle('invbatch-modal', !!isInvBatch);
modalNode.classList.toggle('invbatch-generate-modal', !!(typeof top.kind === 'string' && top.kind.includes('generate')));
modalNode.classList.toggle('invbatch-issue-modal',    !!(typeof top.kind === 'string' && top.kind.includes('issue')));

  }





  if (modalNode) {
    const anchor = (window.__modalAnchor || null);
    if (!anchor) {
      const R = modalNode.getBoundingClientRect();
      window.__modalAnchor = { left: R.left, top: R.top };
      modalNode.style.position = 'fixed';
      modalNode.style.left = R.left + 'px';
      modalNode.style.top  = R.top  + 'px';
      modalNode.style.right = 'auto';
      modalNode.style.bottom= 'auto';
      modalNode.style.transform = 'none';
      L('renderTop: anchored modal (global/new)', window.__modalAnchor);
    } else {
      modalNode.style.position = 'fixed';
      modalNode.style.left = window.__modalAnchor.left + 'px';
      modalNode.style.top  = window.__modalAnchor.top  + 'px';
      modalNode.style.right = 'auto';
      modalNode.style.bottom= 'auto';
      modalNode.style.transform = 'none';
      L('renderTop: anchored modal (global/reuse)', window.__modalAnchor);
    }
  }

  const showChildDelete = isChild && (top.kind==='client-rate' || top.kind==='candidate-override') && top.hasId;
  btnDel.style.display = showChildDelete ? '' : 'none'; btnDel.onclick = null;

let btnEdit = byId('btnEditModal');
if (!btnEdit) {
  btnEdit = document.createElement('button');
  btnEdit.id = 'btnEditModal';
  btnEdit.type = 'button';
  btnEdit.className = 'btn btn-outline btn-sm';
  btnEdit.textContent = 'Edit';
  const bar = btnSave?.parentElement || btnClose?.parentElement;
  if (bar) bar.insertBefore(btnEdit, btnSave);
  L('renderTop (global): created btnEdit');
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// NEW: Timesheet footer buttons (created once; shown/hidden in _updateButtons)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const bar = btnSave?.parentElement || btnClose?.parentElement;

const ensureFooterBtn = (id, text, className, beforeEl) => {
  let b = byId(id);
  if (!b) {
    b = document.createElement('button');
    b.id = id;
    b.type = 'button';
    b.className = className || 'btn btn-outline btn-sm';
    b.textContent = text;
    if (bar) bar.insertBefore(b, beforeEl || btnSave);
    L('renderTop: created footer button', { id });
  }
  return b;
};

const hintEl2 = document.getElementById('modalHint');
const setHint = (txt, tone) => {
  if (!hintEl2) return;
  hintEl2.textContent = String(txt || '');
  if (tone) hintEl2.setAttribute('data-tone', tone);
  else hintEl2.removeAttribute('data-tone');
  try { hintEl2.classList.remove('ok','warn','err'); } catch {}
  if (tone === 'warn') try { hintEl2.classList.add('warn'); } catch {}
  if (tone === 'err')  try { hintEl2.classList.add('err'); } catch {}
  if (tone === 'ok')   try { hintEl2.classList.add('ok'); } catch {}
};

// âœ… Legacy footer conversion buttons are removed.
// If any old DOM button exists from previous sessions, hide/disable it.
['btnTsConvertManual','btnTsRestoreElectronic','btnTsRequestNewElectronic'].forEach(id => {
  const b = byId(id);
  if (b) { b.style.display = 'none'; b.disabled = true; }
});


// âœ… NEW: VIEW-mode Authorise / Unauthorise (footer, next to Save/Edit)
const btnTsAuthorise = ensureFooterBtn(
  'btnTsAuthorise',
  'Authorise',
  'btn btn-outline btn-sm',
  btnSave
);

const btnTsUnauthorise = ensureFooterBtn(
  'btnTsUnauthorise',
  'Unauthorise',
  'btn btn-outline btn-sm',
  btnSave
);

// âœ… NEW: VIEW-mode planned weekly manual â†’ process into a real timesheet
const btnTsProcess = ensureFooterBtn(
  'btnTsProcessTimesheet',
  'Process Timesheet',
  'btn btn-outline btn-sm',
  btnSave
);

// âœ… NEW: footer-only Unprocess
const btnTsUnprocess = ensureFooterBtn(
  'btnTsUnprocessTimesheet',
  'Unprocess Timesheet',
  'btn btn-outline btn-sm',
  btnSave
);

const btnTsDelete = ensureFooterBtn(
  'btnTsDeleteTimesheet',
  'Delete timesheet',
  'btn btn-warn',
  btnSave
);

// Default hidden; _updateButtons decides
btnTsAuthorise.style.display   = 'none';
btnTsUnauthorise.style.display = 'none';
btnTsProcess.style.display     = 'none';
btnTsUnprocess.style.display   = 'none'; // âœ… NEW
btnTsDelete.style.display      = 'none';


// Hover hint: Process only
btnTsProcess.onmouseenter = () => setHint(
  'Process this planned MANUAL week into a real timesheet using the stored schedule/hours.',
  'warn'
);
btnTsProcess.onmouseleave = () => setHint('', null);


  (function dragWire() {
    if (!header || !modalNode) return;

    const onDown = (e) => {
      if ((e.button !== 0 && e.type === 'mousedown') || e.target.closest('button')) return;

      const R = modalNode.getBoundingClientRect();
      modalNode.style.position = 'fixed';
      modalNode.style.left     = R.left + 'px';
      modalNode.style.top      = R.top  + 'px';
      modalNode.style.right    = 'auto';
      modalNode.style.bottom   = 'auto';
      modalNode.style.transform= 'none';
      modalNode.classList.add('dragging');

      const ox = e.clientX - R.left;
      const oy = e.clientY - R.top;

      // Measure header relative to the modal so we can keep it mostly visible
      const headerRect    = header.getBoundingClientRect();
      const headerOffsetY = headerRect.top - R.top;   // distance from modal top to header top
      const headerHeight  = headerRect.height || 0;

      document.onmousemove = (ev) => {
        let l = ev.clientX - ox;
        let t = ev.clientY - oy;

        const vw = window.innerWidth;
        const vh = window.innerHeight;

        // Horizontal: allow up to ~80% off-screen, keep ~20% visible
        const minLeft = -R.width * 0.8;         // up to ~80% off the left
        const maxLeft = vw - R.width * 0.2;     // leave ~20% visible on the right

        // Vertical (critical bit):
        // Ensure the header top never goes above -20% of its height.
        // i.e. at least 80% of the header remains visible.
        // headerTopInViewport = t + headerOffsetY
        const minTop = -headerOffsetY - headerHeight * 0.2;

        // Bottom clamp: keep the whole modal roughly within the viewport height
        const maxTop = vh - R.height;

        if (l < minLeft) l = minLeft;
        if (l > maxLeft) l = maxLeft;
        if (t < minTop)  t = minTop;
        if (t > maxTop)  t = maxTop;

        modalNode.style.left = l + 'px';
        modalNode.style.top  = t + 'px';
      };

      document.onmouseup = () => {
        modalNode.classList.remove('dragging');
        const R2 = modalNode.getBoundingClientRect();
        window.__modalAnchor = { left: R2.left, top: R2.top };
        document.onmousemove = null;
        document.onmouseup   = null;
        L('dragWire (global): saved new anchor', window.__modalAnchor);
      };

      e.preventDefault();
    };

    const onDbl = (e) => {
      if (!e.target.closest('button')) sanitizeModalGeometry();
    };

    header.addEventListener('mousedown', onDown);
    header.addEventListener('dblclick',  onDbl);

    const prev = top._detachGlobal;
    top._detachGlobal = () => {
      try { header.removeEventListener('mousedown', onDown); } catch {}
      try { header.removeEventListener('dblclick',  onDbl); } catch {}
      document.onmousemove = null;
      document.onmouseup   = null;
      if (typeof prev === 'function') {
        try { prev(); } catch {}
      }
    };
  })();

 const wantApply =
  (isChild && !top.noParentGate) ||
  (
    top.kind === 'client-rate'       ||
    top.kind === 'candidate-override'||
    top.kind === 'rate-presets-picker' ||
    top.kind === 'candidate-picker'  ||
    top.kind === 'client-picker'     ||
    top.kind === 'qr-decision'       ||
    top.kind === 'contract_settings' // âœ… NEW: always an Apply-style staging child
  );



  const defaultPrimary =
    (top.kind === 'contract-clone-extend')      ? 'Create'
  : (top.kind === 'advanced-search')            ? 'Search'
  : (top.kind === 'selection-load')             ? 'Load'
  : (top.kind === 'timesheet-evidence-replace') ? 'Save evidence'
  : (wantApply ? 'Apply' : 'Save');



  btnSave.textContent = defaultPrimary; btnSave.setAttribute('aria-label', defaultPrimary);
  L('showModal defaultPrimary', { kind: top.kind, defaultPrimary });
const setCloseLabel = ()=> {
const isUtilityKind =
  top.kind === 'timesheets-resolve' ||
  top.kind === 'resolve-candidate'  ||
  top.kind === 'resolve-client'     ||
  top.kind === 'invoice-reference-numbers' ||
  top.kind === 'invoice-send-email-confirm' ||
  (typeof top.kind === 'string' && top.kind.startsWith('import-summary-')) ||
  (typeof top.kind === 'string' && top.kind.startsWith('invoice-batch-')) ||
  (typeof top.kind === 'string' && top.kind.startsWith('import-summary-invoice-batch-'));



 const label =
  (top.kind === 'advanced-search')
    ? 'Close'
  : (top.kind === 'timesheet-evidence-replace')
    ? 'Discard'
  : (top.kind === 'timesheet-evidence-viewer')
    ? (top.isDirty ? 'Discard' : 'Close')
  : isUtilityKind
    ? 'Close'
    : (top.isDirty ? 'Discard' : 'Close');


  btnClose.textContent = label;
  btnClose.setAttribute('aria-label', label);
  btnClose.setAttribute('title', label);
};


top._updateButtons = ()=> {
  try {
    const h = document.getElementById('modalHint');
    if (h) {
      h.textContent = '';
      h.removeAttribute('data-tone');
      h.classList.remove('ok','warn','err');
    }
  } catch {}

  const parentEditable = top.noParentGate ? true : (parent ? (parent.mode==='edit' || parent.mode==='create') : true);
  const relatedBtn = byId('btnRelated');

  if (top && top._showSave === false) {
    btnSave.style.display = 'none';
    btnSave.disabled = true;
    btnEdit.style.display = 'none';

    if (relatedBtn) {
      relatedBtn.style.display = 'none';
      relatedBtn.disabled = true;
    }

    btnClose.textContent = 'Close';
    btnClose.setAttribute('aria-label', 'Close');
    btnClose.setAttribute('title', 'Close');

    L('_updateButtons snapshot (forced no-save)', {
      kind: top.kind,
      isChild,
      mode: top.mode,
      btnSave: { display: btnSave.style.display, disabled: btnSave.disabled },
      btnEdit: { display: btnEdit.style.display }
    });
    return;
  }


  // NEW: hide Preset Manager's "New" button whenever a child is open or when the top frame isn't the manager
  try {
    const rpNew = byId('btnRpNew');
    if (rpNew) {
      const shouldShow = (!isChild && top.kind === 'rates-presets');
      rpNew.style.display = shouldShow ? '' : 'none';
    }
  } catch {}

  if (top.kind === 'advanced-search') {
    btnEdit.style.display='none';
    btnSave.style.display='';
    btnSave.disabled=!!top._saving;
    if (relatedBtn) {
      relatedBtn.style.display = 'none';
      relatedBtn.disabled = true;
    }

  } else if (top.kind === 'rates-presets') {
    btnEdit.style.display='none';
    btnSave.style.display='none';
    btnSave.disabled=true;
    if (relatedBtn) {
      relatedBtn.style.display = 'none';
      relatedBtn.disabled = true;
    }

    // Always show â€œCloseâ€ for the Preset Rates manager (never â€œDiscardâ€)
    btnClose.textContent = 'Close';
    btnClose.setAttribute('aria-label', 'Close');
    btnClose.setAttribute('title', 'Close');

    L('_updateButtons snapshot (global)', {
      kind: top.kind, isChild, parentEditable, mode: top.mode,
      btnSave: { display: btnSave.style.display, disabled: btnSave.disabled },
      btnEdit: { display: btnEdit.style.display }
    });
    return;

  } else if (top.kind === 'candidate-picker' || top.kind === 'client-picker') {
    // NEW: candidate/client pickers â€“ explicit Apply, gated by row selection
    btnEdit.style.display = 'none';
    btnSave.style.display = '';
    btnSave.disabled = !!top._saving || !top._pickerHasSelection;

    if (relatedBtn) {
      relatedBtn.style.display = 'none';
      relatedBtn.disabled = true;
    }

    L('_updateButtons snapshot (picker)', {
      kind: top.kind,
      isChild,
      hasSelection: !!top._pickerHasSelection,
      btnSave: { display: btnSave.style.display, disabled: btnSave.disabled }
    });
    return;

  } else if (top.kind === 'qr-decision') {
    // NEW: QR decision modal â€“ Apply gated by selected radio
    btnEdit.style.display = 'none';
    btnSave.style.display = '';
    btnSave.disabled      = !!top._saving || !top._qrChoice;

    if (relatedBtn) {
      relatedBtn.style.display = 'none';
      relatedBtn.disabled = true;
    }

    btnClose.textContent = 'Cancel';
    btnClose.setAttribute('aria-label', 'Cancel');
    btnClose.setAttribute('title', 'Cancel');
    return;

     } else if (
    top.kind === 'timesheets-resolve' ||
    top.kind === 'resolve-candidate'  ||
    top.kind === 'resolve-client'     ||
    top.kind === 'invoice-reference-numbers' ||
    (typeof top.kind === 'string' && top.kind.startsWith('import-summary-')) ||
    (typeof top.kind === 'string' && top.kind.startsWith('invoice-batch-')) ||
    (typeof top.kind === 'string' && top.kind.startsWith('import-summary-invoice-batch-'))
  ) {
    // NEW: utility modals (resolve/import/invoice-batch) â€” hide Save/Edit, Close-only

    // No Save/Edit on these; everything happens via inline buttons in the modal body
    btnSave.style.display = 'none';
    btnSave.disabled      = true;
    btnEdit.style.display = 'none';

    if (relatedBtn) {
      relatedBtn.style.display = 'none';
      relatedBtn.disabled = true;
    }

    // Always simple "Close" label (never "Discard")
    btnClose.textContent = 'Close';
    btnClose.setAttribute('aria-label', 'Close');
    btnClose.setAttribute('title', 'Close');

    L('_updateButtons snapshot (utility)', {
      kind: top.kind,
      isChild,
      mode: top.mode,
      btnSave: { display: btnSave.style.display, disabled: btnSave.disabled },
      btnEdit: { display: btnEdit.style.display }
    });
    return;


  } else if (isChild && !top.noParentGate) {

    if (top.mode === 'view') {
      btnSave.style.display = 'none';
      btnSave.disabled = true;
      btnEdit.style.display = 'none';
      if (relatedBtn) {
        relatedBtn.style.display = 'none';
        relatedBtn.disabled = true;
      }
    } else {
      btnSave.style.display = parentEditable ? '' : 'none';

      // Child apply gating:
      // - rate-presets-picker: gate by __canSave
      // - client-rate / candidate-override: gate by _applyDesired
      // - address-lookup (and other simple children): always allow Apply if parent is editable
      let wantApply;
      if (top.kind === 'rate-presets-picker') {
        wantApply = !!top.__canSave;
      } else if (top.kind === 'client-rate' || top.kind === 'candidate-override') {
        wantApply = (top._applyDesired === true);
      } else {
        wantApply = true;
      }

      btnSave.disabled = (!parentEditable) || top._saving || !wantApply;
      btnEdit.style.display='none';
      if (relatedBtn) {
        relatedBtn.style.display = 'none';
        relatedBtn.disabled = true;
      }
      if (LOG) console.log('[MODAL] child _updateButtons()', {
        parentEditable, wantApply, disabled: btnSave.disabled, kind: top.kind
      });
    }

  } else {

    // â”€â”€ Edit gating (Timesheets + generic entities) â”€â”€
    let canEdit = false;

    const mcTs = (window.modalCtx || {});
    const meta = (mcTs && mcTs.timesheetMeta) || {};
    const det  = (mcTs && mcTs.timesheetDetails) || {};
    const tsfin= det.tsfin || {};

    // Timesheet identity + status
    const tsId   = mcTs?.data?.timesheet_id || null;
    const weekId = mcTs?.data?.contract_week_id || null;

    const sheetScope = String(meta.sheetScope || '').toUpperCase();
    const subMode    = String(meta.subMode    || '').toUpperCase();
    const cwMode     = String(meta.cw_submission_mode_snapshot || '').toUpperCase();

    const isWeekly   = (sheetScope === 'WEEKLY');
    const isDaily    = (sheetScope === 'DAILY');

    const locked =
      !!meta.isPaid ||
      !!meta.isInvoiced ||
      !!tsfin.locked_by_invoice_id ||
      !!tsfin.paid_at_utc;

 if (top.entity === 'timesheets') {
  const hasTsMeta  = !!meta.hasTs;
  const isPlanned  = !!meta.isPlannedWeek;

  const isWeeklyManualTs =
    hasTsMeta && isWeekly && subMode === 'MANUAL' && !locked;

  const isPlannedManualWeek =
    !hasTsMeta && isPlanned && isWeekly && !!weekId && !locked && (cwMode === 'MANUAL');

  const isDailyManualTs =
    hasTsMeta && isDaily && subMode === 'MANUAL' && !locked;

  // âœ… NEW: import-authoritative (from SUMMARY row)
  const boolish = (v) => {
    if (v === true) return true;
    if (v === false) return false;
    if (v == null) return false;
    const s = String(v).trim().toLowerCase();
    return (s === 'true' || s === '1' || s === 'yes' || s === 'y' || s === 'on');
  };

  const isImportAuthoritativeFromSummary = (routeType, noTimesheetRequired) => {
    const rt = String(routeType || '').toUpperCase();
    const noTs = boolish(noTimesheetRequired);
    return (
      rt === 'WEEKLY_NHSP' ||
      rt === 'WEEKLY_NHSP_ADJUSTMENT' ||
      (rt === 'WEEKLY_HEALTHROSTER' && noTs === true)
    );
  };

  const dSum = (mcTs && mcTs.data) ? mcTs.data : {};
const importAuthoritative =
  isImportAuthoritativeFromSummary(dSum.route_type, dSum.client_no_timesheet_required);

// âœ… Allow Edit for import-authoritative *real timesheets* (for deferrals)
const isImportAuthEditable =
  hasTsMeta && !locked && importAuthoritative;

// âœ… NEW: import-authoritative planned stub â†’ cannot Edit
const isImportAuthPlannedStub =
  (!hasTsMeta && isPlanned && importAuthoritative);

canEdit =
  (top.mode === 'view') &&
  !isImportAuthPlannedStub &&
  (isWeeklyManualTs || isPlannedManualWeek || isDailyManualTs || isImportAuthEditable);

} else {
  canEdit = (top.mode === 'view' && top.hasId);
}


    // Footer placement: ONLY show Edit when allowed (no convert replacement)
    btnEdit.style.display = (canEdit ? '' : 'none');

    // âœ… Hard-hide any legacy footer conversion buttons (all converts live in Overview Actions now)
    ['btnTsConvertManual','btnTsRestoreElectronic','btnTsRequestNewElectronic'].forEach(id => {
      const b = byId(id);
      if (b) { b.style.display = 'none'; b.disabled = true; }
    });

    // Helper: kill old addEventListener closures by cloning once, then use onclick + ownerToken forever
    const staleSafeBtn = (btn) => {
      if (!btn) return null;
      if (btn.dataset && btn.dataset.staleSafe === '1') return btn;
      const clone = btn.cloneNode(true);
      btn.parentNode && btn.parentNode.replaceChild(clone, btn);
      clone.dataset.staleSafe = '1';
      return clone;
    };

       // â”€â”€ Footer buttons for timesheets: Authorise / Unauthorise / Process / Delete â”€â”€
   let btnTsAuthorise   = byId('btnTsAuthorise');
let btnTsUnauthorise = byId('btnTsUnauthorise');
let btnTsProcess     = byId('btnTsProcessTimesheet');
let btnTsUnprocess   = byId('btnTsUnprocessTimesheet'); // âœ… NEW
let btnTsDelete      = byId('btnTsDeleteTimesheet');

btnTsAuthorise   = staleSafeBtn(btnTsAuthorise);
btnTsUnauthorise = staleSafeBtn(btnTsUnauthorise);
btnTsProcess     = staleSafeBtn(btnTsProcess);
btnTsUnprocess   = staleSafeBtn(btnTsUnprocess);       // âœ… NEW
btnTsDelete      = staleSafeBtn(btnTsDelete);


if (!isChild && top.entity === 'timesheets') {
  const mcNow    = window.modalCtx || {};
  const metaNow  = (mcNow && mcNow.timesheetMeta) || {};
  const detNow   = (mcNow && mcNow.timesheetDetails) || {};
  const tsNowObj = detNow.timesheet || {};
  const tsfinNow = detNow.tsfin || {};
  const cwNow    = detNow.contract_week || {};
  const policyNow = detNow.policy || {};

  const tsIdNow   = mcNow.data?.timesheet_id || null;          // real TS id (if exists)
  const weekIdNow = mcNow.data?.contract_week_id || null;      // planned CW id (if any)

  const lockedNow = !!(
    metaNow.isPaid ||
    metaNow.isInvoiced ||
    tsfinNow.locked_by_invoice_id ||
    tsfinNow.paid_at_utc
  );

  const isAuthorisedNow = !!(
    tsNowObj.authorised_at_server ||
    mcNow.data?.authorised_at_server
  );

  // requiresAuth: prefer helper if available, else fallback
let requiresAuthNow = false;
try {
  if (typeof computeRequiresTimesheetAuthorisation === 'function') {
    const x = computeRequiresTimesheetAuthorisation(detNow, (mcNow.data || {}));
    requiresAuthNow = !!(x && x.requires); // âœ… apply helper output
  } else {
    const stageRawNow = String(tsfinNow.processing_status || mcNow.data?.processing_status || '').toUpperCase();

    const asBool = (v) => {
      if (v === true) return true;
      if (v === false) return false;
      if (v == null) return false;
      const s = String(v).trim().toLowerCase();
      return (s === 'true' || s === '1' || s === 'yes' || s === 'y' || s === 'on');
    };

    // Prefer summary-row fields (contract-resolved) when present; otherwise fallback to policy
    const d = mcNow.data || {};
    const requiresHrNow =
      (Object.prototype.hasOwnProperty.call(d, 'client_requires_hr'))
        ? asBool(d.client_requires_hr)
        : !!policyNow.requires_hr;

    const autoprocessHrNow =
      (Object.prototype.hasOwnProperty.call(d, 'client_autoprocess_hr'))
        ? asBool(d.client_autoprocess_hr)
        : !!policyNow.autoprocess_hr;

    requiresAuthNow =
      (stageRawNow === 'PENDING_AUTH') ||
      (requiresHrNow && !autoprocessHrNow && stageRawNow === 'READY_FOR_HR');
  }
} catch {
  requiresAuthNow = false;
}


  const canAuthoriseNow =
    (top.mode === 'view') &&
    !!tsIdNow &&
    !lockedNow &&
    requiresAuthNow &&
    !isAuthorisedNow;

  const canUnauthoriseNow =
    (top.mode === 'view') &&
    !!tsIdNow &&
    !lockedNow &&
    isAuthorisedNow;

  // Process Timesheet (planned weekly MANUAL week â†’ create real timesheet)
  const sheetScopeNow = String(metaNow.sheetScope || '').toUpperCase();
  const cwModeNow     = String(
    metaNow.cw_submission_mode_snapshot ||
    cwNow.submission_mode_snapshot ||
    ''
  ).toUpperCase();
  const isWeeklyNow   = (sheetScopeNow === 'WEEKLY');

const boolish = (v) => {
  if (v === true) return true;
  if (v === false) return false;
  if (v == null) return false;
  const s = String(v).trim().toLowerCase();
  return (s === 'true' || s === '1' || s === 'yes' || s === 'y' || s === 'on');
};

const isImportAuthoritativeFromSummary = (routeType, noTimesheetRequired) => {
  const rt = String(routeType || '').toUpperCase();
  const noTs = boolish(noTimesheetRequired);
  return (
    rt === 'WEEKLY_NHSP' ||
    rt === 'WEEKLY_NHSP_ADJUSTMENT' ||
    (rt === 'WEEKLY_HEALTHROSTER' && noTs === true)
  );
};

const dSum = (mcNow && mcNow.data) ? mcNow.data : {};
const importAuthoritativeNow =
  isImportAuthoritativeFromSummary(dSum.route_type, dSum.client_no_timesheet_required);

const canProcessNow =
  (top.mode === 'view') &&
  isWeeklyNow &&
  !lockedNow &&
  !importAuthoritativeNow &&   // âœ… NEW
  !tsIdNow &&
  !!weekIdNow &&
  (cwModeNow === 'MANUAL');


 // âœ… NEW: delete-preview policy (backend-authoritative; do NOT replace existing UI gating â€” only tighten delete)
  const dpNow =
    (mcNow && mcNow.timesheetDeletePreview && typeof mcNow.timesheetDeletePreview === 'object')
      ? mcNow.timesheetDeletePreview
      : null;

  const dpKindNow = String((dpNow && dpNow.kind) ? dpNow.kind : '').toUpperCase();
  const dpEligibleNow = (dpNow && typeof dpNow.eligible === 'boolean') ? dpNow.eligible : false;

  // Delete (real OR planned)
  const isPlannedOnlyNow = (!tsIdNow && !!weekIdNow);

  const canDeleteNowBase =
    ((top.mode === 'edit' || top.mode === 'view') && !lockedNow && (!!tsIdNow || !!weekIdNow));

  const canDeleteNow =
    canDeleteNowBase &&
    (
      isPlannedOnlyNow ||
      (dpEligibleNow === true && dpKindNow !== 'IMPORT_CHILD_ADJUSTMENT')
    );

  // âœ… Unprocess eligibility:
  // - real TS exists
  // - WEEKLY + MANUAL
  // - has contract week
  // - not locked
  // - NOT authorised (user must unauthorise first)
  const subModeNow = String(metaNow.subMode || '').toUpperCase();
  const isWeeklyNow2 = (String(metaNow.sheetScope || '').toUpperCase() === 'WEEKLY');
  const hasCwNow = !!(detNow.contract_week_id || cwNow.id || weekIdNow);

  const canUnprocessNow =
    (top.mode === 'view') &&
    !!tsIdNow &&
    isWeeklyNow2 &&
    (subModeNow === 'MANUAL') &&
    hasCwNow &&
    !lockedNow &&
    !isAuthorisedNow;

  const refreshFooter = async () => {
    const fn = ensureTsRefreshAndRepaintOverview();
    await fn();
  };

  if (btnTsUnprocess) {
    btnTsUnprocess.style.display = canUnprocessNow ? '' : 'none';
    btnTsUnprocess.disabled      = !!top._saving;

    btnTsUnprocess.dataset.ownerToken = top._token;
    btnTsUnprocess.onclick = async () => {
      const fr = (typeof currentFrame === 'function') ? currentFrame() : null;
      if (!fr || btnTsUnprocess.dataset.ownerToken !== fr._token) return;

      const mc = window.modalCtx || {};
      const det = mc.timesheetDetails || {};

      const tsIdX = mc.data?.timesheet_id || null;
      const cwIdX = det.contract_week_id || mc.data?.contract_week_id || null;

      if (!tsIdX) { alert('Timesheet id missing.'); return; }
      if (!cwIdX) { alert('Contract week id missing.'); return; }

      const ok = window.confirm(
        'Unprocess Timesheet?\n\n' +
        'This will delete the processed MANUAL timesheet and revert back to the planned week.'
      );
      if (!ok) return;

   try {
  // This is your existing â€œdelete-manual-reopenâ€ operation.
  await deleteManualTimesheetAndReopenWeek(tsIdX, cwIdX);

  // âœ… flip modal context into planned-week shape BEFORE refresh
  try {
    mc.data = mc.data || {};
    mc.data.timesheet_id = null;
    mc.data.contract_week_id = cwIdX; // planned-week identity
    mc.data.id = cwIdX;

    // âœ… FIX: clear row-level TSFIN-derived fields so badges do NOT read stale row.* values
    mc.data.processing_status     = null;
    mc.data.ready_to_pay          = null;
    mc.data.paid_at_utc           = null;
    mc.data.locked_by_invoice_id  = null;
    mc.data.locked_by_invoice_number = null;
    mc.data.total_hours           = null;
    mc.data.total_pay_ex_vat      = null;
    mc.data.total_charge_ex_vat   = null;
    mc.data.margin_ex_vat         = null;
    mc.data.pay_on_hold           = null;
    mc.data.authorised_at_server  = null;

    // âœ… Prevent planned week being treated as QR via row flags
    mc.data.is_qr     = false;
    mc.data.qr_status = null;
  } catch {}
  try { fr.hasId = false; } catch {}

  // âœ… FIX (Issue #1): clear stale TS/TSFIN so Overview badges repaint immediately
  // âœ… ALSO: clear evidence list so planned-week gating never sees old TS evidence
  try {
    mc.timesheetDetails = mc.timesheetDetails || {};
    mc.timesheetDetails.timesheet = null;
    mc.timesheetDetails.tsfin = null;

    // clear fields that make the UI think itâ€™s still â€œprocessed/QRâ€
    mc.timesheetDetails.qr_status = null;
    mc.timesheetDetails.qr_generated_at = null;
    mc.timesheetDetails.qr_scanned_at = null;
    mc.timesheetDetails.qr_r2_key = null;
    mc.timesheetDetails.manual_pdf_r2_key = null;

    // keep the week pointer consistent
    mc.timesheetDetails.contract_week_id = cwIdX;

    // clear evidence cache (prevents old SYS:NHSP:* / NHSP kind leaking into planned-week gating)
    mc.timesheetState = (mc.timesheetState && typeof mc.timesheetState === 'object') ? mc.timesheetState : {};
    mc.timesheetState.evidence = [];

    // optional: clear related caches (prevents old invoice badge/data)
    mc.timesheetRelated = mc.timesheetRelated || {};
    mc.timesheetRelated.invoice = null;
  } catch {}

  window.__toast && window.__toast('Timesheet unprocessed.');
  await refreshFooter();
} catch (e) {

        try {
          if (typeof tsHandleMoved409Modal === 'function') {
            const handled = await tsHandleMoved409Modal(e, {
              tabKey: 'overview',
              label: 'footer-unprocess-timesheet',
              toast: 'This timesheet changed while you were editing; review and try again.'
            });
            if (handled) return;
          }
        } catch {}
        alert(e?.message || 'Failed to unprocess timesheet.');
      }
    };
  }


      // â”€â”€ Authorise â”€â”€
      if (btnTsAuthorise) {
        btnTsAuthorise.style.display = canAuthoriseNow ? '' : 'none';
        btnTsAuthorise.disabled      = !!top._saving;

        btnTsAuthorise.dataset.ownerToken = top._token;
        btnTsAuthorise.onclick = async () => {
          const fr = (typeof currentFrame === 'function') ? currentFrame() : null;
          if (!fr || btnTsAuthorise.dataset.ownerToken !== fr._token) return;

          const id = (window.modalCtx?.data?.timesheet_id || null);
          if (!id) { alert('Timesheet id missing.'); return; }

          try {
            await authoriseTimesheet(id);
            window.__toast && window.__toast('Timesheet authorised');
            await refreshFooter();
          } catch (e) {
            try {
              if (typeof tsHandleMoved409Modal === 'function') {
                const handled = await tsHandleMoved409Modal(e, {
                  tabKey: 'overview',
                  label: 'footer-authorise',
                  toast: 'This timesheet changed while you were editing; review and try again.'
                });
                if (handled) return;
              }
            } catch {}
            alert(e?.message || 'Failed to authorise timesheet.');
          }
        };
      }

      // â”€â”€ Unauthorise â”€â”€
      if (btnTsUnauthorise) {
        btnTsUnauthorise.style.display = canUnauthoriseNow ? '' : 'none';
        btnTsUnauthorise.disabled      = !!top._saving;

        btnTsUnauthorise.dataset.ownerToken = top._token;
        btnTsUnauthorise.onclick = async () => {
          const fr = (typeof currentFrame === 'function') ? currentFrame() : null;
          if (!fr || btnTsUnauthorise.dataset.ownerToken !== fr._token) return;

          const id = (window.modalCtx?.data?.timesheet_id || null);
          if (!id) { alert('Timesheet id missing.'); return; }

          const ok = window.confirm('Unauthorise this timesheet? It will return to a pending state.');
          if (!ok) return;

          try {
            await unauthoriseTimesheet(id);
            window.__toast && window.__toast('Timesheet unauthorised');
            await refreshFooter();
          } catch (e) {
            try {
              if (typeof tsHandleMoved409Modal === 'function') {
                const handled = await tsHandleMoved409Modal(e, {
                  tabKey: 'overview',
                  label: 'footer-unauthorise',
                  toast: 'This timesheet changed while you were editing; review and try again.'
                });
                if (handled) return;
              }
            } catch {}
            alert(e?.message || 'Failed to unauthorise timesheet.');
          }
        };
      }

   // â”€â”€ Process Timesheet â”€â”€
if (btnTsProcess) {
  btnTsProcess.style.display = canProcessNow ? '' : 'none';
  btnTsProcess.disabled      = !!top._saving;

  btnTsProcess.dataset.ownerToken = top._token;
  btnTsProcess.onclick = async () => {
    const fr = (typeof currentFrame === 'function') ? currentFrame() : null;
    if (!fr || btnTsProcess.dataset.ownerToken !== fr._token) return;

    const mc = window.modalCtx || {};
    const det = mc.timesheetDetails || {};
    const tsfin = det.tsfin || {};
    const cw = det.contract_week || {};

    const lockedX = !!(tsfin.locked_by_invoice_id || tsfin.paid_at_utc);
    if (lockedX) { alert('This timesheet is locked (paid or invoiced).'); return; }

    const weekIdX = mc.data?.contract_week_id || null;
    if (!weekIdX) { alert('Contract week id missing.'); return; }

    const ok = window.confirm(
      'Process Timesheet?\n\n' +
      'This will create a real timesheet from the saved MANUAL planned week.'
    );
    if (!ok) return;

    const tryParseSchedule = (src) => {
      if (!src) return null;
      if (Array.isArray(src)) return JSON.parse(JSON.stringify(src));
      if (typeof src === 'string') {
        try { const p = JSON.parse(src); if (Array.isArray(p)) return p; } catch {}
      }
      if (typeof src === 'object') return JSON.parse(JSON.stringify(src));
      return null;
    };

    const scheduleX = tryParseSchedule(cw && cw.planned_schedule_json) || null;

    if (!Array.isArray(scheduleX) || !scheduleX.length) {
      alert('No planned schedule is saved for this week. Click Edit, enter the schedule, then Save before processing.');
      return;
    }

    // pull draft extras from contract_weeks.totals_json.additional_units_week
    let auWeek = null;
    try {
      auWeek = (cw && cw.totals_json && typeof cw.totals_json === 'object')
        ? cw.totals_json.additional_units_week
        : null;

      if (typeof auWeek === 'string') {
        try { auWeek = JSON.parse(auWeek); } catch { auWeek = null; }
      }

      if (!auWeek || typeof auWeek !== 'object') auWeek = {};
    } catch {
      auWeek = {};
    }
const sanitizeSchedule = (arr) => {
  const out = Array.isArray(arr) ? JSON.parse(JSON.stringify(arr)) : [];
  for (const seg of out) {
    if (!seg || typeof seg !== 'object') continue;

    const breaksArr = Array.isArray(seg.breaks) ? seg.breaks.filter(b => b && (b.start || b.end)) : [];
    const hasBreakWindows =
      breaksArr.length > 0 ||
      String(seg.break_start || '').trim() ||
      String(seg.break_end || '').trim();

    if (hasBreakWindows) {
      // âœ… Break windows win â†’ strip mins fields
      delete seg.break_minutes;
      delete seg.break_mins;

      // also strip legacy mins aliases if you have any
      delete seg.breakMin;
      delete seg.breakMinutes;

      // if legacy break_start/end exist, ensure they are represented in breaks[]
      if (!breaksArr.length) {
        const bs = String(seg.break_start || '').trim();
        const be = String(seg.break_end || '').trim();
        if (bs || be) seg.breaks = [{ start: bs, end: be }];
      } else {
        seg.breaks = breaksArr;
      }
    } else {
      // âœ… No windows â†’ keep minutes if present, strip breaks fields
      if (seg.break_minutes != null) {
        const n = Number(seg.break_minutes);
        if (!Number.isFinite(n) || n <= 0) delete seg.break_minutes;
        else seg.break_minutes = Math.floor(n);
      }
      delete seg.breaks;
      delete seg.break_start;
      delete seg.break_end;
      delete seg.break_mins;
    }
  }
  return out;
};

const payload = {
  actual_schedule_json: sanitizeSchedule(scheduleX),
  additional_units_week: auWeek
};
    

    try {
      const result = await manualUpsertContractWeek(weekIdX, payload);
      const newTsId = result?.timesheet_id || null;

    if (newTsId) {
  try {
    if (window.modalCtx && window.modalCtx.data) {
      window.modalCtx.data.timesheet_id = newTsId;
      window.modalCtx.data.id = newTsId;
    }
  } catch {}
  window.__toast && window.__toast('Timesheet processed.');
} else {
  alert('Processed, but no timesheet_id was returned.');
}

// âœ… Keep modal open and ALWAYS do canonical refresh
await refreshFooter();

    } catch (e) {
      alert(e?.message || 'Process Timesheet failed');
    }
  };
}


      // â”€â”€ Delete Timesheet â”€â”€
      if (btnTsDelete) {
        btnTsDelete.style.display = canDeleteNow ? '' : 'none';
        btnTsDelete.disabled      = !!top._saving;

        btnTsDelete.dataset.ownerToken = top._token;
        btnTsDelete.onclick = async () => {
          const fr = (typeof currentFrame === 'function') ? currentFrame() : null;
          if (!fr || btnTsDelete.dataset.ownerToken !== fr._token) return;

          const mc = window.modalCtx || {};
          const det = mc.timesheetDetails || {};
          const tsfin = det.tsfin || {};
          const tsIdX = mc.data?.timesheet_id || null;
          const weekIdX = mc.data?.contract_week_id || null;

          const lockedX = !!(tsfin.locked_by_invoice_id || tsfin.paid_at_utc);
          if (lockedX) { alert('This timesheet is locked (paid or invoiced).'); return; }

          const isPlannedOnly = (!tsIdX && !!weekIdX);

          // âœ… Enforce backend delete-preview policy for real timesheets (planned weeks keep existing behaviour)
          const dpX =
            (mc && mc.timesheetDeletePreview && typeof mc.timesheetDeletePreview === 'object')
              ? mc.timesheetDeletePreview
              : null;

          const dpKindX = String((dpX && dpX.kind) ? dpX.kind : '').toUpperCase();
          const dpEligibleX = (dpX && typeof dpX.eligible === 'boolean') ? dpX.eligible : false;

          if (!isPlannedOnly) {
            if (dpKindX === 'IMPORT_CHILD_ADJUSTMENT') {
              alert("This is an NHSP/HR child adjustment and can't be deleted directly. Delete must be performed via the parent timesheet (if eligible).");
              return;
            }
            if (dpEligibleX !== true) {
              alert('Delete is not available for this timesheet (it may be locked, invoiced/paid, or not eligible).');
              return;
            }
          }

          // Friendly confirm modal (uses preview.delete_items for details)
          const enc2 = escapeHtml;

          const fmtGBP = (n) => {
            const x = Number(n || 0);
            const v = Number.isFinite(x) ? x : 0;
            return `Â£${v.toFixed(2)}`;
          };

          const fmtHours = (n) => {
            const x = Number(n || 0);
            const v = Number.isFinite(x) ? x : 0;
            return v.toFixed(2);
          };

          const roleLabel = (it) => {
            const r = String(it?.display_role || '').toUpperCase();
            if (r === 'PARENT') return 'Parent';
            if (r === 'MANUAL_ADJUSTMENT') return 'Manual Adjustment';
            if (r === 'IMPORT_CHILD_ADJUSTMENT') return 'Import Adjustment';
            if (r === 'ADJUSTMENT') return 'Adjustment';
            return 'Timesheet';
          };

          const buildDeleteTableHtml = (items) => {
            const list = Array.isArray(items) ? items : [];
            if (!list.length) return '';

            let sumH = 0, sumPay = 0, sumChg = 0;
            const rows = list.map(it => {
              const h = Number(it?.total_hours || 0) || 0;
              const p = Number(it?.total_pay_ex_vat || 0) || 0;
              const c = Number(it?.total_charge_ex_vat || 0) || 0;
              sumH += h; sumPay += p; sumChg += c;

              const id8 = String(it?.timesheet_id || '').slice(0, 8);
              return `
                <tr>
                  <td style="padding:6px 8px;border-bottom:1px solid var(--line);">${enc2(roleLabel(it))}</td>
                  <td style="padding:6px 8px;border-bottom:1px solid var(--line);font-family:monospace;">${enc2(id8 ? `${id8}â€¦` : '')}</td>
                  <td style="padding:6px 8px;border-bottom:1px solid var(--line);text-align:right;">${enc2(fmtHours(h))}</td>
                  <td style="padding:6px 8px;border-bottom:1px solid var(--line);text-align:right;">${enc2(fmtGBP(p))}</td>
                  <td style="padding:6px 8px;border-bottom:1px solid var(--line);text-align:right;">${enc2(fmtGBP(c))}</td>
                </tr>
              `;
            }).join('');

            const totalRow = `
              <tr>
                <td style="padding:6px 8px;font-weight:700;">Total</td>
                <td style="padding:6px 8px;"></td>
                <td style="padding:6px 8px;text-align:right;font-weight:700;">${enc2(fmtHours(sumH))}</td>
                <td style="padding:6px 8px;text-align:right;font-weight:700;">${enc2(fmtGBP(sumPay))}</td>
                <td style="padding:6px 8px;text-align:right;font-weight:700;">${enc2(fmtGBP(sumChg))}</td>
              </tr>
            `;

            return `
              <div style="margin-top:10px;">
                <div class="mini" style="margin-bottom:6px;opacity:.85;">
                  The following timesheet(s) will be deleted:
                </div>
                <table style="width:100%;border-collapse:collapse;border:1px solid var(--line);border-radius:10px;overflow:hidden;">
                  <thead>
                    <tr>
                      <th style="text-align:left;padding:6px 8px;border-bottom:1px solid var(--line);">Type</th>
                      <th style="text-align:left;padding:6px 8px;border-bottom:1px solid var(--line);">ID</th>
                      <th style="text-align:right;padding:6px 8px;border-bottom:1px solid var(--line);">Hours</th>
                      <th style="text-align:right;padding:6px 8px;border-bottom:1px solid var(--line);">Net pay</th>
                      <th style="text-align:right;padding:6px 8px;border-bottom:1px solid var(--line);">Net charge</th>
                    </tr>
                  </thead>
                  <tbody>
                    ${rows}
                    ${totalRow}
                  </tbody>
                </table>
              </div>
            `;
          };

          const dpItems = (!isPlannedOnly && dpX && Array.isArray(dpX.delete_items)) ? dpX.delete_items : [];
          const weYmdX =
            (dpItems[0] && dpItems[0].week_ending_date) ? String(dpItems[0].week_ending_date) :
            (det?.timesheet?.week_ending_date) ? String(det.timesheet.week_ending_date) :
            (mc.data?.week_ending_date) ? String(mc.data.week_ending_date) :
            '';

          const title =
            isPlannedOnly ? 'Delete planned week?' : 'Delete timesheet(s)?';

          const messageHtml =
            isPlannedOnly
              ? `
                <div style="font-size:14px;font-weight:700;margin-bottom:6px;">
                  Delete this planned week?
                </div>
                <div class="mini" style="white-space:pre-wrap;">
                  This is a planned week (no timesheet has been created yet).
                  Deleting will remove the planned contract week.
                </div>
                <div class="mini" style="margin-top:10px;opacity:.8;">
                  This action cannot be undone.
                </div>
              `
              : `
                <div style="font-size:14px;font-weight:700;margin-bottom:6px;">
                  Delete timesheet(s) for week ending ${enc2(weYmdX || 'Unknown')}?
                </div>
                <div class="mini" style="white-space:pre-wrap;">
                  This will permanently delete the timesheet(s) listed below.
                </div>
                <div class="mini" style="margin-top:10px;opacity:.8;">
                  This action cannot be undone.
                </div>
              `;

          const extraHtml =
            isPlannedOnly ? '' : buildDeleteTableHtml(dpItems);

          const confirmLabel =
            isPlannedOnly ? 'Delete planned week' : 'Delete timesheet(s)';

          const confirmRes = await openUiConfirmModal({
            title,
            message_html: messageHtml,
            extra_html: extraHtml,
            confirm_label: confirmLabel,
            cancel_label: 'Cancel',
            confirm_class: 'btn btn-warn',
            cancel_class: 'btn btn-outline'
          });

          if (!confirmRes || !confirmRes.confirmed) return;

          // OK-only info modal (utility child)
          const showOkInfoModal = async (infoTitle, infoHtml) => {
            const modalKind = 'import-summary-ui-info';
            const btnId = `btnUiInfoOk_${Date.now()}_${Math.random().toString(36).slice(2)}`;

            return await new Promise((resolve) => {
              let done = false;
              const finish = () => { if (done) return; done = true; resolve(true); };

              showModal(
                String(infoTitle || 'Done'),
                [{ key: 'ok', label: 'OK' }],
                () => `
                  <div style="padding: 6px 2px;">
                    ${String(infoHtml || '')}
                    <div style="display:flex; gap:10px; margin-top:14px;">
                      <button id="${enc2(btnId)}" type="button" class="btn btn-primary">OK</button>
                    </div>
                  </div>
                `,
                null,
                true,
                null,
                {
                  kind: modalKind,
                  noParentGate: true,
                  showSave: false,
                  showApply: false,
                  onDismiss: () => finish()
                }
              );

              const wire = () => {
                const okBtn = document.getElementById(btnId);
                if (okBtn && !okBtn.__wired) {
                  okBtn.__wired = true;
                  okBtn.onclick = () => {
                    finish();
                    try { document.getElementById('btnCloseModal')?.click(); } catch {}
                  };
                }
              };

              try { requestAnimationFrame(() => requestAnimationFrame(wire)); } catch { setTimeout(wire, 0); }
            });
          };

          // Capture summary ctx (if available) BEFORE closing anything
          let summaryCtx = null;
          try { summaryCtx = fr._summaryCtx || top._summaryCtx || mc.__summaryCtx || null; } catch { summaryCtx = null; }
          try { mc.__summaryCtx = summaryCtx || null; } catch {}

          try {
            if (isPlannedOnly) {
              if (!weekIdX) throw new Error('Contract week id missing.');
              await deletePlannedContractWeek(weekIdX);
            } else {
              if (!tsIdX) throw new Error('Timesheet id missing.');
              await deleteTimesheetPermanent(tsIdX);
            }

            await showOkInfoModal(
              'Deleted',
              `<div style="font-size:14px;font-weight:700;margin-bottom:6px;">Deleted successfully.</div>
               <div class="mini">The selected timesheet(s) have been deleted.</div>`
            );

                  // Update summary behind (use helper; fallback to renderAll only if needed)
            try {
              if (typeof applyTimesheetDeleteImpactToSummary === 'function') {
                await applyTimesheetDeleteImpactToSummary({
                  entity: 'timesheets',
                  preview: dpX || null,
                  opened_timesheet_id: tsIdX || null,
                  planned_contract_week_id: (isPlannedOnly ? (weekIdX || null) : null),
                  summaryCtx: summaryCtx || null,
                  fallbackFullRefresh: true
                });
              } else {
                try { await renderAll(); } catch {}
              }
            } catch {
              try { await renderAll(); } catch {}
            }

    // Close the timesheet modal after the user confirms OK
// âœ… Do NOT rely on btnCloseModal.click() here (token-guarded, can no-op after utility child modals).
// âœ… Hard-close the modal stack (timesheet no longer exists).
try {
  discardAllModalsAndState();
} catch {
  // fallback: attempt normal close
  try { byId('btnCloseModal')?.click(); } catch {}
}



          } catch (e) {
            try {
              if (typeof tsHandleMoved409Modal === 'function') {
                const handled = await tsHandleMoved409Modal(e, {
                  tabKey: (currentFrame?.() && currentFrame().currentTabKey) ? currentFrame().currentTabKey : 'overview',
                  label: 'footer-delete-timesheet',
                  toast: 'This timesheet changed while you were editing; review and try again.'
                });
                if (handled) return;
              }
            } catch {}
            alert(e?.message || 'Delete failed');
          }
        };
      }


  } else {
  // not a top-level timesheet â†’ hide footer actions
  if (btnTsAuthorise)   { btnTsAuthorise.style.display   = 'none'; btnTsAuthorise.disabled   = true; }
  if (btnTsUnauthorise) { btnTsUnauthorise.style.display = 'none'; btnTsUnauthorise.disabled = true; }
  if (btnTsProcess)     { btnTsProcess.style.display     = 'none'; btnTsProcess.disabled     = true; }
  if (btnTsUnprocess)   { btnTsUnprocess.style.display   = 'none'; btnTsUnprocess.disabled   = true; } // âœ… NEW
  if (btnTsDelete)      { btnTsDelete.style.display      = 'none'; btnTsDelete.disabled      = true; }
}



    // Related button (unchanged)
    if (relatedBtn) {
      const relatedEntity =
        top.entity === 'candidates' ? 'candidate' :
        top.entity === 'clients'    ? 'client'    :
        top.entity === 'contracts'  ? 'contract'  :
        top.entity === 'timesheets' ? 'timesheet' :
        top.entity === 'invoices'   ? 'invoice'   :
        top.entity === 'umbrellas'  ? 'umbrella'  :
        null;

      const showRelated =
        !isChild &&
        top.hasId &&
        !!relatedEntity;

      relatedBtn.style.display = showRelated ? '' : 'none';

      const canClick = showRelated && top.mode === 'view';
      relatedBtn.disabled = !canClick;

      if (canClick) {
        relatedBtn.onclick = async (ev) => {
          try {
            ev.preventDefault();
            ev.stopPropagation();

            const ctxId = window.modalCtx?.data?.id || null;
            if (!ctxId) {
              console.warn('[RELATED] no id on modalCtx.data; cannot open related menu');
              return;
            }

            const counts = await fetchRelatedCounts(relatedEntity, ctxId);

            const x = ev.clientX;
            const y = ev.clientY + 8;

            showRelatedMenu(x, y, counts, relatedEntity, ctxId);
          } catch (e) {
            console.warn('[RELATED] failed to open related menu', e);
          }
        };
      } else {
        relatedBtn.onclick = null;
      }
    }

      // Default Save/Edit display logic
    if (top.mode === 'create') {
      btnSave.style.display = '';
      btnSave.disabled = top._saving;
    } else if (top.mode === 'view') {
      btnSave.style.display = 'none';
      btnSave.disabled = true;
    } else {
      btnSave.style.display = '';

      let gateOK = true;

      if (top.entity === 'contracts') {
        try {
          gateOK = (typeof computeContractSaveEligibility === 'function') ? !!computeContractSaveEligibility() : true;
        } catch { gateOK = true; }
      }

      // âœ… Invoice modal: enable Save ONLY when there are staged edits (top.isDirty is driven externally)
      if (top.entity === 'invoices' && top.kind === 'invoice-modal') {
        btnSave.disabled = !!top._saving || !top.isDirty;
      } else {
        btnSave.disabled = (top.entity === 'contracts')
          ? (top._saving || ((top.kind !== 'contract-clone-extend') && !top.isDirty) || !gateOK)
          : (
              top._saving ||
              (top.kind === 'timesheet-evidence-viewer' && !top.isDirty)
            );
      }
    }


  // ðŸ”¹ Top-level Invoice Modal â†’ wire global Delete button (VIEW mode only, eligible only)
// NOTE: This aligns with your brief: delete is only possible AFTER unissue + remove all lines + Save.
// We DO NOT delete in edit mode; we only show the delete button in VIEW when invoice is eligible.
if (!isChild && top.entity === 'invoices' && top.kind === 'invoice-modal') {
  const mc = window.modalCtx || {};
  const det = mc.data || mc.dataLoaded || mc.invoiceDetail || null;

  const inv = det && typeof det === 'object'
    ? (det.invoice || det.invoice_row || det.invoiceRow || null)
    : null;

  const items = (det && Array.isArray(det.items)) ? det.items : [];

  const status = String(inv?.status || '').toUpperCase();
  const eligible =
    !!inv &&
    (inv.paid_at_utc == null) &&
    (inv.issued_at_utc == null) &&
    (status === 'DRAFT') &&
    (items.length === 0);

  if (top.mode === 'view' && eligible) {
    btnDel.style.display = '';
    btnDel.disabled = !!top._saving;
    btnDel.textContent = 'Delete Invoice';
    btnDel.onclick = async () => {
      try {
        if (typeof handleInvoiceDelete === 'function') {
          await handleInvoiceDelete(mc);
        } else {
          alert('Delete invoice action is not available.');
          return;
        }
        try { byId('btnCloseModal')?.click(); } catch {}
        try { await renderAll(); } catch {}
      } catch (e) {
        alert(e?.message || 'Delete failed');
      }
    };
  } else {
    btnDel.style.display = 'none';
    btnDel.disabled = true;
    btnDel.onclick = null;
    // restore default label if other flows rely on it
    btnDel.textContent = 'Delete';
  }

} else

// ðŸ”¹ Top-level Edit Contract â†’ wire global Delete button
if (!isChild && top.entity === 'contracts') {
  const canDelete = !!(window.modalCtx?.data && window.modalCtx.data.can_delete);
  const showDelete = (top.mode === 'edit' && top.hasId && canDelete);

  if (showDelete) {
    btnDel.style.display = '';
    btnDel.disabled = !!top._saving;

    // âœ… FIX: ensure label is correct for Contracts (prevents â€œDelete Invoiceâ€ bleed)
    btnDel.textContent = 'Delete Contract';

    btnDel.onclick = async () => {
      const id = window.modalCtx?.data?.id;
      if (!id) return;

      const ok = window.confirm('Do you want to permanently delete this contract?');
      if (!ok) return;

      try {
        if (typeof deleteContract === 'function') {
          if (LOG) console.log('[MODAL][CONTRACTS] delete via btnDelete', { id });
          await deleteContract(id);
        } else {
          alert('Delete contract action is not available.');
          return;
        }
        try { discardAllModalsAndState(); } catch {}
        try { await renderAll(); } catch {}
      } catch (e) {
        alert(e?.message || 'Delete failed');
      }
    };
  } else {
    btnDel.style.display = 'none';
    btnDel.disabled = true;
    btnDel.onclick = null;

    // âœ… FIX: reset label when hidden so it canâ€™t carry over from other entities
    btnDel.textContent = 'Delete';
  }
} else if (!isChild) {
  btnDel.style.display = 'none';
  btnDel.disabled = true;
  btnDel.onclick = null;

  // âœ… FIX: reset label on any non-child non-contract/non-invoice top frame
  btnDel.textContent = 'Delete';
}


  }

  setCloseLabel();
  L('_updateButtons snapshot (global)', {
    kind: top.kind, isChild, parentEditable, mode: top.mode,
    btnSave: { display: btnSave.style.display, disabled: btnSave.disabled },
    btnEdit: { display: btnEdit.style.display }
  });
};



   top._updateButtons();
  btnEdit.onclick = ()=> {
    const isChildNow    = (stack().length > 1);
    const isRatePreset  = (top.kind === 'rate-preset');

    // Block Edit for search & normal child-apply modals,
    // but allow Edit for rate-preset even when opened as a child.
    if (!isRatePreset && (isChildNow || top.kind === 'advanced-search')) return;

   if (top.mode === 'view') {
  top._snapshot = {
    data               : deep(window.modalCtx?.data || null),
    formState          : deep(window.modalCtx?.formState || null),
    rolesState         : deep(window.modalCtx?.rolesState || null),
    ratesState         : deep(window.modalCtx?.ratesState || null),
    hospitalsState     : deep(window.modalCtx?.hospitalsState || null),
    clientSettingsState: deep(window.modalCtx?.clientSettingsState || null),
    overrides          : deep(window.modalCtx?.overrides || { existing:[], stagedNew:[], stagedEdits:{}, stagedDeletes:[] }),
    candidateMainModel : deep(window.modalCtx?.candidateMainModel || null),

    // NEW: snapshot any timesheet-specific staging (lines, issues, etc.)
    timesheetState     : deep(window.modalCtx?.timesheetState || null),

    // âœ… NEW: snapshot invoice modal state so discard/no-change doesn't leave stale staged state
    invoiceDetail      : deep(window.modalCtx?.invoiceDetail || null),
    invoiceState       : deep(window.modalCtx?.invoiceState || null),
    invoiceUi          : deep(window.modalCtx?.invoiceUi || null),

    // invoiceRemove contains a Set â†’ store as array and rebuild on restore
    invoiceRemoveSelectedTimesheetIds: Array.from(
      (window.modalCtx?.invoiceRemove?.selectedTimesheetIds instanceof Set)
        ? window.modalCtx.invoiceRemove.selectedTimesheetIds
        : []
    )
  };
  top.isDirty = false;
  setFrameMode(top, 'edit');
  L('btnEdit (global) â†’ switch to edit (snapshot includes timesheetState)', {
    hasTimesheetState: !!top._snapshot.timesheetState,
    keys: Object.keys(top._snapshot || {})
  });
}


  };



  const handleSecondary = (ev)=>{
    if (currentFrame && currentFrame() !== top) return;
    if (top._confirmingDiscard || top._closing) return;

    if (top.kind==='advanced-search') {
      top._closing=true;
      document.onmousemove=null; document.onmouseup=null; byId('modal')?.classList.remove('dragging'); sanitizeModalGeometry();
      const closing=stack().pop(); 

try { if (closing && typeof closing._onDismiss === 'function') closing._onDismiss(); } catch {}
      if (closing?._detachDirty){ try{closing._detachDirty();}catch{} closing._detachDirty=null; }
      if (closing?._detachGlobal){ try{closing._detachGlobal();}catch{} closing._detachGlobal=null; } top._wired=false;
      if (stack().length>0) {
        const p = currentFrame();
        if (p && p._ctxRef) window.modalCtx = p._ctxRef;

        const resumeMode =
          (typeof closing !== 'undefined' && closing && closing._parentModeOnOpen)
            ? closing._parentModeOnOpen
            : p.mode;

        try { setFrameMode(p, resumeMode); } catch {}
        p._updateButtons?.();

        renderTop();
        try { p.onReturn && p.onReturn(); } catch {}
      } else {
        discardAllModalsAndState(); if (window.__pendingFocus) { try{ renderAll(); } catch(e){ console.error('refresh after modal close failed',e); } }
      }
      return;
    }

    const isChildNow = (stack().length > 1);

    // Child frames with noParentGate: if dirty in edit/create, confirm discard before closing.
    // Never prompt for the Rate Presets picker or the candidate/client pickers â€“ they are
    // selection utilities, not real edit forms.
 const suppressChildDiscardPrompt =
  top.kind === 'rate-presets-picker' ||
  top.kind === 'candidate-picker'    ||
  top.kind === 'client-picker'       ||
  top.kind === 'qr-decision';

    if (isChildNow &&
        top.noParentGate &&
        (top.mode === 'edit' || top.mode === 'create') &&
        top.isDirty &&
        !suppressChildDiscardPrompt) {
      let ok = false;
      try {
        top._confirmingDiscard = true;
        btnClose.disabled = true;
        ok = window.confirm('Discard changes and close?');
      } finally {
        top._confirmingDiscard = false;
        btnClose.disabled = false;
      }
      if (!ok) return;
    }



       if (!isChildNow && !top.noParentGate && top.mode==='edit' && top.kind!=='rates-presets') {
    if (!top.isDirty) {
  if (top._snapshot && window.modalCtx) {
    window.modalCtx.data                = deep(top._snapshot.data);
    window.modalCtx.formState           = deep(top._snapshot.formState);
    window.modalCtx.rolesState          = deep(top._snapshot.rolesState);
    window.modalCtx.ratesState          = deep(top._snapshot.ratesState);
    window.modalCtx.hospitalsState      = deep(top._snapshot.hospitalsState);
    window.modalCtx.clientSettingsState = deep(top._snapshot.clientSettingsState);
    if (top._snapshot.overrides)         window.modalCtx.overrides          = deep(top._snapshot.overrides);
    window.modalCtx.candidateMainModel  = deep(top._snapshot.candidateMainModel || null);

    // NEW: restore timesheetState so staged Lines/Issues state is rolled back
    window.modalCtx.timesheetState      = deep(top._snapshot.timesheetState || null);

    // âœ… NEW: restore invoice modal state
    window.modalCtx.invoiceDetail       = deep(top._snapshot.invoiceDetail || null);
    window.modalCtx.invoiceState        = deep(top._snapshot.invoiceState || null);
    window.modalCtx.invoiceUi           = deep(top._snapshot.invoiceUi || null);

    // rebuild Set for invoiceRemove selection (safe default)
    window.modalCtx.invoiceRemove       = window.modalCtx.invoiceRemove || {};
    window.modalCtx.invoiceRemove.selectedTimesheetIds =
      new Set(Array.isArray(top._snapshot.invoiceRemoveSelectedTimesheetIds) ? top._snapshot.invoiceRemoveSelectedTimesheetIds : []);

    if (LOG) {
      console.log('[MODAL][RESTORE][no-change]', {
        entity: top.entity,
        hasTimesheetState: !!top._snapshot.timesheetState
      });
    }

   try {
  const frNow = currentFrame();
  if (frNow && frNow.entity === 'candidates' && frNow.currentTabKey === 'rates') {
    renderCandidateRatesTable?.();
  }
} catch {}

  }
  try {
    if (top.entity === 'contracts') {
      const cid = window.modalCtx?.data?.id;
      if (cid && typeof discardContractCalendarStage === 'function') discardContractCalendarStage(cid);
    }
  } catch {}
  top.isDirty=false; setFrameMode(top,'view'); top._snapshot=null;
  try{ window.__toast?.('No changes'); }catch{}; return;
}

  else {
        let ok=false; try{ top._confirmingDiscard=true; btnClose.disabled=true; ok=window.confirm('Discard changes and return to view?'); } finally { top._confirmingDiscard=false; btnClose.disabled=false; }
        if (!ok) return;
     if (top._snapshot && window.modalCtx) {
  window.modalCtx.data                = deep(top._snapshot.data);
  window.modalCtx.formState           = deep(top._snapshot.formState);
  window.modalCtx.rolesState          = deep(top._snapshot.rolesState);
  window.modalCtx.ratesState          = deep(top._snapshot.ratesState);
  window.modalCtx.hospitalsState      = deep(top._snapshot.hospitalsState);
  window.modalCtx.clientSettingsState = deep(top._snapshot.clientSettingsState);
  if (top._snapshot.overrides) window.modalCtx.overrides = deep(top._snapshot.overrides);
  // ðŸ”¹ restore candidateMainModel as well so job titles (and primary) roll back
  window.modalCtx.candidateMainModel  = deep(top._snapshot.candidateMainModel || null);

  // NEW: restore timesheetState so staged per-line changes are discarded
  window.modalCtx.timesheetState      = deep(top._snapshot.timesheetState || null);

  // âœ… NEW: restore invoice modal state
  window.modalCtx.invoiceDetail       = deep(top._snapshot.invoiceDetail || null);
  window.modalCtx.invoiceState        = deep(top._snapshot.invoiceState || null);
  window.modalCtx.invoiceUi           = deep(top._snapshot.invoiceUi || null);

  // rebuild Set for invoiceRemove selection (safe default)
  window.modalCtx.invoiceRemove       = window.modalCtx.invoiceRemove || {};
  window.modalCtx.invoiceRemove.selectedTimesheetIds =
    new Set(Array.isArray(top._snapshot.invoiceRemoveSelectedTimesheetIds) ? top._snapshot.invoiceRemoveSelectedTimesheetIds : []);

  if (LOG) {
    console.log('[MODAL][RESTORE][discard]', {
      entity: top.entity,
      hasTimesheetState: !!top._snapshot.timesheetState
    });
  }

  try { renderCandidateRatesTable?.(); } catch {}
}

        try {
          if (top.entity === 'contracts') {
            const cid = window.modalCtx?.data?.id;
            if (cid && typeof discardContractCalendarStage === 'function') discardContractCalendarStage(cid);
          }
        } catch {}
        top.isDirty=false; top._snapshot=null; setFrameMode(top,'view'); return;
      }
    }



    if (top._closing) return;
    top._closing=true;
    document.onmousemove=null; document.onmouseup=null; byId('modal')?.classList.remove('dragging');

    if (!isChildNow && !top.noParentGate && top.mode==='create' && top.isDirty && top.kind!=='rates-presets') {
      let ok=false; try{ top._confirmingDiscard=true; btnClose.disabled=true; ok=window.confirm('You have unsaved changes. Discard them and close?'); } finally { top._confirmingDiscard=false; btnClose.disabled=false; }
      if (!ok) { top._closing=false; return; }
    }


    try {
      if (top.entity === 'contracts' && (top.mode==='edit' || top.mode==='create')) {
        const cid = window.modalCtx?.data?.id;
        if (cid && typeof discardContractCalendarStage === 'function') discardContractCalendarStage(cid);
      }
    } catch {}
   sanitizeModalGeometry();
const closing = stack().pop();

// âœ… NEW: call onDismiss for ALL modal kinds (not just advanced-search)
try { if (closing && typeof closing._onDismiss === 'function') closing._onDismiss(); } catch {}

// âœ… NEW: prevent MutationObserver leaks from invoice modal wiring
try {
  const ctx = closing && closing._ctxRef ? closing._ctxRef : null;
  if (ctx && ctx._invoiceObserver) {
    try { ctx._invoiceObserver.disconnect(); } catch {}
    ctx._invoiceObserver = null;
  }
} catch {}

// âœ… NEW: detach invoice delegated click handler (bound to #modalBody)
try {
  const ctx = closing && closing._ctxRef ? closing._ctxRef : null;
  if (ctx && ctx.__invDelegated && ctx.__invDelegated.targetEl) {
    try {
      if (ctx.__invDelegated.handler) {
        ctx.__invDelegated.targetEl.removeEventListener('click', ctx.__invDelegated.handler, true);
      }
    } catch {}
    try {
      if (ctx.__invDelegated.changeHandler) {
        ctx.__invDelegated.targetEl.removeEventListener('change', ctx.__invDelegated.changeHandler, true);
      }
    } catch {}
    ctx.__invDelegated = null;
  }
} catch {}



if (closing?._detachDirty){ try{closing._detachDirty();}catch{} closing._detachDirty=null; }

    if (closing?._detachGlobal){ try{closing._detachGlobal();}catch{} closing._detachGlobal=null; } top._wired=false;
   if (stack().length>0) {
  const p = currentFrame();

  // restore parent context for the frame now on top
  if (p && p._ctxRef) window.modalCtx = p._ctxRef;

  const closingKind = (closing && typeof closing.kind === 'string') ? closing.kind : '';
  const closingIsUtility =
    (typeof closingKind === 'string' && (
      closingKind === 'invoice-reference-numbers' ||
      closingKind === 'invoice-send-email-confirm' ||
      closingKind.startsWith('import-summary-') ||
      closingKind.startsWith('invoice-batch-') ||
      closingKind.startsWith('import-summary-invoice-batch-')
    ));


  // âœ… Utility modal rule:
  // Closing a utility child should NOT trigger parent "restore" work beyond renderTop().
  // This prevents unrelated redraws (e.g., rates table) and modal stack corruption.
  if (closingIsUtility) {
    renderTop();
    try { p.onReturn && p.onReturn(); } catch {}
    return;
  }

  // Non-utility children: resume parent mode normally
  const resumeMode =
    (typeof closing !== 'undefined' &&
     closing &&
     closing._parentModeOnOpen &&
     closing.kind !== 'rate-presets-picker')
      ? closing._parentModeOnOpen
      : p.mode;

  try { setFrameMode(p, resumeMode); } catch {}
  p._updateButtons && p._updateButtons();
  renderTop();

  try { p.onReturn && p.onReturn(); } catch {}
} else {
  discardAllModalsAndState();
  if (window.__pendingFocus) { try { renderAll(); } catch(e) { console.error('refresh after modal close failed', e); } }
}


  };
  // AFTER
  const onCloseClick = (ev) => {
    const btn = ev?.currentTarget || byId('btnCloseModal');
    const bound = btn?.dataset?.ownerToken;
    const topNow = currentFrame();
    if (!topNow || bound !== topNow._token) return;
    handleSecondary(ev);
  };

  const bindClose = (btn, fr) => {
    if (!btn || !fr) return;
    btn.dataset.ownerToken = fr._token;
    btn.onclick = onCloseClick;
  };

  bindClose(btnClose, top);

  const hasStagedClientDeletes = ()=> {
    try {
      const anyFlag = Array.isArray(window.modalCtx?.ratesState) && window.modalCtx.ratesState.some(w => w && w.__delete === true);
      const anySet  = (window.modalCtx?.ratesStagedDeletes instanceof Set) && window.modalCtx.ratesStagedDeletes.size > 0;
      const ovDel   = (window.modalCtx?.overrides?.stagedDeletes instanceof Set) && window.modalCtx.overrides.stagedDeletes.size > 0;
      return !!(anyFlag || anySet || ovDel);
    } catch { return false; }
  };

async function saveForFrame(fr) {
  if (!fr || fr._saving) return;
  const onlyDel    = hasStagedClientDeletes();
  const allowApply = (fr.kind === 'candidate-override' || fr.kind === 'client-rate') && fr._applyDesired === true;

  L('saveForFrame ENTER (global)', {
    kind: fr.kind,
    mode: fr.mode,
    noParentGate: fr.noParentGate,
    isDirty: fr.isDirty,
    onlyDel,
    allowApply
  });

 const isChildNow = (window.__modalStack?.length > 1);
const isTimesheetFrame = (fr.entity === 'timesheets');

const shouldNoop =
  (fr.kind !== 'advanced-search') &&
  !fr.noParentGate &&
  fr.mode === 'edit' &&
  !fr.isDirty &&
  !onlyDel &&
  !allowApply &&
  !isTimesheetFrame;

if (shouldNoop) {
  L('saveForFrame GUARD (global): no-op (no changes and apply not allowed)');
  if (isChildNow) {
    sanitizeModalGeometry();

    const closing = window.__modalStack.pop();

    // âœ… Cleanup (mirror the Close/ESC path) so we don't leak listeners/observers
    try { if (closing && typeof closing._onDismiss === 'function') closing._onDismiss(); } catch {}

    // Prevent MutationObserver leaks from invoice modal wiring
    try {
      const ctx = closing && closing._ctxRef ? closing._ctxRef : null;
      if (ctx && ctx._invoiceObserver) {
        try { ctx._invoiceObserver.disconnect(); } catch {}
        ctx._invoiceObserver = null;
      }
    } catch {}

    // Detach invoice delegated click handler (bound to #modalBody)
    try {
      const ctx = closing && closing._ctxRef ? closing._ctxRef : null;
      if (ctx && ctx.__invDelegated && ctx.__invDelegated.targetEl) {
        try {
          if (ctx.__invDelegated.handler) {
            ctx.__invDelegated.targetEl.removeEventListener('click', ctx.__invDelegated.handler, true);
          }
        } catch {}
        try {
          if (ctx.__invDelegated.changeHandler) {
            ctx.__invDelegated.targetEl.removeEventListener('change', ctx.__invDelegated.changeHandler, true);
          }
        } catch {}
        ctx.__invDelegated = null;
      }
    } catch {}

    if (closing?._detachDirty) { try { closing._detachDirty(); } catch {} closing._detachDirty = null; }
    if (closing?._detachGlobal){ try { closing._detachGlobal(); } catch {} closing._detachGlobal = null; }
    try { if (closing) closing._wired = false; } catch {}

    if (window.__modalStack.length > 0) {
      const p = window.__modalStack[window.__modalStack.length - 1];
      renderTop();
      try { p.onReturn && p.onReturn(); } catch {}
    } else {
      discardAllModalsAndState();
      if (window.__pendingFocus) {
        try { renderAll(); } catch(e) { console.error('refresh after modal close failed', e); }
      }
    }

  } else {
    fr.isDirty = false;
    fr._snapshot = null;
    setFrameMode(fr, 'view');
    fr._updateButtons && fr._updateButtons();
  }
  try { window.__toast?.('No changes'); } catch {};
  return;
}

// âœ… IMPORTANT: do NOT re-declare setFrameMode() inside saveForFrame.
// saveForFrame must always use the single authoritative setFrameMode() defined in showModal scope.



  fr.persistCurrentTabState();

  if (isChildNow && !fr.noParentGate && fr.kind !== 'advanced-search') {
    const p = window.__modalStack[window.__modalStack.length - 2];
    if (!p || !(p.mode === 'edit' || p.mode === 'create')) {
      L('saveForFrame GUARD (global): parent not editable');
      return;
    }
  }

  fr._saving = true;
  fr._updateButtons && fr._updateButtons();

  let ok = false, saved = null;
  if (typeof fr.onSave === 'function') {
    try {
      const res = await fr.onSave();
      ok = (res === true) || (res && res.ok === true);
      if (res && res.saved) saved = res.saved;
    } catch (e) {
      L('saveForFrame onSave threw (global)', e);
      ok = false;
    }
  }
  fr._saving = false;
  if (!ok) {
    L('saveForFrame RESULT not ok (global)');
    fr._updateButtons && fr._updateButtons();
    return;
  }

   // âœ… NEW: Patch Summary in-place (filter parity + obey current sort), with minimal server calls.
  // This runs BEFORE modal close/view flip so the grid updates immediately.
  try {
    if (saved && typeof summaryApplySavedRecordToActiveSummary === 'function') {
      const sctx = fr._summaryCtx || null;

      // Only patch if the saved modal entity maps to the captured summary section.
      const ent = String(fr.entity || window.modalCtx?.entity || '').trim();

      // âœ… OPTION A: Timesheets already refresh/patch Summary via their own post-save refresh pipeline.
      // Skipping the generic patch here prevents the visible "flip back then forward" bounce.
      if (String(ent).toLowerCase() !== 'timesheets') {
        const secEnt = (typeof getSectionForEntity === 'function')
          ? getSectionForEntity(ent)
          : String(currentSection || '');

        if (sctx && secEnt && String(sctx.section || '') === String(secEnt)) {
          // Prefer common wrapper shapes but fall back to saved as-is
          const savedRoot = (saved && typeof saved === 'object')
            ? (saved.contract || saved.candidate || saved.client || saved.invoice || saved.timesheet || saved.umbrella || saved)
            : saved;

          await summaryApplySavedRecordToActiveSummary(ent, savedRoot, sctx);
        }
      }
    }
  } catch (e) {
    // Never break save/close flow if Summary patch fails
    try { console.warn('[SUMMARY][PATCH] failed (non-fatal)', e); } catch {}
  }



  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Existing post-save logic (unchanged)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  if (fr.kind === 'advanced-search') {
    sanitizeModalGeometry();
    const closing = window.__modalStack.pop();
    if (closing?._detachDirty) { try { closing._detachDirty(); } catch {} closing._detachDirty = null; }
    if (closing?._detachGlobal) { try { closing._detachGlobal(); } catch {} closing._detachGlobal = null; }
    fr._wired = false;


    if (window.__modalStack.length > 0) {
      const p = window.__modalStack[window.__modalStack.length - 1];
      renderTop();
      try { p.onReturn && p.onReturn(); } catch {}
    } else {
      discardAllModalsAndState();
    }

    L('saveForFrame EXIT (global advanced-search closed)');
    return;
  }

  if (isChildNow) {
    // If this child should remain open after save (successor contract),
    // flip it in-place to view mode and keep it on screen.
    if (fr.stayOpenOnSave) {
      try {
        if (saved && window.modalCtx) {
          window.modalCtx.data = { ...(window.modalCtx.data || {}), ...(saved.contract || saved) };
          fr.hasId = !!window.modalCtx.data?.id;
        }
        setFrameMode(fr, 'view');
        fr._updateButtons && fr._updateButtons();
        renderTop();
      } catch {}
      L('saveForFrame EXIT (child kept open)');
    } else {
      if (!fr.noParentGate) {
        try { window.dispatchEvent(new CustomEvent('modal-dirty')); } catch {}
      }

      sanitizeModalGeometry();
      window.__modalStack.pop();

      if (window.__modalStack.length > 0) {
        const p = window.__modalStack[window.__modalStack.length - 1];

        let resumeMode =
          (typeof fr !== 'undefined' &&
           fr &&
           fr._parentModeOnOpen &&
           fr.kind !== 'rate-presets-picker')
            ? fr._parentModeOnOpen
            : p.mode;

        // SPECIAL CASE: candidate pay-method change â†’ treat as successful parent save
        if (fr.kind === 'candidate-pay-method-change' && p.entity === 'candidates') {
          resumeMode   = 'view';
          p.isDirty    = false;
          p._snapshot  = null;

          try {
            if (saved && window.modalCtx && window.modalCtx.entity === 'candidates') {
              window.modalCtx.data = {
                ...(window.modalCtx.data || {}),
                ...(saved || {})
              };
            }
          } catch {}
        }

        try { setFrameMode(p, resumeMode); } catch {}
        p._updateButtons && p._updateButtons();
        renderTop();

        try { window.dispatchEvent(new Event('contracts-main-rendered')); } catch {}
        try { p.onReturn && p.onReturn(); } catch {}
      }

      L('saveForFrame EXIT (global child)');
    }
  } else {
    // parent branch...
    try {
      const savedContract = (saved && (saved.contract || saved)) || null;
      const id = savedContract?.id || window.modalCtx?.data?.id || null;
      if (id && savedContract) {
        const idx = Array.isArray(currentRows)
          ? currentRows.findIndex(x => String(x.id) === String(id))
          : -1;
        if (idx >= 0) currentRows[idx] = savedContract;
        (window.__lastSavedAtById ||= {})[String(id)] = Date.now();
      }
    } catch (e) {
      console.warn('[SAVE] list cache merge failed', e);
    }

    if (saved && window.modalCtx) {
      window.modalCtx.data = { ...(window.modalCtx.data || {}), ...(saved.contract || saved) };
      fr.hasId = !!window.modalCtx.data?.id;
    }
    fr.isDirty = false;
    fr._snapshot = null;
    setFrameMode(fr, 'view');
    L('saveForFrame EXIT (global parent, kept open)');
  }
}

const onSaveClick = async (ev)=>{
  const btn = ev?.currentTarget || byId('btnSave');

  // âœ… Guard: utility/hidden Save must not fire (prevents Enter / stale handler surprises)
  try {
    if (!btn) return;
    if (btn.disabled) return;
    const disp = (btn.style && btn.style.display) ? String(btn.style.display) : '';
    if (disp === 'none') return;
  } catch {}

  const topNow = currentFrame();
  const bound  = btn?.dataset?.ownerToken;

  if (LOG) console.log('[MODAL] click #btnSave (global)', {
    boundToken: bound,
    topToken: topNow?._token,
    topKind: topNow?.kind,
    topTitle: topNow?.title
  });

  if (!topNow) return;
  if (bound !== topNow._token) {
    if (LOG) console.warn('[MODAL] token mismatch (global); using top frame');
  }

  await saveForFrame(topNow);
};

const bindSave = (btn, fr) => {
  if (!btn || !fr) return;

  // âœ… If Save is hidden, clear any previous handler so it cannot trigger via Enter/stale state.
  let hidden = false;
  try {
    if (btn.hidden) hidden = true;
    const disp = (btn.style && btn.style.display) ? String(btn.style.display) : '';
    if (disp === 'none') hidden = true;
  } catch {}

  if (hidden) {
    try { btn.onclick = null; } catch {}
    try { btn.dataset.ownerToken = ''; } catch {}
    return;
  }

  btn.dataset.ownerToken = fr._token;
  btn.onclick = onSaveClick;

  if (LOG) console.log('[MODAL] bind #btnSave â†’ (global)', {
    ownerToken: fr._token,
    kind: fr.kind || '(parent)',
    title: fr.title,
    mode: fr.mode
  });
};

bindSave(btnSave, top);

  // FIX: ignore programmatic "dirty" while suppression is active
   const onDirtyEvt = ()=> {
    const fr = currentFrame();
    if (!fr) return;
    if (fr._suppressDirty) return;

    // Special case: candidate/client pickers
    // When they fire a `modal-dirty` (e.g. via setContractFormValue in the
    // Contracts editor), we want the *parent* frame to become dirty so its
    // Save button enables â€“ the picker itself is just a selector.
    if (fr.kind === 'candidate-picker' || fr.kind === 'client-picker') {
      const p = parentFrame();
      if (p && (p.mode === 'edit' || p.mode === 'create')) {
        p.isDirty = true;
        p._updateButtons && p._updateButtons();
      }
      // Do NOT mark the picker dirty â€“ that avoids â€œDiscard changes?â€ prompts
      // when closing the picker.
      return;
    }

    // Allow presets picker dirty â†’ parent (ignore only truly load-only frames)
    if (fr._loadOnly === true) return;

    const isChildNow = (stack().length > 1);
    if (isChildNow) {
      if (fr.noParentGate) {
        if (fr.mode === 'edit' || fr.mode === 'create') {
          fr.isDirty = true;
          fr._updateButtons && fr._updateButtons();
        }
      } else {
        const p = parentFrame();
        if (p && (p.mode === 'edit' || p.mode === 'create')) {
          p.isDirty = true;
          p._updateButtons && p._updateButtons();
        }
      }
    } else if (fr.mode === 'edit' || fr.mode === 'create') {
      fr.isDirty = true;
      fr._updateButtons && fr._updateButtons();
    }
    try {
      const t = currentFrame();
      if (t && t.entity === 'candidates' && t.currentTabKey === 'rates') {
        renderCandidateRatesTable?.();
      }
    } catch {}
  };



  const onApplyEvt = ev=>{
    const isChildNow=(stack().length>1); if(!isChildNow) return;
    const t=currentFrame(); if(!(t && (t.kind==='client-rate'||t.kind==='candidate-override'))) return;
    const enabled=!!(ev && ev.detail && ev.detail.enabled);
    t._applyDesired=enabled;
    t._updateButtons&&t._updateButtons();
    bindSave(byId('btnSave'), t);
    if(LOG) console.log('[MODAL] onApplyEvt (global) â†’ _applyDesired =', enabled,'rebound save to top frame');
  };

 const onModeChanged = ev=>{
  const t = currentFrame();
  if (!t) return;

  const isChildNow = (stack().length > 1);

  // âœ… Existing behavior: parent mode change should update/rebind the child frame
  if (isChildNow) {
    const parentIdx = stack().length - 2;
    const changed   = ev?.detail?.frameIndex ?? -1;

    if (changed === parentIdx) {
      if (LOG) console.log('[MODAL] parent mode changed (global) â†’ child _updateButtons()');
      const topChild = currentFrame();
      topChild._updateButtons && topChild._updateButtons();
      bindSave(byId('btnSave'), topChild);
      bindClose(byId('btnCloseModal'), topChild);
    }
    return;
  }

  // âœ… NEW: top-level mode flips (e.g. Viewâ†’Edit) must rebind Save/Close
  // because bindSave() clears onclick/token when Save was hidden in view mode.
  try {
    const changed = ev?.detail?.frameIndex ?? -1;
    const topIdx  = stack().length - 1;

    if (changed === topIdx) {
      if (LOG) console.log('[MODAL] top mode changed (global) â†’ rebind Save/Close');
      t._updateButtons && t._updateButtons();
      bindSave(byId('btnSave'), t);
      bindClose(byId('btnCloseModal'), t);
    }
  } catch {}
};


  const onMarginsEvt = ()=>{ try { const t=currentFrame(); if (t && (t.mode==='edit'||t.mode==='create')) t._updateButtons(); } catch {} };

  if (!top._wired) {
    window.addEventListener('modal-dirty', onDirtyEvt);
    window.addEventListener('modal-apply-enabled', onApplyEvt);
    window.addEventListener('modal-frame-mode-changed', onModeChanged);
    window.addEventListener('contract-margins-updated', onMarginsEvt);
    const onEsc=e=>{ if(e.key==='Escape'){ if(top._confirmingDiscard||top._closing) return; e.preventDefault(); byId('btnCloseModal').click(); } };
    window.addEventListener('keydown', onEsc);
    const onOverlayClick=e=>{ if(top._confirmingDiscard||top._closing) return; if(e.target===byId('modalBack')) { e.preventDefault(); e.stopPropagation(); return; } };
    byId('modalBack').addEventListener('click', onOverlayClick, true);

    top._detachGlobal = ()=>{ try{window.removeEventListener('modal-dirty',onDirtyEvt);}catch{} try{window.removeEventListener('modal-apply-enabled',onApplyEvt);}catch{} try{window.removeEventListener('modal-frame-mode-changed',onModeChanged);}catch{} try{window.removeEventListener('contract-margins-updated',onMarginsEvt);}catch{} try{window.removeEventListener('keydown',onEsc);}catch{} try{byId('modalBack').removeEventListener('click', onOverlayClick, true);}catch{}; };
    top._wired = true;
    L('renderTop (global): listeners wired');
  }


  const parentEditable = parent && (parent.mode==='edit' || parent.mode==='create');
  const isChildNow = (stack().length > 1);
  if (isChildNow && !top.noParentGate) setFormReadOnly(byId('modalBody'), !parentEditable);
  else                                 setFrameMode(top, top.mode);

  top._updateButtons && top._updateButtons();
  bindSave(btnSave, top);

  try {
    const pc = document.getElementById('btnPickCandidate');
    const pl = document.getElementById('btnPickClient');
    L('renderTop final snapshot (global)', {
      entity: top.entity, mode: top.mode, currentTabKey: top.currentTabKey,
      pickButtons: {
        btnPickCandidate: { exists: !!pc, disabled: !!(pc && pc.disabled) },
        btnPickClient:    { exists: !!pl, disabled: !!(pl && pl.disabled) }
      }
    });
  } catch {}

  GE();
}

  byId('modalBack').style.display='flex';
  window.__getModalFrame = currentFrame;

  const _tabsForLog = Array.isArray(tabs) ? tabs : [];
  L('showModal ENTER', {
    title,
    tabs: _tabsForLog.map(t => (t && (t.key || t.title)) || ''),
    hasId,
    entity: window.modalCtx?.entity,
    kind: opts.kind,
    forceEdit: !!opts.forceEdit
  });

  renderTop();
}

async function applyTimesheetDeleteImpactToSummary(opts = {}) {
  const entity = String(opts.entity || 'timesheets');
  const preview = (opts.preview && typeof opts.preview === 'object') ? opts.preview : null;

  const openedTimesheetId = opts.opened_timesheet_id ? String(opts.opened_timesheet_id) : '';
  const plannedWeekId = opts.planned_contract_week_id ? String(opts.planned_contract_week_id) : '';

  // Prefer caller-provided summary ctx; otherwise try to capture from current UI state
  let summaryCtx = opts.summaryCtx || null;
  if (!summaryCtx) {
    try {
      if (typeof captureSummaryContextForModalOpen === 'function') {
        summaryCtx = captureSummaryContextForModalOpen();
      }
    } catch {
      summaryCtx = null;
    }
  }

  const ids = new Set();

  if (plannedWeekId) ids.add(plannedWeekId);

  // Use preview.delete_items if present (this is your canonical UI list)
  try {
    const items = (preview && Array.isArray(preview.delete_items)) ? preview.delete_items : [];
    for (const it of items) {
      const id = it && it.timesheet_id ? String(it.timesheet_id) : '';
      if (id) ids.add(id);
    }
  } catch {}

  // Also ensure the currently-opened id is included (defensive)
  if (openedTimesheetId) ids.add(openedTimesheetId);

  const idList = Array.from(ids).filter(Boolean);

  // If we have nothing to update, do nothing
  if (!idList.length) {
    return { ok: true, didTargeted: false, didFallback: false, removedAny: false, ids: [] };
  }

  // Targeted removal pass
  let removedAny = false;
  let didTargeted = false;

  if (typeof summaryRemoveRowIfNowExcluded === 'function') {
    didTargeted = true;
    for (const id of idList) {
      try {
        const removed = await summaryRemoveRowIfNowExcluded(entity, id, summaryCtx);
        if (removed) removedAny = true;
      } catch {}
    }
  }

  // Fallback: if we couldnâ€™t remove anything (or targeted helper unavailable), do full refresh
  const allowFallback = (opts.fallbackFullRefresh !== false);
  if (allowFallback && (!didTargeted || !removedAny)) {
    try {
      if (typeof renderAll === 'function') {
        await renderAll();
        return { ok: true, didTargeted, didFallback: true, removedAny, ids: idList };
      }
    } catch {}
  }

  return { ok: true, didTargeted, didFallback: false, removedAny, ids: idList };
}





function tsExtractMoved409(err) {
  const status = err?.status ?? err?.statusCode ?? null;
  const j = err?.json || null;

  if (status === 409 && j && j.error === 'TIMESHEET_MOVED' && j.current_timesheet_id) {
    return { moved: true, current_timesheet_id: String(j.current_timesheet_id) };
  }
  return { moved: false, current_timesheet_id: null };
}
async function createAdditionalManualAdjustmentAndOpen() {
  // Defensive: must be a timesheet modal and must be in VIEW mode
  const fr = (typeof window.__getModalFrame === 'function') ? window.__getModalFrame() : null;
  if (!fr || fr.entity !== 'timesheets') {
    alert('Not in a timesheet modal.');
    return;
  }
  if (String(fr.mode || '').toLowerCase() !== 'view') {
    alert('Return to VIEW mode before creating an additional manual adjustment timesheet.');
    return;
  }

  const mc  = window.modalCtx || {};
  const det = mc.timesheetDetails || {};
  const ts  = det.timesheet || {};
  const tf  = det.tsfin || {};
  const cw  = det.contract_week || {};

  const sheetScope =
    String(det.sheet_scope || mc.data?.sheet_scope || ts.sheet_scope || '').toUpperCase();

  const isWeekly = (sheetScope === 'WEEKLY');
  const isDaily  = (sheetScope === 'DAILY');

  const tsId =
    mc.data?.timesheet_id ||
    ts.timesheet_id ||
    det.current_timesheet_id ||
    null;

  const weekId =
    mc.data?.contract_week_id ||
    det.contract_week_id ||
    cw.id ||
    null;

  if (!isWeekly && !isDaily) {
    alert('This action is only available for Weekly or Daily timesheets.');
    return;
  }
  if (isWeekly && !weekId) {
    alert('Contract week id missing.');
    return;
  }
  if (isDaily && !tsId) {
    alert('Timesheet id missing.');
    return;
  }

  const locked = !!(tf.locked_by_invoice_id || tf.paid_at_utc);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Adjustment-exists pre-check
  // Weekly: via /api/contract-weeks?include_plan=true
  // Daily:  reliable via GET /api/timesheets/:id/adjustments (new backend)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let existingCount = 0;

  try {
    if (isWeekly) {
      const contractId =
        mc.data?.contract_id ||
        cw.contract_id ||
        ts.contract_id ||
        null;

      const weekEnding =
        mc.data?.week_ending_date ||
        cw.week_ending_date ||
        ts.week_ending_date ||
        mc.data?.contract_week_ending_date ||
        null;

      if (contractId && weekEnding && typeof authFetch === 'function' && typeof API === 'function') {
        const qs = new URLSearchParams();
        qs.set('contract_id', String(contractId));
        qs.set('week_ending_from', String(weekEnding));
        qs.set('week_ending_to', String(weekEnding));
        qs.set('include_plan', 'true');

        const res = await authFetch(API(`/api/contract-weeks?${qs.toString()}`));
        const rows = (typeof toList === 'function')
          ? await toList(res)
          : await res.json().catch(() => []);

        const list = Array.isArray(rows) ? rows : [];

        const isAdjBool = (v) => {
          if (v === true) return true;
          if (v === false) return false;
          if (v == null) return false;
          const s = String(v).trim().toLowerCase();
          return (s === 'true' || s === '1' || s === 'yes' || s === 'y' || s === 'on');
        };

        // Count ALL adjustment weeks for that contract+week (even if you're currently on one)
        existingCount = list.filter(w => w && isAdjBool(w.is_adjustment)).length;
      }
    } else if (isDaily) {
      if (typeof authFetch === 'function' && typeof API === 'function') {
        const res = await authFetch(API(`/api/timesheets/${encodeURIComponent(String(tsId))}/adjustments`));
        const txt = await res.text().catch(() => '');
        if (res.ok) {
          let j = null;
          try { j = txt ? JSON.parse(txt) : null; } catch { j = null; }
          const n = Number(j?.count ?? 0);
          existingCount = Number.isFinite(n) ? n : 0;
        } else {
          // Non-fatal: if the check fails, just skip the warning
          existingCount = 0;
        }
      }
    }
  } catch {
    // Non-fatal: if the check fails, just skip the warning
    existingCount = 0;
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Confirm prompts
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const baseOk = window.confirm(
    (isWeekly
      ? 'Add an additional manual timesheet for this week?\n\n'
      : 'Add an additional manual timesheet for this shift?\n\n'
    ) +
    'This creates a separate manual adjustment timesheet.\n' +
    'Use this for expenses or corrections without altering the original sheet.' +
    (locked ? '\n\nNote: the original sheet is locked (paid/invoiced). The adjustment will be separate.' : '')
  );
  if (!baseOk) return;

  if (existingCount > 0) {
    const ok2 = window.confirm(
      `Warning: ${existingCount} adjustment time(s) already exist for this ${isWeekly ? 'week' : 'shift'}.\n\n` +
      'Do you want to create another additional manual adjustment timesheet?'
    );
    if (!ok2) return;
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Create adjustment via backend
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let created = null;

  try {
    if (isWeekly) {
      created = await apiPostJson(
        `/api/contract-weeks/${encodeURIComponent(String(weekId))}/additional-weekly-adjustment`,
        {}
      );
    } else {
      created = await apiPostJson(
        `/api/timesheets/${encodeURIComponent(String(tsId))}/additional-daily-manual`,
        {}
      );
    }
  } catch (err) {
    // If you have moved-409 handling available, apply it
    try {
      if (typeof tsHandleMoved409Modal === 'function') {
        const handled = await tsHandleMoved409Modal(err, {
          tabKey: 'overview',
          toast: 'This timesheet changed while you were editing; review and try again.',
          label: 'add-additional-manual'
        });
        if (handled) return;
      }
    } catch {}

    alert(err?.message || 'Failed to create additional manual timesheet.');
    return;
  }

  const newId =
    (created && (created.current_timesheet_id || created.timesheet_id || created.new_timesheet_id || created.id))
      ? String(created.current_timesheet_id || created.timesheet_id || created.new_timesheet_id || created.id)
      : null;

  if (!newId) {
    alert('Created, but no timesheet id was returned.');
    return;
  }

  window.__toast && window.__toast('Additional manual timesheet created.');

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // âœ… Update expected_timesheet_id to the new timesheet (so any subsequent guarded writes target the new sheet)
  // (Even though we close + reopen, set it defensively for consistency.)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  try {
    window.modalCtx ||= {};
    window.modalCtx.data ||= {};
    window.modalCtx.timesheetMeta ||= {};

    window.modalCtx.data.timesheet_id = newId;
    window.modalCtx.data.id = newId;
    window.modalCtx.timesheetMeta.expected_timesheet_id = newId;
  } catch {}

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Close current modal, then open the new timesheet modal
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  try { byId('btnCloseModal')?.click(); } catch {}

  // Let the close settle
  await Promise.resolve();

  // Open new timesheet with a minimal row (openTimesheet will fetch full details)
  await openTimesheet({ timesheet_id: newId, id: newId });
}

async function tsModalAdoptTimesheetId(newId, opts) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][ROTATE][ADOPT]');
  GC('tsModalAdoptTimesheetId');

  const id = String(newId || '').trim();
  if (!id) {
    GE();
    return { ok: false };
  }

  const o = (opts && typeof opts === 'object') ? opts : {};
  const repaintTab = String(o.tabKey || '').trim() || null;

  try {
    window.modalCtx = window.modalCtx || {};
    window.modalCtx.data = window.modalCtx.data || {};

    window.modalCtx.data.timesheet_id = id;
    window.modalCtx.data.id = id;

    if (window.modalCtx.timesheetMeta && typeof window.modalCtx.timesheetMeta === 'object') {
      window.modalCtx.timesheetMeta.expected_timesheet_id = id;
      window.modalCtx.timesheetMeta.hasTs = true;
      window.modalCtx.timesheetMeta.isPlannedWeek = false;
    }

    if (window.modalCtx.timesheetDetails && typeof window.modalCtx.timesheetDetails === 'object') {
      const det = window.modalCtx.timesheetDetails;
      if (det.timesheet && typeof det.timesheet === 'object') {
        det.timesheet.timesheet_id = id;
      }
      det.current_timesheet_id = id;
    }
  } catch {}

  try {
    await refreshTimesheetsSummaryAfterRotation(id);
  } catch {}

  // Optional: refresh details from backend (best-effort)
  if (o.refreshDetails && typeof fetchTimesheetDetails === 'function') {
    try {
      const fresh = await fetchTimesheetDetails(id);
      window.modalCtx.timesheetDetails = fresh;
    } catch (e) {
      L('fetchTimesheetDetails failed (non-fatal)', e);
    }
  }

  // Optional: repaint current/target tab without clobbering staged state
  try {
    const fr = (typeof window.__getModalFrame === 'function') ? window.__getModalFrame() : null;
    if (fr && fr.entity === 'timesheets') {
      const key = repaintTab || fr.currentTabKey || 'overview';
      fr._suppressDirty = true;
      await fr.setTab(key);
      fr._suppressDirty = false;
      fr._updateButtons && fr._updateButtons();
    }
  } catch {}

  GE();
  return { ok: true, timesheet_id: id };
}


async function tsHandleMoved409Modal(err, opts) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][ROTATE][409]');
  GC('tsHandleMoved409Modal');

  const o = (opts && typeof opts === 'object') ? opts : {};
  const tabKey = String(o.tabKey || '').trim() || null;

  let moved = null;

  if (err && err.json && typeof err.json === 'object') {
    moved = err.json;
  }

  if (!moved) {
    try {
      const msg = String(err?.message || '');
      if (msg && msg.trim().startsWith('{')) moved = JSON.parse(msg);
    } catch {}
  }

  const isMoved =
    (err && err.status === 409) &&
    moved &&
    moved.error === 'TIMESHEET_MOVED' &&
    moved.current_timesheet_id;

  if (!isMoved) {
    GE();
    return false;
  }

  const newId = String(moved.current_timesheet_id || '').trim();
  if (!newId) {
    GE();
    return false;
  }

  try {
    await tsModalAdoptTimesheetId(newId, {
      tabKey: tabKey || 'overview',
      refreshDetails: true
    });
  } catch {}

  try {
    const toastMsg = String(o.toast || '').trim();
    if (toastMsg && typeof window.__toast === 'function') {
      window.__toast(toastMsg);
    }
  } catch {}

  GE();
  return true;
}


// Candidate calendar loader (Bookings tab)
// Safe to call on every tab switch; it will either build the scaffold or just refresh.
// Candidate calendar loader (Bookings tab)
// Safe to call on every tab switch; it will either build the scaffold or just refresh.



// ======== Manual weekly DRAFT upsert (contract weeks) ========
// Draft/manual week save path (must NOT create a timesheet):
//   POST /api/contract-weeks/:weekId/manual-draft-upsert
// Payload:
//   - actual_schedule_json (recommended; backend computes totals)
//   - optionally hours (fallback) / additional_units_week / day_references_json / qr_action
// Return:
//   - backend should return updated contract_week (recommended) or { hours } / similar

async function switchDailyTimesheetToManual(ctxOrId, expectedTimesheetId) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][SWITCH-DAILY->MANUAL]');
  GC('switchDailyTimesheetToManual');

  const mc  = window.modalCtx || {};
  const row = (mc.data && mc.data.timesheet_id) ? mc.data : (ctxOrId && ctxOrId.row ? ctxOrId.row : {});
  const tsId = (typeof ctxOrId === 'string') ? ctxOrId : (row.timesheet_id || row.id || mc.data?.id || null);

  if (!tsId) {
    L('ERROR: missing timesheetId');
    GE();
    throw new Error('switchDailyTimesheetToManual: timesheetId is required');
  }

  const expected =
    (expectedTimesheetId != null ? String(expectedTimesheetId) : '') ||
    (mc.timesheetMeta && mc.timesheetMeta.expected_timesheet_id) ||
    String(tsId);

  const encId   = encodeURIComponent(tsId);
  const urlPath = `/api/timesheets/${encId}/switch-daily-to-manual`;

  const payload = { expected_timesheet_id: expected };

  L('REQUEST', { url: API(urlPath), tsId, payload });

  // âœ… Use apiPostJson so 409 errors preserve err.status + err.json (TIMESHEET_MOVED)
  const json = await apiPostJson(urlPath, payload);

  const newId =
    (json && (json.current_timesheet_id || json.new_timesheet_id || json.timesheet_id))
      ? (json.current_timesheet_id || json.new_timesheet_id || json.timesheet_id)
      : null;

  const resolvedId = (newId && String(newId).trim()) ? String(newId) : String(tsId);

  // Adopt id + refresh details if this TS is open
  try {
    if (window.modalCtx && window.modalCtx.data) {
      const cur = window.modalCtx.data.timesheet_id || window.modalCtx.data.id || null;
      const isSame = String(cur || '') === String(tsId || '');

      if (isSame) {
        if (String(resolvedId) !== String(cur || '')) {
          window.modalCtx.data.timesheet_id = resolvedId;
          window.modalCtx.data.id = resolvedId;
        }

        try {
          window.modalCtx.data.submission_mode = 'MANUAL';
        } catch {}

        // keep meta aligned
        if (window.modalCtx.timesheetMeta && typeof window.modalCtx.timesheetMeta === 'object') {
          window.modalCtx.timesheetMeta.expected_timesheet_id = resolvedId;
          window.modalCtx.timesheetMeta.hasTs = true;
          window.modalCtx.timesheetMeta.sheetScope = 'DAILY';
          window.modalCtx.timesheetMeta.subMode = 'MANUAL';
          window.modalCtx.timesheetMeta.isPlannedWeek = false;
        }

        try {
          const fresh = await fetchTimesheetDetails(resolvedId);
          window.modalCtx.timesheetDetails = fresh;

          // also ensure the details copy reflects MANUAL
          try {
            if (window.modalCtx.timesheetDetails?.timesheet) {
              window.modalCtx.timesheetDetails.timesheet.submission_mode = 'MANUAL';
            }
          } catch {}
        } catch (e) {
          L('refresh details failed (non-fatal)', e);
        }
      }
    }
  } catch {}

  // Focus + summary refresh
  try {
    window.__pendingFocus = {
      section: 'timesheets',
      ids: [String(resolvedId)],
      primaryIds: [String(resolvedId)]
    };
  } catch {}

  try {
    if (typeof refreshTimesheetsSummaryAfterRotation === 'function') {
      await refreshTimesheetsSummaryAfterRotation(resolvedId);
    }
  } catch (e) {
    L('summary refresh failed (non-fatal)', e);
  }

  L('RESULT', { json, resolvedId });
  GE();
  return { ok: true, json, resolvedId };
}

async function switchContractWeekToElectronic(contractWeekId) {
  const LOGM = (typeof window.__LOG_MODAL === 'boolean') ? window.__LOG_MODAL : false;
  const L = (...a) => { if (LOGM) console.log('[TS][CW-SWITCH-ELEC]', ...a); };

  if (!contractWeekId) {
    throw new Error('switchContractWeekToElectronic: contractWeekId is required');
  }

  const enc = encodeURIComponent(String(contractWeekId));
  const url = API(`/api/contract-weeks/${enc}/switch-mode`);

  L('REQUEST', { url, contractWeekId });

  let res;
  let text = '';
  try {
    res = await authFetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ submission_mode_snapshot: 'ELECTRONIC' })
    });
    text = await res.text().catch(() => '');
  } catch (err) {
    L('network error', err);
    throw err;
  }

  if (!res.ok) {
    L('server error', { status: res.status, bodyPreview: (text || '').slice(0, 400) });
    throw new Error(text || 'Failed to switch contract week to ELECTRONIC');
  }

  let json = null;
  try { json = text ? JSON.parse(text) : null; } catch { json = null; }

  L('RESULT', json);
  return json;
}


async function contractWeekManualDraftUpsert(weekId, payload) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][MANUAL-DRAFT-UPsert]');
  GC('contractWeekManualDraftUpsert');

  if (!weekId) {
    GE();
    throw new Error('contractWeekManualDraftUpsert: weekId is required');
  }

  const normaliseScheduleField = (x) => {
    if (x == null) return x;
    if (Array.isArray(x) || typeof x === 'object') return x;
    if (typeof x === 'string') {
      try {
        const p = JSON.parse(x);
        if (Array.isArray(p) || typeof p === 'object') return p;
      } catch {}
    }
    return x;
  };

  const safePayload = { ...(payload || {}) };

  if (Object.prototype.hasOwnProperty.call(safePayload, 'actual_schedule_json')) {
    safePayload.actual_schedule_json = normaliseScheduleField(safePayload.actual_schedule_json);
  }

  // âœ… Schedule-driven payload is authoritative; do not rely on hours-only.
  // If schedule is present, drop legacy hours if the caller accidentally included them.
  if (safePayload.actual_schedule_json != null) {
    if (Object.prototype.hasOwnProperty.call(safePayload, 'hours')) {
      delete safePayload.hours;
    }
  }

  const encId   = encodeURIComponent(weekId);
  const urlPath = `/api/contract-weeks/${encId}/manual-draft-upsert`;

  L('REQUEST', { url: API(urlPath), weekId, payload: safePayload });

  // Use apiPostJson for consistent error shape + status handling
  const json = await apiPostJson(urlPath, safePayload);

  L('RESULT', json);
  GE();
  return json;
}


async function loadCandidateCalendar(holder, candidateId, opts) {
  try {
    if (!holder) return;
    if (!candidateId) {
      holder.innerHTML = `<div class="hint">No candidate selected.</div>`;
      return;
    }

    // Ensure the expected mount id exists (renderCandidateCalendarTab uses this id)
    if (holder.id !== 'candidateCalendarHolder') {
      try { holder.id = 'candidateCalendarHolder'; } catch {}
    }

    // Ensure state container exists
    window.__calState = window.__calState || {};

    // If scaffold already exists, just refresh; otherwise create it.
    const hasScaffold =
      !!byId('__candCalScroll') &&
      !!byId('__candCal') &&
      !!byId('__candCalLegend') &&
      !!byId('__candCalContracts');

    if (!hasScaffold) {
      // Fast visual feedback while the tab loads
      holder.innerHTML = `<div class="hint">Loading calendarâ€¦</div>`;

      if (typeof renderCandidateCalendarTab === 'function') {
        await renderCandidateCalendarTab(candidateId);
      } else {
        holder.innerHTML = `<div class="hint">Calendar renderer not available.</div>`;
        return;
      }
    }

    // Refresh
    if (typeof fetchAndRenderCandidateCalendar === 'function') {
      if (opts && opts.from && opts.to) {
        // explicit window request
        await fetchAndRenderCandidateCalendar(candidateId, opts);
      } else {
        // default: reuse cached feed if requested, otherwise refetch
        const reuse = !!(opts && opts._reuseLast);
        await fetchAndRenderCandidateCalendar(candidateId, { _reuseLast: reuse });
      }
    }
  } catch (e) {
    try { console.warn('[CAL][candidate] load failed', e); } catch {}
    try { holder.innerHTML = `<div class="hint">Failed to load calendar.</div>`; } catch {}
  }
}

// Selection state helpers â€” simplified to explicit IDs only

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// IDs-only selection helpers (single source of truth: Set of selected IDs)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function openImportColumnAliasesModal(opts) {
  // âœ… FIX: ensure we have a local HTML-escape helper in this closure
  // (prevents "ReferenceError: enc is not defined")
  const enc = (typeof escapeHtml === 'function')
    ? escapeHtml
    : (x) => String(x || '')
        .replaceAll('&','&amp;')
        .replaceAll('<','&lt;')
        .replaceAll('>','&gt;')
        .replaceAll('"','&quot;')
        .replaceAll("'",'&#39;');

  const seed = (opts && typeof opts === 'object') ? opts : {};
  const initSystem = String(seed.system_type || 'NHSP').toUpperCase();
  const initField  = String(seed.field_key   || 'ASSIGNMENT').toUpperCase();

  // Local modal state (kept in closure; no persistence needed)
  const state = {
    system_type: (['NHSP','HR_WEEKLY','HR_DAILY'].includes(initSystem) ? initSystem : 'NHSP'),
    field_key:   (['ASSIGNMENT','GRADE'].includes(initField) ? initField : 'ASSIGNMENT'),
    include_inactive: !!seed.include_inactive,
    rows: [],
    loading: false,
    error: '',
    // add form
    add_alias_name: '',
    add_notes: '',
    add_active: true,
    // edit panel
    editing: null,   // row object
    edit_alias_name: '',
    edit_notes: '',
    edit_active: true
  };

  const kind = 'import-summary-import-column-aliases';

  const renderTab = () => {
    const sys = state.system_type;
    const fk  = state.field_key;

    const listBody = (state.rows && state.rows.length)
      ? state.rows.map(r => {
          const id    = r.id || '';
          const alias = (r.alias_name || '').toString();
          const notes = (r.notes || '').toString();
          const active = (r.active !== false);

          const pill = active ? 'pill-ok' : 'pill-warn';
          const pillTxt = active ? 'ACTIVE' : 'INACTIVE';

          return `
            <tr data-id="${enc(id)}" class="ica-row">
              <td><span class="mini mono">${enc(alias || 'â€”')}</span></td>
              <td>
                <span class="pill ${pill}" style="padding:2px 8px; font-size:12px;">${enc(pillTxt)}</span>
              </td>
              <td>
                <span class="mini" style="white-space: normal; word-break: break-word; display:inline-block; max-width:320px;">
                  ${enc(notes || '')}
                </span>
              </td>
              <td style="white-space:nowrap;">
                <button type="button" class="btn mini" data-act="ica-edit" data-id="${enc(id)}">Edit</button>
                <button type="button" class="btn mini" style="margin-left:4px;" data-act="ica-toggle" data-id="${enc(id)}">
                  ${active ? 'Disable' : 'Enable'}
                </button>
                <button type="button" class="btn mini" style="margin-left:4px;" data-act="ica-delete" data-id="${enc(id)}">
                  Remove
                </button>
              </td>
            </tr>
          `;
        }).join('')
      : `
        <tr>
          <td colspan="4">
            <span class="mini">${state.loading ? 'Loadingâ€¦' : 'No aliases found for this filter.'}</span>
          </td>
        </tr>
      `;

    const errHtml = state.error
      ? `<div class="hint" style="color:#ffb4b4;">${enc(state.error)}</div>`
      : '';

    const editOpen = !!state.editing;

    return `
      <div class="form" id="importColumnAliasesModal">
        <div class="card">
          <div class="row">
            <label>Filters</label>
            <div class="controls" style="display:flex;gap:8px;flex-wrap:wrap;align-items:center;">
              <select class="input" id="ica_system" style="max-width:220px;">
                <option value="NHSP" ${sys==='NHSP'?'selected':''}>NHSP</option>
                <option value="HR_WEEKLY" ${sys==='HR_WEEKLY'?'selected':''}>HR weekly</option>
                <option value="HR_DAILY" ${sys==='HR_DAILY'?'selected':''}>HR daily</option>
              </select>

              <select class="input" id="ica_field" style="max-width:220px;">
                <option value="ASSIGNMENT" ${fk==='ASSIGNMENT'?'selected':''}>ASSIGNMENT (NHSP)</option>
                <option value="GRADE" ${fk==='GRADE'?'selected':''}>GRADE (HR)</option>
              </select>

              <label class="mini" style="display:flex;gap:6px;align-items:center;">
                <input type="checkbox" id="ica_include_inactive" ${state.include_inactive ? 'checked' : ''}/>
                Show inactive
              </label>

              <button type="button" class="btn" id="ica_refresh" ${state.loading ? 'disabled' : ''}>
                Refresh
              </button>

              <span class="mini" style="opacity:.85;">
                ${state.loading ? 'Loadingâ€¦' : `${(state.rows||[]).length} row(s)`}
              </span>
            </div>
          </div>
          ${errHtml}
        </div>

        <div class="card" style="margin-top:10px;">
          <div class="row">
            <label>Add alias</label>
            <div class="controls" style="display:flex;gap:8px;flex-wrap:wrap;align-items:flex-start;">
              <div style="min-width:260px;flex:1;">
                <div class="mini" style="margin-bottom:4px;">Alias name</div>
                <input class="input" id="ica_add_alias" type="text" placeholder="e.g. Assignment, Request Grade, Gradeâ€¦" value="${enc(state.add_alias_name||'')}" />
              </div>

              <div style="min-width:260px;flex:2;">
                <div class="mini" style="margin-bottom:4px;">Notes (optional)</div>
                <input class="input" id="ica_add_notes" type="text" placeholder="Optional noteâ€¦" value="${enc(state.add_notes||'')}" />
              </div>

              <div style="min-width:140px;">
                <div class="mini" style="margin-bottom:4px;">Active</div>
                <label class="mini" style="display:flex;gap:6px;align-items:center;">
                  <input type="checkbox" id="ica_add_active" ${state.add_active ? 'checked' : ''}/>
                  Active
                </label>
              </div>

              <div style="min-width:140px;padding-top:18px;">
                <button type="button" class="btn btn-primary" id="ica_add_save" ${state.loading ? 'disabled' : ''}>
                  Add
                </button>
              </div>
            </div>
          </div>
        </div>

        <div class="card" style="margin-top:10px; display:${editOpen ? '' : 'none'};" id="ica_edit_card">
          <div class="row">
            <label>Edit alias</label>
            <div class="controls" style="display:flex;gap:8px;flex-wrap:wrap;align-items:flex-start;">
              <div class="mini" style="width:100%;">
                Editing ID: <span class="mono" id="ica_edit_id">${enc(state.editing?.id || '')}</span>
              </div>

              <div style="min-width:260px;flex:1;">
                <div class="mini" style="margin-bottom:4px;">Alias name</div>
                <input class="input" id="ica_edit_alias" type="text" value="${enc(state.edit_alias_name||'')}" />
              </div>

              <div style="min-width:260px;flex:2;">
                <div class="mini" style="margin-bottom:4px;">Notes</div>
                <input class="input" id="ica_edit_notes" type="text" value="${enc(state.edit_notes||'')}" />
              </div>

              <div style="min-width:140px;">
                <div class="mini" style="margin-bottom:4px;">Active</div>
                <label class="mini" style="display:flex;gap:6px;align-items:center;">
                  <input type="checkbox" id="ica_edit_active" ${state.edit_active ? 'checked' : ''}/>
                  Active
                </label>
              </div>

              <div style="min-width:220px;padding-top:18px;">
                <button type="button" class="btn btn-primary" id="ica_edit_save" ${state.loading ? 'disabled' : ''}>
                  Save changes
                </button>
                <button type="button" class="btn" id="ica_edit_cancel" style="margin-left:6px;">
                  Cancel
                </button>
              </div>
            </div>
          </div>
        </div>

        <div class="card" style="margin-top:10px;">
          <div class="row">
            <label>Aliases</label>
            <div class="controls">
              <table class="grid">
                <thead>
                  <tr>
                    <th>Alias</th>
                    <th>Active</th>
                    <th>Notes</th>
                    <th>Actions</th>
                  </tr>
                </thead>
                <tbody id="ica_tbody">
                  ${listBody}
                </tbody>
              </table>
              <div class="hint">
                These aliases are used by the parsers to find the correct column even if the supplier renames headers.
              </div>
            </div>
          </div>
        </div>
      </div>
    `;
  };

  const loadList = async () => {
    state.loading = true;
    state.error = '';
    try {
      repaint();
      const rows = await apiListImportColumnAliases({
        system_type: state.system_type,
        field_key: state.field_key,
        include_inactive: state.include_inactive
      });
      state.rows = Array.isArray(rows) ? rows : [];
    } catch (e) {
      state.rows = [];
      state.error = e?.message || String(e);
    } finally {
      state.loading = false;
      repaint();
    }
  };

  const startEdit = (row) => {
    if (!row) return;
    state.editing = row;
    state.edit_alias_name = (row.alias_name || '').toString();
    state.edit_notes = (row.notes || '').toString();
    state.edit_active = (row.active !== false);
    repaint();
  };

  const cancelEdit = () => {
    state.editing = null;
    state.edit_alias_name = '';
    state.edit_notes = '';
    state.edit_active = true;
    repaint();
  };

  const repaint = () => {
    const fr = window.__getModalFrame?.();
    if (!fr) return;
    // Re-render the only tab to reflect state changes
    try { fr.setTab(fr.currentTabKey || 'p'); } catch {}
    // Re-run wiring after repaint (setTab re-writes DOM)
    try {
      const fr2 = window.__getModalFrame?.();
      if (fr2 && typeof fr2.onReturn === 'function') fr2.onReturn();
    } catch {}
  };

  const onReturn = () => {
    const root = document.getElementById('importColumnAliasesModal');
    if (!root) return;

    const selSystem = document.getElementById('ica_system');
    const selField  = document.getElementById('ica_field');
    const chkInact  = document.getElementById('ica_include_inactive');
    const btnRef    = document.getElementById('ica_refresh');

    const addAlias  = document.getElementById('ica_add_alias');
    const addNotes  = document.getElementById('ica_add_notes');
    const addAct    = document.getElementById('ica_add_active');
    const addSave   = document.getElementById('ica_add_save');

    const editAlias = document.getElementById('ica_edit_alias');
    const editNotes = document.getElementById('ica_edit_notes');
    const editAct   = document.getElementById('ica_edit_active');
    const editSave  = document.getElementById('ica_edit_save');
    const editCancel= document.getElementById('ica_edit_cancel');

    if (selSystem && !selSystem.__icaWired) {
      selSystem.__icaWired = true;
      selSystem.addEventListener('change', () => {
        state.system_type = String(selSystem.value || 'NHSP').toUpperCase();
        cancelEdit();
        loadList();
      });
    }

    if (selField && !selField.__icaWired) {
      selField.__icaWired = true;
      selField.addEventListener('change', () => {
        state.field_key = String(selField.value || 'ASSIGNMENT').toUpperCase();
        cancelEdit();
        loadList();
      });
    }

    if (chkInact && !chkInact.__icaWired) {
      chkInact.__icaWired = true;
      chkInact.addEventListener('change', () => {
        state.include_inactive = !!chkInact.checked;
        cancelEdit();
        loadList();
      });
    }

    if (btnRef && !btnRef.__icaWired) {
      btnRef.__icaWired = true;
      btnRef.addEventListener('click', () => loadList());
    }

    if (addAlias && !addAlias.__icaWired) {
      addAlias.__icaWired = true;
      addAlias.addEventListener('input', () => { state.add_alias_name = String(addAlias.value || ''); });
      addAlias.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          const btn = document.getElementById('ica_add_save');
          if (btn && !btn.disabled) btn.click();
        }
      });
    }
    if (addNotes && !addNotes.__icaWired) {
      addNotes.__icaWired = true;
      addNotes.addEventListener('input', () => { state.add_notes = String(addNotes.value || ''); });
    }
    if (addAct && !addAct.__icaWired) {
      addAct.__icaWired = true;
      addAct.addEventListener('change', () => { state.add_active = !!addAct.checked; });
    }

    if (addSave && !addSave.__icaWired) {
      addSave.__icaWired = true;
      addSave.addEventListener('click', async () => {
        const aliasName = String(state.add_alias_name || '').trim();
        if (!aliasName) {
          alert('Alias name is required.');
          return;
        }
        try {
          state.loading = true;
          state.error = '';
          repaint();

          await apiCreateImportColumnAlias({
            system_type: state.system_type,
            field_key: state.field_key,
            alias_name: aliasName,
            active: !!state.add_active,
            notes: String(state.add_notes || '').trim() || null
          });

          window.__toast && window.__toast('Alias added.');
          state.add_alias_name = '';
          state.add_notes = '';
          state.add_active = true;

          await loadList();
        } catch (e) {
          state.error = e?.message || String(e);
          state.loading = false;
          repaint();
          alert(state.error);
        }
      });
    }

    if (editAlias && !editAlias.__icaWired) {
      editAlias.__icaWired = true;
      editAlias.addEventListener('input', () => { state.edit_alias_name = String(editAlias.value || ''); });
    }
    if (editNotes && !editNotes.__icaWired) {
      editNotes.__icaWired = true;
      editNotes.addEventListener('input', () => { state.edit_notes = String(editNotes.value || ''); });
    }
    if (editAct && !editAct.__icaWired) {
      editAct.__icaWired = true;
      editAct.addEventListener('change', () => { state.edit_active = !!editAct.checked; });
    }

    if (editSave && !editSave.__icaWired) {
      editSave.__icaWired = true;
      editSave.addEventListener('click', async () => {
        if (!state.editing || !state.editing.id) return;
        const id = state.editing.id;

        const aliasName = String(state.edit_alias_name || '').trim();
        if (!aliasName) {
          alert('Alias name is required.');
          return;
        }

        try {
          state.loading = true;
          state.error = '';
          repaint();

          await apiUpdateImportColumnAlias(id, {
            alias_name: aliasName,
            notes: String(state.edit_notes || '').trim() || null,
            active: !!state.edit_active
          });

          window.__toast && window.__toast('Alias updated.');
          cancelEdit();
          await loadList();
        } catch (e) {
          state.error = e?.message || String(e);
          state.loading = false;
          repaint();
          alert(state.error);
        }
      });
    }

    if (editCancel && !editCancel.__icaWired) {
      editCancel.__icaWired = true;
      editCancel.addEventListener('click', () => cancelEdit());
    }

    // Row actions (Edit / Toggle / Remove)
    if (!root.__icaWiredTable) {
      root.__icaWiredTable = true;
      root.addEventListener('click', async (ev) => {
        const btn = ev.target.closest('button[data-act]');
        if (!btn) return;

        const act = btn.getAttribute('data-act');
        const id  = btn.getAttribute('data-id');

        if (!id) return;

        const row = (state.rows || []).find(x => String(x.id) === String(id)) || null;

        if (act === 'ica-edit') {
          startEdit(row);
          return;
        }

        if (act === 'ica-toggle') {
          if (!row) return;
          const next = !(row.active !== false);
          try {
            state.loading = true;
            state.error = '';
            repaint();

            await apiUpdateImportColumnAlias(id, { active: next });

            window.__toast && window.__toast(next ? 'Alias enabled.' : 'Alias disabled.');
            cancelEdit();
            await loadList();
          } catch (e) {
            state.error = e?.message || String(e);
            state.loading = false;
            repaint();
            alert(state.error);
          }
          return;
        }

        if (act === 'ica-delete') {
          const ok = window.confirm('Remove this alias? (It will be deactivated for safety)');
          if (!ok) return;

          try {
            state.loading = true;
            state.error = '';
            repaint();

            await apiDeleteImportColumnAlias(id);

            window.__toast && window.__toast('Alias removed.');
            cancelEdit();
            await loadList();
          } catch (e) {
            state.error = e?.message || String(e);
            state.loading = false;
            repaint();
            alert(state.error);
          }
          return;
        }
      });
    }
  };

  // Utility modal: Close-only, no Save/Edit buttons in header.
  // We also ensure it never gates the parent.
  showModal(
    'Import Column Aliases',
    [{ key: 'p', title: 'Aliases' }],
    () => renderTab(),
    async () => true,
    false,
    onReturn,
    { kind, noParentGate: true }
  );

  // Initial onReturn + initial load (same â€œpost-render kickâ€ pattern used by pickers)
  setTimeout(() => {
    try {
      const fr = window.__getModalFrame?.();
      if (fr && fr.kind === kind && typeof fr.onReturn === 'function' && !fr.__icaInit) {
        fr.__icaInit = true;
        fr.onReturn();
        loadList();
      }
    } catch (e) {
      console.warn('[IMPORT_COL_ALIASES] init failed', e);
    }
  }, 0);
}


function renderTimesheetAuditTab(ctx) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][AUDIT][TAB]');
  const { row, details } = normaliseTimesheetCtx(ctx);

  GC('render');

  const ts    = details.timesheet || {};
  const tsId  = ts.timesheet_id || row.timesheet_id || null;
  const enc   = (typeof escapeHtml === 'function') ? escapeHtml : (s)=>String(s ?? '');

  const mc = window.modalCtx || {};
  const cache = (mc.timesheetAuditCache && typeof mc.timesheetAuditCache === 'object')
    ? mc.timesheetAuditCache
    : {};
  const items = (tsId && cache[String(tsId)]) ? cache[String(tsId)] : null;

  const fmtUkDateTime = (iso) => {
    if (!iso) return '';
    const d = new Date(iso);
    if (Number.isNaN(d.getTime())) return enc(iso);
    return enc(d.toLocaleString('en-GB', {
      timeZone: 'Europe/London',
      weekday: 'short',
      day: '2-digit',
      month: 'short',
      year: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
      hour12: false
    }).replace(',', ''));
  };

  const fmtJsonInline = (v, maxLen = 260) => {
    if (v == null) return '';
    try {
      let s = '';
      if (typeof v === 'string') {
        s = v.trim();
      } else {
        s = JSON.stringify(v);
      }
      if (!s) return '';
      if (s.length <= maxLen) return enc(s);
      return enc(s.slice(0, maxLen) + 'â€¦');
    } catch {
      return enc(String(v));
    }
  };

  // RPC returns fixed columns:
  // id, ts_utc, object_type, object_id_text, action, reason, actor_user_id,
  // actor_display, actor_role_at_time, before_json, after_json, correlation_id
  const actorLabel = (it) => {
    const a =
      it?.actor_display ||
      it?.actor_user_id ||
      null;
    return a ? enc(String(a)) : 'â€”';
  };

  const actorRoleLabel = (it) => {
    const r = it?.actor_role_at_time || null;
    return r ? enc(String(r)) : 'â€”';
  };

  const eventLabel = (it) => {
    const e = it?.action || 'EVENT';
    return enc(String(e));
  };

  const timeLabel = (it) => {
    const t = it?.ts_utc || null;
    return fmtUkDateTime(t) || 'â€”';
  };

  const objectLabel = (it) => {
    const ot = it?.object_type ? String(it.object_type) : '';
    const oid = it?.object_id_text ? String(it.object_id_text) : '';
    if (!ot && !oid) return 'â€”';
    if (oid && oid.length > 12) return enc(`${ot}:${oid.slice(0, 8)}â€¦`);
    return enc(`${ot}:${oid}`);
  };

  const reasonLabel = (it) => {
    const s = it?.reason || '';
    return enc(String(s || ''));
  };

  const beforeJson = (it) => it?.before_json ?? null;
  const afterJson  = (it) => it?.after_json  ?? null;

  const hasTs = !!tsId;

  const headerHtml = `
    <div class="card">
      <div class="row">
        <label>Audit</label>
        <div class="controls">
          <div class="mini">
            Timesheet ID: <strong>${hasTs ? enc(tsId) : 'â€”'}</strong>
          </div>
          <div class="mini" style="margin-top:4px;color:#aaa;">
            Read-only log from audit_events (timesheet + linked contract_week where applicable).
          </div>
        </div>
      </div>
    </div>
  `;

  if (!hasTs) {
    GE();
    return `
      <div class="tabc">
        ${headerHtml}
        <div class="card" style="margin-top:10px;">
          <div class="row">
            <label>Events</label>
            <div class="controls">
              <span class="mini">No timesheet exists yet for this planned week, so there is no audit feed.</span>
            </div>
          </div>
        </div>
      </div>
    `;
  }

  if (!items) {
    GE();
    return `
      <div class="tabc">
        ${headerHtml}
        <div class="card" style="margin-top:10px;">
          <div class="row">
            <label>Events</label>
            <div class="controls">
              <span class="mini">Loading audit eventsâ€¦</span>
              <div class="mini" style="margin-top:6px;color:#888;">
                If this does not load, click the Audit tab again.
              </div>
            </div>
          </div>
        </div>
      </div>
    `;
  }

  if (!Array.isArray(items) || items.length === 0) {
    GE();
    return `
      <div class="tabc">
        ${headerHtml}
        <div class="card" style="margin-top:10px;">
          <div class="row">
            <label>Events</label>
            <div class="controls">
              <span class="mini">No audit events found for this timesheet.</span>
            </div>
          </div>
        </div>
      </div>
    `;
  }

  const rowsHtml = items.map((it) => {
    const t    = timeLabel(it);
    const ev   = eventLabel(it);
    const who  = actorLabel(it);
    const role = actorRoleLabel(it);
    const obj  = objectLabel(it);

    const reason = reasonLabel(it);

    const corr = it?.correlation_id ? String(it.correlation_id) : '';
    const corrShort = corr ? (corr.length > 16 ? `${corr.slice(0, 16)}â€¦` : corr) : '';

    // Show before/after as compact snippets
    const beforeStr = fmtJsonInline(beforeJson(it), 220);
    const afterStr  = fmtJsonInline(afterJson(it),  220);

    return `
      <tr>
        <td class="mini" style="white-space:nowrap;">${t}</td>
        <td class="mini" style="white-space:nowrap;"><strong>${ev}</strong></td>
        <td class="mini" style="white-space:nowrap;">${who}</td>
        <td class="mini" style="white-space:nowrap;">${role}</td>
        <td class="mini" style="white-space:nowrap;">${obj}</td>
        <td class="mini">${reason || '<span style="color:#777;">â€”</span>'}</td>
        <td class="mini">
          ${beforeStr ? `<code style="white-space:pre-wrap;">${beforeStr}</code>` : '<span style="color:#777;">â€”</span>'}
        </td>
        <td class="mini">
          ${afterStr ? `<code style="white-space:pre-wrap;">${afterStr}</code>` : '<span style="color:#777;">â€”</span>'}
        </td>
        <td class="mini" style="white-space:nowrap;">
          ${corrShort ? `<code>${enc(corrShort)}</code>` : '<span style="color:#777;">â€”</span>'}
        </td>
      </tr>
    `;
  }).join('');

  const tableHtml = `
    <div class="card" style="margin-top:10px;">
      <div class="row">
        <label>Events</label>
        <div class="controls" style="overflow:auto;">
          <table class="tbl" style="width:100%;min-width:1200px;">
            <thead>
              <tr>
                <th class="mini">When</th>
                <th class="mini">Action</th>
                <th class="mini">Actor</th>
                <th class="mini">Role</th>
                <th class="mini">Object</th>
                <th class="mini">Reason</th>
                <th class="mini">Before</th>
                <th class="mini">After</th>
                <th class="mini">Corr</th>
              </tr>
            </thead>
            <tbody>
              ${rowsHtml}
            </tbody>
          </table>
          <div class="mini" style="margin-top:8px;color:#888;">
            Showing ${items.length} event${items.length === 1 ? '' : 's'}.
          </div>
        </div>
      </div>
    </div>
  `;

  GE();
  return `
    <div class="tabc">
      ${headerHtml}
      ${tableHtml}
    </div>
  `;
}


















async function openTimesheetsResolveModal(selectedRows) {
  const rowsIn = Array.isArray(selectedRows) ? selectedRows : [];
  const ids = rowsIn
    .map(r => String(r.timesheet_id || r.id || ''))
    .filter(Boolean);

  if (!ids.length) {
    console.warn('[TS][RESOLVE] openTimesheetsResolveModal called with no ids');
    return;
  }

  let rows = [];
  try {
    const res = await authFetch(API('/api/timesheets/resolve-preview'), {
      method: 'POST',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify({ timesheet_ids: ids })
    });
    const text = await res.text();
    if (!res.ok) {
      throw new Error(text || `Failed to load resolve preview (${res.status})`);
    }
    rows = text ? JSON.parse(text) : [];
    if (!Array.isArray(rows)) rows = [];
  } catch (err) {
    console.error('[TS][RESOLVE] failed to fetch resolve-preview', err);
    alert(err?.message || 'Failed to load resolve preview.');
    return;
  }

  // Keep state globally so child modals (candidate/client resolve) can refresh
  window.__resolveTimesheetsState = {
    rows,
    selectionIds: ids
  };

  // Show a simple modal with a single "Resolve" tab
  showModal(
    'Resolve timesheets',
    [{ key: 'main', label: 'Resolve' }],
    (key) => {
      if (key !== 'main') return '';
      return renderTimesheetsResolveModal(window.__resolveTimesheetsState || { rows: [] });
    },
    null,               // no onSave
    false,              // hasId
    null,               // onReturn
    {
      kind: 'timesheets-resolve',
      noParentGate: true,    // editing aliases shouldn't be gated by parent mode
      stayOpenOnSave: false  // there is no save, just close/child actions
    }
  );
}
function renderTimesheetsResolveModal(state) {
  const enc = (typeof escapeHtml === 'function')
    ? escapeHtml
    : (s) => String(s == null ? '' : s);

  const rows = state && Array.isArray(state.rows) ? state.rows : [];

  // Build a human label from candidate_hint_text (if present + object)
  const hintLabelFor = (r) => {
    const h = r && r.candidate_hint_text;
    if (!h || typeof h !== 'object' || Array.isArray(h)) return null;

    const first = String(h.first_name || h.firstname || '').trim();
    const sur   = String(h.surname || h.last_name || h.lastname || '').trim();
    const disp  = String(h.display_name || '').trim();
    const email = String(h.email || '').trim();

    const name =
      (first || sur) ? `${first} ${sur}`.trim()
      : (disp ? disp : '');

    const bits = [];
    if (name)  bits.push(name);
    if (email) bits.push(email);

    const primary = bits.join(' â€¢ ').trim();
    if (!primary) return null;

    return primary;
  };

  const rowsHtml = rows.length
    ? rows.map((r, idx) => {
        const scope  = (r.sheet_scope || '').toUpperCase();
        const weYmd  = r.week_ending_date || r.worked_date || r.date_ymd || '';
        const occ    = r.occupant_key_norm || '';
        const hosp   = r.hospital_norm || '';
        const pRaw   = r.processing_status || '';
        const p      = String(pRaw || '').toUpperCase();

        let pillCls = 'pill-info';
        if (p === 'UNASSIGNED' || p === 'CLIENT_UNRESOLVED') pillCls = 'pill-bad';
        else if (p === 'READY_FOR_HR') pillCls = 'pill-warn';
        else if (p === 'READY_FOR_INVOICE') pillCls = 'pill-ok';

        const canAssignCand   = (p === 'UNASSIGNED');
        const canAssignClient = (p === 'CLIENT_UNRESOLVED');

        // âœ… Display: show hint when UNASSIGNED and hint available; otherwise show occupant_key_norm
        // âœ… DO NOT show the long Global Key as a secondary line
        const hintLabel = canAssignCand ? hintLabelFor(r) : null;
        const rotaNameHtml = hintLabel
          ? `<div class="mini" style="white-space:normal;word-break:break-word;">${enc(hintLabel)}</div>`
          : `<span class="mini" style="white-space:normal;word-break:break-word;">${occ ? enc(occ) : 'â€”'}</span>`;

        // âœ… Buttons: stack vertically and constrain width so they never overflow the table cell
        const resolveBtnsHtml = `
          <div style="display:flex;flex-direction:column;gap:6px;align-items:stretch;min-width:170px;max-width:220px;">
            ${
              canAssignCand
                ? `<button type="button"
                           class="btn mini"
                           style="width:100%;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;"
                           onclick="openResolveCandidatePicker && openResolveCandidatePicker((window.__resolveTimesheetsState||{}).rows[${idx}])">
                     Assign candidateâ€¦
                   </button>`
                : ''
            }
            ${
              canAssignClient
                ? `<button type="button"
                           class="btn mini"
                           style="width:100%;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;"
                           onclick="openResolveClientPicker && openResolveClientPicker((window.__resolveTimesheetsState||{}).rows[${idx}])">
                     Assign clientâ€¦
                   </button>`
                : ''
            }
          </div>
        `;

        return `
          <tr>
            <td><span class="mini">${enc(scope || 'â€”')}</span></td>
            <td><span class="mini">${weYmd ? enc(weYmd) : 'â€”'}</span></td>
            <td>${rotaNameHtml}</td>
            <td><span class="mini" style="white-space:normal;word-break:break-word;">${hosp ? enc(hosp) : 'â€”'}</span></td>
            <td>
              <span class="pill ${pillCls}" style="white-space:nowrap;">${p ? enc(p) : 'UNKNOWN'}</span>
            </td>
            <td>
              ${resolveBtnsHtml}
            </td>
          </tr>
        `;
      }).join('')
    : `
      <tr>
        <td colspan="6">
          <span class="mini">No timesheets in this selection require candidate/client resolution.</span>
        </td>
      </tr>
    `;

  // âœ… Make the modal body wider by using an inner wrapper with a min-width.
  // This avoids relying on global modal sizing/CSS.
  return html(`
    <div class="form" id="ts-resolve-wrapper">
      <div style="min-width: 980px; max-width: 1200px;">
        <div class="card">
          <div class="row">
            <label>Resolve timesheets</label>
            <div class="controls">
              <span class="mini">
                Use this screen to fix unassigned candidates and unresolved clients
                by teaching the system how rota/HR names map to database records.
              </span>
            </div>
          </div>
        </div>

        <div class="card" style="margin-top:10px;">
          <div class="row">
            <label>Timesheets</label>
            <div class="controls">
              <div style="overflow-x:auto;">
                <table class="grid" style="min-width: 980px;">
                  <thead>
                    <tr>
                      <th style="width:90px;">Scope</th>
                      <th style="width:130px;">Week ending / Date</th>
                      <th>Rota name</th>
                      <th style="width:160px;">Rota hospital</th>
                      <th style="width:140px;">Status</th>
                      <th style="width:220px;">Resolve</th>
                    </tr>
                  </thead>
                  <tbody>
                    ${rowsHtml}
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </div>

      </div>
    </div>
  `);
}

// Wire up the "Close" button once the modal is rendered
(function wireTsResolveCloseButtonOnce() {
  // This will be re-run on each tab render, so guard with a small timeout
  setTimeout(() => {
    try {
      const btn = document.getElementById('btnTsResolveClose');
      if (btn && !btn.__tsResolveWired) {
        btn.__tsResolveWired = true;
        btn.addEventListener('click', () => {
          const closeBtn = document.getElementById('btnCloseModal');
          if (closeBtn) closeBtn.click();
        });
      }
    } catch (e) {
      console.warn('[TS][RESOLVE] failed wiring Close button', e);
    }
  }, 0);
})();



// Wrapper: use contract-style candidate picker with hint-seeded suggestions
async function openResolveCandidatePicker(resolveRow) {
  if (!resolveRow || !resolveRow.timesheet_id) {
    alert('Timesheet context missing for resolve.');
    return;
  }
  if (typeof openCandidatePicker !== 'function') {
    alert('Candidate picker is not available.');
    return;
  }

  const tsId = String(resolveRow.timesheet_id || '').trim();
  const hint = (resolveRow && resolveRow.candidate_hint_text && typeof resolveRow.candidate_hint_text === 'object' && !Array.isArray(resolveRow.candidate_hint_text))
    ? resolveRow.candidate_hint_text
    : null;

  // Context block for the picker (optional)
  const ctx = {
    staffName: (() => {
      if (!hint) return (resolveRow.occupant_key_norm || resolveRow.candidate_name || '(unknown)');
      const first = String(hint.first_name || hint.firstname || '').trim();
      const sur   = String(hint.surname || hint.last_name || hint.lastname || '').trim();
      const disp  = String(hint.display_name || '').trim();
      const email = String(hint.email || '').trim();
      const name  = (first || sur) ? `${first} ${sur}`.trim() : (disp || '');
      return [name, email].filter(Boolean).join(' â€¢ ') || (resolveRow.occupant_key_norm || '(unknown)');
    })(),
    hospital: resolveRow.hospital_norm || '',
    unit: resolveRow.hospital_norm || '',
    dateYmd: resolveRow.week_ending_date || resolveRow.worked_date || resolveRow.date_ymd || '',
  };

  // Expected id guard for rotate safety
  const expected = String(resolveRow.timesheet_id || '');

  const refreshResolvePreview = async () => {
    try {
      const rs = window.__resolveTimesheetsState || {};
      const ids = Array.isArray(rs.selectionIds)
        ? rs.selectionIds
        : (rs.rows || []).map(r => String(r.timesheet_id || r.id || '')).filter(Boolean);

      if (!ids.length) return;

      const res = await authFetch(API('/api/timesheets/resolve-preview'), {
        method: 'POST',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify({ timesheet_ids: ids })
      });
      const text = await res.text();
      if (!res.ok) return;

      const newRows = text ? JSON.parse(text) : [];
      window.__resolveTimesheetsState ||= {};
      window.__resolveTimesheetsState.rows = Array.isArray(newRows) ? newRows : [];

      const fr = (typeof window.__getModalFrame === 'function') ? window.__getModalFrame() : null;
      if (fr && fr.kind === 'timesheets-resolve') fr.setTab('main');
    } catch (e) {
      console.warn('[TS][RESOLVE] refresh resolve-preview failed', e);
    }
  };

  // Open the existing picker, but seed with hint data (openCandidatePicker will need to support these opts)
  openCandidatePicker(async ({ id, label }) => {
    try {
      // ensure apiResolveTimesheetCandidate uses expected id
      window.modalCtx ||= {};
      window.modalCtx.timesheetMeta ||= {};
      window.modalCtx.timesheetMeta.expected_timesheet_id = expected;

      await apiResolveTimesheetCandidate(tsId, id);
      window.__toast && window.__toast('Candidate mapping updated for timesheet.');

      // Refresh resolve modal list + main summary behind
      await refreshResolvePreview();
      try {
        if (typeof renderAll === 'function') await renderAll();
      } catch {}
    } catch (err) {
      const movedTo = err?.json?.current_timesheet_id || null;
      if (err?.status === 409 && err?.json?.error === 'TIMESHEET_MOVED' && movedTo) {
        window.__toast && window.__toast('This timesheet changed while you were editing. Please retry.');
        // best-effort: refresh preview and let user try again
        await refreshResolvePreview();
        return;
      }
      console.error('[TS][RESOLVE] apiResolveTimesheetCandidate failed', err);
      alert(err?.message || 'Failed to assign candidate.');
    }
  }, {
    context: ctx,
    // These are the new options youâ€™ll implement inside openCandidatePicker
    seed_hint: hint,
    ignoreMembership: true,
  });
}


// Wrapper: use contract-style client picker; prefill from hospital_norm where possible
async function openResolveClientPicker(resolveRow) {
  if (!resolveRow || !resolveRow.timesheet_id) {
    alert('Timesheet context missing for resolve.');
    return;
  }
  if (typeof openClientPicker !== 'function') {
    alert('Client picker is not available.');
    return;
  }

  const tsId = String(resolveRow.timesheet_id || '').trim();
  const expected = String(resolveRow.timesheet_id || '');
  const hosp = String(resolveRow.hospital_norm || '').trim();

  const refreshResolvePreview = async () => {
    try {
      const rs = window.__resolveTimesheetsState || {};
      const ids = Array.isArray(rs.selectionIds)
        ? rs.selectionIds
        : (rs.rows || []).map(r => String(r.timesheet_id || r.id || '')).filter(Boolean);

      if (!ids.length) return;

      const res = await authFetch(API('/api/timesheets/resolve-preview'), {
        method: 'POST',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify({ timesheet_ids: ids })
      });
      const text = await res.text();
      if (!res.ok) return;

      const newRows = text ? JSON.parse(text) : [];
      window.__resolveTimesheetsState ||= {};
      window.__resolveTimesheetsState.rows = Array.isArray(newRows) ? newRows : [];

      const fr = (typeof window.__getModalFrame === 'function') ? window.__getModalFrame() : null;
      if (fr && fr.kind === 'timesheets-resolve') fr.setTab('main');
    } catch (e) {
      console.warn('[TS][RESOLVE] refresh resolve-preview failed', e);
    }
  };

  openClientPicker(async ({ id, label }) => {
    try {
      window.modalCtx ||= {};
      window.modalCtx.timesheetMeta ||= {};
      window.modalCtx.timesheetMeta.expected_timesheet_id = expected;

      await apiResolveTimesheetClient(tsId, id);
      window.__toast && window.__toast('Client mapping updated for timesheet.');

      await refreshResolvePreview();
      try {
        if (typeof renderAll === 'function') await renderAll();
      } catch {}
    } catch (err) {
      const movedTo = err?.json?.current_timesheet_id || null;
      if (err?.status === 409 && err?.json?.error === 'TIMESHEET_MOVED' && movedTo) {
        window.__toast && window.__toast('This timesheet changed while you were editing. Please retry.');
        await refreshResolvePreview();
        return;
      }
      console.error('[TS][RESOLVE] apiResolveTimesheetClient failed', err);
      alert(err?.message || 'Failed to assign client.');
    }
  }, {
    context: {
      staffName: resolveRow.occupant_key_norm || '',
      hospital: hosp,
      unit: hosp,
      dateYmd: resolveRow.week_ending_date || resolveRow.worked_date || resolveRow.date_ymd || '',
    },
    // New option youâ€™ll implement inside openClientPicker:
    seed_query: hosp,
    ignoreMembership: true,
  });
}




async function searchCandidatesForResolve(term) {
  const q = String(term || '').trim();
  if (!q) return [];

  const url = `/api/candidates?search=${encodeURIComponent(q)}`;

  const res  = await authFetch(API(url));
  const text = await res.text();

  if (!res.ok) {
    throw new Error(text || `Candidate search failed (${res.status})`);
  }

  let json;
  try {
    json = text ? JSON.parse(text) : [];
  } catch {
    json = [];
  }

  return Array.isArray(json) ? json : [];
}

async function apiResolveTimesheetCandidate(timesheetId, candidateId) {
  const tsId   = String(timesheetId || '').trim();
  const candId = String(candidateId || '').trim();
  if (!tsId || !candId) {
    throw new Error('Missing timesheet_id or candidate_id for resolve.');
  }

  const urlPath = `/api/timesheets/${encodeURIComponent(tsId)}/resolve-candidate`;

  // âœ… Required for guard
  const expected =
    window.modalCtx?.timesheetMeta?.expected_timesheet_id ||
    tsId;

  const json = await apiPostJson(urlPath, {
    candidate_id: candId,
    expected_timesheet_id: expected
  });

  // âœ… Defensive adoption on success (if backend returns current_timesheet_id)
  try {
    const movedTo = json?.current_timesheet_id || null;
    if (movedTo && window.modalCtx) {
      window.modalCtx.data ||= {};
      window.modalCtx.timesheetMeta ||= {};
      window.modalCtx.data.timesheet_id = movedTo;
      window.modalCtx.data.id = movedTo;
      window.modalCtx.timesheetMeta.expected_timesheet_id = movedTo;
    }
  } catch {}

  return json;
}

async function searchClientsForResolve(term) {
  const q = String(term || '').trim();
  if (!q) return [];

  const url = `/api/clients?search=${encodeURIComponent(q)}`;

  const res  = await authFetch(API(url));
  const text = await res.text();

  if (!res.ok) {
    throw new Error(text || `Client search failed (${res.status})`);
  }

  let json;
  try {
    json = text ? JSON.parse(text) : [];
  } catch {
    json = [];
  }

  return Array.isArray(json) ? json : [];
}

async function apiResolveTimesheetClient(timesheetId, clientId) {
  const tsId    = String(timesheetId || '').trim();
  const cliId   = String(clientId || '').trim();
  if (!tsId || !cliId) {
    throw new Error('Missing timesheet_id or client_id for resolve.');
  }

  const urlPath = `/api/timesheets/${encodeURIComponent(tsId)}/resolve-client`;

  const expected =
    window.modalCtx?.timesheetMeta?.expected_timesheet_id ||
    tsId;

  const json = await apiPostJson(urlPath, {
    client_id: cliId,
    expected_timesheet_id: expected
  });

  // âœ… Defensive adoption on success
  try {
    const movedTo = json?.current_timesheet_id || null;
    if (movedTo && window.modalCtx) {
      window.modalCtx.data ||= {};
      window.modalCtx.timesheetMeta ||= {};
      window.modalCtx.data.timesheet_id = movedTo;
      window.modalCtx.data.id = movedTo;
      window.modalCtx.timesheetMeta.expected_timesheet_id = movedTo;
    }
  } catch {}

  return json;
}


async function openImportsModal() {
  // Seed a neutral modalCtx for this screen
  window.modalCtx = {
    entity: 'imports',
    data: {},
    importsState: {}
  };

const renderImportsTab = (key) => {
  if (key !== 'main') return '';
  const enc = (typeof escapeHtml === 'function')
    ? escapeHtml
    : (s) => String(s == null ? '' : s);

  return html(`
    <div class="form" id="importsMain">
      <div class="card">
        <div class="row">
          <label>Imports</label>
          <div class="controls">
            <span class="mini">
              Use this screen to upload and process NHSP and HealthRoster files.
              Each tile accepts an Excel export from the corresponding system.
            </span>
          </div>
        </div>
      </div>

      <div class="grid-3" style="margin-top:10px;gap:12px;">
        <!-- NHSP Weekly Import -->
        <div class="card dropzone"
             id="nhspImportDrop"
             data-import-kind="nhsp">
          <div class="row">
            <label>NHSP Weekly Import</label>
            <div class="controls">
              <span class="mini">
                Drop NHSP weekly export anywhere in this tile or<br/>
                <input id="nhspImportFile"
                       type="file"
                       accept=".xls,.xlsx,.csv"
                       style="
                         margin-top:4px;
                         background:#020617;
                         border:1px solid var(--line);
                         color:var(--text);
                         border-radius:8px;
                         padding:6px 8px;
                         font-size:12px;
                       " />
              </span>
              <div class="hint mini" style="margin-top:4px;">
                NHSP weekly export (self-bill style). The system will parse, classify,
                let you resolve unmapped staff/clients, and then create weeks & timesheets.
              </div>
              <div id="nhspImportSummary" class="mini" style="margin-top:4px;"></div>
            </div>
          </div>
        </div>

        <!-- HealthRoster Weekly Import -->
        <div class="card dropzone"
             id="hrWeeklyImportDrop"
             data-import-kind="hr-weekly">
          <div class="row">
            <label>HealthRoster Weekly Import</label>
            <div class="controls">
              <span class="mini">
                Drop HealthRoster weekly export anywhere in this tile or<br/>
                <input id="hrWeeklyImportFile"
                       type="file"
                       accept=".xls,.xlsx,.csv"
                       style="
                         margin-top:4px;
                         background:#020617;
                         border:1px solid var(--line);
                         color:var(--text);
                         border-radius:8px;
                         padding:6px 8px;
                         font-size:12px;
                       " />
              </span>
              <div class="hint mini" style="margin-top:4px;">
                Weekly HealthRoster template shifts. These are auto-processed into
                nhsp_shifts / contract weeks, with optional candidate/client resolve.
              </div>
              <div id="hrWeeklyImportSummary" class="mini" style="margin-top:4px;"></div>
            </div>
          </div>
        </div>

        <!-- HealthRoster Rota Validation (Daily) -->
        <div class="card dropzone"
             id="hrRotaImportDrop"
             data-import-kind="hr-rota">
          <div class="row">
            <label>HealthRoster Rota Validation (Daily)</label>
            <div class="controls">
              <span class="mini">
                Drop HR rota daily export anywhere in this tile or<br/>
                <input id="hrRotaImportFile"
                       type="file"
                       accept=".xls,.xlsx,.csv"
                       style="
                         margin-top:4px;
                         background:#020617;
                         border:1px solid var(--line);
                         color:var(--text);
                         border-radius:8px;
                         padding:6px 8px;
                         font-size:12px;
                       " />
              </span>
              <div class="hint mini" style="margin-top:4px;">
                Daily HealthRoster rota used to validate self-reported daily timesheets.
                Weâ€™ll compare start/end/break/â€œActual Hoursâ€, check gradeâ†’roleâ†’rates, and
                let you queue mismatch emails to Temp Staffing.
              </div>
              <div id="hrRotaImportSummary" class="mini" style="margin-top:4px;"></div>
            </div>
          </div>
        </div>
      </div>
    </div>
  `);
};


  showModal(
    'Imports',
    [{ key: 'main', label: 'Imports' }],
    renderImportsTab,
    null,         // no onSave
    false,        // hasId
    null,         // onReturn
    {
      kind: 'imports',
      noParentGate: true,
      stayOpenOnSave: false
    }
  );

  // Install global drag/drop guards once so dropping files never opens them in a new tab
  if (!window.__importsGlobalDragGuards) {
    window.__importsGlobalDragGuards = true;

    const preventGlobal = (ev) => {
      ev.preventDefault();
      ev.stopPropagation();
    };

    window.addEventListener('dragover', preventGlobal);
    window.addEventListener('drop', preventGlobal);
  }

  // Wire file inputs and dropzones after the modal is rendered
  setTimeout(() => {
    try {
      wireImportDropzones();
    } catch (e) {
      console.warn('[IMPORTS] wireImportDropzones failed', e);
    }
  }, 0);
}

function wireImportDropzones() {
  const LOG = (typeof window.__LOG_IMPORTS === 'boolean') ? window.__LOG_IMPORTS : true;
  const L   = (...a) => { if (LOG) console.log('[IMPORTS]', ...a); };

  const root = document.getElementById('importsMain');
  if (!root) {
    if (LOG) L('wireImportDropzones: no importsMain root, skipping');
    return;
  }

  // Small helper to prevent default drag behaviour
  const prevent = (ev) => {
    ev.preventDefault();
    ev.stopPropagation();
  };

  const wireOneZone = (dropId, fileId, handler) => {
    const dz   = document.getElementById(dropId);
    const file = document.getElementById(fileId);

    if (!dz && !file) {
      if (LOG) L(`wireImportDropzones: missing elements for ${dropId}/${fileId}`);
      return;
    }

    // File input select
    if (file && !file.__importsWired) {
      file.__importsWired = true;
      file.addEventListener('change', async (ev) => {
        try {
          const files = ev.target.files ? Array.from(ev.target.files) : [];
          const f = files[0] || null;
          if (!f) return;
          await handler(f);
          ev.target.value = ''; // reset
        } catch (err) {
          console.error('[IMPORTS] file handler failed', err);
          alert(err?.message || 'Import failed.');
        }
      });
    }

    // Drag & drop
    if (dz && !dz.__importsWired) {
      dz.__importsWired = true;

      dz.addEventListener('dragenter', prevent);
      dz.addEventListener('dragover', (ev) => {
        prevent(ev);
        dz.classList && dz.classList.add('drop-hover');
      });
      dz.addEventListener('dragleave', (ev) => {
        prevent(ev);
        dz.classList && dz.classList.remove('drop-hover');
      });
      dz.addEventListener('drop', async (ev) => {
        prevent(ev);
        dz.classList && dz.classList.remove('drop-hover');

        try {
          const files = (ev.dataTransfer && ev.dataTransfer.files)
            ? Array.from(ev.dataTransfer.files)
            : [];
          const f = files[0] || null;
          if (!f) return;
          await handler(f);
        } catch (err) {
          console.error('[IMPORTS] drop handler failed', err);
          alert(err?.message || 'Import failed.');
        }
      });
    }
  };

  // NHSP Weekly
  wireOneZone('nhspImportDrop', 'nhspImportFile', handleNhspFileDrop);

  // HR Weekly autoprocess
  wireOneZone('hrWeeklyImportDrop', 'hrWeeklyImportFile', handleHrWeeklyFileDrop);

  // HR Rota daily
  wireOneZone('hrRotaImportDrop', 'hrRotaImportFile', handleHrRotaFileDrop);
}



// Install once so dropping a file anywhere in the app never opens it in a new tab.
function installGlobalFileDropGuards() {
  if (window.__globalFileDropGuardsInstalled) return;
  window.__globalFileDropGuardsInstalled = true;

  const prevent = (ev) => {
    ev.preventDefault();
    ev.stopPropagation();
  };

  window.addEventListener('dragover', prevent);
  window.addEventListener('drop', prevent);
}

// Attach weekly summary behaviour (Assign buttons + optional group selection)
// Attach weekly summary behaviour (Assign buttons + optional group selection)




function getWeeklyMondayOptions(baseWeekRefYmd) {
  // Returns Â±4 Monday week-start options.
  // Input: a base week reference (typically week_ending_date OR week_start Monday)
  // Output: [{ value:'YYYY-MM-DD', label:'Mon 01 Jan 2025' }, ...]

  const parseYmd = (ymd) => {
    if (!ymd || typeof ymd !== 'string') return null;
    const m = ymd.match(/^(\d{4})-(\d{2})-(\d{2})$/);
    if (!m) return null;
    const d = new Date(Date.UTC(Number(m[1]), Number(m[2]) - 1, Number(m[3])));
    return Number.isNaN(d.getTime()) ? null : d;
  };

  const toYmd = (d) => {
    if (!(d instanceof Date) || Number.isNaN(d.getTime())) return null;
    return `${d.getUTCFullYear()}-${String(d.getUTCMonth() + 1).padStart(2,'0')}-${String(d.getUTCDate()).padStart(2,'0')}`;
  };

  const isMondayYmd = (ymd) => {
    const d = parseYmd(ymd);
    return !!(d && d.getUTCDay() === 1);
  };

  const weekStartFromWeekEnding = (weYmd) => {
    const d = parseYmd(weYmd);
    if (!d) return null;
    // week_ending_date is usually Sunday -> Monday is -6
    d.setUTCDate(d.getUTCDate() - 6);
    return toYmd(d);
  };

  const addDaysYmd = (ymd, days) => {
    const d = parseYmd(ymd);
    if (!d) return null;
    d.setUTCDate(d.getUTCDate() + Number(days || 0));
    return toYmd(d);
  };

  const labelFor = (ymd) => {
    if (typeof formatYmdToNiceDate === 'function') {
      // You already have this helper; use it for consistency
      return formatYmdToNiceDate(ymd);
    }
    // fallback: Mon 01 Jan 2025
    const d = parseYmd(ymd);
    if (!d) return ymd;
    const days = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
    const mons = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
    return `${days[d.getUTCDay()]} ${String(d.getUTCDate()).padStart(2,'0')} ${mons[d.getUTCMonth()]} ${d.getUTCFullYear()}`;
  };

  // Determine base Monday
  let base = String(baseWeekRefYmd || '').trim();
  if (!base) return [];

  if (!isMondayYmd(base)) {
    // treat as week_ending_date and derive Monday
    const derived = weekStartFromWeekEnding(base);
    base = derived || base;
  }
  if (!isMondayYmd(base)) return [];

  const out = [];
  for (let i = -4; i <= 4; i++) {
    const ymd = addDaysYmd(base, i * 7);
    if (!ymd) continue;
    out.push({ value: ymd, label: labelFor(ymd) });
  }
  return out;
}


// In-memory store keyed by (type, importId, external_row_key), survives re-renders.
// - initFromPreview(preview) adds defaults ONLY for new keys
// - serialize(preview) only includes keys that exist in current preview (prevents backend "unknown key" rejection)
function getOrInitWeeklyImportDecisionsStore(type, importId, preview) {
  const t = String(type || '').toUpperCase();
  const id = String(importId || '').trim();

  window.__weeklyImportDecisions = window.__weeklyImportDecisions || {};
  window.__weeklyImportDecisions[t] = window.__weeklyImportDecisions[t] || {};

  let state = window.__weeklyImportDecisions[t][id];
  if (!state || typeof state !== 'object') {
    state = { byKey: {}, lastPreviewKeys: [] };
    window.__weeklyImportDecisions[t][id] = state;
  }

  const asBool = (v) => (v === true || v === 'true' || v === 1 || v === '1');

  const getChanged = (p) => {
    const root = p || {};
    const sum  = (root && typeof root.summary === 'object' && root.summary) ? root.summary : root;
    return (
      (Array.isArray(root.changed_shifts) ? root.changed_shifts :
       Array.isArray(sum.changed_shifts)  ? sum.changed_shifts  :
       Array.isArray(root?.summary?.changed_shifts) ? root.summary.changed_shifts :
       [])
    );
  };

  const getKeySetFromPreview = (p) => {
    const arr = getChanged(p);
    return new Set(arr.map(x => String(x?.external_row_key || '').trim()).filter(Boolean));
  };

  const computeDefaultWeeks = (row) => {
    // prefer explicit week_start if present, otherwise derive from week_ending_date
    const we = String(row?.week_ending_date || '').trim();
    const ws = String(row?.week_start || '').trim();
    const base = ws || we;
    const opts = getWeeklyMondayOptions(base);
    const first = opts && opts[4] ? opts[4].value : (opts[0] ? opts[0].value : null); // centre if present
    return { baseWeekStart: first, options: opts };
  };

  const initFromPreview = (p) => {
    const arr = getChanged(p);

    for (const row of arr) {
      const ek = String(row?.external_row_key || '').trim();
      if (!ek) continue;

      // only required rows MUST have decisions
      const requires = asBool(row?.requires_any_decision);
      if (!requires) continue;

      state.byKey[ek] = (state.byKey[ek] && typeof state.byKey[ek] === 'object') ? state.byKey[ek] : { skip: false };
      const d = state.byKey[ek];

      if (typeof d.skip !== 'boolean') d.skip = !!d.skip;

      if (asBool(row?.is_invoiced)) {
        const { baseWeekStart } = computeDefaultWeeks(row);
        if (baseWeekStart) {
          if (!d.credit_week_start) d.credit_week_start = baseWeekStart;
          if (!d.reinvoice_week_start) d.reinvoice_week_start = baseWeekStart;
        }
      }
    }

    // remember the keys present for this preview (used to filter serialize)
    state.lastPreviewKeys = Array.from(getKeySetFromPreview(p));
  };

  const set = (externalKey, patch) => {
    const ek = String(externalKey || '').trim();
    if (!ek) return;
    state.byKey[ek] = (state.byKey[ek] && typeof state.byKey[ek] === 'object') ? state.byKey[ek] : {};
    Object.assign(state.byKey[ek], patch || {});
  };

  const get = (externalKey) => {
    const ek = String(externalKey || '').trim();
    return ek ? state.byKey[ek] : null;
  };

  const serialize = (p) => {
    const allowed = getKeySetFromPreview(p);
    const out = {};
    for (const [k, v] of Object.entries(state.byKey || {})) {
      if (!allowed.has(String(k))) continue; // prevent backend unknown-key rejection
      if (!v || typeof v !== 'object') continue;

      const row = {};
      row.skip = asBool(v.skip);

      if (!row.skip) {
        if (v.credit_week_start) row.credit_week_start = String(v.credit_week_start);
        if (v.reinvoice_week_start) row.reinvoice_week_start = String(v.reinvoice_week_start);
      }
      out[String(k)] = row;
    }
    return out;
  };

  const validate = (p) => {
    const changed = getChanged(p);

    // Build lookup for decisions
    const decisions = serialize(p);

    const errors = [];
    const badKeys = [];

    for (const row of changed) {
      const ek = String(row?.external_row_key || '').trim();
      if (!ek) continue;

      const requires = asBool(row?.requires_any_decision);
      if (!requires) continue;

      const d = decisions[ek];
      if (!d || typeof d !== 'object') {
        errors.push(`Missing decision for ${ek}`);
        badKeys.push(ek);
        continue;
      }

      if (asBool(d.skip)) continue; // skip means no more required fields

      if (asBool(row?.is_invoiced)) {
        if (!d.credit_week_start || !d.reinvoice_week_start) {
          errors.push(`Invoiced shift ${ek} requires credit_week_start and reinvoice_week_start`);
          badKeys.push(ek);
          continue;
        }

        // Enforce Monday-ness client-side (same rule backend enforces)
        const opts = getWeeklyMondayOptions(row?.week_start || row?.week_ending_date || '');
        const allowed = new Set(opts.map(o => o.value));
        if (!allowed.has(String(d.credit_week_start)) || !allowed.has(String(d.reinvoice_week_start))) {
          errors.push(`Invoiced shift ${ek} has invalid credit/reinvoice week (must be a Monday within Â±4 weeks).`);
          badKeys.push(ek);
        }
      }
    }

    return { ok: errors.length === 0, errors, badKeys };
  };

  // init on demand if preview provided
  if (preview) initFromPreview(preview);

  return { byKey: state.byKey, initFromPreview, set, get, serialize, validate };
}







// Normalise mappings object for a given type/importId into the payload shape
function getWeeklyImportMappings(type, importId) {
  const t = String(type || '').toUpperCase();
  const mRoot = (window.__weeklyImportMappings && window.__weeklyImportMappings[t]) || {};
  const m     = mRoot[importId] || {};

  const candidate_mappings = Array.isArray(m.candidate_mappings)
    ? m.candidate_mappings.slice()
    : [];

  const client_aliases = Array.isArray(m.client_aliases)
    ? m.client_aliases.slice()
    : [];

  return { candidate_mappings, client_aliases };
}

// Build an array of preview_group_ids selected in the weekly summary (if implemented)
function getWeeklySelectedGroupIds(type, importId) {
  const t = String(type || '').toUpperCase();

  // Preferred way: honour the selected set maintained by wireWeeklyImportSummaryActions
  if (window.__weeklySelectedGroups &&
      window.__weeklySelectedGroups[t] &&
      window.__weeklySelectedGroups[t][importId] instanceof Set) {
    return Array.from(window.__weeklySelectedGroups[t][importId]);
  }

  // Fallback: read from DOM checkboxes if present
  const root = document.getElementById('weeklyImportSummary');
  if (!root) return [];

  const selected = [];
  const cbs = root.querySelectorAll('input[data-act="weekly-select-group"]');
  cbs.forEach(cb => {
    if (!cb.checked) return;
    const gid = cb.getAttribute('data-group-id');
    if (gid) selected.push(gid);
  });

  return selected;
}

async function handleHrWeeklyFileDrop(file) {
  const summaryEl = document.getElementById('hrWeeklyImportSummary');
  if (summaryEl) {
    summaryEl.textContent = 'Preparing HealthRoster weekly importâ€¦';
  }

  try {
    // Ensure modalCtx/importsState exist
    window.modalCtx = window.modalCtx || {};
    window.modalCtx.importsState = window.modalCtx.importsState || {};
    const st = window.modalCtx.importsState;

    // 0) Ensure a client_id is selected (use picker if missing)
    let clientId =
      st.hrWeeklyClientId ? String(st.hrWeeklyClientId).trim() : '';
    let clientName = st.hrWeeklyClientName || '';

    if (!clientId) {
      const picked = await openHrWeeklyClientPicker();
      if (!picked) {
        throw new Error('Select a client for the HealthRoster weekly import before uploading.');
      }
      clientId   = String(picked.clientId || '').trim();
      clientName = picked.clientName || '';

      st.hrWeeklyClientId   = clientId;
      st.hrWeeklyClientName = clientName;
    }

    if (summaryEl) {
      summaryEl.textContent =
        `Client: ${clientName || clientId} â€” uploading HealthRoster weekly file to storageâ€¦`;
    }

    // 1) Upload file to R2
    const { fileKey, filename } = await uploadImportFileToR2(file);

    if (summaryEl) {
      summaryEl.textContent = 'Registering HealthRoster weekly import and parsing workbookâ€¦';
    }

    // 2) Register HR autoprocess import
    const resUpload = await authFetch(API('/api/healthroster/autoprocess/import'), {
      method: 'POST',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify({
        original_name: filename,
        file_key: fileKey,
        client_id: clientId,
        tz_assumption: 'Europe/London'
      })
    });
    const textUpload = await resUpload.text();
    if (!resUpload.ok) {
      throw new Error(textUpload || `HealthRoster weekly import upload failed (${resUpload.status})`);
    }

    let parsed;
    try { parsed = textUpload ? JSON.parse(textUpload) : {}; } catch { parsed = {}; }
    const importId = parsed.import_id || parsed.id || null;
    if (!importId) {
      throw new Error('HealthRoster weekly import did not return an import_id.');
    }

    if (summaryEl) {
      summaryEl.textContent =
        `File uploaded. Loading HealthRoster weekly classification for import ${importId}â€¦`;
    }

    // 3) Fetch preview / classification
    const resPrev  = await authFetch(API(`/api/healthroster/autoprocess/${encodeURIComponent(importId)}/preview`));
    const textPrev = await resPrev.text();
    if (!resPrev.ok) {
      throw new Error(textPrev || `HealthRoster weekly preview failed (${resPrev.status})`);
    }

    let summaryState;
    try { summaryState = textPrev ? JSON.parse(textPrev) : {}; } catch { summaryState = {}; }

    // âœ… REQUIRED: HR_WEEKLY must NOT show options modal.
    // Instead, auto-seed weekly UI store options:
    // - missingShiftsEnabled = true
    // - dateFrom/dateTo = truth_meta.file_date_min/max (when available)
    // This is belt-and-braces: renderImportSummaryModal also enforces missingShiftsEnabled=true,
    // but we seed here so the UI is correct even before any later rerenders.
    try {
      const asYmd = (v) => {
        if (!v) return null;
        if (typeof v === 'string') {
          const s = v.trim();
          if (/^\d{4}-\d{2}-\d{2}$/.test(s)) return s;
          if (s.length >= 10 && /^\d{4}-\d{2}-\d{2}/.test(s)) return s.slice(0, 10);
        }
        try {
          const d = new Date(v);
          if (Number.isNaN(d.getTime())) return null;
          const yyyy = d.getUTCFullYear();
          const mm = String(d.getUTCMonth() + 1).padStart(2, '0');
          const dd = String(d.getUTCDate()).padStart(2, '0');
          return `${yyyy}-${mm}-${dd}`;
        } catch {
          return null;
        }
      };

      const tm =
        (summaryState && typeof summaryState.truth_meta === 'object' && summaryState.truth_meta) ? summaryState.truth_meta :
        (summaryState && summaryState.summary && typeof summaryState.summary.truth_meta === 'object' && summaryState.summary.truth_meta) ? summaryState.summary.truth_meta :
        null;

      const fileMin = tm ? asYmd(tm.file_date_min) : null;
      const fileMax = tm ? asYmd(tm.file_date_max) : null;

      window.__weeklyImportUi = window.__weeklyImportUi || {};
      window.__weeklyImportUi.HR_WEEKLY = window.__weeklyImportUi.HR_WEEKLY || {};

      const impIdStr = String(importId);
      const existingUi = window.__weeklyImportUi.HR_WEEKLY[impIdStr] || null;

      const ui = existingUi && typeof existingUi === 'object'
        ? existingUi
        : {
            options: { missingShiftsEnabled: true, dateFrom: null, dateTo: null },
            actionSelection: new Set(),
            filters: { showOnlyRed: false, showOnlyUnticked: false, showOnlyCancellations: false, search: '' },
            emailSelection: new Set(),
            hydratedFlags: { didInitDefaultActionChecks: false }
          };

      ui.options = ui.options && typeof ui.options === 'object' ? ui.options : {};
      ui.options.missingShiftsEnabled = true;

      // Only seed dateFrom/dateTo if we have file min/max.
      // (If absent, renderImportSummaryModal/ensureWeeklyUiStore will still compute defaults.)
      if (fileMin) ui.options.dateFrom = fileMin;
      if (fileMax) ui.options.dateTo = fileMax;

      if (!(ui.actionSelection instanceof Set)) ui.actionSelection = new Set();
      if (!(ui.emailSelection instanceof Set)) ui.emailSelection = new Set();

      ui.filters = ui.filters && typeof ui.filters === 'object' ? ui.filters : {};
      if (typeof ui.filters.showOnlyRed !== 'boolean') ui.filters.showOnlyRed = false;
      if (typeof ui.filters.showOnlyUnticked !== 'boolean') ui.filters.showOnlyUnticked = false;
      if (typeof ui.filters.showOnlyCancellations !== 'boolean') ui.filters.showOnlyCancellations = false;
      if (typeof ui.filters.search !== 'string') ui.filters.search = '';

      ui.hydratedFlags = ui.hydratedFlags && typeof ui.hydratedFlags === 'object' ? ui.hydratedFlags : {};
      if (typeof ui.hydratedFlags.didInitDefaultActionChecks !== 'boolean') ui.hydratedFlags.didInitDefaultActionChecks = false;

      window.__weeklyImportUi.HR_WEEKLY[impIdStr] = ui;
    } catch (e) {
      console.warn('[IMPORTS][HR_WEEKLY] failed to auto-seed weekly UI store options (non-fatal)', e);
    }

    // 4) Persist and render summary modal (no options step)
    window.modalCtx = window.modalCtx || {};
    window.modalCtx.importsState = window.modalCtx.importsState || {};
    window.modalCtx.importsState.hrWeekly = {
      import_id: importId,
      summary: summaryState
    };

    const total =
      (summaryState.summary && typeof summaryState.summary.total_rows === 'number')
        ? summaryState.summary.total_rows
        : Array.isArray(summaryState.rows) ? summaryState.rows.length : 0;

    if (summaryEl) {
      summaryEl.textContent =
        `Import ${importId} (${clientName || clientId}): ${total} rows parsed.`;
    }

    if (typeof renderImportSummaryModal === 'function') {
      renderImportSummaryModal('HR_WEEKLY', summaryState);
    } else {
      console.warn('[IMPORTS] renderImportSummaryModal is not defined; HR weekly summary not shown.');
    }
  } catch (err) {
    console.error('[IMPORTS][HR_WEEKLY] handleHrWeeklyFileDrop failed', err);
    if (summaryEl) {
      summaryEl.textContent =
        `HealthRoster weekly import failed: ${err?.message || 'Unknown error'}`;
    }
    alert(err?.message || 'HealthRoster weekly import failed.');
  }
}


async function handleHrRotaFileDrop(file) {
  const summaryEl = document.getElementById('hrRotaImportSummary');
  if (summaryEl) {
    summaryEl.textContent = 'Uploading HR rota daily file to storageâ€¦';
  }

  try {
    // 1) Upload file to R2
    const { fileKey, filename } = await uploadImportFileToR2(file);

    if (summaryEl) {
      summaryEl.textContent = 'Registering HR rota daily import and parsing workbookâ€¦';
    }

    // 2) Call parse endpoint with JSON and file_r2_key
    const res = await authFetch(API('/api/imports/hr-rota/parse'), {
      method: 'POST',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify({
        file_r2_key: fileKey,
        original_name: filename
      })
    });
    const text = await res.text();
    if (!res.ok) {
      throw new Error(text || `HR rota daily import upload failed (${res.status})`);
    }

    let parsed;
    try { parsed = text ? JSON.parse(text) : {}; } catch { parsed = {}; }
    const importId = parsed.import_id || parsed.id || null;
    if (!importId) {
      throw new Error('HR rota daily import did not return an import_id.');
    }

    if (summaryEl) {
      summaryEl.textContent =
        `File uploaded. Loading HR rota classification for import ${importId}â€¦`;
    }

    // 3) Fetch preview / classification
    const previewRes  = await authFetch(API(`/api/imports/hr-rota/${encodeURIComponent(importId)}/preview`));
    const previewText = await previewRes.text();
    if (!previewRes.ok) {
      throw new Error(previewText || `HR rota daily preview failed (${previewRes.status})`);
    }

    let summaryState;
    try { summaryState = previewText ? JSON.parse(previewText) : {}; } catch { summaryState = {}; }

    // 4) Persist into modalCtx and render summary modal
    window.modalCtx = window.modalCtx || {};
    window.modalCtx.importsState = window.modalCtx.importsState || {};
    window.modalCtx.importsState.hrRota = {
      import_id: importId,
      summary: summaryState
    };

    const total =
      (summaryState.summary && typeof summaryState.summary.total_rows === 'number')
        ? summaryState.summary.total_rows
        : Array.isArray(summaryState.rows) ? summaryState.rows.length : 0;

    if (summaryEl) {
      summaryEl.textContent = `Import ${importId}: ${total} rows parsed.`;
    }

    if (typeof renderImportSummaryModal === 'function') {
      renderImportSummaryModal('HR_ROTA_DAILY', summaryState);
    } else {
      console.warn('[IMPORTS] renderImportSummaryModal is not defined; HR rota summary not shown.');
    }
  } catch (err) {
    console.error('[IMPORTS][HR_ROTA] handleHrRotaFileDrop failed', err);
    if (summaryEl) {
      summaryEl.textContent =
        `HR rota daily import failed: ${err?.message || 'Unknown error'}`;
    }
    alert(err?.message || 'HR rota daily import failed.');
  }
}

async function searchClientsForResolve(term) {
  const q = String(term || '').trim();
  if (!q) return [];

  const url = `/api/clients?search=${encodeURIComponent(q)}`;

  const res  = await authFetch(API(url));
  const text = await res.text();

  if (!res.ok) {
    throw new Error(text || `Client search failed (${res.status})`);
  }

  let json;
  try {
    json = text ? JSON.parse(text) : [];
  } catch {
    json = [];
  }

  return Array.isArray(json) ? json : [];
}



async function uploadImportFileToR2(file) {
  if (!file) {
    throw new Error('No file provided for upload.');
  }

  const filename    = file.name || 'import.xlsx';
  const contentType =
    file.type ||
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';

  // 1) Get presigned URL + key
  const presignRes = await authFetch(API('/api/files/presign-upload'), {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify({
      filename,
      content_type: contentType,
      use_case: 'IMPORT'
    })
  });
  const presignText = await presignRes.text();
  if (!presignRes.ok) {
    throw new Error(
      presignText || `Failed to presign upload (${presignRes.status})`
    );
  }

  let presign;
  try { presign = presignText ? JSON.parse(presignText) : {}; } catch { presign = {}; }

  const uploadUrl = presign.upload_url;
  const fileKey   = presign.key;

  if (!uploadUrl || !fileKey) {
    throw new Error('Presign response missing upload_url or key.');
  }

  // 2) PUT the file to R2
  const putRes  = await fetch(uploadUrl, {
    method: 'PUT',
    headers: { 'content-type': contentType },
    body: file
  });
  const putText = await putRes.text().catch(() => '');
  if (!putRes.ok) {
    throw new Error(putText || `File upload failed (${putRes.status})`);
  }

  return { fileKey, filename };
}

async function applyHrRotaValidation(importId, sendEmailRowIds) {
  const rawId = String(importId || '').trim();
  if (!rawId) {
    throw new Error('Missing import_id for applyHrRotaValidation.');
  }
  const encId = encodeURIComponent(rawId);

  if (typeof authFetch !== 'function' || typeof API !== 'function') {
    throw new Error('authFetch/API helper missing in applyHrRotaValidation.');
  }

  const body = {
    // Ensure we only send string ids (FE already ensures these are real hr_row_id values)
    send_email_row_ids: Array.isArray(sendEmailRowIds)
      ? sendEmailRowIds.map(x => String(x || '').trim()).filter(Boolean)
      : []
  };

  const res = await authFetch(API(`/api/imports/hr-rota/${encId}/apply`), {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify(body)
  });

  const text = await res.text().catch(() => '');
  if (!res.ok) {
    throw new Error(text || `HR rota apply failed (${res.status})`);
  }

  let payload;
  try { payload = text ? JSON.parse(text) : {}; } catch { payload = {}; }

  // New backend shape:
  // { import_id, apply: { validations_upserted, ... , email_jobs }, post_commit: { emails_queued, email_failures } }
  const apply = (payload && typeof payload.apply === 'object' && payload.apply) ? payload.apply : {};
  const post  = (payload && typeof payload.post_commit === 'object' && payload.post_commit) ? payload.post_commit : {};

  const validationsUpserted =
    (apply.validations_upserted ?? payload.validations_upserted ?? 0);

  const emailsQueued =
    (post.emails_queued ?? payload.emails_queued ?? body.send_email_row_ids.length ?? 0);

  const emailFailuresCount =
    Array.isArray(post.email_failures) ? post.email_failures.length : 0;

  const msg =
    `Applied HR rota validations (${validationsUpserted} validations upserted, ${emailsQueued} emails queued` +
    (emailFailuresCount ? `, ${emailFailuresCount} email failures` : '') +
    ').';

  if (window.__toast) window.__toast(msg);

  // Refresh so email_already_sent and related flags reflect immediately
  if (typeof refreshHrRotaSummary === 'function') {
    await refreshHrRotaSummary(rawId);
  }

  return payload;
}


async function apiQueueHrRotaTsoEmail(row) {
  if (!row || !row.timesheet_id) {
    throw new Error('Missing timesheet_id for TSO email.');
  }

  const body = {
    timesheet_id: row.timesheet_id,
    hr_request_id: row.request_id || row.hr_request_id || null,
    reason_code: row.failure_reason || row.reason_code || null,
    mismatch_details: row.detail || null
  };

  const res  = await authFetch(API('/api/hr/rota/tso-email'), {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify(body)
  });
  const text = await res.text();

  if (!res.ok) {
    throw new Error(text || `Failed to queue HR rota TSO email (${res.status})`);
  }

  window.__toast && window.__toast('Query email queued to Temporary Staffing.');
}


























































function ensureSelection(section) {
  window.__selection = window.__selection || {};
  if (!window.__selection[section]) {
    window.__selection[section] = {
      fingerprint: '',
      ids: new Set(),
    };
  }
  return window.__selection[section];
}

function getSelectionSnapshot(section) {
  const sel = ensureSelection(section);
  return {
    fingerprint: sel.fingerprint || '',
    ids: Array.from(sel.ids || []),
    section,
  };
}
function applySelectionSnapshot(section, snapshot) {
  if (!snapshot || (snapshot.section && snapshot.section !== section)) {
    return getSelectionSnapshot(section);
  }
  const sel = ensureSelection(section);
  sel.fingerprint = String(snapshot.fingerprint || sel.fingerprint || '');
  sel.ids = new Set((snapshot.ids || []).map(String));
  return getSelectionSnapshot(section);
}

function isRowSelected(section, id) {
  if (!id) return false;
  return ensureSelection(section).ids.has(String(id));
}

function setRowSelected(section, id, selected) {
  if (!id) return getSelectionSnapshot(section);
  const sel = ensureSelection(section);
  const key = String(id);
  if (selected) sel.ids.add(key);
  else sel.ids.delete(key);
  return getSelectionSnapshot(section);
}


async function applyShortlistFilter(section, { ids }) {
  const cleanIds = Array.isArray(ids) ? ids.map(String).filter(Boolean) : [];
  if (!cleanIds.length) {
    alert('No records selected to focus.');
    return;
  }

  // Reset paging & REPLACE existing filters with IDs-only
  window.__listState = window.__listState || {};
  const st = (window.__listState[section] ||= {
    page: 1, pageSize: 50, total: null, hasMore: false, filters: null,
  });
  st.page = 1;
  st.filters = { ids: cleanIds }; // â† replace, don't merge

  // Mirror into selection for checkbox sync
  const sel = ensureSelection(section);
  sel.fingerprint = JSON.stringify({ section, filters: st.filters || {} });
  sel.ids = new Set(cleanIds);

  // Reload with the focused shortlist
  const rows = await search(section, st.filters);
  renderSummary(rows);
}


// Convenience: focus current selection by applying its IDs as a filter
async function focusCurrentSelection(section) {
  const sel = ensureSelection(section);
  const ids = Array.from(sel.ids || []);
  if (!ids.length) {
    alert('No records selected to focus.');
    return;
  }
  await applyShortlistFilter(section, { ids });
}

// Apply IDs-only selection as a filter and reload
// Apply IDs-only selection as a filter and reload
async function applySelectionAsFilter(section, selectionSnapshot) {
  // Supports:
  // - Focus by explicit ids[]
  // - Related-mode focus via selectionSnapshot.related { source_entity, source_id, relation_type }
  //
  // Rule:
  // - When entering related mode, REPLACE filters with { related: ... } (do not merge any existing filters).

  const ids = Array.isArray(selectionSnapshot?.ids)
    ? selectionSnapshot.ids.map(String).filter(Boolean)
    : [];

  const related = (selectionSnapshot && typeof selectionSnapshot === 'object' && selectionSnapshot.related && typeof selectionSnapshot.related === 'object')
    ? {
        source_entity: String(selectionSnapshot.related.source_entity || '').trim(),
        source_id: String(selectionSnapshot.related.source_id || '').trim(),
        relation_type: String(selectionSnapshot.related.relation_type || '').trim()
      }
    : null;

  const hasRelated =
    !!related &&
    !!related.source_entity &&
    !!related.source_id &&
    !!related.relation_type;

  if (!hasRelated && !ids.length) {
    alert('No records selected to focus.');
    return;
  }

  // Reset paging & REPLACE existing filters
  window.__listState = window.__listState || {};
  const st = (window.__listState[section] ||= {
    page: 1, pageSize: 50, total: null, hasMore: false, filters: null,
  });
  st.page = 1;
  st.total = null;
  st.hasMore = false;

  if (hasRelated) {
    // âœ… Related mode: do NOT merge incompatible filters; replace entirely
    st.filters = { related };
  } else {
    // âœ… IDs-only focus: replace entirely
    st.filters = { ids };
  }

  // Mirror into selection for checkbox sync
  const sel = ensureSelection(section);
  sel.fingerprint = JSON.stringify({ section, filters: st.filters || {} });
  sel.ids = new Set(hasRelated ? [] : ids);

  // Reload data and re-render (use normal section list load path if available)
  try {
    if (typeof loadSection === 'function' && typeof renderSummary === 'function') {
      // Ensure currentSection is correct before loadSection
      try { currentSection = section; } catch {}
      const data = await loadSection();
      renderSummary(data);
      return;
    }
  } catch (e) {
    console.warn('[applySelectionAsFilter] loadSection path failed, falling back to search()', e);
  }

  // Fallback: direct search
  const rows = await search(section, st.filters);
  renderSummary(rows);
}




function clearSelection(section) {
  const sel = ensureSelection(section);
  sel.ids.clear();
  return getSelectionSnapshot(section);
}

function serializeSelection(section) {
  return getSelectionSnapshot(section);
}



function mergeSelectionSnapshots(section, baseSnapshot, addSnapshot) {
  const base = baseSnapshot || getSelectionSnapshot(section);
  const add  = addSnapshot  || {};
  const result = {
    fingerprint: base.fingerprint || add.fingerprint || '',
    ids: Array.from(new Set([
      ...(base.ids || []).map(String),
      ...(add.ids  || []).map(String),
    ])),
    section
  };
  return applySelectionSnapshot(section, result);
}

function dedupeIds(arr) {
  return Array.from(new Set((arr || []).map(String)));
}


async function apiListAssignmentBandMappings(params) {
  const p = params || {};

  // âœ… Accept either incoming_like or incoming_code (exact) from callers.
  // If only incoming_code is provided, treat it as incoming_like for compatibility.
  const incomingLike =
    (p.incoming_like != null ? p.incoming_like : null) ??
    (p.incoming_code != null ? p.incoming_code : null);

  const query = __qs({
    system_type: p.system_type,
    candidate_id: p.candidate_id,
    client_id: p.client_id,
    incoming_like: incomingLike,                 // backend supports this
    scope: p.scope,                              // GLOBAL|CLIENT|CANDIDATE (optional)
    include_inactive: p.include_inactive ? 'true' : undefined
  });

  const res = await authFetch(API(`/api/assignment-band-mappings${query}`), { method: 'GET' });
  const txt = await res.text().catch(() => '');
  if (!res.ok) throw new Error(txt || `Failed to list assignment-band-mappings (${res.status})`);

  let json;
  try { json = txt ? JSON.parse(txt) : null; } catch { json = null; }

  return __unwrapRows(json);
}

async function openHrWeeklyBandResolveModal(opts) {
  const enc = (typeof escapeHtml === 'function')
    ? escapeHtml
    : (s) => String(s == null ? '' : s)
        .replace(/[&<>"']/g, (c) => ({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[c]));

  const seed = (opts && typeof opts === 'object') ? opts : {};

  const importId = String(seed.import_id || seed.importId || '').trim();
  const candidateId = String(seed.candidate_id || seed.candidateId || '').trim();
  const clientId = String(seed.client_id || seed.clientId || '').trim();
  const incomingCode = String(seed.incoming_code || seed.incomingCode || '').trim();

  // Scope date (used to list contracts "active in scope")
  const scopeYmdRaw =
    seed.work_date || seed.workDate ||
    seed.week_ending_date || seed.weekEndingDate ||
    seed.active_on || seed.activeOn ||
    null;

  if (!importId) throw new Error('openHrWeeklyBandResolveModal: import_id is required');
  if (!candidateId) throw new Error('openHrWeeklyBandResolveModal: candidate_id is required');
  if (!clientId) throw new Error('openHrWeeklyBandResolveModal: client_id is required');
  if (!incomingCode) throw new Error('openHrWeeklyBandResolveModal: incoming_code is required');

  if (typeof showModal !== 'function') throw new Error('showModal is not defined');
  if (typeof listContracts !== 'function') throw new Error('listContracts is not defined');
  if (typeof apiCreateAssignmentBandMapping !== 'function') throw new Error('apiCreateAssignmentBandMapping is not defined');

  const kind = 'import-summary-hr-weekly-band-resolve';

  const toYmd = (v) => {
    const s = String(v || '').trim();
    if (!s) return null;
    if (/^\d{4}-\d{2}-\d{2}$/.test(s)) return s;
    if (s.length >= 10 && /^\d{4}-\d{2}-\d{2}/.test(s)) return s.slice(0, 10);
    return null;
  };

  const state = {
    import_id: importId,
    candidate_id: candidateId,
    client_id: clientId,
    incoming_code: incomingCode,
    scope_ymd: toYmd(scopeYmdRaw) || null,

    loading: false,
    error: '',
    contracts: [],
    selected_contract_id: null,

    // derived display (best-effort)
    candidate_display: '',
    client_name: ''
  };

  const safeBand = (c) => String(c?.band || c?.band_snapshot || c?.band_label || '').trim();
  const safeRole = (c) => String(c?.role || c?.role_snapshot || c?.job_title || c?.job_title_norm || '').trim();
  const safeSite = (c) => String(
    c?.display_site ||
    c?.hospital_norm ||
    c?.client_site ||
    c?.site ||
    c?.ward_hint ||
    c?.ward_norm ||
    ''
  ).trim();

  const safeDate = (d) => {
    const s = String(d || '').trim();
    return s ? s : 'â€”';
  };

  const repaint = () => {
    const fr = (typeof window.__getModalFrame === 'function') ? window.__getModalFrame() : null;
    if (!fr) return;
    try { fr.setTab(fr.currentTabKey || 'main'); } catch {}
    try {
      const fr2 = (typeof window.__getModalFrame === 'function') ? window.__getModalFrame() : null;
      if (fr2 && typeof fr2.onReturn === 'function') fr2.onReturn();
    } catch {}
  };

  const loadContracts = async () => {
    state.loading = true;
    state.error = '';
    repaint();

    try {
      const activeOn = state.scope_ymd || null;

      // listContracts should return contracts; we request candidate+client scoped + active in range
      const rows = await listContracts({
        client_id: state.client_id,
        candidate_id: state.candidate_id,
        active_only: true,
        active_on: activeOn
      });

      state.contracts = Array.isArray(rows) ? rows : [];

      // Best-effort display labels
      if (!state.candidate_display) {
        const any = state.contracts.find(Boolean) || null;
        const cd = String(any?.candidate_display || any?.candidate_name || '').trim();
        if (cd) state.candidate_display = cd;
      }
      if (!state.client_name) {
        const any = state.contracts.find(Boolean) || null;
        const cn = String(any?.client_name || any?.client || '').trim();
        if (cn) state.client_name = cn;
      }

      // Preselect if only one
      if (!state.selected_contract_id && state.contracts.length === 1) {
        const onlyId = String(state.contracts[0]?.id || '').trim();
        if (onlyId) state.selected_contract_id = onlyId;
      }
    } catch (e) {
      state.contracts = [];
      state.error = e?.message || String(e);
    } finally {
      state.loading = false;
      repaint();
    }
  };

  const renderTab = (key) => {
    if (key !== 'main') return '';

    const contracts = Array.isArray(state.contracts) ? state.contracts : [];
    const selectedId = String(state.selected_contract_id || '').trim();

    const headerCandidate = state.candidate_display ? state.candidate_display : 'Selected candidate';
    const headerClient = state.client_name ? state.client_name : state.client_id;

    const scopeLine = state.scope_ymd
      ? `Active on: <span class="mono">${enc(state.scope_ymd)}</span>`
      : `Active on: <span class="mini">â€”</span>`;

    const tableBody = contracts.length
      ? contracts.map((c) => {
          const id = String(c?.id || '').trim();
          const band = safeBand(c);
          const role = safeRole(c);
          const site = safeSite(c);

          const start = safeDate(c?.start_date);
          const end = safeDate(c?.end_date);

          const isSel = (id && id === selectedId);
          const radio = id
            ? `<input type="radio" name="hrwbr_contract" data-act="hrwbr-select" data-id="${enc(id)}" ${isSel ? 'checked' : ''}/>`
            : `<span class="mini">â€”</span>`;

          return `
            <tr data-id="${enc(id)}" style="cursor:pointer;" data-act="hrwbr-row">
              <td class="mini" style="width:70px; text-align:center;">${radio}</td>
              <td class="mini" style="white-space:normal; word-break:break-word;">${enc(band || 'â€”')}</td>
              <td class="mini" style="white-space:normal; word-break:break-word;">${enc(role || 'â€”')}</td>
              <td class="mini" style="white-space:normal; word-break:break-word;">${enc(site || 'â€”')}</td>
              <td class="mini" style="width:120px; white-space:nowrap;">${enc(start)}</td>
              <td class="mini" style="width:120px; white-space:nowrap;">${enc(end)}</td>
            </tr>
          `;
        }).join('')
      : `
        <tr>
          <td colspan="6">
            <span class="mini">${state.loading ? 'Loadingâ€¦' : 'No active contracts found for this candidate/client on this date.'}</span>
          </td>
        </tr>
      `;

    const errHtml = state.error
      ? `<div class="hint" style="color:#ffb4b4; margin-top:8px;">${enc(state.error)}</div>`
      : '';

    return `
      <div id="hrWeeklyBandResolveModal" data-import-id="${enc(state.import_id)}">
        <div class="card">
          <div class="row">
            <label>Resolve HealthRoster grade to contract</label>
            <div class="controls">
              <div class="mini">
                Incoming HealthRoster code: <span class="mono">${enc(state.incoming_code)}</span><br/>
                Candidate: <strong>${enc(headerCandidate)}</strong><br/>
                Client: <span class="mini">${enc(headerClient)}</span><br/>
                ${scopeLine}
              </div>
              <div class="hint" style="margin-top:8px;">
                Pick the correct contract for this candidate and client. We will create a <strong>candidate + client</strong> mapping
                for this incoming code, targeting the chosen contract (most reliable).
              </div>
              ${errHtml}
            </div>
          </div>
        </div>

        <div class="card" style="margin-top:10px;">
          <div class="row">
            <label>Active contracts</label>
            <div class="controls">
              <div style="max-height:46vh; overflow:auto; border:1px solid var(--line); border-radius:10px;">
                <table class="grid" style="table-layout:auto; width:100%; min-width:980px;">
                  <thead>
                    <tr>
                      <th style="width:70px;">Pick</th>
                      <th style="width:140px;">Band</th>
                      <th style="width:220px;">Role</th>
                      <th>Site / Ward</th>
                      <th style="width:120px;">Start</th>
                      <th style="width:120px;">End</th>
                    </tr>
                  </thead>
                  <tbody>${tableBody}</tbody>
                </table>
              </div>

              <div class="hint" style="margin-top:8px;">
                This creates a candidate+client rule:
                <span class="mono">${enc(state.incoming_code)}</span> â†’ <span class="mono">(selected contract)</span>.
                It applies whenever this candidate appears for this client with this code in future HR weekly imports.
              </div>
            </div>
          </div>
        </div>

        <div class="row" style="margin-top:10px;">
          <label></label>
          <div class="controls">
            <button type="button" class="btn" data-act="hrwbr-refresh" ${state.loading ? 'disabled' : ''}>Refresh</button>
            <button type="button" class="btn btn-primary" style="margin-left:8px;" data-act="hrwbr-save" ${state.loading ? 'disabled' : ''}>Save mapping</button>
            <button type="button" class="btn" style="margin-left:8px;" data-act="hrwbr-cancel">Close</button>
          </div>
        </div>
      </div>
    `;
  };

  const onReturn = () => {
    const root = document.getElementById('hrWeeklyBandResolveModal');
    if (!root) return;

    // De-dupe per DOM instance (re-render replaces DOM, so this is safe)
    if (root.__hrwbrWired) return;
    root.__hrwbrWired = true;

    const closeModal = () => {
      const closeBtn = document.getElementById('btnCloseModal');
      if (closeBtn) closeBtn.click();
    };

    root.addEventListener('click', async (ev) => {
      const btnAny = ev.target && ev.target.closest ? ev.target.closest('[data-act]') : null;
      const act = btnAny ? String(btnAny.getAttribute('data-act') || '') : '';

      // Row selection
      const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-act="hrwbr-row"]') : null;
      if (tr) {
        const id = String(tr.getAttribute('data-id') || '').trim();
        if (id) {
          state.selected_contract_id = id;
          repaint();
        }
        return;
      }

      if (act === 'hrwbr-select') {
        const id = String(btnAny.getAttribute('data-id') || '').trim();
        if (id) {
          state.selected_contract_id = id;
          repaint();
        }
        return;
      }

      if (act === 'hrwbr-refresh') {
        await loadContracts();
        return;
      }

      if (act === 'hrwbr-cancel') {
        closeModal();
        return;
      }

      if (act === 'hrwbr-save') {
        try {
          const selId = String(state.selected_contract_id || '').trim();
          if (!selId) {
            alert('Pick a contract row first.');
            return;
          }

          const c = (state.contracts || []).find(x => String(x?.id || '').trim() === selId) || null;
          if (!c) {
            alert('Selected contract not found (please refresh).');
            return;
          }

          const band = safeBand(c);
          const role = safeRole(c);

          // band_match_pattern is still required by schema; keep it readable even though contract target is authoritative.
          const bandPattern = (band || role || 'Contract').trim();

          const ok = window.confirm(
            `Create candidate+client mapping?\n\nIncoming code: ${state.incoming_code}\nTarget: ${bandPattern}\n\nThis will affect future HR weekly imports for this candidate + client.`
          );
          if (!ok) return;

          state.loading = true;
          state.error = '';
          repaint();

          // âœ… NEW LOGIC:
          // Create candidate+client scoped row targeting contract_id (most reliable).
          await apiCreateAssignmentBandMapping({
            system_type: 'HR_WEEKLY',
            incoming_code: state.incoming_code,
            candidate_id: state.candidate_id,
            client_id: state.client_id,
            target_contract_id: selId,
            band_match_pattern: bandPattern,
            active: true,
            scope_kind: 'CANDIDATE_CLIENT',
            allow_candidate_client_scope: true,
            notes: `Resolved via HR_WEEKLY import ${state.import_id} (candidate+client contract-target).`
          });

          if (window.__toast) window.__toast('Contract mapping saved.');

          state.loading = false;
          repaint();

          // Reclassify the weekly import preview immediately
          if (typeof refreshWeeklyImportSummary === 'function') {
            try { await refreshWeeklyImportSummary('HR_WEEKLY', state.import_id); } catch {}
          }

          closeModal();
        } catch (e) {
          state.loading = false;
          state.error = e?.message || String(e);
          repaint();
          alert(state.error);
        }
      }
    });
  };

  showModal(
    'Resolve HealthRoster grade',
    [{ key: 'main', label: 'Resolve contract' }],
    renderTab,
    null,
    false,
    onReturn,
    {
      kind,
      noParentGate: true,
      stayOpenOnSave: false,
      showSave: false
    }
  );

  // Initial load
  setTimeout(() => {
    try {
      const fr = (typeof window.__getModalFrame === 'function') ? window.__getModalFrame() : null;
      if (fr && fr.kind === kind && typeof fr.onReturn === 'function' && !fr.__hrwbrInit) {
        fr.__hrwbrInit = true;
        fr.onReturn();
        loadContracts();
      }
    } catch (e) {
      console.warn('[HR_WEEKLY_BAND_RESOLVE] init failed', e);
    }
  }, 0);
}


async function openHrWeeklyClientPicker() {
  window.modalCtx = window.modalCtx || {};
  window.modalCtx.importsState = window.modalCtx.importsState || {};
  const st = window.modalCtx.importsState;

  if (st.hrWeeklyClientId) {
    return {
      clientId: st.hrWeeklyClientId,
      clientName: st.hrWeeklyClientName || ''
    };
  }

  let items = [];
  try {
    const res  = await authFetch(API('/api/healthroster/autoprocess/clients'));
    const text = await res.text();
    if (!res.ok) throw new Error(text || `Failed to load HealthRoster clients (${res.status})`);
    const json = text ? JSON.parse(text) : {};
    items = Array.isArray(json.items) ? json.items : [];
  } catch (e) {
    console.error('[IMPORTS][HR_WEEKLY] failed to load clients', e);
    alert(e?.message || 'Failed to load HealthRoster clients for weekly import.');
    return null;
  }

  if (!items.length) {
    alert('No HealthRoster weekly import clients are configured.');
    return null;
  }

  return new Promise((resolve) => {
    const optionsHtml = items.map((c) => {
      const id = String(c.client_id || '');
      const name = String(c.client_name || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');
      return `<option value="${id}">${name}</option>`;
    }).join('');

    showModal(
      'Select HealthRoster client',
      [{ key: 'main', label: 'Select client' }],
      (k) => {
        if (k !== 'main') return '';
        return `
          <div style="display:block;">
            <div class="row">
              <label>Client</label>
              <div class="controls">
                <select class="input" id="hrWeeklyClientSelect">
                  <option value="">-- choose a client --</option>
                  ${optionsHtml}
                </select>
              </div>
            </div>
            <div class="hint" style="grid-column:1/-1">
              This client will be used for parsing and applying this HealthRoster weekly export.
              You can change it in future imports.
            </div>
          </div>
        `;
      },
      async () => {
        const sel = document.getElementById('hrWeeklyClientSelect');
        if (!sel || !sel.value) {
          alert('Please select a client to continue.');
          return false; // keep modal open
        }

        const clientId = String(sel.value || '').trim();
        const clientName = (sel.options && sel.selectedIndex >= 0)
          ? String(sel.options[sel.selectedIndex].textContent || '')
          : '';

        st.hrWeeklyClientId = clientId;
        st.hrWeeklyClientName = clientName;

        resolve({ clientId, clientName });
        return true; // close modal
      },
      false,
      null,
      { kind: 'hr-weekly-client-picker', noParentGate: true }
    );
  });
}




// =================== ADD HOSPITAL MODAL (UPDATED: push into stagedNew) ===================
// ==== CHILD MODAL (ADD HOSPITAL) â€” throw on errors; return true on success ====

function openClientHospitalModal(client_id) {
  const parentFrame = _currentFrame();
  // âœ… Allow create OR edit to add hospitals pre-save
  const parentEditable = parentFrame && (parentFrame.mode === 'edit' || parentFrame.mode === 'create');
  const ctx = window.modalCtx; // ðŸ”§ use canonical context

  const formHtml = html(`
    <div class="form" id="hospitalForm">
      ${input('hospital_name_norm','Hospital / Trust (normalised)','', 'text', parentEditable ? {} : { disabled:true })}
      ${input('ward_hint','Ward hint (optional)','', 'text', parentEditable ? {} : { disabled:true })}
    </div>
  `);

  // â¬‡ï¸ Key change: pass noParentGate so the child save isn't blocked by the "not dirty" guard
  showModal(
    'Add Hospital / Ward',
    [{key:'form',label:'Form'}],
    () => formHtml,
    async ()=> {
      const pf = _parentFrame();
      // âœ… Allow create OR edit to apply
      if (!pf || (pf.mode !== 'edit' && pf.mode !== 'create')) return false;

      const raw  = collectForm('#hospitalForm');
      const name = String(raw.hospital_name_norm || '').trim();
      if (!name) { alert('Hospital / Trust is required'); return false; }

      const H = ctx.hospitalsState || (ctx.hospitalsState = { existing: [], stagedNew: [], stagedEdits:{}, stagedDeletes: new Set() });
      H.stagedNew.push({ hospital_name_norm: name, ward_hint: (raw.ward_hint || '').trim() || null });

      try { window.dispatchEvent(new CustomEvent('modal-dirty')); } catch {}
      try { renderClientHospitalsTable(); } catch {}
      return true; // Apply closes child
    },
    false,
    () => {
      const parent = _currentFrame();
      if (parent) { parent.currentTabKey = 'hospitals'; parent.setTab('hospitals'); }
    },
    // â¬‡ï¸ Options: bypass parent-gate guard for this child modal only
    { noParentGate: true, forceEdit: true, kind: 'client-hospital' }
  );
}



async function weeklySearchClientsForResolve(importType, term) {
  const q = String(term || '').trim();
  if (!q) return [];

  let results = [];
  try {
    results = await searchClientsForResolve(q);
    if (!Array.isArray(results)) results = [];
  } catch (e) {
    console.error('[WEEKLY][RESOLVE] client search failed', e);
    throw e;
  }

  const t = String(importType || '').toUpperCase();

  // For NHSP, only show clients with is_nhsp === true
  if (t === 'NHSP') {
    results = results.filter(c => c && (c.is_nhsp === true || c.client_is_nhsp === true));
  }

  return results;
}

async function openWeeklyClientResolveModal(importType, importId, rowIdx) {
  const type = String(importType || '').toUpperCase();
  const enc  = (typeof escapeHtml === 'function')
    ? escapeHtml
    : (s) => String(s == null ? '' : s);

  const st   = window.__importSummaryState && window.__importSummaryState[type];
  const rows = st && Array.isArray(st.rows) ? st.rows : [];
  const row  = (rowIdx >= 0 && rowIdx < rows.length) ? rows[rowIdx] : null;
  if (!row) {
    alert('Row not found for client resolve.');
    return;
  }

  const staffRaw = row.staff_name || row.staff_raw || '';
  const unitRaw  = row.unit || row.hospital_or_trust || row.hospital_norm || '';

  window.__weeklyResolveClientState = {
    type,
    importId,
    rowIdx,
    term: unitRaw,
    results: [],
    selectedClientId: null
  };

  const state = () => window.__weeklyResolveClientState || {};

  const renderTab = (key) => {
    if (key !== 'main') return '';
    const s = state();
    const term = s.term || '';

    return html(`
      <div class="form" id="weeklyResolveClient">
        <div class="card">
          <div class="row">
            <label>Assign client / site</label>
            <div class="controls">
              <div class="mini">
                Import: <span class="mono">${enc(importId || '')}</span><br/>
                Unit / Site (from import): <strong>${enc(unitRaw || 'â€”')}</strong><br/>
                Staff: <span class="mini">${enc(staffRaw || 'â€”')}</span>
              </div>
            </div>
          </div>
        </div>

        <div class="card" style="margin-top:10px;">
          <div class="row">
            <label>Client name</label>
            <div class="controls">
              <input id="weeklyClientSearch"
                     class="input"
                     type="text"
                     placeholder="Type to search by client name"
                     value="${enc(term)}" />
              <div class="hint mini" style="margin-top:4px;">
                For NHSP, only NHSP-enabled clients will be shown.
              </div>
            </div>
          </div>
          <div class="row">
            <label>Matches</label>
            <div class="controls" id="weeklyClientResults">
              <span class="mini">Type a name to search for clients.</span>
            </div>
          </div>
          <div class="row" style="margin-top:8px;">
            <label></label>
            <div class="controls">
              <button type="button"
                      class="btn btn-primary"
                      data-act="weekly-client-link">
                Link to this client
              </button>
              <button type="button"
                      class="btn"
                      style="margin-left:8px;"
                      data-act="weekly-client-cancel">
                Cancel
              </button>
            </div>
          </div>
        </div>
      </div>
    `);
  };

  showModal(
    'Assign client (weekly import)',
    [{ key: 'main', label: 'Assign client' }],
    renderTab,
    null,
    false,
    null,
    {
      kind: 'import-summary-weekly-resolve-client',
      noParentGate: true,
      stayOpenOnSave: false
    }
  );

  function renderClientResults() {
    const s = state();
    const results    = Array.isArray(s.results) ? s.results : [];
    const selectedId = s.selectedClientId || '';

    const root = document.getElementById('modalBody');
    if (!root) return;
    const host = root.querySelector('#weeklyClientResults');
    if (!host) return;

    if (!results.length) {
      host.innerHTML = '<span class="mini">No clients matched. Try typing a different name.</span>';
      return;
    }

    const listHtml = `
      <div class="card" style="max-height:250px;overflow:auto;border:1px solid #ddd;margin-top:4px;">
        <ul class="mini">
          ${results.map(c => {
            const id   = c.id;
            const name = c.name || c.client_name || '';
            const selected = String(id) === String(selectedId);
            const style = selected ? ' style="background:#007bff;color:#fff;cursor:pointer;"' : ' style="cursor:pointer;"';
            return `
              <li class="weekly-client-option"${style}
                  data-act="weekly-client-select"
                  data-client-id="${enc(id)}">
                <strong>${enc(name || '')}</strong>
                ${c.cli_ref ? ` &nbsp; <span class="mono">(${enc(c.cli_ref)})</span>` : ''}
              </li>
            `;
          }).join('')}
        </ul>
      </div>
    `;

    host.innerHTML = listHtml;
  }

  async function searchAndRender(term) {
    const q = String(term || '').trim();
    window.__weeklyResolveClientState = state();
    window.__weeklyResolveClientState.term = q;

    if (!q) {
      window.__weeklyResolveClientState.results = [];
      window.__weeklyResolveClientState.selectedClientId = null;
      renderClientResults();
      return;
    }

    try {
      const results = await weeklySearchClientsForResolve(type, q);
      window.__weeklyResolveClientState.results = Array.isArray(results) ? results : [];
      if (results && results.length === 1) {
        window.__weeklyResolveClientState.selectedClientId = results[0].id;
      }
    } catch (err) {
      console.error('[WEEKLY][RESOLVE] client search failed', err);
      alert(err?.message || 'Client search failed.');
      window.__weeklyResolveClientState.results = [];
      window.__weeklyResolveClientState.selectedClientId = null;
    }

    renderClientResults();
  }

  setTimeout(() => {
    const root = document.getElementById('modalBody');
    if (!root) return;

    const fr = (typeof window.__getModalFrame === 'function') ? window.__getModalFrame() : null;
    if (!fr || fr.kind !== 'import-summary-weekly-resolve-client') return;

    const input = root.querySelector('#weeklyClientSearch');
    if (input && !input.__weeklyClientInputWired) {
      input.__weeklyClientInputWired = true;
      input.addEventListener('input', () => {
        const term = (input.value || '').trim();
        searchAndRender(term);
      });
      searchAndRender(input.value || '');
    }

    const resultsHost = root.querySelector('#weeklyClientResults');
    if (resultsHost && !resultsHost.__weeklyClientSelectWired) {
      resultsHost.__weeklyClientSelectWired = true;
      resultsHost.addEventListener('click', (ev) => {
        const li = ev.target.closest('li[data-act="weekly-client-select"]');
        if (!li) return;
        const clientId = li.getAttribute('data-client-id') || '';
        if (!clientId) return;
        window.__weeklyResolveClientState = state();
        window.__weeklyResolveClientState.selectedClientId = clientId;
        renderClientResults();
      });
    }

    // âœ… FIX: guard against stacking duplicate click listeners on #modalBody
    root.__wkResolveActionsWired ||= new Set();
    if (!root.__wkResolveActionsWired.has('import-summary-weekly-resolve-client')) {
      root.__wkResolveActionsWired.add('import-summary-weekly-resolve-client');

      root.addEventListener('click', (ev) => {
        const frNow = (typeof window.__getModalFrame === 'function') ? window.__getModalFrame() : null;
        if (!frNow || frNow.kind !== 'import-summary-weekly-resolve-client') return;

        const btn = ev.target.closest('button[data-act]');
        if (!btn) return;

        const act = btn.getAttribute('data-act');
        const s   = state();

        if (act === 'weekly-client-cancel') {
          const closeBtn = document.getElementById('btnCloseModal');
          if (closeBtn) closeBtn.click();
          return;
        }

        if (act === 'weekly-client-link') {
          const selectedId = s.selectedClientId;
          if (!selectedId) {
            alert('Select a client from the list on the right first.');
            return;
          }

          const mappings = ensureWeeklyImportMappings(type, importId);
          const hospRaw  = row.hospital_or_trust || row.unit || row.hospital_norm || '';
          const hospNorm = String(hospRaw || '').trim().toLowerCase();

          mappings.client_aliases.push({
            hospital_norm: hospNorm || '',
            client_id: selectedId
          });

          const all = window.__importSummaryState && window.__importSummaryState[type];
          if (all && Array.isArray(all.rows)) {
            const newRows = all.rows.slice();
            const cur = { ...(newRows[rowIdx] || {}) };
            cur.client_id = selectedId;

            if (!cur.candidate_id) cur.resolution_status = 'NO_CANDIDATE';
            else cur.resolution_status = 'OK';

            newRows[rowIdx] = cur;
            window.__importSummaryState[type] = {
              import_id: all.import_id,
              summary: all.summary,
              rows: newRows
            };
            renderImportSummaryModal(type, {
              import_id: all.import_id,
              summary: all.summary.summary || all.summary,
              rows: newRows
            });
          }

          window.__toast && window.__toast('Client mapping queued for this import.');

          const closeBtn = document.getElementById('btnCloseModal');
          if (closeBtn) closeBtn.click();
        }
      });
    }
  }, 0);
}

async function openWeeklyCandidateResolveModal(importType, importId, rowIdx) {
  const type = String(importType || '').toUpperCase();

  const st   = window.__importSummaryState && window.__importSummaryState[type];
  const rows = st && Array.isArray(st.rows) ? st.rows : [];
  const row  = (rowIdx >= 0 && rowIdx < rows.length) ? rows[rowIdx] : null;

  if (!row) {
    alert('Row not found for candidate resolve.');
    return;
  }

  const staffRaw = row.staff_name || row.staff_raw || '';
  const unitRaw  = row.unit || row.hospital_or_trust || row.hospital_norm || '';

  if (typeof openCandidatePicker !== 'function') {
    alert('Candidate picker is not available (openCandidatePicker is missing).');
    return;
  }
  if (typeof postWeeklyResolveMappings !== 'function') {
    alert('postWeeklyResolveMappings is not defined.');
    return;
  }
  if (typeof refreshWeeklyImportSummary !== 'function') {
    alert('refreshWeeklyImportSummary is not defined.');
    return;
  }

  // Seed hint for suggestions (openCandidatePicker already supports seed_hint + ignoreMembership)
  const parts = String(staffRaw || '').trim().split(/\s+/).filter(Boolean);
  const first = parts.length ? parts[0] : '';
  const sur   = parts.length > 1 ? parts[parts.length - 1] : '';

  const seedHint = {
    source: 'weekly_import',
    display_name: String(staffRaw || '').trim(),
    first_name: first || '',
    surname: sur || ''
  };

  // Context block shown above picker search
  const ctx = {
    staffName: staffRaw || '(unknown)',
    unit: unitRaw || '',
    hospital: unitRaw || '',
    importId: String(importId || ''),
    dateYmd: row.work_date || row.date_local || row.week_ending_date || ''
  };

  // Open canonical picker and persist mapping via resolve-conflicts
  await openCandidatePicker(async ({ id, label }) => {
    const selectedId = String(id || '').trim();
    if (!selectedId) throw new Error('No candidate selected.');

    const staffNorm =
      row.staff_norm ||
      String(staffRaw || '').trim().toLowerCase();

    const hospRaw =
      row.hospital_or_trust ||
      row.unit ||
      row.hospital_norm ||
      unitRaw ||
      '';

    const hospNorm = String(hospRaw || '').trim().toLowerCase() || null;

    const mapping = {
      staff_norm: staffNorm || '',
      hospital_or_trust: hospNorm,
      candidate_id: selectedId,

      // extra context (safe / helpful for backend validation paths)
      client_id: row.client_id || null,
      work_date: row.work_date || row.date_local || row.date || row.week_ending_date || null
    };

    // Persist immediately
    await postWeeklyResolveMappings(importId, type, {
      candidate_mappings: [mapping],
      client_aliases: []
    });

    // Keep local per-import mapping queue consistent (existing behaviour)
    try {
      const mappings = (typeof ensureWeeklyImportMappings === 'function')
        ? ensureWeeklyImportMappings(type, importId)
        : null;
      if (mappings && Array.isArray(mappings.candidate_mappings)) {
        mappings.candidate_mappings.push(mapping);
      }
    } catch {}

    window.__toast && window.__toast(`Candidate ${label || ''} linked. Reclassifyingâ€¦`);

    // Reclassify/refresh the weekly preview
    await refreshWeeklyImportSummary(type, importId);
  }, {
    context: ctx,
    seed_hint: seedHint,
    // Weekly imports should be able to pick from all candidates, not just â€œmembershipâ€
    ignoreMembership: true
  });
}


function ensureWeeklyImportMappings(type, importId) {
  const t = String(type || '').toUpperCase();
  const id = String(importId || '');
  window.__weeklyImportMappings = window.__weeklyImportMappings || {};
  if (!window.__weeklyImportMappings[t]) {
    window.__weeklyImportMappings[t] = {};
  }
  let m = window.__weeklyImportMappings[t][id];
  if (!m) {
    m = {
      candidate_mappings: [],
      client_aliases: []
    };
    window.__weeklyImportMappings[t][id] = m;
  }
  return m;
}


function renderImportSummaryModal(importType, summaryState) {
  const enc = (typeof escapeHtml === 'function')
    ? escapeHtml
    : (s) => String(s == null ? '' : s);

  const type = String(importType || '').toUpperCase();

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Normalize preview wrapper vs summary-only payload into a canonical object.
  // This ensures top-level extensions like actions / groups / truth_meta and
  // changed_shifts are never dropped (even if nested under summary).
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const normalizePreview = (ss) => {
    const raw = ss || {};
    const sum = (raw && typeof raw.summary === 'object' && raw.summary) ? raw.summary : raw;

    const importId =
      raw.import_id || raw.id ||
      sum.import_id || sum.id ||
      (raw.summary && (raw.summary.import_id || raw.summary.id)) ||
      null;

    const rows =
      Array.isArray(raw.rows) ? raw.rows :
      Array.isArray(sum.rows) ? sum.rows :
      [];

    const changed_shifts =
      Array.isArray(raw.changed_shifts) ? raw.changed_shifts :
      Array.isArray(sum.changed_shifts) ? sum.changed_shifts :
      [];

    // âœ… Preserve weekly preview fields even when nested under summary
    const actions =
      Array.isArray(raw.actions) ? raw.actions :
      Array.isArray(sum.actions) ? sum.actions :
      [];

    const validation_groups =
      Array.isArray(raw.validation_groups) ? raw.validation_groups :
      Array.isArray(sum.validation_groups) ? sum.validation_groups :
      [];

    const action_groups =
      Array.isArray(raw.action_groups) ? raw.action_groups :
      Array.isArray(sum.action_groups) ? sum.action_groups :
      [];

    const truth_meta =
      (raw && typeof raw.truth_meta === 'object' && raw.truth_meta) ? raw.truth_meta :
      (sum && typeof sum.truth_meta === 'object' && sum.truth_meta) ? sum.truth_meta :
      null;

    // Keep validation_meta if present (useful for weekly HR email UI)
    const validation_meta =
      (raw && typeof raw.validation_meta === 'object' && raw.validation_meta) ? raw.validation_meta :
      (sum && typeof sum.validation_meta === 'object' && sum.validation_meta) ? sum.validation_meta :
      null;

    // âœ… Preserve NEW auto-apply action IDs (even if nested under summary or camelCase)
    const auto_apply_action_ids =
      Array.isArray(raw.auto_apply_action_ids) ? raw.auto_apply_action_ids :
      Array.isArray(sum.auto_apply_action_ids) ? sum.auto_apply_action_ids :
      Array.isArray(raw.autoApplyActionIds) ? raw.autoApplyActionIds :
      Array.isArray(sum.autoApplyActionIds) ? sum.autoApplyActionIds :
      [];

    // âœ… Preserve mode summary if present (snake + camel, raw + summary)
    let mode_summary =
      raw.mode_summary || sum.mode_summary ||
      raw.modeSummary || sum.modeSummary ||
      null;

    const asBool = (v) => (v === true || v === 'true' || v === 1 || v === '1');
    const decisionNeededCount = changed_shifts.filter(x => asBool(x?.requires_any_decision)).length;

    const summary = Object.assign({}, sum);
    // Put changed_shifts into summary too, so any code path using only summary still sees them.
    if (!Array.isArray(summary.changed_shifts)) summary.changed_shifts = changed_shifts;
    if (typeof summary.changed_shifts_count !== 'number') summary.changed_shifts_count = changed_shifts.length;
    if (typeof summary.changed_shifts_decision_needed_count !== 'number') summary.changed_shifts_decision_needed_count = decisionNeededCount;

    // âœ… Put auto_apply_action_ids into summary too, so summary-only code paths see them.
    if (!Array.isArray(summary.auto_apply_action_ids)) summary.auto_apply_action_ids = auto_apply_action_ids;

    // âœ… Put mode_summary into summary too (for summary-only code paths).
    if (typeof summary.mode_summary !== 'string' && typeof mode_summary === 'string') {
      summary.mode_summary = mode_summary;
    }

    const canonical = Object.assign({}, raw);
    canonical.import_id = importId;
    canonical.summary = summary;
    canonical.rows = rows;

    canonical.changed_shifts = changed_shifts;

    // âœ… Hoist weekly preview payload fields to top level for consistent access
    canonical.actions = actions;
    canonical.validation_groups = validation_groups;
    canonical.action_groups = action_groups;
    if (truth_meta) canonical.truth_meta = truth_meta;
    if (validation_meta) canonical.validation_meta = validation_meta;

    // âœ… Hoist auto-apply IDs (snake + camel for max compatibility)
    canonical.auto_apply_action_ids = auto_apply_action_ids;
    canonical.autoApplyActionIds = auto_apply_action_ids;

    // âœ… Hoist mode summary (snake + camel compatibility)
    if (typeof mode_summary === 'string' && mode_summary) {
      canonical.mode_summary = mode_summary;
      canonical.modeSummary = mode_summary;
    }

    return canonical;
  };

  const preview = normalizePreview(summaryState);
  const importId = preview.import_id || null;
  const rows = Array.isArray(preview.rows) ? preview.rows : [];

  // Compute an authoritative mode for HR_WEEKLY:
  // Prefer backend mode_summary; only fall back to safe heuristics.
  const computeWeeklyMode = (t, p) => {
    const T = String(t || '').toUpperCase();
    const raw =
      (p && (p.mode_summary || p.modeSummary)) ||
      (p && p.summary && (p.summary.mode_summary || p.summary.modeSummary)) ||
      null;

    const ms = String(raw || '').trim().toUpperCase();
    if (ms === 'MODE_A_ONLY' || ms === 'MODE_B_ONLY' || ms === 'MIXED') return ms;

    // Fallback heuristics (only when backend didn't provide mode_summary):
    // IMPORTANT: avoid falling back to Mode-B messaging when Phase-2 rejects produce no groups.
    if (T === 'HR_WEEKLY') {
      const vg = Array.isArray(p?.validation_groups) ? p.validation_groups.length : 0;
      const ag = Array.isArray(p?.action_groups) ? p.action_groups.length : 0;
      const acts = Array.isArray(p?.actions) ? p.actions.length : 0;

      if (vg > 0 && (ag > 0 || acts > 0)) return 'MIXED';
      if (vg > 0) return 'MODE_A_ONLY';
      if (ag > 0 || acts > 0) return 'MODE_B_ONLY';

      // If EVERYTHING is empty, treat as Mode A by default so we never show apply/overwrite semantics.
      return 'MODE_A_ONLY';
    }

    // For NHSP, keep historical behaviour (no forced default).
    return '';
  };

  const effectiveMode = computeWeeklyMode(type, preview);

  // Keep canonical preview consistent (top-level + summary) for downstream UI.
  if (type === 'HR_WEEKLY') {
    if (effectiveMode) {
      preview.mode_summary = effectiveMode;
      preview.modeSummary = effectiveMode;
      preview.summary = preview.summary && typeof preview.summary === 'object' ? preview.summary : {};
      preview.summary.mode_summary = effectiveMode;
    }
  }

  window.__importSummaryState = window.__importSummaryState || {};
  // Store canonical preview object (NOT just summary+rows)
  window.__importSummaryState[type] = preview;

  // Identify existing summary frame
  const summaryKind = `import-summary-${type.toLowerCase()}`;
  const stack       = window.__modalStack || [];

  let existingSummaryFrame = null;
  for (let i = stack.length - 1; i >= 0; i--) {
    const fr = stack[i];
    if (fr && fr.kind === summaryKind) {
      existingSummaryFrame = fr;
      break;
    }
  }

  const renderTab = (key) => {
    if (key !== 'main') return '';

    if (type === 'HR_ROTA_DAILY') {
      return renderHrRotaDailySummary(type, importId, rows, preview);
    }

    if (type === 'NHSP') {
      // NHSP unchanged: keep existing weekly apply-style renderer
      return renderWeeklyImportSummary(type, importId, rows, preview);
    }

    if (type === 'HR_WEEKLY') {
      const ms = String(preview?.mode_summary || preview?.modeSummary || preview?.summary?.mode_summary || '').toUpperCase();

      // âœ… Authoritative routing for HR_WEEKLY
      if (ms === 'MODE_A_ONLY' || ms === 'MIXED') {
        if (typeof renderHrWeeklyValidationSummary === 'function') {
          const validationHtml = renderHrWeeklyValidationSummary(type, importId, preview);

          // For MIXED, append existing weekly summary (actions) below validation UI.
          if (ms === 'MIXED') {
            const actionsHtml = renderWeeklyImportSummary(type, importId, rows, preview);
            return html(`
              ${validationHtml}
              <div class="form" style="margin-top:10px">
                <div class="card">
                  <div class="row">
                    <label>Apply actions</label>
                    <div class="controls">
                      <span class="mini">This import includes both validation items and apply actions.</span>
                    </div>
                  </div>
                </div>
              </div>
              ${actionsHtml}
            `);
          }

          return validationHtml;
        }

        // Fallback: if the new renderer isn't present, do not show apply messaging.
        return html(`
          <div class="form">
            <div class="card">
              <div class="row">
                <label>Validation</label>
                <div class="controls">
                  <span class="mini">Validation renderer is missing (renderHrWeeklyValidationSummary).</span>
                  <div class="hint">Update the frontend bundle to include the Mode-A validation renderer.</div>
                </div>
              </div>
            </div>
          </div>
        `);
      }

      // Mode B only: keep existing weekly apply-style renderer unchanged
      return renderWeeklyImportSummary(type, importId, rows, preview);
    }

    return html(`
      <div class="form">
        <div class="card">
          <div class="row">
            <label>Summary</label>
            <div class="controls">
              <span class="mini">Unsupported import type: ${enc(importType)}</span>
            </div>
          </div>
        </div>
      </div>
    `);
  };

  // Title must reflect validation mode for HR_WEEKLY (and keep NHSP unchanged)
  const summaryTitle = (() => {
    if (type === 'HR_ROTA_DAILY') return 'HR Rota Daily Validation';
    if (type === 'NHSP') return 'NHSP Weekly Import Summary';

    if (type === 'HR_WEEKLY') {
      const ms = String(preview?.mode_summary || preview?.modeSummary || preview?.summary?.mode_summary || '').toUpperCase();
      if (ms === 'MODE_A_ONLY') return 'HealthRoster Weekly Validation';
      if (ms === 'MIXED') return 'HealthRoster Weekly Validation + Apply';
      return 'HealthRoster Weekly Import Summary';
    }

    return 'Import Summary';
  })();

  // Create or reuse modal frame
  if (!existingSummaryFrame) {
    showModal(
      summaryTitle,
      [{ key: 'main', label: 'Summary' }],
      renderTab,
      null,
      false,
      null,
      {
        kind: summaryKind,
        noParentGate: true,
        stayOpenOnSave: false,
        // âœ… never show global footer Save for import summary utility modals
        showSave: false
      }
    );
  } else {
    try {
      // âœ… enforce showSave=false even on reused frames (prevents Save appearing)
      existingSummaryFrame.showSave = false;
      if (existingSummaryFrame.opts && typeof existingSummaryFrame.opts === 'object') existingSummaryFrame.opts.showSave = false;
      if (existingSummaryFrame._opts && typeof existingSummaryFrame._opts === 'object') existingSummaryFrame._opts.showSave = false;

      existingSummaryFrame.title         = summaryTitle;
      existingSummaryFrame.tabs          = [{ key: 'main', label: 'Summary' }];
      existingSummaryFrame.renderTab     = renderTab;
      existingSummaryFrame.currentTabKey = 'main';

      const top = (window.__modalStack || [])[ (window.__modalStack || []).length - 1 ] || null;
      if (top === existingSummaryFrame && typeof existingSummaryFrame.setTab === 'function') {
        existingSummaryFrame.setTab('main');
      }
    } catch (e) {
      console.warn('[IMPORTS] failed to re-render existing import summary frame', e);
    }
  }

  // âœ… Belt-and-braces: hide the global footer Save button for this modal kind (UI-level)
  setTimeout(() => {
    try {
      const frNow = (typeof window.__getModalFrame === 'function') ? window.__getModalFrame() : null;
      if (!frNow) return;
      if (String(frNow.kind || '') !== summaryKind) return;

      const btnSave = document.getElementById('btnSave');
      if (btnSave) btnSave.style.display = 'none';
    } catch {}
  }, 0);

  // Wiring:
  // - NHSP: unchanged weekly wiring
  // - HR_WEEKLY:
  //   - MODE_A_ONLY: do NOT call weekly action wiring; wire validation UI only
  //   - MIXED: call weekly action wiring (for actions section) AND wire validation UI
  //   - MODE_B_ONLY: unchanged weekly wiring
  try {
    if (type === 'NHSP') {
      wireWeeklyImportSummaryActions(type, importId);
    } else if (type === 'HR_WEEKLY') {
      const ms = String(preview?.mode_summary || preview?.modeSummary || preview?.summary?.mode_summary || '').toUpperCase();

      if (ms === 'MODE_A_ONLY') {
        if (typeof wireHrWeeklyValidationSummaryActions === 'function') {
          wireHrWeeklyValidationSummaryActions('HR_WEEKLY', importId);
        }
      } else if (ms === 'MIXED') {
        // Mode-B actions section wiring (existing behaviour)
        wireWeeklyImportSummaryActions(type, importId);

        // Mode-A validation section wiring (emails + reclassify + finalise + resolve buttons)
        if (typeof wireHrWeeklyValidationSummaryActions === 'function') {
          wireHrWeeklyValidationSummaryActions('HR_WEEKLY', importId);
        }
      } else {
        // MODE_B_ONLY (or unknown): preserve existing behaviour
        wireWeeklyImportSummaryActions(type, importId);
      }
    }
  } catch {}
}

function openAssignmentBandMappingsModal(opts) {
  // Ensure we have a local HTML-escape helper in this closure
  // (prevents "ReferenceError: enc is not defined")
  const enc = (typeof escapeHtml === 'function')
    ? escapeHtml
    : (x) => String(x || '')
        .replaceAll('&','&amp;')
        .replaceAll('<','&lt;')
        .replaceAll('>','&gt;')
        .replaceAll('"','&quot;')
        .replaceAll("'",'&#39;');

  const seed = (opts && typeof opts === 'object') ? opts : {};
  const initSystem = String(seed.system_type || seed.systemType || 'NHSP').toUpperCase();

  // Weekly-only (per your decision)
  const SYSTEMS = ['NHSP', 'HR_WEEKLY'];

  const state = {
    // Filters
    system_type: SYSTEMS.includes(initSystem) ? initSystem : 'NHSP',
    scope_filter: 'ANY', // ANY | GLOBAL | CLIENT | CANDIDATE
    filter_incoming_like: String(seed.incoming_code || seed.incomingCode || '').trim(),
    filter_candidate_id: seed.candidate_id || seed.candidateId || null,
    filter_candidate_label: '',
    filter_client_id: seed.client_id || seed.clientId || null,
    filter_client_label: '',
    include_inactive: false,

    // List
    rows: [],
    loading: false,
    error: '',

    // Add form
    add_scope: (() => {
      const cid = seed.candidate_id || seed.candidateId || null;
      const lid = seed.client_id || seed.clientId || null;
      if (cid) return 'CANDIDATE';
      if (lid) return 'CLIENT';
      return 'GLOBAL';
    })(),
    add_incoming_code: String(seed.incoming_code || seed.incomingCode || '').trim(),
    add_band_match_pattern: '',
    add_notes: '',
    add_active: true,
    add_candidate_id: seed.candidate_id || seed.candidateId || null,
    add_candidate_label: '',
    add_client_id: seed.client_id || seed.clientId || null,
    add_client_label: '',

    // Edit form
    editing: null,
    edit_band_match_pattern: '',
    edit_notes: '',
    edit_active: true
  };

  const kind = 'import-summary-assignment-band-mappings';

  // âœ… Scope label: do NOT include IDs; candidate/client names are shown in dedicated columns where available.
  const scopeLabelForRow = (r) => {
    const hasCand = !!r.candidate_id;
    const hasCli  = !!r.client_id;
    if (hasCand && hasCli) return 'Candidate+Client';
    if (hasCand) return 'Candidate';
    if (hasCli)  return 'Client';
    return 'Global';
  };

  const renderTab = () => {
    const sys = state.system_type;

    const errHtml = state.error
      ? `<div class="hint" style="color:#ffb4b4;">${enc(state.error)}</div>`
      : '';

    const editOpen = !!state.editing;

    const addScope = state.add_scope;
    const showAddCand = (addScope === 'CANDIDATE');
    const showAddCli  = (addScope === 'CLIENT');

    const filterScope = state.scope_filter;
    const showFilterCand = (filterScope === 'CANDIDATE');
    const showFilterCli  = (filterScope === 'CLIENT');

    // Buttons in the Actions column are wrapped so they never spill out
    const listBody = (state.rows && state.rows.length)
      ? state.rows.map(r => {
          const id = r.id || '';
          const incoming = (r.incoming_code || '').toString();
          const patt = (r.band_match_pattern || '').toString();
          const notes = (r.notes || '').toString();
          const active = (r.active !== false);

          const pill    = active ? 'pill-ok' : 'pill-warn';
          const pillTxt = active ? 'ACTIVE' : 'INACTIVE';

          const hasCand = !!r.candidate_id;
          const candName = String(r.candidate_name || r.candidate_label || '').trim();
          const candDisp = hasCand ? (candName || 'Candidate') : 'â€”';

          const scopeTxt = scopeLabelForRow(r);

          // âœ… Notes: keep compact (2-line clamp + hover title)
          const notesTitle = notes ? ` title="${enc(notes)}"` : '';

          return `
            <tr data-id="${enc(id)}">
              <td><span class="mini mono">${enc(incoming || 'â€”')}</span></td>
              <td>
                <span class="mini" style="white-space:normal;word-break:break-word;display:inline-block;max-width:260px;">
                  ${enc(patt || 'â€”')}
                </span>
              </td>
              <td>
                <span class="mini" style="white-space:normal;word-break:break-word;display:inline-block;max-width:260px;">
                  ${enc(candDisp)}
                </span>
              </td>
              <td>
                <span class="mini">${enc(scopeTxt)}</span>
              </td>
              <td><span class="pill ${pill}" style="padding:2px 8px;font-size:12px;">${enc(pillTxt)}</span></td>
              <td>
                <span class="mini"${notesTitle} style="
                  display:-webkit-box;
                  -webkit-line-clamp:2;
                  -webkit-box-orient:vertical;
                  overflow:hidden;
                  max-width:320px;
                  white-space:normal;
                  word-break:break-word;
                ">
                  ${enc(notes || '')}
                </span>
              </td>
              <td>
                <div style="display:flex;flex-wrap:wrap;gap:6px;align-items:flex-start;">
                  <button type="button" class="btn mini" data-act="abm-edit" data-id="${enc(id)}">Edit</button>
                  <button type="button" class="btn mini" data-act="abm-toggle" data-id="${enc(id)}">
                    ${active ? 'Disable' : 'Enable'}
                  </button>
                  <button type="button" class="btn mini" data-act="abm-delete" data-id="${enc(id)}">
                    Remove
                  </button>
                </div>
              </td>
            </tr>
          `;
        }).join('')
      : `
        <tr>
          <td colspan="7"><span class="mini">${state.loading ? 'Loadingâ€¦' : 'No mappings found for this filter.'}</span></td>
        </tr>
      `;

    // âœ… IMPORTANT: no ".form" wrapper (which would split into 2 columns).
    // This makes the whole modal body full-width.
    return `
      <div id="assignmentBandMappingsModal">
        <div class="card">
          <div class="row">
            <label>Filters</label>
            <div class="controls" style="display:flex;gap:8px;flex-wrap:wrap;align-items:center;">
              <select class="input" id="abm_system" style="max-width:220px;">
                <option value="NHSP" ${sys==='NHSP'?'selected':''}>NHSP</option>
                <option value="HR_WEEKLY" ${sys==='HR_WEEKLY'?'selected':''}>HR weekly</option>
              </select>

              <select class="input" id="abm_scope_filter" style="max-width:200px;">
                <option value="ANY" ${filterScope==='ANY'?'selected':''}>Any scope</option>
                <option value="GLOBAL" ${filterScope==='GLOBAL'?'selected':''}>Global only</option>
                <option value="CLIENT" ${filterScope==='CLIENT'?'selected':''}>Client only</option>
                <option value="CANDIDATE" ${filterScope==='CANDIDATE'?'selected':''}>Candidate only</option>
              </select>

              <input class="input" id="abm_incoming_like" type="text"
                     style="max-width:260px;"
                     placeholder="Filter by code (e.g. CPN120)â€¦"
                     value="${enc(state.filter_incoming_like || '')}"/>

              <label class="mini" style="display:flex;gap:6px;align-items:center;">
                <input type="checkbox" id="abm_include_inactive" ${state.include_inactive ? 'checked' : ''}/>
                Show inactive
              </label>

              <button type="button" class="btn" id="abm_refresh" ${state.loading ? 'disabled' : ''}>Refresh</button>

              <span class="mini" style="opacity:.85;">
                ${state.loading ? 'Loadingâ€¦' : `${(state.rows||[]).length} row(s)`}
              </span>
            </div>
          </div>

          <div class="row" style="margin-top:6px; display:${(showFilterCand || showFilterCli) ? '' : 'none'};">
            <label>Scope target</label>
            <div class="controls" style="display:flex;gap:8px;flex-wrap:wrap;align-items:center;">
              <div style="display:${showFilterCand ? '' : 'none'};">
                <span class="mini">Candidate:</span>
                <span class="mini mono" id="abm_filter_candidate_label">${enc(state.filter_candidate_label || (state.filter_candidate_id ? 'Selected candidate' : 'â€”'))}</span>
                <button type="button" class="btn mini" style="margin-left:6px;" data-act="abm-pick-filter-candidate">Pickâ€¦</button>
                <button type="button" class="btn mini" style="margin-left:4px;" data-act="abm-clear-filter-candidate">Clear</button>
              </div>

              <div style="display:${showFilterCli ? '' : 'none'};">
                <span class="mini">Client:</span>
                <span class="mini mono" id="abm_filter_client_label">${enc(state.filter_client_label || (state.filter_client_id ? 'Selected client' : 'â€”'))}</span>
                <button type="button" class="btn mini" style="margin-left:6px;" data-act="abm-pick-filter-client">Pickâ€¦</button>
                <button type="button" class="btn mini" style="margin-left:4px;" data-act="abm-clear-filter-client">Clear</button>
              </div>

              <span class="mini" style="opacity:.75;">
                (Scope target is optional; pick one to narrow results further.)
              </span>
            </div>
          </div>

          ${errHtml}
        </div>

        <div class="card" style="margin-top:10px;">
          <div class="row">
            <label>Add mapping</label>
            <div class="controls" style="display:flex;gap:8px;flex-wrap:wrap;align-items:flex-start;">
              <div style="min-width:180px;">
                <div class="mini" style="margin-bottom:4px;">Scope</div>
                <select class="input" id="abm_add_scope" style="max-width:180px;">
                  <option value="GLOBAL" ${addScope==='GLOBAL'?'selected':''}>Global</option>
                  <option value="CLIENT" ${addScope==='CLIENT'?'selected':''}>Client</option>
                  <option value="CANDIDATE" ${addScope==='CANDIDATE'?'selected':''}>Candidate</option>
                </select>
              </div>

              <div style="min-width:220px;flex:1;">
                <div class="mini" style="margin-bottom:4px;">Incoming code</div>
                <input class="input" id="abm_add_incoming" type="text"
                       placeholder="e.g. CPN120"
                       value="${enc(state.add_incoming_code || '')}"/>
              </div>

              <div style="min-width:260px;flex:2;">
                <div class="mini" style="margin-bottom:4px;">Band match pattern</div>
                <input class="input" id="abm_add_pattern" type="text"
                       placeholder="e.g. Band 6, CPN, 6"
                       value="${enc(state.add_band_match_pattern || '')}"/>
              </div>

              <div style="min-width:260px;flex:2;">
                <div class="mini" style="margin-bottom:4px;">Notes (optional)</div>
                <input class="input" id="abm_add_notes" type="text"
                       placeholder="Optional noteâ€¦"
                       value="${enc(state.add_notes || '')}"/>
              </div>

              <div style="min-width:140px;">
                <div class="mini" style="margin-bottom:4px;">Active</div>
                <label class="mini" style="display:flex;gap:6px;align-items:center;">
                  <input type="checkbox" id="abm_add_active" ${state.add_active ? 'checked' : ''}/>
                  Active
                </label>
              </div>

              <div style="min-width:140px;padding-top:18px;">
                <button type="button" class="btn btn-primary" id="abm_add_save" ${state.loading ? 'disabled' : ''}>
                  Add
                </button>
              </div>
            </div>
          </div>

          <div class="row" style="margin-top:6px; display:${showAddCand ? '' : 'none'};">
            <label>Candidate</label>
            <div class="controls" style="display:flex;gap:8px;flex-wrap:wrap;align-items:center;">
              <span class="mini mono" id="abm_add_candidate_label">${enc(state.add_candidate_label || (state.add_candidate_id ? 'Selected candidate' : 'â€”'))}</span>
              <button type="button" class="btn mini" data-act="abm-pick-add-candidate">Pickâ€¦</button>
              <button type="button" class="btn mini" data-act="abm-clear-add-candidate">Clear</button>
            </div>
          </div>

          <div class="row" style="margin-top:6px; display:${showAddCli ? '' : 'none'};">
            <label>Client</label>
            <div class="controls" style="display:flex;gap:8px;flex-wrap:wrap;align-items:center;">
              <span class="mini mono" id="abm_add_client_label">${enc(state.add_client_label || (state.add_client_id ? 'Selected client' : 'â€”'))}</span>
              <button type="button" class="btn mini" data-act="abm-pick-add-client">Pickâ€¦</button>
              <button type="button" class="btn mini" data-act="abm-clear-add-client">Clear</button>
            </div>
          </div>
        </div>

        <div class="card" style="margin-top:10px; display:${editOpen ? '' : 'none'};" id="abm_edit_card">
          <div class="row">
            <label>Edit mapping</label>
            <div class="controls" style="display:flex;gap:8px;flex-wrap:wrap;align-items:flex-start;">
              <div class="mini" style="width:100%;">
                Editing ID: <span class="mono" id="abm_edit_id">${enc(state.editing?.id || '')}</span>
                &nbsp;â€¢&nbsp;
                Code: <span class="mono">${enc(state.editing?.incoming_code || '')}</span>
                &nbsp;â€¢&nbsp;
                Scope: <span class="mono">${enc(state.editing ? scopeLabelForRow(state.editing) : '')}</span>
              </div>

              <div style="min-width:260px;flex:2;">
                <div class="mini" style="margin-bottom:4px;">Band match pattern</div>
                <input class="input" id="abm_edit_pattern" type="text" value="${enc(state.edit_band_match_pattern||'')}" />
              </div>

              <div style="min-width:260px;flex:2;">
                <div class="mini" style="margin-bottom:4px;">Notes</div>
                <input class="input" id="abm_edit_notes" type="text" value="${enc(state.edit_notes||'')}" />
              </div>

              <div style="min-width:140px;">
                <div class="mini" style="margin-bottom:4px;">Active</div>
                <label class="mini" style="display:flex;gap:6px;align-items:center;">
                  <input type="checkbox" id="abm_edit_active" ${state.edit_active ? 'checked' : ''}/>
                  Active
                </label>
              </div>

              <div style="min-width:220px;padding-top:18px;">
                <button type="button" class="btn btn-primary" id="abm_edit_save" ${state.loading ? 'disabled' : ''}>Save changes</button>
                <button type="button" class="btn" id="abm_edit_cancel" style="margin-left:6px;">Cancel</button>
              </div>
            </div>
          </div>
        </div>

        <!-- âœ… FULL-WIDTH MAPPINGS BOX -->
        <div class="card" style="margin-top:10px;">
          <div class="row">
            <label>Mappings</label>
            <div class="controls">
              <div style="
                max-height: 46vh;
                overflow: auto;
                border: 1px solid var(--line);
                border-radius: 10px;
              ">
                <table class="grid" style="table-layout:auto; width:100%;">
                  <thead>
                    <tr>
                      <th style="width:140px;">Incoming code</th>
                      <th style="width:220px;">Band pattern</th>
                      <th style="width:260px;">Candidate</th>
                      <th style="width:140px;">Scope</th>
                      <th style="width:90px;">Active</th>
                      <th style="width:320px; min-width:320px;">Notes</th>
                      <th style="width:260px;">Actions</th>
                    </tr>
                  </thead>
                  <tbody id="abm_tbody">${listBody}</tbody>
                </table>
              </div>

              <div class="hint" style="margin-top:8px;">
                Precedence: Candidate overrides Client overrides Global. Matching is a simple â€œband contains patternâ€ check.
              </div>
            </div>
          </div>
        </div>
      </div>
    `;
  };

  const repaint = () => {
    const fr = window.__getModalFrame?.();
    if (!fr) return;
    try { fr.setTab(fr.currentTabKey || 'p'); } catch {}
    try {
      const fr2 = window.__getModalFrame?.();
      if (fr2 && typeof fr2.onReturn === 'function') fr2.onReturn();
    } catch {}
  };

  const applyLocalScopeFilterIfNeeded = (rowsIn) => {
    const rows = Array.isArray(rowsIn) ? rowsIn : [];
    const sf = String(state.scope_filter || 'ANY').toUpperCase();

    // If the user chose CLIENT/CANDIDATE but didn't pick an id, we still want a useful filter
    // without relying on backend scope=CLIENT/CANDIDATE (which requires a target id).
    if (sf === 'CLIENT' && !state.filter_client_id) {
      return rows.filter(r => (r && r.candidate_id == null && r.client_id != null));
    }
    if (sf === 'CANDIDATE' && !state.filter_candidate_id) {
      return rows.filter(r => (r && r.candidate_id != null));
    }
    return rows;
  };

  const loadList = async () => {
    state.loading = true;
    state.error = '';
    try {
      repaint();

      const sf = String(state.scope_filter || 'ANY').toUpperCase();

      // âœ… IMPORTANT:
      // - scope=GLOBAL works without a target id (backend supported)
      // - scope=CLIENT/CANDIDATE require a target id (backend enforced)
      // So only pass those scope values when the target id exists; otherwise fetch ANY and filter locally.
      const scopeParam =
        (sf === 'GLOBAL') ? 'GLOBAL' :
        (sf === 'CLIENT' && state.filter_client_id) ? 'CLIENT' :
        (sf === 'CANDIDATE' && state.filter_candidate_id) ? 'CANDIDATE' :
        null;

      const rows = await apiListAssignmentBandMappings({
        system_type: state.system_type,
        incoming_like: state.filter_incoming_like || null,
        scope: scopeParam,
        candidate_id: (scopeParam === 'CANDIDATE') ? (state.filter_candidate_id || null) : null,
        client_id:    (scopeParam === 'CLIENT')    ? (state.filter_client_id || null)    : null,
        include_inactive: state.include_inactive
      });

      state.rows = applyLocalScopeFilterIfNeeded(rows);
    } catch (e) {
      state.rows = [];
      state.error = e?.message || String(e);
    } finally {
      state.loading = false;
      repaint();
    }
  };

  const startEdit = (row) => {
    if (!row) return;
    state.editing = row;
    state.edit_band_match_pattern = (row.band_match_pattern || '').toString();
    state.edit_notes = (row.notes || '').toString();
    state.edit_active = (row.active !== false);
    repaint();
  };

  const cancelEdit = () => {
    state.editing = null;
    state.edit_band_match_pattern = '';
    state.edit_notes = '';
    state.edit_active = true;
    repaint();
  };

  const onReturn = () => {
    const root = document.getElementById('assignmentBandMappingsModal');
    if (!root) return;

    // Filters
    const selSystem = document.getElementById('abm_system');
    const selScope  = document.getElementById('abm_scope_filter');
    const inpLike   = document.getElementById('abm_incoming_like');
    const chkInact  = document.getElementById('abm_include_inactive');
    const btnRef    = document.getElementById('abm_refresh');

    // Add
    const addScope  = document.getElementById('abm_add_scope');
    const addIn     = document.getElementById('abm_add_incoming');
    const addPat    = document.getElementById('abm_add_pattern');
    const addNotes  = document.getElementById('abm_add_notes');
    const addAct    = document.getElementById('abm_add_active');
    const addSave   = document.getElementById('abm_add_save');

    // Edit
    const editPat   = document.getElementById('abm_edit_pattern');
    const editNotes = document.getElementById('abm_edit_notes');
    const editAct   = document.getElementById('abm_edit_active');
    const editSave  = document.getElementById('abm_edit_save');
    const editCancel= document.getElementById('abm_edit_cancel');

    // Wire filter changes
    if (selSystem && !selSystem.__abmWired) {
      selSystem.__abmWired = true;
      selSystem.addEventListener('change', () => {
        state.system_type = String(selSystem.value || 'NHSP').toUpperCase();
        cancelEdit();
        loadList();
      });
    }
    if (selScope && !selScope.__abmWired) {
      selScope.__abmWired = true;
      selScope.addEventListener('change', () => {
        state.scope_filter = String(selScope.value || 'ANY').toUpperCase();
        if (state.scope_filter !== 'CANDIDATE') { state.filter_candidate_id = null; state.filter_candidate_label = ''; }
        if (state.scope_filter !== 'CLIENT')    { state.filter_client_id = null; state.filter_client_label = ''; }
        cancelEdit();

        // âœ… FIX: changing scope must actually refresh the list (not just repaint)
        loadList();
      });
    }
    if (inpLike && !inpLike.__abmWired) {
      inpLike.__abmWired = true;
      inpLike.addEventListener('input', () => { state.filter_incoming_like = String(inpLike.value || ''); });
      inpLike.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') { e.preventDefault(); loadList(); }
      });
    }
    if (chkInact && !chkInact.__abmWired) {
      chkInact.__abmWired = true;
      chkInact.addEventListener('change', () => {
        state.include_inactive = !!chkInact.checked;
        cancelEdit();
        loadList();
      });
    }
    if (btnRef && !btnRef.__abmWired) {
      btnRef.__abmWired = true;
      btnRef.addEventListener('click', () => loadList());
    }

    // Wire add fields
    if (addScope && !addScope.__abmWired) {
      addScope.__abmWired = true;
      addScope.addEventListener('change', () => {
        state.add_scope = String(addScope.value || 'GLOBAL').toUpperCase();
        if (state.add_scope !== 'CANDIDATE') { state.add_candidate_id = null; state.add_candidate_label = ''; }
        if (state.add_scope !== 'CLIENT')    { state.add_client_id = null; state.add_client_label = ''; }
        repaint();
      });
    }
    if (addIn && !addIn.__abmWired) {
      addIn.__abmWired = true;
      addIn.addEventListener('input', () => { state.add_incoming_code = String(addIn.value || ''); });
    }
    if (addPat && !addPat.__abmWired) {
      addPat.__abmWired = true;
      addPat.addEventListener('input', () => { state.add_band_match_pattern = String(addPat.value || ''); });
    }
    if (addNotes && !addNotes.__abmWired) {
      addNotes.__abmWired = true;
      addNotes.addEventListener('input', () => { state.add_notes = String(addNotes.value || ''); });
    }
    if (addAct && !addAct.__abmWired) {
      addAct.__abmWired = true;
      addAct.addEventListener('change', () => { state.add_active = !!addAct.checked; });
    }
    if (addSave && !addSave.__abmWired) {
      addSave.__abmWired = true;
      addSave.addEventListener('click', async () => {
        const incoming = String(state.add_incoming_code || '').trim();
        const pattern  = String(state.add_band_match_pattern || '').trim();

        if (!incoming) { alert('Incoming code is required.'); return; }
        if (!pattern)  { alert('Band match pattern is required.'); return; }

        const scope = String(state.add_scope || 'GLOBAL').toUpperCase();
        let candidate_id = null;
        let client_id = null;

        if (scope === 'CANDIDATE') {
          candidate_id = state.add_candidate_id || null;
          if (!candidate_id) { alert('Pick a candidate for a candidate-specific rule.'); return; }
        } else if (scope === 'CLIENT') {
          client_id = state.add_client_id || null;
          if (!client_id) { alert('Pick a client for a client-specific rule.'); return; }
        }

        try {
          state.loading = true;
          state.error = '';
          repaint();

          await apiCreateAssignmentBandMapping({
            system_type: state.system_type,
            incoming_code: incoming,
            candidate_id,
            client_id,
            band_match_pattern: pattern,
            active: !!state.add_active,
            notes: String(state.add_notes || '').trim() || null
          });

          window.__toast && window.__toast('Mapping added.');

          state.add_band_match_pattern = '';
          state.add_notes = '';
          state.add_active = true;

          await loadList();
        } catch (e) {
          state.error = e?.message || String(e);
          state.loading = false;
          repaint();
          alert(state.error);
        }
      });
    }

    // Wire edit fields
    if (editPat && !editPat.__abmWired) {
      editPat.__abmWired = true;
      editPat.addEventListener('input', () => { state.edit_band_match_pattern = String(editPat.value || ''); });
    }
    if (editNotes && !editNotes.__abmWired) {
      editNotes.__abmWired = true;
      editNotes.addEventListener('input', () => { state.edit_notes = String(editNotes.value || ''); });
    }
    if (editAct && !editAct.__abmWired) {
      editAct.__abmWired = true;
      editAct.addEventListener('change', () => { state.edit_active = !!editAct.checked; });
    }
    if (editSave && !editSave.__abmWired) {
      editSave.__abmWired = true;
      editSave.addEventListener('click', async () => {
        if (!state.editing || !state.editing.id) return;
        const id = state.editing.id;

        const pattern = String(state.edit_band_match_pattern || '').trim();
        if (!pattern) { alert('Band match pattern is required.'); return; }

        try {
          state.loading = true;
          state.error = '';
          repaint();

          await apiUpdateAssignmentBandMapping(id, {
            band_match_pattern: pattern,
            notes: String(state.edit_notes || '').trim() || null,
            active: !!state.edit_active
          });

          window.__toast && window.__toast('Mapping updated.');
          cancelEdit();
          await loadList();
        } catch (e) {
          state.error = e?.message || String(e);
          state.loading = false;
          repaint();
          alert(state.error);
        }
      });
    }
    if (editCancel && !editCancel.__abmWired) {
      editCancel.__abmWired = true;
      editCancel.addEventListener('click', () => cancelEdit());
    }

    // Button actions + pickers + row actions
    if (!root.__abmWiredActions) {
      root.__abmWiredActions = true;
      root.addEventListener('click', async (ev) => {
        const btn = ev.target.closest('button[data-act]');
        if (!btn) return;

        const act = btn.getAttribute('data-act');

        // Filter pickers
        if (act === 'abm-pick-filter-candidate') {
          openCandidatePicker(async ({ id, label }) => {
            state.filter_candidate_id = id;
            state.filter_candidate_label = label || '';
            repaint();
            await loadList();
          }, { context: { staffName: 'Filter scope', unit: 'Candidate', importId: seed.import_id || '' } });
          return;
        }
        if (act === 'abm-clear-filter-candidate') {
          state.filter_candidate_id = null;
          state.filter_candidate_label = '';
          repaint();
          await loadList();
          return;
        }
        if (act === 'abm-pick-filter-client') {
          openClientPicker(async ({ id, label }) => {
            state.filter_client_id = id;
            state.filter_client_label = label || '';
            repaint();
            await loadList();
          }, { context: { staffName: 'Filter scope', unit: 'Client', importId: seed.import_id || '' } });
          return;
        }
        if (act === 'abm-clear-filter-client') {
          state.filter_client_id = null;
          state.filter_client_label = '';
          repaint();
          await loadList();
          return;
        }

        // Add pickers
        if (act === 'abm-pick-add-candidate') {
          openCandidatePicker(async ({ id, label }) => {
            state.add_candidate_id = id;
            state.add_candidate_label = label || '';
            repaint();
          }, { context: { staffName: 'Mapping scope', unit: 'Candidate', importId: seed.import_id || '' } });
          return;
        }
        if (act === 'abm-clear-add-candidate') {
          state.add_candidate_id = null;
          state.add_candidate_label = '';
          repaint();
          return;
        }
        if (act === 'abm-pick-add-client') {
          openClientPicker(async ({ id, label }) => {
            state.add_client_id = id;
            state.add_client_label = label || '';
            repaint();
          }, { context: { staffName: 'Mapping scope', unit: 'Client', importId: seed.import_id || '' } });
          return;
        }
        if (act === 'abm-clear-add-client') {
          state.add_client_id = null;
          state.add_client_label = '';
          repaint();
          return;
        }

        // Row actions
        if (act === 'abm-edit') {
          const id = btn.getAttribute('data-id');
          const row = (state.rows || []).find(x => String(x.id) === String(id)) || null;
          startEdit(row);
          return;
        }

        if (act === 'abm-toggle') {
          const id = btn.getAttribute('data-id');
          const row = (state.rows || []).find(x => String(x.id) === String(id)) || null;
          if (!row) return;

          const nextActive = !(row.active !== false);

          try {
            state.loading = true;
            state.error = '';
            repaint();

            await apiUpdateAssignmentBandMapping(id, { active: nextActive });

            window.__toast && window.__toast(nextActive ? 'Mapping enabled.' : 'Mapping disabled.');
            cancelEdit();
            await loadList();
          } catch (e) {
            state.error = e?.message || String(e);
            state.loading = false;
            repaint();
            alert(state.error);
          }
          return;
        }

        if (act === 'abm-delete') {
          const id = btn.getAttribute('data-id');
          const ok = window.confirm('Remove this mapping? (It will be deactivated for safety)');
          if (!ok) return;

          try {
            state.loading = true;
            state.error = '';
            repaint();

            await apiDeleteAssignmentBandMapping(id);

            window.__toast && window.__toast('Mapping removed.');
            cancelEdit();
            await loadList();
          } catch (e) {
            state.error = e?.message || String(e);
            state.loading = false;
            repaint();
            alert(state.error);
          }
          return;
        }
      });
    }
  };

  showModal(
    'Weekly Band Mappings',
    [{ key: 'p', title: 'Mappings' }],
    () => renderTab(),
    async () => true,
    false,
    onReturn,
    { kind, noParentGate: true }
  );

  // Initial wiring + load
  setTimeout(() => {
    try {
      const fr = window.__getModalFrame?.();
      if (fr && fr.kind === kind && typeof fr.onReturn === 'function' && !fr.__abmInit) {
        fr.__abmInit = true;
        fr.onReturn();
        loadList();
      }
    } catch (e) {
      console.warn('[ASSIGNMENT_BAND_MAPPINGS] init failed', e);
    }
  }, 0);
}


async function openWeeklyImportOptionsModal(type, importId, preview) {
  const t = String(type || '').toUpperCase();
  const impId = (importId != null) ? String(importId) : '';

  // Weekly imports only
  if (!impId || (t !== 'NHSP' && t !== 'HR_WEEKLY')) return true;

  const asYmd = (v) => {
    if (!v) return null;
    if (typeof v === 'string') {
      const s = v.trim();
      if (/^\d{4}-\d{2}-\d{2}$/.test(s)) return s;
      if (s.length >= 10 && /^\d{4}-\d{2}-\d{2}/.test(s)) return s.slice(0, 10);
    }
    try {
      const d = new Date(v);
      if (Number.isNaN(d.getTime())) return null;
      const yyyy = d.getUTCFullYear();
      const mm   = String(d.getUTCMonth() + 1).padStart(2, '0');
      const dd   = String(d.getUTCDate()).padStart(2, '0');
      return `${yyyy}-${mm}-${dd}`;
    } catch {
      return null;
    }
  };

  const p = (preview && typeof preview === 'object') ? preview : {};
  const truthMeta = (p.truth_meta && typeof p.truth_meta === 'object') ? p.truth_meta : {};
  const actions = Array.isArray(p.actions) ? p.actions : [];

  const fileMin = asYmd(truthMeta.file_date_min);
  const fileMax = asYmd(truthMeta.file_date_max);

  // Fallback only if file min/max are not provided by backend (should be rare)
  const minMaxFromActions = () => {
    let minD = null, maxD = null;
    for (const a of actions) {
      const wd = asYmd(a?.work_date || a?.workDate || a?.date_local || a?.date || null);
      if (!wd) continue;
      if (!minD || wd < minD) minD = wd;
      if (!maxD || wd > maxD) maxD = wd;
    }
    return { minD, maxD };
  };
  const { minD: actMin, maxD: actMax } = minMaxFromActions();

  // âœ… Forced behaviour: include missing shifts, and date range = import file min/max
  const forcedFrom = fileMin || actMin || null;
  const forcedTo   = fileMax || actMax || null;

  // Ensure persistent weekly UI store exists (NO MODAL)
  window.__weeklyImportUi = window.__weeklyImportUi || {};
  window.__weeklyImportUi[t] = window.__weeklyImportUi[t] || {};

  let ui = window.__weeklyImportUi[t][impId] || null;
  if (!ui || typeof ui !== 'object' || Array.isArray(ui)) {
    ui = {
      options: { missingShiftsEnabled: true, dateFrom: null, dateTo: null },
      actionSelection: new Set(),
      filters: { showOnlyRed: false, showOnlyUnticked: false, showOnlyCancellations: false, search: '' },
      // NHSP legacy Set; HR_WEEKLY validation uses Map for explicit untick
      emailSelection: (t === 'HR_WEEKLY') ? new Map() : new Set(),
      hydratedFlags: (t === 'HR_WEEKLY')
        ? { didInitDefaultActionChecks: false, didInitDefaultEmailChecks: false, didInitDefaultInvalidationChecks: false }
        : { didInitDefaultActionChecks: false }
    };
  }

  // Options forced (no user choice)
  ui.options = (ui.options && typeof ui.options === 'object' && !Array.isArray(ui.options)) ? ui.options : {};
  ui.options.missingShiftsEnabled = true;
  ui.options.dateFrom = forcedFrom;
  ui.options.dateTo = forcedTo;

  // Normalise / repair inverted ranges (forced)
  const df0 = asYmd(ui.options.dateFrom);
  const dt0 = asYmd(ui.options.dateTo);
  if (df0 && dt0 && df0 > dt0) {
    ui.options.dateFrom = forcedFrom;
    ui.options.dateTo = forcedTo;
  } else {
    ui.options.dateFrom = df0 || ui.options.dateFrom;
    ui.options.dateTo = dt0 || ui.options.dateTo;
  }

  // Normalise core stores (no clobber)
  if (!(ui.actionSelection instanceof Set)) ui.actionSelection = new Set();

  if (t === 'HR_WEEKLY') {
    if (ui.emailSelection instanceof Set) {
      const m = new Map();
      for (const k of Array.from(ui.emailSelection)) {
        const kk = String(k || '').trim();
        if (kk) m.set(kk, true);
      }
      ui.emailSelection = m;
    }
    if (!(ui.emailSelection instanceof Map)) ui.emailSelection = new Map();

    if (!(ui.invalidationSelection instanceof Map)) ui.invalidationSelection = new Map();
    if (!(ui.altEmailByKey instanceof Map)) ui.altEmailByKey = new Map();

    ui.hydratedFlags = (ui.hydratedFlags && typeof ui.hydratedFlags === 'object' && !Array.isArray(ui.hydratedFlags)) ? ui.hydratedFlags : {};
    if (typeof ui.hydratedFlags.didInitDefaultActionChecks !== 'boolean') ui.hydratedFlags.didInitDefaultActionChecks = false;
    if (typeof ui.hydratedFlags.didInitDefaultEmailChecks !== 'boolean') ui.hydratedFlags.didInitDefaultEmailChecks = false;
    if (typeof ui.hydratedFlags.didInitDefaultInvalidationChecks !== 'boolean') ui.hydratedFlags.didInitDefaultInvalidationChecks = false;
  } else {
    if (!(ui.emailSelection instanceof Set)) ui.emailSelection = new Set();
    ui.hydratedFlags = (ui.hydratedFlags && typeof ui.hydratedFlags === 'object' && !Array.isArray(ui.hydratedFlags)) ? ui.hydratedFlags : {};
    if (typeof ui.hydratedFlags.didInitDefaultActionChecks !== 'boolean') ui.hydratedFlags.didInitDefaultActionChecks = false;
  }

  ui.filters = (ui.filters && typeof ui.filters === 'object' && !Array.isArray(ui.filters)) ? ui.filters : {};
  if (typeof ui.filters.showOnlyRed !== 'boolean') ui.filters.showOnlyRed = false;
  if (typeof ui.filters.showOnlyUnticked !== 'boolean') ui.filters.showOnlyUnticked = false;
  if (typeof ui.filters.showOnlyCancellations !== 'boolean') ui.filters.showOnlyCancellations = false;
  if (typeof ui.filters.search !== 'string') ui.filters.search = '';

  window.__weeklyImportUi[t][impId] = ui;

  // âœ… No options modal is ever shown now
  return true;
}

async function handleNhspFileDrop(file) {
  const summaryEl = document.getElementById('nhspImportSummary');
  if (summaryEl) {
    summaryEl.textContent = 'Uploading NHSP file to storageâ€¦';
  }

  try {
    // 1) Upload file to R2 and get file_key
    const { fileKey, filename } = await uploadImportFileToR2(file);

    if (summaryEl) {
      summaryEl.textContent = 'Registering NHSP import and parsing workbookâ€¦';
    }

    // 2) Tell backend about the file so it can parse + classify
    const resUpload = await authFetch(API('/api/nhsp/import'), {
      method: 'POST',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify({
        original_name: filename,
        file_key: fileKey,
        tz_assumption: 'Europe/London'
      })
    });
    const textUpload = await resUpload.text();
    if (!resUpload.ok) {
      throw new Error(textUpload || `NHSP import upload failed (${resUpload.status})`);
    }

    let parsed;
    try { parsed = textUpload ? JSON.parse(textUpload) : {}; } catch { parsed = {}; }
    const importId = parsed.import_id || parsed.id || null;
    if (!importId) {
      throw new Error('NHSP import did not return an import_id.');
    }

    if (summaryEl) {
      summaryEl.textContent = `File uploaded. Loading NHSP classification for import ${importId}â€¦`;
    }

    // 3) Fetch preview / classification
    const resPrev  = await authFetch(API(`/api/nhsp/${encodeURIComponent(importId)}/preview`));
    const textPrev = await resPrev.text();
    if (!resPrev.ok) {
      throw new Error(textPrev || `NHSP import preview failed (${resPrev.status})`);
    }

    let summaryState;
    try { summaryState = textPrev ? JSON.parse(textPrev) : {}; } catch { summaryState = {}; }

    // âœ… Forced behaviour: include missing shifts always; use file min/max date range
    try {
      const asYmd = (v) => {
        if (!v) return null;
        if (typeof v === 'string') {
          const s = v.trim();
          if (/^\d{4}-\d{2}-\d{2}$/.test(s)) return s;
          if (s.length >= 10 && /^\d{4}-\d{2}-\d{2}/.test(s)) return s.slice(0, 10);
        }
        try {
          const d = new Date(v);
          if (Number.isNaN(d.getTime())) return null;
          const yyyy = d.getUTCFullYear();
          const mm = String(d.getUTCMonth() + 1).padStart(2, '0');
          const dd = String(d.getUTCDate()).padStart(2, '0');
          return `${yyyy}-${mm}-${dd}`;
        } catch {
          return null;
        }
      };

      const tm =
        (summaryState && typeof summaryState.truth_meta === 'object' && summaryState.truth_meta) ? summaryState.truth_meta :
        (summaryState && summaryState.summary && typeof summaryState.summary.truth_meta === 'object' && summaryState.summary.truth_meta) ? summaryState.summary.truth_meta :
        null;

      const fileMin = tm ? asYmd(tm.file_date_min) : null;
      const fileMax = tm ? asYmd(tm.file_date_max) : null;

      window.__weeklyImportUi = window.__weeklyImportUi || {};
      window.__weeklyImportUi.NHSP = window.__weeklyImportUi.NHSP || {};

      const impIdStr = String(importId);
      let ui = window.__weeklyImportUi.NHSP[impIdStr] || null;
      if (!ui || typeof ui !== 'object' || Array.isArray(ui)) {
        ui = {
          options: { missingShiftsEnabled: true, dateFrom: null, dateTo: null },
          actionSelection: new Set(),
          filters: { showOnlyRed: false, showOnlyUnticked: false, showOnlyCancellations: false, search: '' },
          emailSelection: new Set(),
          hydratedFlags: { didInitDefaultActionChecks: false }
        };
      }

      ui.options = (ui.options && typeof ui.options === 'object' && !Array.isArray(ui.options)) ? ui.options : {};
      ui.options.missingShiftsEnabled = true;
      ui.options.dateFrom = fileMin;
      ui.options.dateTo = fileMax;

      if (!(ui.actionSelection instanceof Set)) ui.actionSelection = new Set();
      if (!(ui.emailSelection instanceof Set)) ui.emailSelection = new Set();

      ui.filters = (ui.filters && typeof ui.filters === 'object' && !Array.isArray(ui.filters)) ? ui.filters : {};
      if (typeof ui.filters.showOnlyRed !== 'boolean') ui.filters.showOnlyRed = false;
      if (typeof ui.filters.showOnlyUnticked !== 'boolean') ui.filters.showOnlyUnticked = false;
      if (typeof ui.filters.showOnlyCancellations !== 'boolean') ui.filters.showOnlyCancellations = false;
      if (typeof ui.filters.search !== 'string') ui.filters.search = '';

      ui.hydratedFlags = (ui.hydratedFlags && typeof ui.hydratedFlags === 'object' && !Array.isArray(ui.hydratedFlags)) ? ui.hydratedFlags : {};
      if (typeof ui.hydratedFlags.didInitDefaultActionChecks !== 'boolean') ui.hydratedFlags.didInitDefaultActionChecks = false;

      window.__weeklyImportUi.NHSP[impIdStr] = ui;
    } catch (e) {
      console.warn('[IMPORTS][NHSP] failed to seed weekly UI store options (non-fatal)', e);
    }

    // 4) Persist and render summary modal
    window.modalCtx = window.modalCtx || {};
    window.modalCtx.importsState = window.modalCtx.importsState || {};
    window.modalCtx.importsState.nhsp = {
      import_id: importId,
      summary: summaryState
    };

    const total =
      (summaryState.summary && typeof summaryState.summary.total_rows === 'number')
        ? summaryState.summary.total_rows
        : Array.isArray(summaryState.rows) ? summaryState.rows.length : 0;

    if (summaryEl) {
      summaryEl.textContent = `Import ${importId}: ${total} rows parsed.`;
    }

    if (typeof renderImportSummaryModal === 'function') {
      renderImportSummaryModal('NHSP', summaryState);
    } else {
      console.warn('[IMPORTS] renderImportSummaryModal is not defined; NHSP summary not shown.');
    }
  } catch (err) {
    console.error('[IMPORTS][NHSP] handleNhspFileDrop failed', err);
    if (summaryEl) {
      summaryEl.textContent = `NHSP import failed: ${err?.message || 'Unknown error'}`;
    }
    alert(err?.message || 'NHSP import failed.');
  }
}

async function refreshWeeklyImportSummary(type, importId) {
  const LOG = (typeof window.__LOG_IMPORTS === 'boolean') ? window.__LOG_IMPORTS : true;
  const L   = (...a) => { if (LOG) console.log('[IMPORTS][WEEKLY][REFRESH]', ...a); };

  try {
    if (!type || !importId) {
      throw new Error('Missing type or importId for refreshWeeklyImportSummary');
    }

    const t = String(type || '').toUpperCase();
    let url;
    if (t === 'NHSP') {
      url = `/api/nhsp/${encodeURIComponent(importId)}/preview`;
    } else if (t === 'HR_WEEKLY') {
      url = `/api/healthroster/autoprocess/${encodeURIComponent(importId)}/preview`;
    } else {
      throw new Error(`Unsupported weekly import type: ${t}`);
    }

    if (typeof authFetch !== 'function' || typeof API !== 'function') {
      throw new Error('authFetch/API helper missing in refreshWeeklyImportSummary');
    }

    L('fetching preview', { type: t, importId, url: API(url) });
    const res  = await authFetch(API(url));
    const text = await res.text();
    if (!res.ok) {
      throw new Error(text || `Weekly import preview refresh failed (${res.status})`);
    }

    let preview;
    try { preview = text ? JSON.parse(text) : {}; } catch { preview = {}; }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // âœ… Forced behaviour:
    // - include missing shifts ALWAYS
    // - date range = import file min/max (truth_meta)
    // - reconcile selections against refreshed actions
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    try {
      const impId = String(importId);

      const asYmd = (v) => {
        if (!v) return null;
        if (typeof v === 'string') {
          const s = v.trim();
          if (/^\d{4}-\d{2}-\d{2}$/.test(s)) return s;
          if (s.length >= 10 && /^\d{4}-\d{2}-\d{2}/.test(s)) return s.slice(0, 10);
        }
        try {
          const d = new Date(v);
          if (Number.isNaN(d.getTime())) return null;
          const yyyy = d.getUTCFullYear();
          const mm   = String(d.getUTCMonth() + 1).padStart(2, '0');
          const dd   = String(d.getUTCDate()).padStart(2, '0');
          return `${yyyy}-${mm}-${dd}`;
        } catch {
          return null;
        }
      };

      const acts = Array.isArray(preview?.actions) ? preview.actions : [];

      const truthMeta =
        (preview && typeof preview.truth_meta === 'object' && preview.truth_meta) ? preview.truth_meta :
        (preview && preview.summary && typeof preview.summary.truth_meta === 'object' && preview.summary.truth_meta) ? preview.summary.truth_meta :
        null;

      const fileMin = truthMeta ? asYmd(truthMeta.file_date_min) : null;
      const fileMax = truthMeta ? asYmd(truthMeta.file_date_max) : null;

      // Fallback only if file min/max absent
      const minMaxFromActions = () => {
        let minD = null, maxD = null;
        for (const a of acts) {
          const wd = asYmd(a?.work_date || a?.workDate || a?.date_local || a?.date || null);
          if (!wd) continue;
          if (!minD || wd < minD) minD = wd;
          if (!maxD || wd > maxD) maxD = wd;
        }
        return { minD, maxD };
      };
      const { minD: actMin, maxD: actMax } = minMaxFromActions();

      const forcedFrom = fileMin || actMin || null;
      const forcedTo   = fileMax || actMax || null;

      const autoApplyIds = (() => {
        const raw =
          preview?.auto_apply_action_ids ??
          preview?.autoApplyActionIds ??
          (preview?.summary && (preview.summary.auto_apply_action_ids ?? preview.summary.autoApplyActionIds)) ??
          null;

        const arr = Array.isArray(raw) ? raw : [];
        const out = [];
        const seen = new Set();
        for (const v of arr) {
          const s = String(v || '').trim();
          if (!s) continue;
          if (seen.has(s)) continue;
          seen.add(s);
          out.push(s);
        }
        return out;
      })();

      const actionIdOf = (a) => {
        const id = a?.action_id ?? a?.actionId ?? null;
        return id == null ? null : String(id).trim();
      };

      const replacementKeyOf = (a) => {
        const rk = a?.replacement_day_key ?? a?.replacementDayKey ?? null;
        if (rk != null && String(rk).trim()) return String(rk).trim();
        const cid = a?.candidate_id ?? a?.candidateId ?? null;
        const cli = a?.client_id ?? a?.clientId ?? null;
        const wd  = asYmd(a?.work_date ?? a?.workDate ?? a?.date_local ?? a?.date ?? null);
        if (cid && cli && wd) return `${String(cid)}|${String(cli)}|${String(wd)}`;
        return null;
      };

      const isMissingFromImportCancel = (a) => {
        const reason = String(a?.reason || a?.cancel_reason || a?.kind_reason || '').toUpperCase();
        if (reason !== 'MISSING_FROM_IMPORT') return false;

        const id = String(actionIdOf(a) || '').toUpperCase();
        const isCancel =
          (a?.is_cancellation === true) ||
          (a?.isCancellation === true) ||
          (String(a?.action_kind || a?.actionKind || '').toUpperCase().includes('CANCEL')) ||
          id.startsWith('CANCEL:');

        return !!isCancel;
      };

      const inYmdRange = (ymd, fromYmd, toYmd) => {
        const d = asYmd(ymd);
        const f = asYmd(fromYmd);
        const t2 = asYmd(toYmd);
        if (!d) return false;
        if (f && d < f) return false;
        if (t2 && d > t2) return false;
        return true;
      };

      window.__weeklyImportUi = window.__weeklyImportUi || {};
      window.__weeklyImportUi[t] = window.__weeklyImportUi[t] || {};

      // Ensure store exists (but do NOT reset it if it already exists)
      let ui = window.__weeklyImportUi[t][impId] || null;
      if (!ui || typeof ui !== 'object' || Array.isArray(ui)) {
        ui = {
          options: { missingShiftsEnabled: true, dateFrom: null, dateTo: null },
          actionSelection: new Set(),
          filters: { showOnlyRed: false, showOnlyUnticked: false, showOnlyCancellations: false, search: '' },
          emailSelection: (t === 'HR_WEEKLY') ? new Map() : new Set(),
          hydratedFlags: (t === 'HR_WEEKLY')
            ? { didInitDefaultActionChecks: false, didInitDefaultEmailChecks: false, didInitDefaultInvalidationChecks: false }
            : { didInitDefaultActionChecks: false }
        };
      }

      // Force options every refresh (no user control)
      ui.options = (ui.options && typeof ui.options === 'object' && !Array.isArray(ui.options)) ? ui.options : {};
      ui.options.missingShiftsEnabled = true;
      ui.options.dateFrom = forcedFrom;
      ui.options.dateTo = forcedTo;

      if (!(ui.actionSelection instanceof Set)) ui.actionSelection = new Set();

      // Current action lookup by id
      const byId = new Map();
      for (const a of acts) {
        const id = actionIdOf(a);
        if (!id) continue;
        byId.set(id, a);
      }

      // Selection set used for Policy A protection:
      // user ticks + auto-applied NEW shifts
      const selectedAll = new Set([
        ...Array.from(ui.actionSelection),
        ...autoApplyIds
      ]);

      // replacement_day_keys that have a selected new shift
      const selectedNewShiftKeys = new Set();
      for (const a of acts) {
        const id = actionIdOf(a);
        if (!id) continue;
        if (!selectedAll.has(id)) continue;

        const isNew = (a?.is_new_shift === true || a?.isNewShift === true);
        if (!isNew) continue;

        const rk = replacementKeyOf(a);
        if (rk) selectedNewShiftKeys.add(rk);
      }

      // Reconcile:
      // - remove selections that no longer exist
      // - missing-from-import cancels are always enabled, but still constrained to the forced file date range
      for (const sel of Array.from(ui.actionSelection)) {
        const a = byId.get(String(sel)) || null;

        // Selection no longer exists in new preview
        if (!a) {
          ui.actionSelection.delete(sel);
          continue;
        }

        // Missing-from-import cancels: keep only if within forced range OR Policy-A-protected
        if (isMissingFromImportCancel(a)) {
          const rk = replacementKeyOf(a);
          const protectedByPolicyA = !!(rk && selectedNewShiftKeys.has(rk));
          if (!protectedByPolicyA) {
            const wd = asYmd(a?.work_date ?? a?.workDate ?? a?.date_local ?? a?.date ?? null);
            if (!inYmdRange(wd, forcedFrom, forcedTo)) {
              ui.actionSelection.delete(sel);
              continue;
            }
          }
        }
      }

      window.__weeklyImportUi[t][impId] = ui;
    } catch (e) {
      // Non-fatal; renderImportSummaryModal also re-reconciles defensively.
      L('pre-render reconcile failed (non-fatal)', { err: e?.message || String(e) });
    }

    // IMPORTANT: renderImportSummaryModal will normalize + store canonical preview.
    if (typeof renderImportSummaryModal === 'function') {
      renderImportSummaryModal(t, preview);
    } else {
      throw new Error('renderImportSummaryModal is not defined');
    }
  } catch (e) {
    console.error('[IMPORTS][WEEKLY][REFRESH] failed', e);
    const msg = e?.message || 'Failed to refresh weekly import summary.';
    if (window.__toast) window.__toast(msg); else alert(msg);
  }
}

function renderWeeklyImportSummary(type, importId, rows, ss) {
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Robust preview / summary shape handling
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const rootObj = ss || {};
  const summary = (rootObj && typeof rootObj.summary === 'object' && rootObj.summary)
    ? rootObj.summary
    : (rootObj || {});

  const TYPE = String(type || '').toUpperCase();
  const T = TYPE; // âœ… FIX: ensure legacy references to T are defined (used in handlers below)

  const idSafe = String(importId || '').replace(/[^a-zA-Z0-9_-]/g, '_');

  const enc = (typeof escapeHtml === 'function')
    ? escapeHtml
    : (s) => String(s ?? '').replace(/[&<>"']/g, (c) => ({
        '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
      }[c]));

  const round2 = (n) => Math.round((Number(n) || 0) * 100) / 100;
  const normUpper = (s) => String(s || '').trim().toUpperCase();

  const asYmd = (v) => {
    if (!v) return null;
    if (typeof v === 'string') {
      const s = v.trim();
      if (/^\d{4}-\d{2}-\d{2}$/.test(s)) return s;
      if (s.length >= 10 && /^\d{4}-\d{2}-\d{2}/.test(s)) return s.slice(0, 10);
    }
    try {
      const d = new Date(v);
      if (Number.isNaN(d.getTime())) return null;
      const yyyy = d.getUTCFullYear();
      const mm   = String(d.getUTCMonth() + 1).padStart(2, '0');
      const dd   = String(d.getUTCDate()).padStart(2, '0');
      return `${yyyy}-${mm}-${dd}`;
    } catch {
      return null;
    }
  };

  // Prefer rows from preview object when present
  const rowsState = Array.isArray(rootObj.rows)
    ? rootObj.rows
    : (Array.isArray(rows) ? rows : []);

  const total = summary.total_rows || rowsState.length || 0;

  // âœ… Weekly action approvals (changes/cancels/attach) come from preview.actions
  const actions =
    Array.isArray(rootObj.actions) ? rootObj.actions :
    Array.isArray(summary.actions) ? summary.actions :
    [];

  // âœ… NEW shifts are not shown in Actions; backend gives auto_apply_action_ids for them
  const auto_apply_action_ids = (() => {
    const raw =
      rootObj.auto_apply_action_ids ??
      summary.auto_apply_action_ids ??
      rootObj.autoApplyActionIds ??
      summary.autoApplyActionIds ??
      null;

    const arr = Array.isArray(raw) ? raw : [];
    const out = [];
    const seen = new Set();
    for (const v of arr) {
      const s = String(v || '').trim();
      if (!s) continue;
      if (seen.has(s)) continue;
      seen.add(s);
      out.push(s);
    }
    return out;
  })();

  // Truth meta (single source; used for warnings + forced date range)
  const truthMeta =
    (rootObj && typeof rootObj.truth_meta === 'object' && rootObj.truth_meta) ? rootObj.truth_meta :
    (summary && typeof summary.truth_meta === 'object' && summary.truth_meta) ? summary.truth_meta :
    (rootObj && typeof rootObj.truthMeta === 'object' && rootObj.truthMeta) ? rootObj.truthMeta :
    (summary && typeof summary.truthMeta === 'object' && summary.truthMeta) ? summary.truthMeta :
    {};

  const fileMin = asYmd(truthMeta.file_date_min);
  const fileMax = asYmd(truthMeta.file_date_max);

  // âœ… Weekly UI state store (actionSelection must persist across rerenders)
  window.__weeklyImportUi = window.__weeklyImportUi || {};
  window.__weeklyImportUi[TYPE] = window.__weeklyImportUi[TYPE] || {};
  const ui = window.__weeklyImportUi[TYPE][String(importId)] || (window.__weeklyImportUi[TYPE][String(importId)] = {
    // âœ… Forced: missing shifts enabled + date range from import file
    options: { missingShiftsEnabled: true, dateFrom: fileMin, dateTo: fileMax },
    actionSelection: new Set(),
    filters: { showOnlyRed: false, showOnlyUnticked: false, showOnlyCancellations: false, search: '' },
    emailSelection: (TYPE === 'HR_WEEKLY') ? new Map() : new Set(),
    hydratedFlags: { didInitDefaultActionChecks: false }
  });
  if (!(ui.actionSelection instanceof Set)) ui.actionSelection = new Set();
  if (!ui.hydratedFlags || typeof ui.hydratedFlags !== 'object') ui.hydratedFlags = { didInitDefaultActionChecks: false };

  // âœ… Forced every render (no options modal anymore)
  ui.options = (ui.options && typeof ui.options === 'object' && !Array.isArray(ui.options)) ? ui.options : {};
  ui.options.missingShiftsEnabled = true;
  ui.options.dateFrom = fileMin;
  ui.options.dateTo = fileMax;

  const actionIdOf = (a) => {
    const id = a?.action_id ?? a?.actionId ?? null;
    return (id != null) ? String(id) : null;
  };

  const extOfAction = (a) => {
    const k = a?.external_row_key ?? a?.externalRowKey ?? null;
    return (k != null) ? String(k).trim() : '';
  };

  const ymdAddDays = (ymd, deltaDays) => {
    const s = String(ymd || '').trim();
    if (!/^\d{4}-\d{2}-\d{2}$/.test(s)) return null;
    const d = new Date(`${s}T00:00:00Z`);
    if (Number.isNaN(d.getTime())) return null;
    d.setUTCDate(d.getUTCDate() + (Number(deltaDays) || 0));
    return d.toISOString().slice(0, 10);
  };

  // Map: external_row_key -> action_id (for ROW actions)
  const changeActionIdByExternalKey = new Map();

  // Map: action_id -> action object (for reason_text / names)
  const actionById = new Map();

  for (const a of (actions || [])) {
    const id = actionIdOf(a);
    if (!id) continue;

    actionById.set(id, a);

    if (id.toUpperCase().startsWith('ROW:')) {
      const ek = extOfAction(a);
      if (ek) changeActionIdByExternalKey.set(ek, id);
    }
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // âœ… NEW: Hydrate default-checked action IDs ONCE per import
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const defaultCheckedActionIds = (() => {
    const out = [];
    const seen = new Set();

    const contractObj =
      rootObj.action_contract ??
      summary.action_contract ??
      rootObj.actionContract ??
      summary.actionContract ??
      null;

    const rawList =
      contractObj?.default_checked_action_ids ??
      contractObj?.defaultCheckedActionIds ??
      null;

    const pushId = (v) => {
      const s = String(v || '').trim();
      if (!s) return;
      if (seen.has(s)) return;
      seen.add(s);
      out.push(s);
    };

    if (Array.isArray(rawList)) {
      for (const v of rawList) pushId(v);
    }

    for (const a of (actions || [])) {
      const id = actionIdOf(a);
      if (!id) continue;
      const dc = (a?.default_checked === true || a?.defaultChecked === true);
      if (dc) pushId(id);
    }

    return out;
  })();

  if (ui.hydratedFlags.didInitDefaultActionChecks !== true) {
    const beforeCount = ui.actionSelection.size;

    for (const id of (defaultCheckedActionIds || [])) {
      ui.actionSelection.add(String(id));
    }

    ui.hydratedFlags.didInitDefaultActionChecks = true;

    try {
      const LOGW = (typeof window.__LOG_IMPORTS === 'boolean') ? window.__LOG_IMPORTS : true;
      if (LOGW && defaultCheckedActionIds.length) {
        console.log('[IMPORTS][WEEKLY]', 'default-checked hydrated', {
          type: TYPE,
          import_id: String(importId),
          added: Math.max(0, ui.actionSelection.size - beforeCount),
          default_checked_count: defaultCheckedActionIds.length
        });
      }
    } catch {}
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // âœ… NEW: Surface backend warnings + detached/missing-timesheet meta
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const backendWarningsRaw =
    (Array.isArray(rootObj.warnings) ? rootObj.warnings :
     Array.isArray(summary.warnings) ? summary.warnings :
     Array.isArray(rootObj.warning) ? rootObj.warning :
     Array.isArray(summary.warning) ? summary.warning :
     []);

  const warnings = (() => {
    const out = [];
    const seenKey = new Set();

    const addWarn = (w) => {
      if (!w || typeof w !== 'object') return;
      const code = String(w.code || '').trim();
      const msg = String(w.message || w.reason || '').trim();
      const sev = String(w.severity || '').trim().toUpperCase();
      const k = `${code}__${msg}__${sev}`;
      if (seenKey.has(k)) return;
      seenKey.add(k);
      out.push({
        code: code || 'WARN',
        severity: (sev || 'WARN'),
        message: (msg || 'Warning'),
        detached_active_shift_count: (w.detached_active_shift_count != null ? Number(w.detached_active_shift_count) : null),
        missing_timesheet_row_count: (w.missing_timesheet_row_count != null ? Number(w.missing_timesheet_row_count) : null),
        detached_active_shift_ids_sample: Array.isArray(w.detached_active_shift_ids_sample) ? w.detached_active_shift_ids_sample.map(String) : [],
        missing_timesheet_ids_sample: Array.isArray(w.missing_timesheet_ids_sample) ? w.missing_timesheet_ids_sample.map(String) : []
      });
    };

    for (const w of backendWarningsRaw) addWarn(w);

    const detachedCount = (truthMeta && truthMeta.detached_active_shift_count != null)
      ? Number(truthMeta.detached_active_shift_count || 0)
      : 0;
    const missingTsCount = (truthMeta && truthMeta.missing_timesheet_row_count != null)
      ? Number(truthMeta.missing_timesheet_row_count || 0)
      : 0;

    if (detachedCount > 0) {
      addWarn({
        code: 'DETACHED_ACTIVE_SHIFTS_PRESENT',
        severity: 'WARN',
        message: 'Active NHSP shifts exist with no timesheet_id. This should not occur after apply; investigate if seen before finalise.',
        detached_active_shift_count: detachedCount,
        detached_active_shift_ids_sample: Array.isArray(truthMeta.detached_active_shift_ids_sample) ? truthMeta.detached_active_shift_ids_sample : []
      });
    }

    if (missingTsCount > 0) {
      addWarn({
        code: 'MISSING_TIMESHEET_ROWS_REFERENCED',
        severity: 'WARN',
        message: 'NHSP shifts reference timesheet_id values that do not exist in timesheets. This indicates deleted timesheets or inconsistent data.',
        missing_timesheet_row_count: missingTsCount,
        missing_timesheet_ids_sample: Array.isArray(truthMeta.missing_timesheet_ids_sample) ? truthMeta.missing_timesheet_ids_sample : []
      });
    }

    return out;
  })();

  const warningsHtml = (() => {
    if (!warnings.length) return '';

    const rows = warnings.map((w) => {
      const code = String(w.code || 'WARN');
      const msg = String(w.message || 'Warning');
      const sev = String(w.severity || 'WARN').toUpperCase();

      const detCnt = (w.detached_active_shift_count != null && Number.isFinite(Number(w.detached_active_shift_count)))
        ? Number(w.detached_active_shift_count)
        : null;
      const missCnt = (w.missing_timesheet_row_count != null && Number.isFinite(Number(w.missing_timesheet_row_count)))
        ? Number(w.missing_timesheet_row_count)
        : null;

      const detSample = Array.isArray(w.detached_active_shift_ids_sample) ? w.detached_active_shift_ids_sample.slice(0, 15) : [];
      const missSample = Array.isArray(w.missing_timesheet_ids_sample) ? w.missing_timesheet_ids_sample.slice(0, 15) : [];

      const metricsBits = [];
      if (detCnt != null) metricsBits.push(`Detached active shifts: ${detCnt}`);
      if (missCnt != null) metricsBits.push(`Missing timesheet rows: ${missCnt}`);

      const metrics = metricsBits.length ? metricsBits.join(' | ') : '';

      const hasDetails = (detSample.length || missSample.length);

      const detailsHtml = hasDetails ? `
        <details style="margin-top:6px;">
          <summary class="mini" style="cursor:pointer;">Show details</summary>
          ${
            detSample.length
              ? `<div class="mini" style="margin-top:6px;"><b>Detached active shift IDs (sample):</b><br/><span class="mono">${enc(detSample.join(', '))}</span></div>`
              : ''
          }
          ${
            missSample.length
              ? `<div class="mini" style="margin-top:6px;"><b>Missing timesheet IDs (sample):</b><br/><span class="mono">${enc(missSample.join(', '))}</span></div>`
              : ''
          }
        </details>
      ` : '';

      return `
        <div style="border:1px solid #e6b800; background:#fff8d6; border-radius:8px; padding:10px; margin-bottom:8px;">
          <div class="mini" style="margin-bottom:4px;">
            <b>${enc(sev)}</b> â€” <span class="mono">${enc(code)}</span>
          </div>
          <div class="mini">${enc(msg)}</div>
          ${metrics ? `<div class="mini" style="margin-top:4px;color:#444;">${enc(metrics)}</div>` : ''}
          ${detailsHtml}
        </div>
      `;
    }).join('');

    return `
      <div class="row" style="margin-top:10px;">
        <label>Warnings</label>
        <div class="controls">
          <div class="mini" style="color:#666;margin-bottom:6px;">
            These warnings indicate inconsistent data (usually caused by deleted timesheets or detached shifts). Continue only if expected in your controlled test.
          </div>
          ${rows}
        </div>
      </div>
    `;
  })();

  const rowExternalKeyOf = (r) => {
    const ek = r?.external_row_key ?? r?.externalRowKey ?? null;
    return (ek != null) ? String(ek).trim() : '';
  };

  const rowActionRawOf = (r) => normUpper(r?.resolution_status || r?.action || '');

  const isResolutionProblem = (actionRaw) => {
    if (!actionRaw) return true;
    if (actionRaw === 'NO_CANDIDATE' || actionRaw === 'REJECT_NO_CANDIDATE') return true;
    if (actionRaw === 'NO_CLIENT'    || actionRaw === 'REJECT_NO_CLIENT') return true;
    if (actionRaw === 'REJECT_NO_CONTRACT') return true;
    if (actionRaw === 'REJECT_NO_CONTRACT_BAND_MISMATCH') return true;
    if (actionRaw.startsWith('REJECT_')) return true;
    if (actionRaw.startsWith('BLOCK_'))  return true;
    if (actionRaw === 'UNKNOWN') return true;
    return false;
  };

  const getSelectedAll = () => new Set([
    ...Array.from(ui.actionSelection || []),
    ...auto_apply_action_ids
  ]);

  const groupRequiredActionIds = (gr) => {
    const cid = gr?.candidate_id != null ? String(gr.candidate_id) : '';
    const cli = gr?.client_id != null ? String(gr.client_id) : '';
    const con = gr?.contract_id != null ? String(gr.contract_id) : '';
    const we  = gr?.week_ending_date != null ? String(gr.week_ending_date) : '';

    const out = [];
    if (!cid || !cli || !we) return out;

    const weekStart = ymdAddDays(we, -6);

    for (const a of (actions || [])) {
      const id = actionIdOf(a);
      if (!id) continue;

      const ak = String(a?.action_kind || '').toUpperCase();

      if (id.toUpperCase().startsWith('ROW:') || ak === 'SHIFT_CHANGED' || ak === 'SHIFT_ATTACH') {
        const aCid = a?.candidate_id != null ? String(a.candidate_id) : '';
        const aCli = a?.client_id != null ? String(a.client_id) : '';
        const aCon = a?.contract_id != null ? String(a.contract_id) : '';
        const aWe  = a?.week_ending_date != null ? String(a.week_ending_date) : '';

        if (aCid && aCli && aCon && aWe) {
          if (aCid === cid && aCli === cli && aCon === con && aWe === we) out.push(id);
        }
        continue;
      }

      if (id.toUpperCase().startsWith('CANCEL:') || ak === 'SHIFT_CANCEL') {
        const aCid = a?.candidate_id != null ? String(a.candidate_id) : '';
        const aCli = a?.client_id != null ? String(a.client_id) : '';
        const wd = String(a?.work_date || a?.workDate || '').slice(0, 10);

        if (aCid === cid && aCli === cli && weekStart && wd) {
          if (wd >= weekStart && wd <= we) out.push(id);
        }
        continue;
      }
    }

    return out;
  };

  const classifyRowState = (r, selectedAllSet) => {
    const level = String(r?.level || '').toLowerCase();
    const actionRaw = rowActionRawOf(r);

    if (isResolutionProblem(actionRaw)) return 'NEEDS_RESOLUTION';

    if (level === 'row') {
      const ek = rowExternalKeyOf(r);
      const rowId = ek ? `ROW:${ek}` : '';

      const isAutoNew = !!(rowId && auto_apply_action_ids.includes(rowId));
      const isRowActionKnown = !!(rowId && changeActionIdByExternalKey.has(ek));
      const isApprovedRowAction = !!(rowId && selectedAllSet.has(rowId));

      if (isAutoNew) return 'WILL_APPLY';
      if (isRowActionKnown) return (isApprovedRowAction ? 'WILL_APPLY' : 'NOT_APPROVED');

      return (actionRaw === 'SKIP_ALREADY_PROCESSED') ? 'ALREADY_PROCESSED' : 'IGNORED';
    }

    if (level === 'group') {
      const requiredIds = groupRequiredActionIds(r);
      const hasRequired = requiredIds.length > 0;
      const hasUnapprovedRequired = requiredIds.some((id) => !selectedAllSet.has(String(id)));

      if (actionRaw === 'SKIP_ALREADY_PROCESSED' && !hasRequired) return 'ALREADY_PROCESSED';
      if (hasUnapprovedRequired) return 'NOT_APPROVED';

      return 'WILL_APPLY';
    }

    return 'IGNORED';
  };

  const computeOverviewCounts = (rowsArr, selectedAllSet) => {
    let count_apply = 0;
    let count_not_approved = 0;
    let count_ignored = 0;
    let count_needs_resolution = 0;

    for (const r of (rowsArr || [])) {
      const st = classifyRowState(r, selectedAllSet);
      if (st === 'NEEDS_RESOLUTION') count_needs_resolution += 1;
      else if (st === 'WILL_APPLY') count_apply += 1;
      else if (st === 'NOT_APPROVED') count_not_approved += 1;
      else count_ignored += 1;
    }
    return { count_apply, count_not_approved, count_ignored, count_needs_resolution };
  };

  const buildRowsTbodyHtml = (rowsArr, selectedAllSet) => {
    if (!(rowsArr && rowsArr.length)) {
      return `
        <tr>
          <td colspan="7"><span class="mini">No rows to show.</span></td>
        </tr>
      `;
    }

    return rowsArr.map((r, idx) => {
      const level = String(r.level || '').toLowerCase();

      const staff =
        (level === 'group')
          ? (r.candidate_name || r.candidate_id || r.staff_name || r.staff_raw || '')
          : (r.staff_name || r.staff_raw || '');

      const unit =
        (level === 'group')
          ? (r.client_name || r.client_id || r.unit || r.hospital_or_trust || r.hospital_norm || '')
          : (r.unit || r.hospital_or_trust || r.hospital_norm || '');

      const rawDateYmd =
        (level === 'group')
          ? (r.week_ending_date || r.work_date || r.date_local || r.date || '')
          : (r.date_local || r.work_date || r.date || r.week_ending_date || '');

      const date = (typeof formatYmdToNiceDate === 'function') ? formatYmdToNiceDate(rawDateYmd) : (rawDateYmd || '');

      const code =
        (r.incoming_code ||
         r.assignment_code ||
         r.assignment ||
         r.assignment_grade_norm ||
         '').toString();

      let reasonText = (r.reason || '').toString();
      const actionRaw = rowActionRawOf(r);

      const ek = rowExternalKeyOf(r);
      const rowId = ek ? `ROW:${ek}` : '';

      if (ek && changeActionIdByExternalKey.has(ek)) {
        const aid = changeActionIdByExternalKey.get(ek);
        const act = aid ? (actionById.get(aid) || null) : null;
        const rt =
          act && (act.reason_text || act.reasonText)
            ? String(act.reason_text || act.reasonText).trim()
            : '';
        if (rt) reasonText = rt;
      } else if (rowId && auto_apply_action_ids.includes(rowId)) {
        reasonText = 'New shift (auto-applied)';
      } else if (actionRaw === 'SKIP_ALREADY_PROCESSED') {
        reasonText = 'Already processed';
      }

      const st = classifyRowState(r, selectedAllSet);

      let rowClass = 'wi-row-ignore';
      let cls = 'pill-info';
      let displayAction = 'IGNORED';

      if (st === 'NEEDS_RESOLUTION') {
        rowClass = 'wi-row-warn';
        cls = 'pill-warn';
        displayAction = 'NEEDS RESOLUTION';
      } else if (st === 'WILL_APPLY') {
        rowClass = 'wi-row-ready';
        cls = 'pill-ok';
        displayAction = 'WILL APPLY';
      } else if (st === 'NOT_APPROVED') {
        rowClass = 'wi-row-issue';
        cls = 'pill-bad';
        displayAction = 'NOT APPROVED';
      } else if (st === 'ALREADY_PROCESSED') {
        rowClass = 'wi-row-ignore';
        cls = 'pill-info';
        displayAction = 'ALREADY PROCESSED';
      } else {
        rowClass = 'wi-row-ignore';
        cls = 'pill-info';
        displayAction = 'IGNORED';
      }

      if (level === 'group' && st === 'NOT_APPROVED') {
        const reqIds = groupRequiredActionIds(r);
        const unapproved = reqIds.filter((id) => !selectedAllSet.has(String(id)));
        if (unapproved.length) {
          reasonText = 'Not approved yet: tick required changes/cancellations above to apply them.';
        }
      }

      const canAssignCand   = (actionRaw === 'NO_CANDIDATE' || actionRaw === 'REJECT_NO_CANDIDATE');
      const canAssignClient = (actionRaw === 'NO_CLIENT'    || actionRaw === 'REJECT_NO_CLIENT');

      return `
        <tr class="${rowClass}" data-wi-row-idx="${idx}">
          <td class="wi-col-staff"><span class="mini">${enc(staff || 'â€”')}</span></td>
          <td class="wi-col-unit"><span class="mini">${enc(unit || 'â€”')}</span></td>
          <td class="wi-col-date"><span class="mini">${enc(date || 'â€”')}</span></td>
          <td class="wi-col-code"><span class="mini" style="white-space: normal; word-break: break-word; display:inline-block;">${enc(code || 'â€”')}</span></td>
          <td class="wi-col-status"><span class="pill ${cls}" style="white-space: normal; word-break: break-word; display:inline-block; text-align:center;">${enc(displayAction || 'UNKNOWN')}</span></td>
          <td class="wi-col-reason"><span class="mini" style="white-space: normal; word-break: break-word; display:inline-block;">${enc(reasonText || '')}</span></td>
          <td class="wi-col-actions">
            <div class="wi-actions">
              ${canAssignCand ? `<button type="button" class="btn mini" data-act="weekly-resolve-candidate" data-row-idx="${idx}" data-staff="${enc(staff)}" data-unit="${enc(unit)}">Assign candidateâ€¦</button>` : ''}
              ${canAssignClient ? `<button type="button" class="btn mini" data-act="weekly-resolve-client" data-row-idx="${idx}" data-unit="${enc(unit)}">Assign clientâ€¦</button>` : ''}
            </div>
          </td>
        </tr>
      `;
    }).join('');
  };

  const selectedAllInit = getSelectedAll();
  const countsInit = computeOverviewCounts(rowsState, selectedAllInit);

  const rowsHtml = buildRowsTbodyHtml(rowsState, selectedAllInit);

  const markup = html(`
    <div id="weeklyImportSummary">
      <div class="card weekly-import-card">
        ${warningsHtml}

        <div class="row">
          <label>Overview</label>
          <div class="controls">
            <div class="mini">
              Import ID: <span class="mono">${enc(importId || 'â€”')}</span><br/>
              Total rows: <span id="wiTotal_${enc(idSafe)}">${enc(String(total))}</span><br/>
              Will apply: <span id="wiApply_${enc(idSafe)}">${enc(String(countsInit.count_apply))}</span> &nbsp;|&nbsp;
              Not approved: <span id="wiNotApproved_${enc(idSafe)}">${enc(String(countsInit.count_not_approved))}</span> &nbsp;|&nbsp;
              Ignored: <span id="wiIgnored_${enc(idSafe)}">${enc(String(countsInit.count_ignored))}</span> &nbsp;|&nbsp;
              Needs resolution: <span id="wiNeedsRes_${enc(idSafe)}">${enc(String(countsInit.count_needs_resolution))}</span><br/>
              Auto new shifts: ${enc(String(auto_apply_action_ids.length))}
              ${
                (truthMeta && (Number(truthMeta.detached_active_shift_count || 0) > 0 || Number(truthMeta.missing_timesheet_row_count || 0) > 0))
                  ? `<br/>Detached active shifts: <span class="mono">${enc(String(Number(truthMeta.detached_active_shift_count || 0)))}</span> &nbsp;|&nbsp; Missing timesheet rows: <span class="mono">${enc(String(Number(truthMeta.missing_timesheet_row_count || 0)))}</span>`
                  : ``
              }
            </div>
          </div>
        </div>

        <div class="row" style="margin-top:10px;">
          <label>Changes requiring approval</label>
          <div class="controls">
            <div class="mini" style="color:#666;margin-bottom:8px;">
              Tick the boxes below to approve changes/cancellations. New shifts are applied automatically on Finalise.
            </div>
            <div class="wi-table-wrap" style="max-height:240px;">
              <table class="grid wi-grid">
                <thead>
                  <tr>
                    <th style="width:40px;"></th>
                    <th>Action</th>
                    <th>Work date</th>
                    <th>Candidate</th>
                    <th>Client</th>
                    <th>Reason</th>
                  </tr>
                </thead>
                <tbody id="weeklyActionsApprovalTbody">
                  ${
                    (actions && actions.length)
                      ? actions.map(a => {
                          const id = actionIdOf(a) || '';
                          const wd = String(a?.work_date || a?.workDate || '') || '';
                          const wdNice = (typeof formatYmdToNiceDate === 'function' && wd) ? formatYmdToNiceDate(wd) : wd;

                          const cand = String(a?.candidate_name || a?.candidateName || '') || 'â€”';
                          const cli  = String(a?.client_name || a?.clientName || '') || 'â€”';

                          const reasonTxt = String(a?.reason_text || a?.reasonText || a?.reason || '') || '';
                          const labelTxt  = String(a?.label || a?.action_label || a?.actionLabel || 'Change') || 'Change';

                          const checked = (id && ui.actionSelection && ui.actionSelection.has(id)) ? 'checked' : '';

                          return `
                            <tr class="wi-row-issue">
                              <td class="mini" style="text-align:center;">
                                <input type="checkbox" data-act="weekly-approve-action" data-action-id="${enc(id)}" ${checked}/>
                              </td>
                              <td class="mini">${enc(labelTxt)}</td>
                              <td class="mini">${enc(wdNice || 'â€”')}</td>
                              <td class="mini">${enc(cand)}</td>
                              <td class="mini">${enc(cli)}</td>
                              <td class="mini">${enc(reasonTxt)}</td>
                            </tr>
                          `;
                        }).join('')
                      : `
                        <tr>
                          <td colspan="6"><span class="mini">No changes detected.</span></td>
                        </tr>
                      `
                  }
                </tbody>
              </table>
            </div>
          </div>
        </div>

        <div class="row" style="margin-top:10px;">
          <label>Rows</label>
          <div class="controls">
            <div class="wi-table-wrap" id="wiRowsWrap_${enc(idSafe)}">
              <table class="grid wi-grid">
                <thead>
                  <tr>
                    <th class="wi-col-staff">Staff</th>
                    <th class="wi-col-unit">Unit / Site</th>
                    <th class="wi-col-date">Date / Week ending</th>
                    <th class="wi-col-code">Code</th>
                    <th class="wi-col-status">Resolution</th>
                    <th class="wi-col-reason">Reason</th>
                    <th class="wi-col-actions">Resolve</th>
                  </tr>
                </thead>
                <tbody id="wiRowsTbody_${enc(idSafe)}">${rowsHtml}</tbody>
              </table>
            </div>
          </div>
        </div>

        <div class="row weekly-import-footer" style="margin-top:10px;">
          <label></label>
          <div class="controls">
            <button type="button" class="btn" data-act="weekly-import-refresh">Refresh</button>
            <button type="button" class="btn" style="margin-left:8px;" data-act="weekly-import-apply">Finalise import</button>
            <span class="mini" style="margin-left:8px;">
              Tick approvals above to apply changes/cancellations. New shifts are auto-applied on Finalise.
            </span>
          </div>
        </div>
      </div>
    </div>
  `);

  // Wiring: approval checkbox updates + apply + resolve actions
  setTimeout(() => {
    try {
      const root = document.getElementById('weeklyImportSummary');
      if (!root || (type !== 'NHSP' && type !== 'HR_WEEKLY')) return;
      if (root.__weeklyWired) return;
      root.__weeklyWired = true;

      const LOGW = (typeof window.__LOG_IMPORTS === 'boolean') ? window.__LOG_IMPORTS : true;
      const LW   = (...a) => { if (LOGW) console.log('[IMPORTS][WEEKLY]', ...a); };

      const getPreview = () => (window.__importSummaryState && window.__importSummaryState[type])
        ? window.__importSummaryState[type]
        : rootObj;

      const getRowsNow = () => {
        const p = getPreview();
        const rr = (p && Array.isArray(p.rows)) ? p.rows : null;
        return rr || rowsState || [];
      };

      const patchRowsAndOverviewInPlace = () => {
        const rowsWrap = document.getElementById(`wiRowsWrap_${idSafe}`);
        const tbody = document.getElementById(`wiRowsTbody_${idSafe}`);
        if (!tbody) return;

        const scrollTopBefore = rowsWrap ? rowsWrap.scrollTop : 0;

        const selAll = getSelectedAll();
        const rowsNow = getRowsNow();

        tbody.innerHTML = buildRowsTbodyHtml(rowsNow, selAll);

        if (rowsWrap) rowsWrap.scrollTop = scrollTopBefore;

        const c = computeOverviewCounts(rowsNow, selAll);
        const elApply = document.getElementById(`wiApply_${idSafe}`);
        const elNA = document.getElementById(`wiNotApproved_${idSafe}`);
        const elIgn = document.getElementById(`wiIgnored_${idSafe}`);
        const elNR = document.getElementById(`wiNeedsRes_${idSafe}`);
        if (elApply) elApply.textContent = String(c.count_apply);
        if (elNA) elNA.textContent = String(c.count_not_approved);
        if (elIgn) elIgn.textContent = String(c.count_ignored);
        if (elNR) elNR.textContent = String(c.count_needs_resolution);
      };

      const ensureWeeklyImportMappings = () => {
        window.__weeklyImportMappings = window.__weeklyImportMappings || {};
        window.__weeklyImportMappings[type] = window.__weeklyImportMappings[type] || {};
        let m = window.__weeklyImportMappings[type][importId];
        if (!m) {
          m = { candidate_mappings: [], client_aliases: [] };
          window.__weeklyImportMappings[type][importId] = m;
        }
        return m;
      };

      root.addEventListener('change', (ev) => {
        const cb = ev.target && ev.target.closest ? ev.target.closest('input[data-act="weekly-approve-action"]') : null;
        if (!cb) return;

        const id = String(cb.getAttribute('data-action-id') || '').trim();
        if (!id) return;

        if (!(ui.actionSelection instanceof Set)) ui.actionSelection = new Set();

        if (cb.checked) ui.actionSelection.add(id);
        else ui.actionSelection.delete(id);

        patchRowsAndOverviewInPlace();
      });

      root.addEventListener('click', (ev) => {
        const btn = ev.target.closest('button[data-act]');
        if (!btn) return;
        const act = btn.getAttribute('data-act');
        if (act !== 'weekly-resolve-candidate' && act !== 'weekly-resolve-client') return;

        const st = window.__importSummaryState && window.__importSummaryState[T];
        const rowsNow = (st && Array.isArray(st.rows)) ? st.rows : getRowsNow();
        const idx = Number(btn.getAttribute('data-row-idx') || '-1');
        if (idx < 0 || idx >= rowsNow.length) return;

        const row = rowsNow[idx];
        const staffRaw = row.staff_name || row.staff_raw || '';
        const hospRaw  = row.hospital_or_trust || row.unit || row.hospital_norm || '';

        if (act === 'weekly-resolve-candidate') {
          openCandidatePicker(async ({ id, label }) => {
            const mappings = ensureWeeklyImportMappings();
            const mapping = {
              staff_norm: row.staff_norm || staffRaw || '',
              hospital_or_trust: hospRaw || null,
              candidate_id: id,
              client_id: row.client_id || null,
              work_date: row.work_date || row.date_local || row.date || row.week_ending_date || null
            };

            try {
              await postWeeklyResolveMappings(importId, type, { candidate_mappings: [mapping], client_aliases: [] });
              mappings.candidate_mappings.push(mapping);
              window.__toast && window.__toast(`Candidate ${label} linked. Reclassifyingâ€¦`);
              await refreshWeeklyImportSummary(type, importId);
            } catch (err) {
              console.error('[IMPORTS][WEEKLY] resolve-candidate failed', err);
              alert(err?.message || 'Failed to resolve candidate.');
            }
          }, { context: { importId, staffName: staffRaw, unit: hospRaw, source_system: type, rowIndex: idx } });
        }

        if (act === 'weekly-resolve-client') {
          openClientPicker(async ({ id, label }) => {
            const mappings = ensureWeeklyImportMappings();
            const hrRowIds = Array.isArray(row.hr_row_ids) ? row.hr_row_ids.map(String) : (row.hr_row_id ? [String(row.hr_row_id)] : []);
            const mapping = { client_id: id, hr_row_ids: hrRowIds.filter(Boolean), hospital_norm: row.hospital_norm || hospRaw || '' };

            try {
              await postWeeklyResolveMappings(importId, type, { candidate_mappings: [], client_aliases: [mapping] });
              mappings.client_aliases.push(mapping);
              window.__toast && window.__toast(`Client ${label} linked. Reclassifyingâ€¦`);
              await refreshWeeklyImportSummary(type, importId);
            } catch (err) {
              console.error('[IMPORTS][WEEKLY] resolve-client failed', err);
              alert(err?.message || 'Failed to resolve client.');
            }
          }, { nhspOnly: (type === 'NHSP'), hrAutoOnly: (type === 'HR_WEEKLY'), context: { importId, unit: hospRaw } });
        }
      });

      const btnRefresh = root.querySelector('button[data-act="weekly-import-refresh"]');
      if (btnRefresh && !btnRefresh.__weeklyRefreshWired) {
        btnRefresh.__weeklyRefreshWired = true;
        btnRefresh.addEventListener('click', async () => {
          try { await refreshWeeklyImportSummary(type, importId); }
          catch (err) { console.error('[IMPORTS][WEEKLY] refresh failed', err); alert(err?.message || 'Refresh failed.'); }
        });
      }

      const btnApply = root.querySelector('button[data-act="weekly-import-apply"]');
      if (btnApply && !btnApply.__weeklyApplyWired) {
        btnApply.__weeklyApplyWired = true;
        btnApply.addEventListener('click', async () => {
          try {
            const ok = window.confirm('Are you sure you want to finalise now?');
            if (!ok) return;

            if (typeof applyWeeklyImportTransactional !== 'function') {
              throw new Error('applyWeeklyImportTransactional is not defined.');
            }

            const selected_action_ids = Array.from(new Set([
              ...Array.from(ui.actionSelection || []),
              ...auto_apply_action_ids
            ]));

            const result = await applyWeeklyImportTransactional(T, importId, {
              selected_action_ids,
              decisions: {}
            }) || {};

            alert(`Import ${result.import_id || importId} has been finalised.`);
            await refreshWeeklyImportSummary(type, importId);
          } catch (err) {
            console.error('[IMPORTS][WEEKLY] apply failed', err);
            alert(err?.message || 'Weekly import apply failed.');
          }
        });
      }
    } catch (e) {
      console.warn('[IMPORTS] weekly wiring failed', e);
    }
  }, 0);

  return markup;
}




function computePolicyAViolations(actions, selectedActionIds) {
  const acts = Array.isArray(actions) ? actions : [];

  // Accept Set or Array; normalise to Set<string>
  const sel = (() => {
    if (selectedActionIds instanceof Set) {
      const out = new Set();
      for (const v of selectedActionIds) out.add(String(v));
      return out;
    }
    if (Array.isArray(selectedActionIds)) {
      return new Set(selectedActionIds.map(v => String(v)));
    }
    return new Set();
  })();

  const actionIdOf = (a) => {
    if (!a) return null;
    const id = a.action_id ?? a.actionId ?? null;
    if (id == null) return null;
    const s = String(id).trim();
    return s ? s : null;
  };

  const replacementKeyOf = (a) => {
    if (!a) return null;
    const rk = a.replacement_day_key ?? a.replacementDayKey ?? null;
    if (rk != null) {
      const s = String(rk).trim();
      if (s) return s;
    }
    // Fallback (should rarely be needed if backend always supplies replacement_day_key)
    const cid = a.candidate_id ?? a.candidateId ?? null;
    const cli = a.client_id ?? a.clientId ?? null;
    const wd = a.work_date ?? a.workDate ?? a.date_local ?? a.date ?? null;
    if (cid && cli && wd) return `${String(cid)}|${String(cli)}|${String(wd).slice(0, 10)}`;
    return null;
  };

  const isNewShift = (a) => (a?.is_new_shift === true || a?.isNewShift === true);
  const isCancel = (a) => (a?.is_cancellation === true || a?.isCancellation === true);

  // Build maps by replacement_day_key
  const newShiftActionIdsByKey = new Map();  // key -> string[]
  const cancelActionIdsByKey = new Map();    // key -> string[]

  for (const a of acts) {
    const id = actionIdOf(a);
    if (!id) continue;

    const key = replacementKeyOf(a);
    if (!key) continue;

    if (isNewShift(a)) {
      if (!newShiftActionIdsByKey.has(key)) newShiftActionIdsByKey.set(key, []);
      newShiftActionIdsByKey.get(key).push(id);
    }

    if (isCancel(a)) {
      if (!cancelActionIdsByKey.has(key)) cancelActionIdsByKey.set(key, []);
      cancelActionIdsByKey.get(key).push(id);
    }
  }

  // Evaluate violations
  const violations = [];
  const selectedNewShiftKeys = [];

  for (const [key, newIds] of newShiftActionIdsByKey.entries()) {
    // If any new-shift action for this key is selected, then ALL cancels for this key must be selected
    const anyNewSelected = (newIds || []).some(id => sel.has(id));
    if (!anyNewSelected) continue;

    selectedNewShiftKeys.push(key);

    const cancels = cancelActionIdsByKey.get(key) || [];
    const missingCancels = cancels.filter(id => !sel.has(id));

    if (missingCancels.length) {
      violations.push({
        replacement_day_key: key,
        selected_new_shift_action_ids: newIds.filter(id => sel.has(id)),
        required_cancel_action_ids: cancels.slice(),
        missing_cancel_action_ids: missingCancels.slice()
      });
    }
  }

  // A helper structure that makes the â€œTick required cancellations for this dayâ€ button trivial
  const requiredCancelsByKey = {};
  for (const [key, ids] of cancelActionIdsByKey.entries()) {
    requiredCancelsByKey[key] = (ids || []).slice();
  }

  return {
    ok: violations.length === 0,
    violations,
    selected_new_shift_keys: selectedNewShiftKeys,
    required_cancel_action_ids_by_key: requiredCancelsByKey
  };
}

async function applyWeeklyImportTransactional(type, importId, payloadIn) {
  const t = String(type || '').toUpperCase();
  const encId = encodeURIComponent(String(importId || '').trim());

  if (!encId) {
    throw new Error('Missing import_id for applyWeeklyImportTransactional.');
  }

  if (typeof authFetch !== 'function' || typeof API !== 'function') {
    throw new Error('authFetch/API helper missing in applyWeeklyImportTransactional.');
  }

  if (t !== 'NHSP' && t !== 'HR_WEEKLY') {
    throw new Error(`Unsupported weekly import type for applyWeeklyImportTransactional: ${t}`);
  }

  const p = (payloadIn && typeof payloadIn === 'object' && !Array.isArray(payloadIn)) ? payloadIn : {};

  const selected_action_ids = (() => {
    const raw = p.selected_action_ids ?? p.selectedActionIds ?? p.selected_actions ?? p.selectedActions ?? null;

    let arr = [];
    if (raw instanceof Set) {
      arr = Array.from(raw).map(v => String(v)).filter(Boolean);
    } else if (Array.isArray(raw)) {
      arr = raw.map(v => String(v)).filter(Boolean);
    } else {
      arr = [];
    }

    const seen = new Set();
    const out = [];
    for (const x of arr) {
      if (seen.has(x)) continue;
      seen.add(x);
      out.push(x);
    }
    return out;
  })();

  const decisions =
    (p.decisions && typeof p.decisions === 'object' && !Array.isArray(p.decisions))
      ? p.decisions
      : {};

  const normEmail = (v) => {
    const s = String(v ?? '').trim();
    return s ? s : '';
  };

  const email_actions = (() => {
    if (t !== 'HR_WEEKLY') return undefined;

    const raw = p.email_actions ?? p.emailActions ?? null;
    const arr = Array.isArray(raw) ? raw : [];
    const out = [];

    for (const it of arr) {
      if (!it || typeof it !== 'object') continue;

      const tsId = (it.timesheet_id ?? it.timesheetId ?? null);
      const fp   = (it.issue_fingerprint ?? it.issueFingerprint ?? null);
      const ts = tsId != null ? String(tsId).trim() : '';
      const f  = fp != null ? String(fp).trim() : '';
      if (!ts || !f) continue;

      const alt =
        normEmail(it.alt_email) ||
        normEmail(it.alternative_email) ||
        normEmail(it.alt_recipient_email) ||
        normEmail(it.to_email) ||
        normEmail(it.toEmail) ||
        normEmail(it.recipient_email_override) ||
        normEmail(it.override_email) ||
        '';

      out.push({
        timesheet_id: ts,
        issue_fingerprint: f,
        ...(alt ? { alt_email: alt } : {})
      });
    }

    const seen = new Map();
    for (const x of out) {
      const k = `${x.timesheet_id}__${x.issue_fingerprint}`;
      if (!seen.has(k)) {
        seen.set(k, x);
        continue;
      }
      const prev = seen.get(k);
      const prevAlt = String(prev?.alt_email || '').trim();
      const nextAlt = String(x?.alt_email || '').trim();
      if (!prevAlt && nextAlt) {
        seen.set(k, { ...prev, alt_email: nextAlt });
      }
    }
    return Array.from(seen.values());
  })();

  const urlPath =
    (t === 'NHSP')
      ? `/api/nhsp/${encId}/apply`
      : `/api/healthroster/${encId}/autoprocess-apply`;

  // -------------------------------------------------------------------
  // HR_WEEKLY forced fields:
  // - Always include missing shifts
  // - Always send file date range (prefer payload, else canonical preview truth_meta)
  // -------------------------------------------------------------------
  const getPreviewTruthMeta = () => {
    try {
      const p0 = (window.__importSummaryState && window.__importSummaryState.HR_WEEKLY)
        ? window.__importSummaryState.HR_WEEKLY
        : null;
      if (!p0 || typeof p0 !== 'object') return null;

      if (p0.truth_meta && typeof p0.truth_meta === 'object') return p0.truth_meta;
      if (p0.summary && p0.summary.truth_meta && typeof p0.summary.truth_meta === 'object') return p0.summary.truth_meta;
      return null;
    } catch {
      return null;
    }
  };

  const tm0 = (t === 'HR_WEEKLY') ? getPreviewTruthMeta() : null;

  const hrFileDateMin =
    (t === 'HR_WEEKLY')
      ? (
          (p.file_date_min ?? p.fileDateMin ?? p.date_min ?? p.dateMin ?? null) ??
          (p.truth_meta?.file_date_min ?? p.truthMeta?.file_date_min ?? null) ??
          (p.truth_meta?.fileDateMin ?? p.truthMeta?.fileDateMin ?? null) ??
          (tm0?.file_date_min ?? tm0?.fileDateMin ?? null) ??
          null
        )
      : null;

  const hrFileDateMax =
    (t === 'HR_WEEKLY')
      ? (
          (p.file_date_max ?? p.fileDateMax ?? p.date_max ?? p.dateMax ?? null) ??
          (p.truth_meta?.file_date_max ?? p.truthMeta?.file_date_max ?? null) ??
          (p.truth_meta?.fileDateMax ?? p.truthMeta?.fileDateMax ?? null) ??
          (tm0?.file_date_max ?? tm0?.fileDateMax ?? null) ??
          null
        )
      : null;

  const body = { selected_action_ids, decisions };

  if (t === 'HR_WEEKLY') {
    body.email_actions = email_actions || [];
    body.include_missing_shifts = true;

    if (hrFileDateMin) body.file_date_min = String(hrFileDateMin);
    if (hrFileDateMax) body.file_date_max = String(hrFileDateMax);
  }

  const res = await authFetch(API(urlPath), {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify(body)
  });

  const text = await res.text().catch(() => '');

  if (!res.ok) {
    let msg = text || `Weekly import apply failed (${res.status})`;
    try {
      if (text) {
        const j = JSON.parse(text);
        if (j && typeof j === 'object') {
          if (typeof j.message === 'string' && j.message.trim()) msg = j.message.trim();
          else if (typeof j.error === 'string' && j.error.trim()) msg = j.error.trim();
        }
      }
    } catch {}
    throw new Error(msg);
  }

  try { return text ? JSON.parse(text) : {}; } catch { return {}; }
}




function renderClientHospitalsTable() {
  const el = byId('clientHospitals');
  if (!el) return;

  const frame = _currentFrame();
  // Allow create OR edit to add/edit hospitals
  const parentEditable = frame && (frame.mode === 'edit' || frame.mode === 'create');

  const ctx = window.modalCtx || {};
  const H = ctx.hospitalsState || (ctx.hospitalsState = {
    existing: [],
    stagedNew: [],
    stagedEdits: {},
    stagedDeletes: new Set()
  });

  // Normalise stagedDeletes back to a Set if it was JSON-cloned
  if (!(H.stagedDeletes instanceof Set)) {
    H.stagedDeletes = new Set(
      Array.isArray(H.stagedDeletes)
        ? H.stagedDeletes
        : Object.keys(H.stagedDeletes || {})
    );
  }
  H.stagedNew   = Array.isArray(H.stagedNew)   ? H.stagedNew   : [];
  H.existing    = Array.isArray(H.existing)    ? H.existing    : [];
  H.stagedEdits = H.stagedEdits || {};

  el.innerHTML = '';

  const tbl = document.createElement('table');
  tbl.className = 'grid';

  const thead = document.createElement('thead');
  const trh = document.createElement('tr');

  // Columns: Aliases, Ward hint, Status / Actions
  ['Aliases (HealthRoster / NHSP / Rota)','Ward / Unit hint','Status'].forEach(c => {
    const th = document.createElement('th');
    th.textContent = c;
    trh.appendChild(th);
  });
  thead.appendChild(trh);
  tbl.appendChild(thead);

  const tb = document.createElement('tbody');

  // Helper to render alias cell (chips + input) for an existing row
  function buildAliasCellForExisting(x) {
    const td = document.createElement('td');
    const wrap = document.createElement('div');
    wrap.className = 'chip-row';
    wrap.style.display = 'flex';
    wrap.style.flexWrap = 'wrap';
    wrap.style.gap = '4px';

    // Normalise aliases
    let aliases = Array.isArray(x.hospital_name_norm)
      ? x.hospital_name_norm.slice()
      : (x.hospital_name_norm ? [x.hospital_name_norm] : []);
    aliases = aliases.filter(a => !!a).map(a => String(a));

    const rowId = String(x.id);
    const setDirty = () => {
      H.stagedEdits[rowId] = {
        ...(H.stagedEdits[rowId] || {}),
        hospital_name_norm: aliases
      };
      try { window.dispatchEvent(new CustomEvent('modal-dirty')); } catch {}
    };

    const renderChips = () => {
      wrap.innerHTML = '';
      if (!aliases.length) {
        const span = document.createElement('span');
        span.className = 'mini';
        span.textContent = 'No aliases configured yet.';
        wrap.appendChild(span);
        return;
      }
      aliases.forEach(alias => {
        const chip = document.createElement('span');
        chip.className = 'chip';
        chip.dataset.alias = alias;

        const label = document.createElement('span');
        label.className = 'chip-label';
        label.textContent = alias;

        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'chip-remove';
        btn.textContent = 'Ã—';
        btn.title = 'Remove alias';
        btn.disabled = !parentEditable;
        btn.onclick = () => {
          if (!parentEditable) return;
          aliases = aliases.filter(a => a !== alias);
          renderChips();
          setDirty();
        };

        chip.appendChild(label);
        chip.appendChild(btn);
        wrap.appendChild(chip);
      });
    };

    renderChips();
    td.appendChild(wrap);

    const inp = document.createElement('input');
    inp.type = 'text';
    inp.className = 'input alias-input';
    inp.placeholder = 'Add alias (e.g. uhb qe)';
    inp.disabled = !parentEditable;
    inp.style.marginTop = '4px';
    inp.onkeydown = (ev) => {
      if (ev.key !== 'Enter') return;
      const raw = (inp.value || '').trim();
      if (!raw) return;
      const alias = raw.toLowerCase();
      if (!aliases.includes(alias)) {
        aliases.push(alias);
        renderChips();
        setDirty();
      }
      inp.value = '';
    };

    td.appendChild(inp);
    return td;
  }

  // Helper to render alias cell for a NEW (staged) row
  function buildAliasCellForNew(stagedRow) {
    const td = document.createElement('td');
    const wrap = document.createElement('div');
    wrap.className = 'chip-row';
    wrap.style.display = 'flex';
    wrap.style.flexWrap = 'wrap';
    wrap.style.gap = '4px';

    let aliases = Array.isArray(stagedRow.hospital_name_norm)
      ? stagedRow.hospital_name_norm.slice()
      : (stagedRow.hospital_name_norm ? [stagedRow.hospital_name_norm] : []);
    aliases = aliases.filter(a => !!a).map(a => String(a));

    const setDirty = () => {
      stagedRow.hospital_name_norm = aliases;
      try { window.dispatchEvent(new CustomEvent('modal-dirty')); } catch {}
    };

    const renderChips = () => {
      wrap.innerHTML = '';
      if (!aliases.length) {
        const span = document.createElement('span');
        span.className = 'mini';
        span.textContent = 'No aliases configured yet.';
        wrap.appendChild(span);
        return;
      }
      aliases.forEach(alias => {
        const chip = document.createElement('span');
        chip.className = 'chip';
        chip.dataset.alias = alias;

        const label = document.createElement('span');
        label.className = 'chip-label';
        label.textContent = alias;

        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'chip-remove';
        btn.textContent = 'Ã—';
        btn.title = 'Remove alias';
        btn.disabled = !parentEditable;
        btn.onclick = () => {
          if (!parentEditable) return;
          aliases = aliases.filter(a => a !== alias);
          renderChips();
          setDirty();
        };

        chip.appendChild(label);
        chip.appendChild(btn);
        wrap.appendChild(chip);
      });
    };

    renderChips();
    td.appendChild(wrap);

    const inp = document.createElement('input');
    inp.type = 'text';
    inp.className = 'input alias-input';
    inp.placeholder = 'Add alias (e.g. uhb qe)';
    inp.disabled = !parentEditable;
    inp.style.marginTop = '4px';
    inp.onkeydown = (ev) => {
      if (ev.key !== 'Enter') return;
      const raw = (inp.value || '').trim();
      if (!raw) return;
      const alias = raw.toLowerCase();
      if (!aliases.includes(alias)) {
        aliases.push(alias);
        renderChips();
        setDirty();
      }
      inp.value = '';
    };

    td.appendChild(inp);
    return td;
  }

  // Existing rows (DB)
  (H.existing || []).forEach((x) => {
    if (H.stagedDeletes.has(String(x.id))) return;

    const tr = document.createElement('tr');

    // Aliases cell
    const aliasTd = buildAliasCellForExisting(x);

    // Ward hint cell
    const hintTd = document.createElement('td');
    const hintInp = document.createElement('input');
    hintInp.type = 'text';
    hintInp.className = 'input';
    hintInp.value = x.ward_hint || '';
    hintInp.disabled = !parentEditable;
    hintInp.oninput = () => {
      const rowId = String(x.id);
      H.stagedEdits[rowId] = {
        ...(H.stagedEdits[rowId] || {}),
        ward_hint: hintInp.value || null
      };
      try { window.dispatchEvent(new CustomEvent('modal-dirty')); } catch {}
    };
    hintTd.appendChild(hintInp);

    // Status / actions cell
    const actTd = document.createElement('td');
    const rmBtn = document.createElement('button');
    rmBtn.textContent = 'Remove';
    rmBtn.disabled = !parentEditable;
    rmBtn.setAttribute('data-action', 'delete');
    rmBtn.setAttribute('data-hid', String(x.id));
    rmBtn.className = 'btnDelHospital';
    actTd.appendChild(rmBtn);

    tr.appendChild(aliasTd);
    tr.appendChild(hintTd);
    tr.appendChild(actTd);
    tb.appendChild(tr);
  });

  // New (unsaved) rows
  (H.stagedNew || []).forEach((x, idx) => {
    const tr = document.createElement('tr');

    // Aliases cell for staged row
    const aliasTd = buildAliasCellForNew(x);

    // Ward hint
    const hintTd = document.createElement('td');
    const hintInp = document.createElement('input');
    hintInp.type = 'text';
    hintInp.className = 'input';
    hintInp.value = x.ward_hint || '';
    hintInp.disabled = !parentEditable;
    hintInp.oninput = () => {
      x.ward_hint = hintInp.value || null;
      try { window.dispatchEvent(new CustomEvent('modal-dirty')); } catch {}
    };
    hintTd.appendChild(hintInp);

    const actTd = document.createElement('td');
    const rm = document.createElement('button');
    rm.textContent = 'Remove (staged)';
    rm.disabled = !parentEditable;
    rm.onclick = () => {
      if (!parentEditable) return;
      H.stagedNew.splice(idx, 1);
      renderClientHospitalsTable();
      try { window.dispatchEvent(new CustomEvent('modal-dirty')); } catch {}
    };
    actTd.appendChild(rm);

    tr.appendChild(aliasTd);
    tr.appendChild(hintTd);
    tr.appendChild(actTd);
    tb.appendChild(tr);
  });

  tbl.appendChild(tb);

  const actions = document.createElement('div');
  actions.className = 'actions';
  actions.innerHTML = `
    <button id="btnAddClientHospital"${parentEditable ? '' : ' disabled'}>
      Add Hospital / Ward
    </button>
    ${
      parentEditable
        ? ''
        : '<span class="hint">Read-only. Click â€œEditâ€ in the main dialog to add/modify hospitals.</span>'
    }
  `;

  el.appendChild(tbl);
  el.appendChild(actions);

  const addBtn = byId('btnAddClientHospital');
  if (addBtn && parentEditable) {
    addBtn.onclick = () => openClientHospitalModal(ctx.data?.id);
  }
}


async function renderClientSettingsUI(settingsObj){
  const div = byId('clientSettings'); if (!div) return;

  const ctx = window.modalCtx;

  const initial = (ctx.clientSettingsState && typeof ctx.clientSettingsState === 'object')
    ? ctx.clientSettingsState
    : (settingsObj && typeof settingsObj === 'object' ? settingsObj : {});

  // âœ… Ensure we always have a baseline available (DB snapshot) if caller didnâ€™t seed it
  try {
    const hasBaseline =
      (ctx.clientSettingsBaseline && typeof ctx.clientSettingsBaseline === 'object' && Object.keys(ctx.clientSettingsBaseline).length > 0);
    if (!hasBaseline) {
      ctx.clientSettingsBaseline = { ...(settingsObj && typeof settingsObj === 'object' ? settingsObj : {}) };
    }
  } catch {}

  // âœ… Robust: accepts "06:00", "06:00:00", "06:00:00+00", etc
  const _toHHMM = (v) => {
    if (v == null) return '';
    const s = String(v).trim();
    const m = s.match(/^(\d{2}:\d{2})/);
    return m ? m[1] : s;
  };

  const TIME_KEYS = [
    'day_start','day_end',
    'night_start','night_end',
    'sat_start','sat_end',
    'sun_start','sun_end',
    'bh_start','bh_end'
  ];

  const toBool = (v, def = false) => {
    if (typeof v === 'boolean') return v;
    if (v === 'on' || v === 'true' || v === true || v === 1 || v === '1') return true;
    if (v === 'false' || v === false || v === 0 || v === '0' || v == null || v === '') return false;
    return def;
  };

  const up = (v) => String(v || '').trim().toUpperCase();

  // âœ… NEW: client-level temp staffing email (stored on clients.ts_queries_email)
  const clientTsQueriesEmail = (() => {
    try {
      const v = ctx?.data?.ts_queries_email;
      return (v == null) ? '' : String(v).trim();
    } catch { return ''; }
  })();

  // âœ… Seed WITHOUT forcing defaults. Blank means â€œinherit globalâ€.
  const seed = {
    ...initial,

    timezone_id : initial.timezone_id ?? 'Europe/London',

    day_start   : _toHHMM(initial.day_start),
    day_end     : _toHHMM(initial.day_end),
    night_start : _toHHMM(initial.night_start),
    night_end   : _toHHMM(initial.night_end),
    sat_start   : _toHHMM(initial.sat_start),
    sat_end     : _toHHMM(initial.sat_end),
    sun_start   : _toHHMM(initial.sun_start),
    sun_end     : _toHHMM(initial.sun_end),
    bh_start    : _toHHMM(initial.bh_start),
    bh_end      : _toHHMM(initial.bh_end),

    week_ending_weekday:
      Number.isInteger(Number(initial.week_ending_weekday))
        ? String(Math.min(6, Math.max(0, Number(initial.week_ending_weekday))))
        : '0',

    default_submission_mode: String(initial.default_submission_mode || 'ELECTRONIC').toUpperCase(),

    auto_invoice_default: (typeof initial.auto_invoice_default === 'boolean') ? initial.auto_invoice_default : false,

    send_manual_invoices_to_different_email:
      (typeof initial.send_manual_invoices_to_different_email === 'boolean')
        ? initial.send_manual_invoices_to_different_email
        : false,

    manual_invoices_alt_email_address:
      String(initial.manual_invoices_alt_email_address || '').trim(),

    weekly_mode: initial.weekly_mode || '',
    hr_weekly_behaviour: initial.hr_weekly_behaviour || '',

    invoice_consolidation_mode: up(initial.invoice_consolidation_mode || 'NONE'),
    reference_number_required_to_issue_invoice: toBool(initial.reference_number_required_to_issue_invoice, false)
  };

  const seedBlankTimeKeys = TIME_KEYS.filter(k => String(seed[k] ?? '').trim() === '');
  const keepAutoInvSeed   = !!seed.auto_invoice_default;
  const keepManualFlagSeed= !!seed.send_manual_invoices_to_different_email;
  const keepManualEmailSeed = String(seed.manual_invoices_alt_email_address || '').trim();

  const keepInvConsolSeed = up(seed.invoice_consolidation_mode || 'NONE');
  const keepRefToIssueSeed = !!seed.reference_number_required_to_issue_invoice;

  let s = canonicalizeClientSettings(seed);

  s.auto_invoice_default = keepAutoInvSeed;
  s.send_manual_invoices_to_different_email = keepManualFlagSeed;
  s.manual_invoices_alt_email_address = keepManualFlagSeed ? keepManualEmailSeed : '';

  s.invoice_consolidation_mode = keepInvConsolSeed;
  s.reference_number_required_to_issue_invoice = keepRefToIssueSeed;

  seedBlankTimeKeys.forEach(k => { s[k] = ''; });

  ctx.clientSettingsState = { ...initial, ...s };

  const pairTimeRow = (label, aName, aVal, bName, bVal) => `
    <div class="row">
      <label style="white-space:normal">${label}</label>
      <div class="controls" style="display:flex;gap:12px;flex-wrap:wrap;align-items:flex-end;min-width:0;">
        <div style="display:flex;flex-direction:column;gap:4px;width:170px;min-width:170px;">
          <span class="mini" style="opacity:0.9">Start</span>
          <input class="input" type="time" step="60" name="${aName}" value="${String(aVal||'')}" />
        </div>
        <div style="display:flex;flex-direction:column;gap:4px;width:170px;min-width:170px;">
          <span class="mini" style="opacity:0.9">End</span>
          <input class="input" type="time" step="60" name="${bName}" value="${String(bVal||'')}" />
        </div>
      </div>
    </div>
  `;

  const weekEndingAndDefaultRow = () => {
    const mode = String(s.weekly_mode || 'NONE').toUpperCase();
    const beh  = String(s.hr_weekly_behaviour || 'VERIFY').toUpperCase();
    const hideDSM = (mode === 'NHSP') || (mode === 'HEALTHROSTER' && beh === 'CREATE');

    const opts = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday']
      .map((lab,idx)=>`<option value="${idx}" ${String(idx)===String(s.week_ending_weekday)?'selected':''}>${lab}</option>`).join('');

    return `
      <div class="row">
        <label style="white-space:normal">Week ending / Default submission</label>
        <div class="controls" style="display:flex;gap:12px;flex-wrap:wrap;align-items:flex-end;min-width:0;">
          <div style="display:flex;flex-direction:column;gap:4px;width:220px;min-width:220px;">
            <span class="mini" style="opacity:0.9">Week ending day</span>
            <select name="week_ending_weekday">${opts}</select>
          </div>

          ${
            hideDSM
              ? ``
              : `
                <div style="display:flex;flex-direction:column;gap:4px;width:220px;min-width:220px;">
                  <span class="mini" style="opacity:0.9">Default submission</span>
                  <select name="default_submission_mode">
                    <option value="ELECTRONIC" ${String(s.default_submission_mode||'').toUpperCase()==='ELECTRONIC'?'selected':''}>ELECTRONIC</option>
                    <option value="MANUAL"     ${String(s.default_submission_mode||'').toUpperCase()==='MANUAL'?'selected':''}>MANUAL</option>
                  </select>
                </div>
              `
          }
        </div>
      </div>
    `;
  };

  const radioPill = (name, value, text, checked) => `
    <label class="inline chk-tight"
      style="display:inline-flex;align-items:center;gap:6px;margin-right:10px;white-space:nowrap;">
      <input type="radio" name="${name}" value="${value}" ${checked ? 'checked' : ''}/>
      <span style="white-space:nowrap;">${text}</span>
    </label>
  `;

  const radioChoice = (name, value, title, desc, checked) => `
    <label style="
      display:grid;
      grid-template-columns: 18px 1fr;
      column-gap:8px;
      row-gap:4px;
      align-items:start;
      cursor:pointer;
      margin:0;
    ">
      <input type="radio" name="${name}" value="${value}" ${checked ? 'checked' : ''} style="margin-top:2px;" />
      <div style="min-width:0;">
        <div style="line-height:1.2;white-space:normal;word-break:normal;overflow-wrap:break-word;">${title}</div>
        ${desc ? `<div class="mini" style="opacity:0.9;line-height:1.25;white-space:normal;word-break:normal;overflow-wrap:break-word;">${desc}</div>` : ``}
      </div>
    </label>
  `;

  const checkChoice = (name, title, checked) => `
    <label style="
      display:grid;
      grid-template-columns: 18px 1fr;
      column-gap:8px;
      align-items:start;
      cursor:pointer;
      margin:0;
    ">
      <input type="checkbox" name="${name}" ${checked ? 'checked' : ''} style="margin-top:2px;" />
      <div style="line-height:1.2;white-space:normal;word-break:normal;overflow-wrap:break-word;min-width:0;">${title}</div>
    </label>
  `;

  const checkChoiceWithDesc = (name, title, desc, checked) => `
    <label style="
      display:grid;
      grid-template-columns: 18px 1fr;
      column-gap:8px;
      row-gap:4px;
      align-items:start;
      cursor:pointer;
      margin:0;
    ">
      <input type="checkbox" name="${name}" ${checked ? 'checked' : ''} style="margin-top:2px;" />
      <div style="min-width:0;">
        <div style="line-height:1.2;white-space:normal;word-break:normal;overflow-wrap:break-word;min-width:0;">${title}</div>
        ${desc ? `<div class="mini" style="opacity:0.9;line-height:1.25;white-space:normal;overflow-wrap:break-word;">${desc}</div>` : ``}
      </div>
    </label>
  `;

  const invoicingModePanelHTML = (st) => {
    const m = up(st.invoice_consolidation_mode || 'NONE');
    const mode = (m === 'ALL') ? 'ANY_WEEK' : m;

    return `
      <div class="row" style="margin:0;">
        <label style="white-space:normal">Invoice consolidation</label>
        <div class="controls" style="display:flex;flex-direction:column;gap:8px;min-width:0;">
          <div style="display:flex;flex-wrap:wrap;gap:10px;align-items:center;">
            ${radioPill('invoice_consolidation_mode', 'BY_WEEK', 'By week (per client)', mode === 'BY_WEEK')}
            ${radioPill('invoice_consolidation_mode', 'ANY_WEEK', 'All weeks (for client)', mode === 'ANY_WEEK')}
            ${radioPill('invoice_consolidation_mode', 'NONE', 'None', mode === 'NONE')}
          </div>
        </div>
      </div>
    `;
  };

  const hrBehaviourHTML = (st) => {
    const mode = String(st.weekly_mode || 'NONE').toUpperCase();
    if (mode !== 'HEALTHROSTER') return '';

    const beh = String(st.hr_weekly_behaviour || 'VERIFY').toUpperCase();
    const isVerify = (beh !== 'CREATE');

    // âœ… NEW: Temp Staffing Email Address only for HealthRoster VERIFY
    const tsEmailBlock = (isVerify)
      ? `
        <div class="row" style="margin-top:12px;">
          <label style="white-space:normal">Temporary Staffing Email Address</label>
          <div class="controls" style="display:flex;flex-direction:column;gap:6px;min-width:0;">
            <input class="input" name="ts_queries_email" value="${String(clientTsQueriesEmail || '')}" placeholder="name@trust.nhs.uk" />
            <div class="mini" style="opacity:0.85;line-height:1.25;white-space:normal;overflow-wrap:break-word;">
              Used when emailing Temporary Staffing about weekly HealthRoster validation mismatches.
            </div>
          </div>
        </div>
      `
      : ``;

    return `
      <div class="row" style="margin-top:12px;">
        <label style="white-space:normal">Weekly HealthRoster behaviour</label>
        <div class="controls" style="display:flex;flex-direction:column;gap:12px;min-width:0;">
          ${radioChoice(
            'hr_weekly_behaviour',
            'VERIFY',
            'Worker will provide timesheets; the agency will also import healthroster data to verify workers hours',
            'Import will validate that HealthRoster hours match the workerâ€™s weekly timesheet. Mismatches fail validation and healthroster or timesheet will need amending before it can be paid.',
            isVerify
          )}
          ${radioChoice(
            'hr_weekly_behaviour',
            'CREATE',
            'Worker will not provide timesheets; imports create them if a contract exists',
            'Import will create/update weekly timesheets from HealthRoster hours when a contract exists. Healthroster hours will not require any seperate checks.',
            !isVerify
          )}
        </div>
      </div>
      ${tsEmailBlock}
    `;
  };

  const weeklyPanelHTML = (st) => {
    const mode = String(st.weekly_mode || 'NONE').toUpperCase();
    const msg =
      (mode === 'NONE')
        ? 'Weekly timesheets are managed manually (no external weekly import source). Candidates will submit timesheets electronically or using a QR Timesheet.'
      : (mode === 'NHSP')
        ? 'NHSP weekly imports will be used for this client. Candidates will not submit any timesheets.'
      : 'HealthRoster weekly imports will be used for this client.';

    return `
      <div class="row" style="margin:0;">
        <label style="white-space:normal">Weekly timesheet source</label>
        <div class="controls" style="display:flex;flex-direction:column;gap:8px;min-width:0;">
          <div style="display:flex;flex-wrap:wrap;gap:10px;align-items:center;">
            ${radioPill('weekly_mode', 'NONE', 'None (manual)', mode === 'NONE')}
            ${radioPill('weekly_mode', 'NHSP', 'NHSP', mode === 'NHSP')}
            ${radioPill('weekly_mode', 'HEALTHROSTER', 'HealthRoster', mode === 'HEALTHROSTER')}
          </div>
          <div class="mini" style="opacity:0.9;line-height:1.25;white-space:normal;overflow-wrap:break-word;">${msg}</div>
        </div>
      </div>
      ${hrBehaviourHTML(st)}
    `;
  };

  const flagsPanelHTML = (st) => {
    const mode = String(st.weekly_mode || 'NONE').toUpperCase();
    const beh  = String(st.hr_weekly_behaviour || 'VERIFY').toUpperCase();
    const isCreate = (beh === 'CREATE');

    const manualEmailBlock = `
      ${checkChoice('send_manual_invoices_to_different_email', 'Send manual/QR adjustment invoices to a different email', !!st.send_manual_invoices_to_different_email)}
      ${
        st.send_manual_invoices_to_different_email
          ? `
            <div style="display:flex;flex-direction:column;gap:6px;margin-left:26px;">
              <input class="input" name="manual_invoices_alt_email_address" value="${String(st.manual_invoices_alt_email_address || '')}" placeholder="name@company.com" />
              <div class="mini" style="opacity:0.85;line-height:1.25;white-space:normal;overflow-wrap:break-word;">
                Used only when an invoice relates to a manual/QR adjustment timesheet and this flag is enabled.
              </div>
            </div>
          `
          : ``
      }
    `;

    const refToIssueBlock = `
      ${checkChoiceWithDesc(
        'reference_number_required_to_issue_invoice',
        'Reference Numbers required to Issue Invoices',
        'Affects issuing only; invoicing may still occur per contract rules.',
        !!st.reference_number_required_to_issue_invoice
      )}
    `;

    if (mode === 'NHSP') {
      return `
        <div class="row" style="margin:0;">
          <label style="white-space:normal">References & flags</label>
          <div class="controls" style="display:flex;flex-direction:column;gap:12px;min-width:0;">
            <div class="mini" style="opacity:0.9;line-height:1.25;white-space:normal;overflow-wrap:break-word;">
              NHSP mode controls references, invoicing behaviour and attachments automatically.
            </div>
            <div style="display:grid;grid-template-columns:1fr;gap:8px;">
              ${refToIssueBlock}
              ${checkChoice('auto_invoice_default', 'Auto-invoice by default', !!st.auto_invoice_default)}
              ${manualEmailBlock}
            </div>
          </div>
        </div>
      `;
    }

    if (mode === 'NONE') {
      return `
        <div class="row" style="margin:0;">
          <label style="white-space:normal">References & flags</label>
          <div class="controls" style="display:flex;flex-direction:column;gap:12px;min-width:0;">
            <div style="display:grid;grid-template-columns:1fr;gap:8px;">
              ${refToIssueBlock}
              ${checkChoice('pay_reference_required', 'Ref No. required to PAY', !!st.pay_reference_required)}
              ${checkChoice('invoice_reference_required', 'Ref No. required to INVOICE', !!st.invoice_reference_required)}
            </div>

            <div style="display:grid;grid-template-columns:1fr;gap:8px;">
              ${checkChoice('self_bill_no_invoices_sent', 'Self-bill (no invoices sent)', !!st.self_bill_no_invoices_sent)}
              ${checkChoice('daily_calc_of_invoices', 'Daily invoice calculation', !!st.daily_calc_of_invoices)}
              ${checkChoice('group_nightsat_sunbh', 'Group Night/Sat/Sun/BH', !!st.group_nightsat_sunbh)}
              ${checkChoice('auto_invoice_default', 'Auto-invoice by default', !!st.auto_invoice_default)}
              ${manualEmailBlock}
            </div>

            <div class="mini" style="opacity:0.9;line-height:1.25;white-space:normal;overflow-wrap:break-word;">
              Timesheets will always be attached to invoices for manual clients.
            </div>
          </div>
        </div>
      `;
    }

    return `
      <div class="row" style="margin:0;">
        <label style="white-space:normal">References & flags</label>
        <div class="controls" style="display:flex;flex-direction:column;gap:12px;min-width:0;">
          <div style="display:grid;grid-template-columns:1fr;gap:8px;">
            ${refToIssueBlock}
            ${checkChoice('self_bill_no_invoices_sent', 'Self-bill (no invoices sent)', !!st.self_bill_no_invoices_sent)}
            ${checkChoice('daily_calc_of_invoices', 'Daily invoice calculation', !!st.daily_calc_of_invoices)}
            ${checkChoice('group_nightsat_sunbh', 'Group Night/Sat/Sun/BH', !!st.group_nightsat_sunbh)}
            ${checkChoice('auto_invoice_default', 'Auto-invoice by default', !!st.auto_invoice_default)}
            ${manualEmailBlock}
          </div>

          <div style="display:grid;grid-template-columns:1fr;gap:8px;">
            ${checkChoice('hr_attach_to_invoice', 'Attach HealthRoster to invoice', !!st.hr_attach_to_invoice)}
            ${isCreate ? '' : checkChoice('ts_attach_to_invoice', 'Attach timesheets to invoice', !!st.ts_attach_to_invoice)}
          </div>
        </div>
      </div>
    `;
  };

  div.innerHTML = `
    <div id="clientSettingsForm" style="display:block;">
      <div style="
        display:grid;
        grid-template-columns: minmax(520px, 1.15fr) minmax(420px, 0.85fr);
        gap: 18px;
        align-items:start;
        width:100%;
      ">
        <div style="min-width:0;overflow-wrap:break-word;">
          <div class="row">
            <label>Timezone</label>
            <div class="controls"><input class="input" name="timezone_id" value="${String(s.timezone_id||'')}" /></div>
          </div>

          <div class="row">
            <label>Shift times</label>
            <div class="controls">
              <button type="button" class="btn mini" id="btnClearClientShiftTimes">
                Clear shift times and default to global shift times
              </button>
              <div class="hint mini" style="opacity:0.9;margin-top:6px;">
                Clearing all times means this client will inherit the global shift pattern.
              </div>
              <div class="hint mini" style="opacity:0.85;margin-top:4px;">
                Rule: you can either set <b>all</b> shift times, or leave <b>all</b> blank.
              </div>
            </div>
          </div>

          ${pairTimeRow('Day shift',   'day_start',   s.day_start,   'day_end',   s.day_end)}
          ${pairTimeRow('Night shift', 'night_start', s.night_start, 'night_end', s.night_end)}
          ${pairTimeRow('Saturday',    'sat_start',   s.sat_start,   'sat_end',   s.sat_end)}
          ${pairTimeRow('Sunday',      'sun_start',   s.sun_start,   'sun_end',   s.sun_end)}
          ${pairTimeRow('Bank holiday','bh_start',    s.bh_start,    'bh_end',    s.bh_end)}
          ${weekEndingAndDefaultRow()}
        </div>

        <div style="min-width:0;overflow-wrap:break-word;display:flex;flex-direction:column;gap:14px;">
          <div id="csInvModePanel">${invoicingModePanelHTML(s)}</div>
          <div id="csWeeklyPanel">${weeklyPanelHTML(s)}</div>
          <div id="csFlagsPanel">${flagsPanelHTML(s)}</div>
        </div>
      </div>
    </div>
  `;

  const root = document.getElementById('clientSettingsForm');
  const hhmm = /^([01]\d|2[0-3]):[0-5]\d$/;

  let lastValid = { ...s };

  if (root.__wired) {
    root.removeEventListener('input',  root.__syncSoft, true);
    root.removeEventListener('change', root.__syncValidate, true);
    TIME_KEYS.forEach(k=>{
      const el = root.querySelector(`input[name="${k}"]`);
      if (el && el.__syncValidate) el.removeEventListener('blur', el.__syncValidate, true);
    });
  }

  const _currentFrame = window.__getModalFrame || (() => null);

  const getRadio = (name) => {
    const el = root.querySelector(`input[type="radio"][name="${name}"]:checked`);
    return el ? String(el.value || '').trim() : '';
  };

  const getCheckbox = (name) => {
    const el = root.querySelector(`input[type="checkbox"][name="${name}"]`);
    return el ? !!el.checked : null;
  };

  const paintRightPanels = (which) => {
    const st = ctx.clientSettingsState || {};
    const invModeEl = root.querySelector('#csInvModePanel');
    const weeklyEl = root.querySelector('#csWeeklyPanel');
    const flagsEl  = root.querySelector('#csFlagsPanel');

    if (!which || which === 'both' || which === 'inv' || which === 'all') {
      if (invModeEl) invModeEl.innerHTML = invoicingModePanelHTML(st);
    }
    if (!which || which === 'both' || which === 'weekly' || which === 'all') {
      if (weeklyEl) weeklyEl.innerHTML = weeklyPanelHTML(st);
    }
    if (!which || which === 'both' || which === 'flags' || which === 'all') {
      if (flagsEl)  flagsEl.innerHTML  = flagsPanelHTML(st);
    }
  };

  const applyFromDOM = (soft) => {
    const frame = _currentFrame();
    if (!frame || frame.mode !== 'edit') return;

    const prev = ctx.clientSettingsState || {};
    const vals = collectForm('#clientSettingsForm', false);
    let next = { ...prev, ...vals };

    // âœ… NEW: stage client-level ts_queries_email in ctx.data (NOT in client_settings payload)
    if (Object.prototype.hasOwnProperty.call(vals, 'ts_queries_email')) {
      try {
        const v = String(vals.ts_queries_email ?? '').trim();
        ctx.data = ctx.data || {};
        ctx.data.ts_queries_email = v;
      } catch {}
    }

    TIME_KEYS.forEach(k=>{
      const v = String(vals[k] ?? '').trim();
      if (v && !hhmm.test(v)) {
        if (soft) next[k] = lastValid[k];
        else {
          const el = root.querySelector(`input[name="${k}"]`);
          if (el) el.value = lastValid[k] || '';
        }
      }
    });

    const blankTimeKeys = TIME_KEYS.filter(k => String(next[k] ?? '').trim() === '');
    const hasSomeBlank = (blankTimeKeys.length > 0 && blankTimeKeys.length < TIME_KEYS.length);

    if (!soft && hasSomeBlank) {
      TIME_KEYS.forEach(k => {
        next[k] = String(lastValid[k] ?? '');
        const el = root.querySelector(`input[name="${k}"]`);
        if (el) el.value = String(lastValid[k] ?? '');
      });

      alert(
        'Shift times must be either:\n' +
        'â€¢ all filled, or\n' +
        'â€¢ all blank (to inherit global).\n\n' +
        'Use â€œClear shift times and default to global shift timesâ€ to blank them all.'
      );

      ctx.clientSettingsState = { ...lastValid };
      return;
    }

    const w = Number(vals.week_ending_weekday);
    next.week_ending_weekday = Number.isInteger(w)
      ? String(Math.min(6, Math.max(0, w)))
      : lastValid.week_ending_weekday;

    const dsmDom = root.querySelector('select[name="default_submission_mode"]');
    if (dsmDom) {
      const dsm = String(vals.default_submission_mode || next.default_submission_mode || 'ELECTRONIC').toUpperCase();
      next.default_submission_mode = (dsm === 'ELECTRONIC' || dsm === 'MANUAL') ? dsm : 'ELECTRONIC';
    }

    const wm = getRadio('weekly_mode');
    if (wm) next.weekly_mode = wm;

    const hb = getRadio('hr_weekly_behaviour');
    if (hb) next.hr_weekly_behaviour = hb;

    const icm = getRadio('invoice_consolidation_mode');
    if (icm) next.invoice_consolidation_mode = icm;

    const cbKeys = [
      'pay_reference_required',
      'invoice_reference_required',
      'self_bill_no_invoices_sent',
      'daily_calc_of_invoices',
      'group_nightsat_sunbh',
      'auto_invoice_default',
      'hr_attach_to_invoice',
      'ts_attach_to_invoice',
      'send_manual_invoices_to_different_email',
      'reference_number_required_to_issue_invoice'
    ];
    cbKeys.forEach(k=>{
      const v = getCheckbox(k);
      if (v !== null) next[k] = v;
    });

    next.manual_invoices_alt_email_address = String(next.manual_invoices_alt_email_address || '').trim();
    if (!next.send_manual_invoices_to_different_email) {
      next.manual_invoices_alt_email_address = '';
    }

    const keepAutoInv =
      (typeof next.auto_invoice_default === 'boolean')
        ? next.auto_invoice_default
        : !!prev.auto_invoice_default;

    const keepManualFlag =
      (typeof next.send_manual_invoices_to_different_email === 'boolean')
        ? next.send_manual_invoices_to_different_email
        : !!prev.send_manual_invoices_to_different_email;

    const keepManualEmail =
      String(next.manual_invoices_alt_email_address || '').trim();

    const keepInvConsol = up(next.invoice_consolidation_mode || prev.invoice_consolidation_mode || 'NONE');
    const keepRefToIssue =
      (typeof next.reference_number_required_to_issue_invoice === 'boolean')
        ? next.reference_number_required_to_issue_invoice
        : !!prev.reference_number_required_to_issue_invoice;

    const blankKeysNow = TIME_KEYS.filter(k => String(next[k] ?? '').trim() === '');

    next = canonicalizeClientSettings(next);

    next.auto_invoice_default = keepAutoInv;
    next.send_manual_invoices_to_different_email = keepManualFlag;
    next.manual_invoices_alt_email_address = keepManualFlag ? keepManualEmail : '';

    next.invoice_consolidation_mode = keepInvConsol;
    next.reference_number_required_to_issue_invoice = !!keepRefToIssue;

    blankKeysNow.forEach(k => { next[k] = ''; });

    const gatePrev = `${String(prev.weekly_mode||'').toUpperCase()}|${String(prev.hr_weekly_behaviour||'').toUpperCase()}`;
    const gateNext = `${String(next.weekly_mode||'').toUpperCase()}|${String(next.hr_weekly_behaviour||'').toUpperCase()}`;

    const manualFlagPrev = !!prev.send_manual_invoices_to_different_email;
    const manualFlagNext = !!next.send_manual_invoices_to_different_email;

    const invModePrev = up(prev.invoice_consolidation_mode || 'NONE');
    const invModeNext = up(next.invoice_consolidation_mode || 'NONE');

    ctx.clientSettingsState = next;
    lastValid = { ...next };

    if (invModePrev !== invModeNext) {
      paintRightPanels('inv');
      try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
    }

    if (gatePrev !== gateNext) {
      paintRightPanels('both');
      try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
    } else if (manualFlagPrev !== manualFlagNext) {
      paintRightPanels('flags');
      try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
    }
  };

  const syncSoft = ()=> applyFromDOM(true);

  const btnClear = root.querySelector('#btnClearClientShiftTimes');
  if (btnClear && !btnClear.__wired) {
    btnClear.__wired = true;
    btnClear.addEventListener('click', () => {
      const frame = _currentFrame();
      if (!frame || frame.mode !== 'edit') return;

      TIME_KEYS.forEach(k => {
        const el = root.querySelector(`input[name="${k}"]`);
        if (el) el.value = '';
      });

      applyFromDOM(false);
      try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
    });
  }

  root.__syncSoft = syncSoft;

  const syncValidate = root.__syncValidate || (() => applyFromDOM(false));

  root.__syncValidate = syncValidate;
  root.addEventListener('input',  syncSoft, true);
  root.addEventListener('change', syncValidate, true);

  TIME_KEYS.forEach(k=>{
    const el = root.querySelector(`input[name="${k}"]`);
    if (el) {
      el.__syncValidate = syncValidate;
      el.addEventListener('blur', syncValidate, true);
      el.setAttribute('step', '60');
    }
  });

  root.__wired = true;
}


async function upsertClient(payload, id){
  if ('cli_ref' in payload) delete payload.cli_ref;

  // âœ… Allow explicit clearing for specific client fields (e.g., ts_queries_email):
  // - if provided as '' in UI, send NULL so backend clears it.
  const CLEAN_NULLABLE_KEYS = new Set(['ts_queries_email']);

  const clean = {};
  for (const [k, v] of Object.entries(payload || {})) {
    if (v === undefined) continue;

    if (CLEAN_NULLABLE_KEYS.has(k)) {
      if (v === '') {
        clean[k] = null;
        continue;
      }
      if (v === null) {
        clean[k] = null;
        continue;
      }
      clean[k] = v;
      continue;
    }

    if (v === '') continue;
    clean[k] = v;
  }

  const url    = id ? `/api/clients/${id}` : '/api/clients';
  const method = id ? 'PUT' : 'POST';
  const APILOG = (typeof window !== 'undefined' && !!window.__LOG_API) || (typeof __LOG_API !== 'undefined' && !!__LOG_API);
  if (APILOG) console.log('[upsertClient] â†’', { method, url: API(url), body: clean });

  const r = await authFetch(API(url), {
    method,
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify(clean)
  });

  if (APILOG) console.log('[upsertClient] â†', r.status, r.ok);
  if (!r.ok) {
    const msg = await r.text().catch(()=> '');
    if (APILOG) console.error('[upsertClient] error body', msg);
    throw new Error(msg || 'Save failed');
  }

  try {
    const data = await r.json();
    if (APILOG) console.log('[upsertClient] parsed', data);
    let obj = null;
    if (Array.isArray(data)) obj = data[0] || null;
    else if (data && data.client) obj = data.client;
    else if (data && typeof data === 'object') obj = data;
    if (obj) return obj;
  } catch (_) {}

  let clientId = id || null;
  try {
    const loc = r.headers && r.headers.get('Location');
    if (!clientId && loc) {
      const m = loc.match(/\/api\/clients\/([^/?#]+)/i) || loc.match(/\/clients\/([^/?#]+)/i);
      if (m) clientId = m[1];
    }
  } catch (_) {}

  if (clientId) {
    try {
      const rr = await authFetch(API(`/api/clients/${encodeURIComponent(clientId)}`));
      if (rr.ok) {
        const dd = await rr.json().catch(()=> ({}));
        const obj = (dd && dd.client) ? dd.client : dd;
        if (obj && typeof obj === 'object') {
          if (APILOG) console.log('[upsertClient] GET backfill', obj);
          return obj;
        }
      }
    } catch (_) {}
  }

  const fallback = clientId ? { id: clientId, ...clean } : (id ? { id, ...clean } : { ...clean });
  if (APILOG) console.log('[upsertClient] fallback', fallback);
  return fallback;
}



// =================== HOSPITALS TABLE (UPDATED: staged delete & edit) ===================


// ---- Umbrella modal
// ========================= openUmbrella (FIXED) =========================
// ---- Umbrella modal
// ========================= openUmbrella (FIXED) =========================
// ================== FRONTEND: openUmbrella (UPDATED) ==================
// ================== FIXED: openUmbrella (hydrate before showModal) ==================
// ================== FIXED: openUmbrella (hydrate before showModal) ==================
async function openUmbrella(row){
  // ===== Logging helpers (toggle with window.__LOG_MODAL = true/false) =====
  const LOG = (typeof window.__LOG_MODAL === 'boolean') ? window.__LOG_MODAL : true;
  const L  = (...a)=> { if (LOG) console.log('[OPEN_UMBRELLA]', ...a); };
  const W  = (...a)=> { if (LOG) console.warn('[OPEN_UMBRELLA]', ...a); };
  const E  = (...a)=> { if (LOG) console.error('[OPEN_UMBRELLA]', ...a); };

  const deep = (o)=> JSON.parse(JSON.stringify(o || {}));
  const incoming = deep(row || {});
  const seedId   = incoming?.id || null;

  L('ENTRY', { incomingKeys: Object.keys(incoming||{}), seedId });

  const unwrapSingle = (data, key) => {
    if (Array.isArray(data)) return data[0] || null;
    if (data && key && data[key]) return unwrapSingle(data[key], null);
    if (data && Array.isArray(data.rows))  return data.rows[0]  || null;
    if (data && Array.isArray(data.items)) return data.items[0] || null;
    if (data && Array.isArray(data.data))  return data.data[0]  || null;
    return (data && typeof data === 'object') ? data : null;
  };

  // 1) Hydrate full umbrella if we have an id
  let full = incoming;
  if (seedId) {
    try {
      const url = API(`/api/umbrellas/${encodeURIComponent(seedId)}`);
      L('[HTTP] GET', url);
      const res = await authFetch(url);
      L('[HTTP] status', res?.status, res?.ok);

      try {
        const raw = await res.clone().text();
        if (LOG) console.debug('[HTTP] raw body (â‰¤2KB):', raw.slice(0, 2048));
      } catch (peekErr) { W('[HTTP] raw peek failed', peekErr?.message || peekErr); }

      if (res.ok) {
        const data = await res.json().catch(()=> ({}));
        const unwrapped = unwrapSingle(data, 'umbrella');
        L('hydrated JSON keys', Object.keys(data||{}), 'unwrapped keys', Object.keys(unwrapped||{}));
        full = unwrapped || incoming;
      } else {
        W('non-OK response, using incoming row');
      }
    } catch (e) {
      W('openUmbrella hydrate failed; using summary row', e);
    }
  } else {
    L('no seedId â€” create mode');
  }

  // 2) Seed window.modalCtx and SHOW IMMEDIATELY
  const fullKeys = Object.keys(full || {});
  L('seeding window.modalCtx', { entity: 'umbrellas', fullId: full?.id, fullKeys });

  window.modalCtx = {
    entity: 'umbrellas',
    data: deep(full),
    formState: { __forId: full?.id || null, main: {} },
    rolesState: null,
    ratesState: null,
    clientSettingsState: null,
    openToken: ((full?.id) || 'new') + ':' + Date.now()
  };

  L('window.modalCtx seeded', {
    entity: window.modalCtx.entity,
    dataId: window.modalCtx.data?.id,
    dataKeys: Object.keys(window.modalCtx.data||{}),
    formStateForId: window.modalCtx.formState?.__forId,
    openToken: window.modalCtx.openToken
  });

  // 3) Render modal NOW
  L('calling showModal with hasId=', !!full?.id, 'rawHasIdArg=', full?.id);
  showModal(
    'Umbrella',
    [{ key:'main', label:'Main' }],
    (key, r)=> {
      L('[renderUmbrellaTab] tab=', key, 'rowKeys=', Object.keys(r||{}), 'sample=', { name: r?.name, id: r?.id });
      const u = r || {};
      return html(`
        <div class="form" id="tab-main">
          ${input('name','Name', u.name)}
          ${input('remittance_email','Remittance email', u.remittance_email, 'email')}
          ${input('bank_name','Bank', u.bank_name)}
          ${input('sort_code','Sort code', u.sort_code)}
          ${input('account_number','Account number', u.account_number)}

          <div class="row">
            <label>Company registration number</label>
            <div class="controls">
              <input class="input"
                     name="company_number"
                     value="${escapeHtml(u.company_number || '')}">
            </div>
          </div>

          <div class="row">
            <label>Address</label>
            <div class="controls">
              <div class="grid-2">
                <input class="input"
                       name="address_line1"
                       placeholder="Address line 1"
                       value="${escapeHtml(u.address_line1 || '')}">
                <input class="input"
                       name="address_line2"
                       placeholder="Address line 2"
                       value="${escapeHtml(u.address_line2 || '')}">
                <input class="input"
                       name="address_line3"
                       placeholder="Address line 3"
                       value="${escapeHtml(u.address_line3 || '')}">
                <input class="input"
                       name="town_city"
                       placeholder="City / Town"
                       value="${escapeHtml(u.town_city || '')}">
                <input class="input"
                       name="county"
                       placeholder="County"
                       value="${escapeHtml(u.county || '')}">
                <div class="split">
                  <input class="input"
                         name="postcode"
                         placeholder="Postcode"
                         value="${escapeHtml(u.postcode || '')}">
                  <button type="button"
                          class="btn mini"
                          data-act="umbrella-postcode-lookup"
                          title="Lookup by postcode">
                    Lookup
                  </button>
                </div>
                <input class="input"
                       name="country"
                       placeholder="Country"
                       value="${escapeHtml(u.country || '')}">
              </div>
            </div>
          </div>

          ${select('vat_chargeable','VAT chargeable', (u.vat_chargeable ? 'Yes' : 'No'), ['Yes','No'])}
          ${select('enabled','Enabled', (u.enabled === false) ? 'No' : 'Yes', ['Yes','No'])}
        </div>
      `);
    },
    async ()=> {
      L('[onSave] begin', { dataId: window.modalCtx?.data?.id, forId: window.modalCtx?.formState?.__forId });

      const fs = window.modalCtx.formState || { __forId: null, main:{} };
      const sameRecord = (!!window.modalCtx.data?.id && fs.__forId === window.modalCtx.data.id) ||
                         (!window.modalCtx.data?.id && fs.__forId == null);

      const staged = sameRecord ? (fs.main || {}) : {};
      const live   = collectForm('#tab-main');
      const payload = { ...staged, ...live };

      L('[onSave] collected', { sameRecord, stagedKeys: Object.keys(staged||{}), liveKeys: Object.keys(live||{}) });

      if (typeof payload.vat_chargeable !== 'boolean') {
        payload.vat_chargeable = (payload.vat_chargeable === 'Yes' || payload.vat_chargeable === 'true');
      }
      if (typeof payload.enabled !== 'boolean') {
        payload.enabled = (payload.enabled === 'Yes' || payload.enabled === 'true');
      }

      for (const k of Object.keys(payload)) {
        if (payload[k] === '') delete payload[k];
      }

      const idForUpdate = window.modalCtx?.data?.id || full?.id || null;
      L('[onSave] upsertUmbrella', { idForUpdate, payloadKeys: Object.keys(payload||{}) });
      const saved = await upsertUmbrella(payload, idForUpdate).catch(err => { E('upsertUmbrella failed', err); return null; });
      const umbrellaId = idForUpdate || (saved && saved.id);
      L('[onSave] saved', { ok: !!saved, umbrellaId, savedKeys: Object.keys(saved||{}) });
      if (!umbrellaId) { alert('Failed to save umbrella'); return { ok:false }; }

      window.modalCtx.data      = { ...(window.modalCtx.data || {}), ...(saved || {}), id: umbrellaId };
      window.modalCtx.formState = { __forId: umbrellaId, main: {} };

      if (!seedId && umbrellaId) window.__pendingFocus = { section: 'umbrellas', id: umbrellaId };

      L('[onSave] final window.modalCtx', {
        dataId: window.modalCtx.data?.id,
        dataKeys: Object.keys(window.modalCtx.data||{})
      });

      return { ok: true, saved: window.modalCtx.data };
    },
    full?.id,
    // onReturn: (re)bind address + company number to model + postcode lookup
    () => {
      try {
        const container = document.getElementById('tab-main');
        if (!container) return;
        const model = buildUmbrellaDetailsModel(window.modalCtx?.data || {});
        window.modalCtx.umbrellaModel = model;
        bindUmbrellaAddressEvents(container, model);
      } catch (e) {
        W('bindUmbrellaAddressEvents failed', e);
      }
    }
  );

  // (Umbrella has no heavy post-paint preloads in your snippet; if you add any later,
  // keep them here, after showModal, and guard with token/id like in openClient.)
}


// ---- Audit (Outbox)
function openAuditItem(row){
  const body = html(`
    <div class="form">
      ${readonly('Type', row.type)}
      ${readonly('To', row.to)}
      ${readonly('Subject', row.subject)}
      ${readonly('Status', row.status)}
      <div class="row" style="grid-column:1/-1"><label>Last error</label><textarea readonly>${row.last_error || ''}</textarea></div>
    </div>
  `);
  showModal('Outbox', [{key:'v',label:'View'}], ()=>body, async ()=>{ closeModal(); }, row?.id);
  const act = byId('modalActions');
  const retry = document.createElement('button'); retry.textContent='Retry send';
  retry.onclick = async ()=>{ await retryOutbox(row.id); alert('Retry queued'); }
  act.insertBefore(retry, byId('btnSave'));
}

// ---- Settings (global defaults)

async function renderSettingsPanel(content) {
  // Settings are now managed in the Settings modal.
  // IMPORTANT: do NOT change the caller's container (prevents "Summary" being overwritten).

  try {
    // Avoid stacking multiple Settings modals if renderSettingsPanel is called repeatedly
    const fr = (typeof window.__getModalFrame === 'function') ? window.__getModalFrame() : null;
    const alreadyOpen = !!(fr && fr.entity === 'settings');
    if (!alreadyOpen) openSettings();
  } catch (e) {
    alert('Could not open settings');
  }

  return;
}



function renderContractAdditionalRatesTab(ctx) {
  const LOGC = (typeof window.__LOG_CONTRACTS === 'boolean') ? window.__LOG_CONTRACTS : false;

  const merged = mergeContractStateIntoRow(ctx?.data || {});
  const payMethod = String(merged?.pay_method_snapshot || 'PAYE').toUpperCase();
  const payLabel  = (payMethod === 'UMBRELLA') ? 'Pay (Umbrella)' : 'Pay (PAYE)';

  const extras = Array.isArray(merged.additional_rates_json)
    ? merged.additional_rates_json
    : [];

  const findSlot = (code) => extras.find(e => e && String(e.code || '').toUpperCase() === String(code).toUpperCase()) || null;
  const num = (v) => (v == null || v === '') ? '' : String(v);

  const freqOptions = [
    ['ONE_PER_WEEK',         'One per week'],
    ['ONE_PER_DAY',          'One per day'],
    ['WEEKENDS_AND_BH_ONLY', 'Weekends & Bank Holidays only'],
    ['WEEKDAYS_EXCL_BH_ONLY','Weekdays (excl Bank Holidays) only']
  ];

  const esc = (x) => String(x == null ? '' : x)
    .replace(/&/g,'&amp;')
    .replace(/</g,'&lt;')
    .replace(/>/g,'&gt;')
    .replace(/"/g,'&quot;')
    .replace(/'/g,'&#39;');

  const rowsHtml = [];
  for (let i = 1; i <= 5; i++) {
    const code = `EX${i}`;
    const cfg  = findSlot(code) || {};
    const bucketName = cfg.bucket_name || '';
    const unitName   = cfg.unit_name || '';
    const freq       = (cfg.frequency || 'ONE_PER_WEEK').toUpperCase();
    const payRate    = (cfg.pay_rate != null && Number.isFinite(Number(cfg.pay_rate))) ? Number(cfg.pay_rate) : null;
    const chargeRate = (cfg.charge_rate != null && Number.isFinite(Number(cfg.charge_rate))) ? Number(cfg.charge_rate) : null;

      let marginStr = '';
    if (payRate != null && chargeRate != null) {
      const fin = (window.modalCtx && window.modalCtx.finance && typeof window.modalCtx.finance === 'object')
        ? window.modalCtx.finance
        : null;

      const erniMult = (fin && typeof fin.erni_multiplier === 'number' && fin.erni_multiplier > 0)
        ? fin.erni_multiplier
        : (typeof window.__ERNI_MULT__ === 'number' && window.__ERNI_MULT__ > 0)
          ? window.__ERNI_MULT__
          : 1;

      const erniApplies = (fin && typeof fin.erni_applies === 'boolean')
        ? fin.erni_applies
        : (payMethod === 'PAYE');

      // Prefer server-provided per-unit margins (existing contract GET includes them)
      let serverMargin = null;
      try {
        const arr = (window.modalCtx && window.modalCtx.margins && Array.isArray(window.modalCtx.margins.additional_rates_margin_preview))
          ? window.modalCtx.margins.additional_rates_margin_preview
          : [];
        const found = arr.find(x => String(x?.code || '').toUpperCase() === String(code || '').toUpperCase()) || null;
        if (found && found.margin_per_unit != null) serverMargin = Number(found.margin_per_unit);
      } catch {}

      let mg;
      if (serverMargin != null && Number.isFinite(serverMargin)) {
        mg = serverMargin;
      } else {
        mg = chargeRate - (payMethod === 'PAYE' && erniApplies ? payRate * erniMult : payRate);
      }
      marginStr = mg.toFixed(2);
    }


    rowsHtml.push(`
      <div class="row extra-rate-row" data-slot="${esc(code)}">
        <label>Bucket ${i}</label>
        <div class="controls" style="display:flex;flex-direction:column;gap:4px">
          <div class="grid-6" style="min-width:0;gap:8px;align-items:flex-end;flex-wrap:wrap">
            <div class="split">
              <span class="mini">Bucket name</span>
              <input class="input" name="extra_bucket_name_${i}" value="${esc(bucketName)}" placeholder="e.g. Patient visits" />
            </div>
            <div class="split">
              <span class="mini">Unit name</span>
              <input class="input" name="extra_unit_name_${i}" value="${esc(unitName)}" placeholder="e.g. Number of visits" />
            </div>
            <div class="split">
              <span class="mini">Frequency</span>
              <select class="input" name="extra_frequency_${i}">
                ${freqOptions.map(([val,label]) => `
                  <option value="${val}" ${val === freq ? 'selected' : ''}>${esc(label)}</option>
                `).join('')}
              </select>
            </div>
            <div class="split">
              <span class="mini">${payLabel} (per unit)</span>
              <input class="input" type="number" step="0.01" min="0" name="extra_pay_${i}" value="${payRate != null ? esc(payRate.toFixed(2)) : ''}" placeholder="0.00" />
            </div>
            <div class="split">
              <span class="mini">Charge (per unit)</span>
              <input class="input" type="number" step="0.01" min="0" name="extra_charge_${i}" value="${chargeRate != null ? esc(chargeRate.toFixed(2)) : ''}" placeholder="0.00" />
            </div>
            <div class="split">
              <span class="mini">Margin / unit</span>
              <span class="mini" data-role="extra-margin" data-slot="${esc(code)}">${marginStr ? `Â£${esc(marginStr)}` : ''}</span>
            </div>
          </div>
          <div style="margin-top:4px">
            <button type="button"
                    class="btn mini"
                    data-extra-clear="${esc(code)}"
                    title="Clear bucket ${i}">
              Clear
            </button>
          </div>
        </div>
      </div>
    `);
  }

  const html = `
    <div class="tabc" id="contractAdditionalRatesTab">
      <div class="row">
        <label class="section">Additional Rates</label>
        <div class="controls">
          <div class="hint">
            Up to 5 optional additional pay buckets, billed by units (e.g. patient visits).<br/>
            Margins are per-unit and follow the PAYE/Umbrella logic used on the Rates tab.
          </div>
        </div>
      </div>
      <div class="group">
        ${rowsHtml.join('')}
      </div>
    </div>
  `;

  // Wire up margin recalculation + Clear buttons after DOM render
  setTimeout(() => {
    try {
      const root = document.getElementById('contractAdditionalRatesTab');
      if (!root) return;

        const getErniMult = () => {
        try {
          const fin = (window.modalCtx && window.modalCtx.finance && typeof window.modalCtx.finance === 'object')
            ? window.modalCtx.finance
            : null;
          if (fin && typeof fin.erni_multiplier === 'number' && fin.erni_multiplier > 0) {
            return fin.erni_multiplier;
          }
          if (typeof window.__ERNI_MULT__ === 'number' && window.__ERNI_MULT__ > 0) {
            return window.__ERNI_MULT__;
          }
        } catch {}
        return 1;
      };


      const getPayMethod = () => {
        try {
          const fs = (window.modalCtx && window.modalCtx.formState) || { main:{}, pay:{} };
          const staged = (fs.main && fs.main.pay_method_snapshot) || '';
          const sel = document.querySelector('select[name="pay_method_snapshot"], select[name="default_pay_method_snapshot"]');
          const v = (sel && sel.value) || staged || 'PAYE';
          return String(v).toUpperCase();
        } catch {
          return 'PAYE';
        }
      };

      const recalcMargins = () => {
        const pm = getPayMethod();
        const erniMult = getErniMult();
        for (let i = 1; i <= 5; i++) {
          const code = `EX${i}`;
          const payEl    = root.querySelector(`input[name="extra_pay_${i}"]`);
          const chargeEl = root.querySelector(`input[name="extra_charge_${i}"]`);
          const span     = root.querySelector(`span[data-role="extra-margin"][data-slot="${code}"]`);
          if (!span) continue;

          const payVal    = payEl ? Number(payEl.value || 0) : 0;
          const chargeVal = chargeEl ? Number(chargeEl.value || 0) : 0;

          if (!Number.isFinite(payVal) || !Number.isFinite(chargeVal) || (!payEl?.value && !chargeEl?.value)) {
            span.textContent = '';
            continue;
          }

          let mg;
          if (pm === 'PAYE') {
            mg = chargeVal - (payVal * erniMult);
          } else {
            mg = chargeVal - payVal;
          }
          span.textContent = `Â£${mg.toFixed(2)}`;
        }
      };

      // Wire Clear buttons
      root.querySelectorAll('button[data-extra-clear]').forEach(btn => {
        if (btn.__wiredClear) return;
        btn.__wiredClear = true;
        btn.addEventListener('click', () => {
          const slot = btn.getAttribute('data-extra-clear');
          const idx  = slot && slot.replace(/^EX/, '');
          if (!idx) return;
          ['bucket_name','unit_name','pay','charge'].forEach(suffix => {
            const name = suffix === 'bucket_name'
              ? `extra_bucket_name_${idx}`
              : suffix === 'unit_name'
                ? `extra_unit_name_${idx}`
                : suffix === 'pay'
                  ? `extra_pay_${idx}`
                  : `extra_charge_${idx}`;
            const el = root.querySelector(`[name="${name}"]`);
            if (el) {
              el.value = '';
              try { el.dispatchEvent(new Event('input', { bubbles:true })); } catch {}
              try { el.dispatchEvent(new Event('change',{ bubbles:true })); } catch {}
            }
          });
          const span = root.querySelector(`span[data-role="extra-margin"][data-slot="${slot}"]`);
          if (span) span.textContent = '';
          try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
        });
      });

      // Recalc margins on input changes
      const onChange = (ev) => {
        const t = ev.target;
        if (!t || !t.name) return;
        if (/^extra_(pay|charge)_\d+$/.test(t.name)) {
          recalcMargins();
          try { window.dispatchEvent(new Event('modal-dirty')); } catch {}
        }
      };
      root.addEventListener('input', onChange, true);
      root.addEventListener('change', onChange, true);

      recalcMargins();

      // Signal for any wiring that listens for this tab
      try {
        const ev = new CustomEvent('contracts-extras-rendered', { detail: {} });
        window.dispatchEvent(ev);
      } catch {
        window.dispatchEvent(new Event('contracts-extras-rendered'));
      }

      if (LOGC) console.log('[CONTRACTS] renderContractAdditionalRatesTab wired');
    } catch (e) {
      if (LOGC) console.warn('[CONTRACTS] extras tab wiring failed', e);
    }
  }, 0);

  return html;
}



// ===== Generic modal plumbing =====

// =============================== showModal (FIXED) ===============================
// ==== FIXED MODAL FRAMEWORK: close only on explicit success from onSave ====
// ==== CHILD MODAL (CANDIDATE RATE) â€” throw on errors; return true on success ====



// =============================== closeModal (kept) ===============================
// ================== FRONTEND: closeModal (UPDATED to refresh if pending focus) ==================
function closeModal(){
  if (!window.__modalStack || !window.__modalStack.length) {
    // nothing to close; ensure overlay hidden and geometry clean
    discardAllModalsAndState();
    return;
  }

  // Sanitize geometry before changing frames
  const m = byId('modal');
  if (m) {
    m.style.position = '';
    m.style.left = '';
    m.style.top = '';
    m.style.right = '';
    m.style.bottom = '';
    m.style.transform = '';
    m.classList.remove('dragging');
  }
  document.onmousemove = null;
  document.onmouseup   = null;

  const closing = window.__modalStack.pop();
  if (closing) {
    // Detach per-frame listeners
    if (closing._detachDirty)  { try { closing._detachDirty();  } catch(_) {} closing._detachDirty  = null; }
    if (closing._detachGlobal) { try { closing._detachGlobal(); } catch(_) {} closing._detachGlobal = null; }
  }

  if (window.__modalStack.length > 0) {
    const parent = window.__modalStack[window.__modalStack.length - 1];
    byId('modalBack').style.display = 'flex';

    // Rebuild tabs
    const tabsEl = byId('modalTabs'); tabsEl.innerHTML = '';
    (parent.tabs || []).forEach((t) => {
      const b = document.createElement('button');
      b.textContent = t.label;
      if (t.key === parent.currentTabKey) b.classList.add('active');
      b.onclick = () => {
        tabsEl.querySelectorAll('button').forEach(x => x.classList.remove('active'));
        b.classList.add('active');
        parent.setTab(t.key);
      };
      tabsEl.appendChild(b);
    });

    // Re-show parent current tab
    if (parent.currentTabKey) parent.setTab(parent.currentTabKey);
    else if (parent.tabs && parent.tabs[0]) parent.setTab(parent.tabs[0].key);
  } else {
    // last frame closed -> full teardown so nothing lingers
    discardAllModalsAndState();

    // If a pending focus token exists, refresh the summary now so it can jump & highlight
    if (window.__pendingFocus) {
      try { renderAll(); } catch (e) { console.error('refresh after modal close failed', e); }
    }
  }
}

// === Helpers for modal mode & interactivity ===
function _currentFrame() {
  const stk = window.__modalStack || [];
  return stk[stk.length - 1] || null;
}
function _parentFrame() {
  const stk = window.__modalStack || [];
  return stk.length >= 2 ? stk[stk.length - 2] : null;
}
function _setFormReadOnly(root, ro) {
  if (!root) return;
  root.querySelectorAll('input, select, textarea, button').forEach(el => {
    const isDisplayOnly = el.id === 'tms_ref_display' || el.id === 'cli_ref_display';
    if (el.type === 'button') {
      // Buttons are generally disabled only when parent is view/child not editable
      if (ro && !isDisplayOnly) el.disabled = true;
      else if (!isDisplayOnly) el.disabled = false;
      return;
    }
    if (isDisplayOnly) {
      el.setAttribute('disabled', 'true');
      el.setAttribute('readonly', 'true');
      return;
    }
    if (ro) { el.setAttribute('disabled','true'); el.setAttribute('readonly','true'); }
    else    { el.removeAttribute('disabled'); el.removeAttribute('readonly'); }
  });
}
function _setFrameMode(frame, mode) {
  // mode: 'create' | 'view' | 'edit' | 'saving'
  frame.mode = mode;
  // read-only if view or saving
  const readOnly = (mode === 'view' || mode === 'saving');
  _setFormReadOnly(byId('modalBody'), readOnly);
  // buttons update
  if (typeof frame._updateButtons === 'function') frame._updateButtons();
}


// ===== Small helpers (fixed attribute serialization + HTML escaping) =====
const html = (s)=> s;

const _esc = (v) => String(v)
  .replace(/&/g,'&amp;')
  .replace(/</g,'&lt;')
  .replace(/>/g,'&gt;')
  .replace(/"/g,'&quot;')
  .replace(/'/g,'&#39;');

const _attrStr = (extra) => {
  if (!extra) return '';
  if (typeof extra === 'string') {
    const t = extra.trim();
    return t ? (' ' + t) : '';
  }
  if (typeof extra !== 'object') return '';
  let out = '';
  for (const [k, v] of Object.entries(extra)) {
    if (v === false || v == null) continue;      // skip false/null/undefined
    if (v === true) { out += ` ${k}`; continue; } // boolean attribute
    out += ` ${k}="${_esc(v)}"`;                  // key="value"
  }
  return out;
};

const input = (name, label, val = '', type = 'text', extra = '') => {
  const attrs = _attrStr(extra);
  const value = (val == null ? '' : val);
  return `<div class="row"><label>${_esc(label)}</label><input name="${_esc(name)}" type="${_esc(type)}" value="${_esc(value)}"${attrs}/></div>`;
};

const select = (name, label, val, options = [], extra = {}) => {
  const attrs = _attrStr(extra);
  const opts = options.map(o => {
    const selected = String(o) === String(val) ? ' selected' : '';
    return `<option${selected}>${_esc(o)}</option>`;
  }).join('');
  return `<div class="row"><label>${_esc(label)}</label><select name="${_esc(name)}"${attrs}>${opts}</select></div>`;
};

const readonly = (label, value) =>
  `<div class="row"><label>${_esc(label)}</label><input value="${_esc(value ?? '')}" readonly/></div>`;


/**
 * Safer form collector:
 * - Skips elements with no name
 * - Skips disabled/readonly or data-no-collect
 * - Converts Yes/No selects to booleans
 */
function collectForm(sel, jsonTry=false){
  const root = document.querySelector(sel);
  if (!root) return {};

  const out = {};
  root.querySelectorAll('input,select,textarea').forEach(el=>{
    if (!el.name) return;
    if (el.disabled || el.readOnly || el.dataset.noCollect === 'true') return;

    const k = el.name;
    let v;

    if (el.type === 'checkbox') {
      v = el.checked ? 'on' : '';
    } else if (el.type === 'radio') {
      if (!el.checked) return;
      v = el.value;
    } else if (el.type === 'number') {
      v = (el.value === '' ? '' : Number(el.value));
    } else {
      v = el.value;
    }

    if (el.tagName === 'SELECT' && (v === 'Yes' || v === 'No')) v = (v === 'Yes');

    if (jsonTry && (k === 'bh_list' || k === 'margin_includes')) {
      try { v = JSON.parse(v || (k === 'bh_list' ? '[]' : '{}')); } catch {}
    }

    out[k] = v;
  });
  return out;
}


// ================= NEW: Job titles client-side cache ==================
window.__jobTitlesCache = window.__jobTitlesCache || {
  items: [],
  byId: {},
  roots: [],
  loadedAt: 0
};

function normaliseJobTitles(items) {
  const byId = {};
  const roots = [];
  (items || []).forEach((r) => {
    if (!r || !r.id) return;
    const copy = { ...r, children: [] };
    byId[r.id] = copy;
  });
  Object.values(byId).forEach((node) => {
    if (node.parent_id && byId[node.parent_id]) {
      byId[node.parent_id].children.push(node);
    } else {
      roots.push(node);
    }
  });
  return { items, byId, roots };
}

// =============== NEW: loadJobTitlesTree (backend â†’ cache) ===============
// =============== NEW: loadJobTitlesTree (backend â†’ cache) ===============
async function loadJobTitlesTree(force = false, activeOnly = true) {
  // Ensure cache shape
  window.__jobTitlesCache = window.__jobTitlesCache || {
    items: [],
    byId: {},
    roots: [],
    loadedAt: 0
  };
  const C = window.__jobTitlesCache;
  const now = Date.now();

  // Reuse cache only for activeOnly=true
  if (
    activeOnly &&
    !force &&
    C.items &&
    C.items.length &&
    now - C.loadedAt < 60_000
  ) {
    return C;
  }

  const url = API(`/api/job-titles?activeOnly=${activeOnly ? 'true' : 'false'}`);
  const res = await authFetch(url);
  if (!res.ok) {
    console.error('[JOB_TITLES] list failed', res.status);
    throw new Error('Failed to load job titles');
  }
  const data = (await res.json().catch(() => ({}))) || {};
  const items = data.items || [];
  const norm = normaliseJobTitles(items);

  // Only mutate global cache when weâ€™re in activeOnly mode
  if (activeOnly) {
    C.items = items;
    C.byId = norm.byId;
    C.roots = norm.roots;
    C.loadedAt = now;
    return C;
  }

  // For Settings (activeOnly=false) return a separate snapshot
  return {
    items,
    byId: norm.byId,
    roots: norm.roots,
    loadedAt: now
  };
}


// =============== NEW: buildJobTitlePathLabels ==========================
function buildJobTitlePathLabels(jobTitleId) {
  const C = window.__jobTitlesCache || {};
  const byId = C.byId || {};
  const chain = [];
  let cur = byId[jobTitleId];
  while (cur && chain.length < 16) {
    chain.push(cur.label || '');
    cur = cur.parent_id ? byId[cur.parent_id] : null;
  }
  return chain.reverse().filter(Boolean);
}

// =============== NEW: Job titles API helpers ===========================
async function apiCreateJobTitle(payload) {
  const url = API('/api/job-titles');
  const res = await authFetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload || {})
  });
  if (!res.ok) throw new Error('Failed to create job title');
  const data = (await res.json().catch(() => ({}))) || {};
  return data.item || null;
}

async function apiUpdateJobTitle(id, patch) {
  const url = API(`/api/job-titles/${encodeURIComponent(id)}`);
  const res = await authFetch(url, {
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(patch || {})
  });
  if (!res.ok) throw new Error('Failed to update job title');
  const data = (await res.json().catch(() => ({}))) || {};
  return data.item || null;
}

async function apiDeleteJson(urlPath, bodyObj) {
  const res = await authFetch(API(urlPath), {
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(bodyObj || {})
  });

  const text = await res.text().catch(() => '');
  let json = null;
  try { json = text ? JSON.parse(text) : null; } catch { json = null; }

  if (!res.ok) {
    const err = new Error((json && json.error) ? String(json.error) : (text || `Request failed (${res.status})`));
    err.status = res.status;
    err.json = json;
    err.body = text;
    throw err;
  }

  return (json != null ? json : {});
}


async function apiDeleteJobTitle(id) {
  const url = API(`/api/job-titles/${encodeURIComponent(id)}`);
  const res = await authFetch(url, { method: 'DELETE' });
  if (!res.ok) throw new Error('Failed to delete job title');
  const data = (await res.json().catch(() => ({}))) || {};
  return data;
}

function openJobTitleSettingsModal() {
  const S = {
    loading: false,
    error: '',
    items: [],
    byId: {},
    roots: [],
    selectedId: null,
    editing: null, // { id|null, parent_id|null, label, is_role, requires_prof_reg, prof_reg_type, active, isNew }
    collapsed: {}  // { [id]: true } for collapsed nodes
  };

  const profTypes = ['NMC', 'GMC', 'HCPC'];

  const makeEditingFromNode = (node) => {
    if (!node) return null;
    return {
      id: node.id,
      parent_id: node.parent_id || null,
      label: node.label || '',
      is_role: !!node.is_role,
      requires_prof_reg: !!node.requires_prof_reg,
      prof_reg_type: node.prof_reg_type || '',
      active: node.active !== false,
      isNew: false
    };
  };

  const makeEditingNew = (parentId) => ({
    id: null,
    parent_id: parentId || null,
    label: '',
    is_role: false, // default to Category
    requires_prof_reg: false,
    prof_reg_type: '',
    active: true,
    isNew: true
  });

  const renderTree = (nodes, level) => {
    if (!nodes || !nodes.length) return '';
    const pad = level * 16;
    return nodes
      .map((n) => {
        const isSelected =
          S.selectedId === n.id || (!S.selectedId && S.editing && S.editing.id === n.id);
        const kindLabel = n.is_role ? 'Role' : 'Category';
        const regBadge =
          n.is_role && n.requires_prof_reg
            ? `<span class="pill mini" style="margin-left:4px">${n.prof_reg_type || 'Reg'}</span>`
            : '';
        const inactiveTag =
          n.active === false
            ? `<span class="mini" style="margin-left:4px;opacity:.7">(inactive)</span>`
            : '';

        const hasChildren = Array.isArray(n.children) && n.children.length > 0;
        const isCollapsed = !!S.collapsed[n.id];

        const toggleHtml = hasChildren
          ? `<button type="button" class="btn mini" data-act="toggle" data-id="${n.id}" style="margin-right:4px;width:24px;text-align:center;padding:2px 0">${isCollapsed ? '+' : 'âˆ’'}</button>`
          : `<span style="display:inline-block;width:24px"></span>`;

        const childrenHtml = !isCollapsed ? renderTree(n.children || [], level + 1) : '';

        return `
          <div class="jt-node${isSelected ? ' jt-node-active' : ''}" data-id="${n.id}"
               style="padding:4px 6px 4px ${pad + 6}px;cursor:pointer;border-radius:6px;">
            <div style="display:flex;align-items:center;justify-content:space-between;gap:6px">
              <div style="display:flex;align-items:center;gap:4px">
                ${toggleHtml}
                <span class="jt-label" style="font-weight:600">${escapeHtml(n.label || '')}</span>
                <span class="mini" style="margin-left:6px;opacity:.75">${kindLabel}</span>
                ${regBadge}
                ${inactiveTag}
              </div>
              <div class="mini">
                <button type="button" class="btn mini" data-act="add-child" data-id="${n.id}">+ Child</button>
              </div>
            </div>
          </div>
          ${childrenHtml}
        `;
      })
      .join('');
  };

  const renderDetailsPanel = () => {
    const e = S.editing;
    if (!e) {
      return `
        <div class="hint" style="padding:8px">
          Select a node on the left, or click <strong>Add family</strong> to create a new top-level group.
        </div>
      `;
    }

    const node = e.id ? S.byId[e.id] : null;

    const hasRoleDescendants = (n) => {
      if (!n || !Array.isArray(n.children)) return false;
      const stack = [...n.children];
      let guard = 0;
      while (stack.length && guard++ < 1024) {
        const cur = stack.pop();
        if (!cur) continue;
        if (cur.is_role) return true;
        if (Array.isArray(cur.children) && cur.children.length) {
          stack.push(...cur.children);
        }
      }
      return false;
    };

    const depth = node ? (Number(node.depth) || 0) : (e.parent_id ? 1 : 0);
    const hasRoleDesc = node && hasRoleDescendants(node);

    // Determine title based on type + depth
    let title;
    if (e.isNew) {
      if (!e.parent_id) {
        title = 'New Family';
      } else if (!e.is_role) {
        title = 'New Sub Family';
      } else {
        title = 'New Role';
      }
    } else {
      if (e.is_role) {
        title = 'Edit Job Title';
      } else if (depth > 0 || e.parent_id) {
        title = 'Edit Sub Family Name';
      } else {
        title = 'Edit Family Name';
      }
    }

    // Category Type radios
    const nodeTypeGroupChecked = !e.is_role ? 'checked' : '';
    const nodeTypeRoleChecked = e.is_role ? 'checked' : '';

    // Show Role radio?
    let showRoleRadio = true;
    if (e.isNew && !e.parent_id) {
      // Add Family â†’ cannot create a Role at top level
      showRoleRadio = false;
    } else if (!e.isNew && !e.is_role && hasRoleDesc) {
      // Existing Family/Subfamily with descendant Roles â†’ cannot switch to Role
      showRoleRadio = false;
    }

    const requiresChecked = !!(e.is_role && e.requires_prof_reg);
    const regBlockStyle = e.is_role ? '' : 'display:none';

    // Parent path using local state (families > subfamilies)
    const parentPath = (() => {
      if (!e.parent_id) return '(top-level family)';
      const chain = [];
      let cur = S.byId[e.parent_id];
      let guard = 0;
      while (cur && guard++ < 16) {
        chain.push(cur.label || '');
        cur = cur.parent_id ? S.byId[cur.parent_id] : null;
      }
      return chain.length ? chain.reverse().join(' > ') : '(no parent)';
    })();

    const regOptions = profTypes
      .map((t) => `<option value="${t}" ${e.prof_reg_type === t ? 'selected' : ''}>${t}</option>`)
      .join('');

    const activeChecked = e.active ? 'checked' : '';

    return `
      <form id="jt_details_form" class="form" autocomplete="off">
        <div class="row" style="grid-column:1/-1">
          <div class="mini" style="opacity:.85">${title}</div>
        </div>

        <div class="row">
          <label>Label</label>
          <div class="controls">
            <input type="text" name="label" value="${escapeHtml(e.label || '')}" required />
            <div id="jt_cat_vis_row" style="margin-top:6px;display:flex;gap:12px;align-items:center;flex-wrap:wrap">
              <label class="inline">
                <input type="radio" name="node_type" value="group" ${nodeTypeGroupChecked} />
                <span>Category</span>
              </label>
              ${
                showRoleRadio
                  ? `
              <label class="inline">
                <input type="radio" name="node_type" value="role" ${nodeTypeRoleChecked} />
                <span>Role</span>
              </label>`
                  : ''
              }
              <label class="inline">
                <input type="checkbox" name="active" ${activeChecked} />
                <span>Visible to users</span>
              </label>
            </div>
          </div>
        </div>

        <div class="row">
          <label>Parent</label>
          <div class="mini" style="padding:6px 8px;border-radius:8px;background:#020617;border:1px solid var(--line)">
            ${escapeHtml(parentPath)}
          </div>
        </div>

        <div class="row" data-block="reg" style="${regBlockStyle}">
          <label class="inline">
            <input type="checkbox" name="requires_prof_reg" ${requiresChecked ? 'checked' : ''} />
            <span>Requires professional registration</span>
          </label>
          <select name="prof_reg_type" style="margin-top:6px;${requiresChecked ? '' : 'display:none'}">
            <option value="">-- Select type --</option>
            ${regOptions}
          </select>
        </div>

        <div class="row" style="grid-column:1/-1;margin-top:8px;display:flex;flex-direction:row;align-items:center;gap:6px;justify-content:flex-end">
          <button type="button" class="btn mini" style="padding:4px 8px" id="jt_btn_delete" ${(e.isNew || (node && Array.isArray(node.children) && node.children.length)) ? 'disabled' : ''}>Delete</button>
          <button type="button" class="btn mini primary" style="padding:4px 10px" id="jt_btn_save">Save</button>
        </div>
      </form>
    `;
  };

  const buildBody = () => {
    if (S.loading) {
      return html(`
        <div id="jobTitlesSettingsRoot" style="padding:10px">
          <div class="hint">Loading job titlesâ€¦</div>
        </div>
      `);
    }

    const treeHtml = renderTree(S.roots || [], 0);

    return html(`
      <div id="jobTitlesSettingsRoot" style="display:grid;grid-template-columns:minmax(0,1.4fr) minmax(0,1.8fr);gap:12px;min-height:260px">
        <div>
          <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:6px">
            <div class="mini">Families / subfamilies / roles</div>
            <button type="button" class="btn mini" id="jt_add_root">+ Add family</button>
          </div>
          <div id="jt_tree"
               style="border:1px solid var(--line);border-radius:10px;max-height:420px;overflow:auto;padding:4px">
            ${
              treeHtml ||
              '<div class="hint" style="padding:8px">No job titles defined yet. Click <strong>Add family</strong> to create your first group.</div>'
            }
          </div>
          ${S.error ? `<div class="error" style="margin-top:8px">${escapeHtml(S.error)}</div>` : ''}
        </div>

        <div style="border:1px solid var(--line);border-radius:10px;padding:8px;min-height:240px">
          ${renderDetailsPanel()}
        </div>
      </div>
    `);
  };

  const repaint = () => {
    const bodyEl = document.getElementById('modalBody');
    if (!bodyEl) return;
    bodyEl.innerHTML = buildBody();
    wireEvents();
  };

  const showRoleUsageInCandidates = async (candidateIds) => {
    if (!Array.isArray(candidateIds) || !candidateIds.length) {
      alert('This job title is in use, but no candidate IDs were returned.');
      return;
    }
    const ok = window.confirm(
      `This role is assigned to ${candidateIds.length} candidates. Show them in the Candidates list?`
    );
    if (!ok) return;

    try {
      // Switch to Candidates section and filter by ids
      window.currentSection = 'candidates';
      window.__listState = window.__listState || {};
      const st = (window.__listState.candidates ||= {
        page: 1,
        pageSize: 50,
        total: null,
        hasMore: false,
        filters: null,
        sort: { key: null, dir: 'asc' }
      });
      st.page = 1;
      st.filters = { ...(st.filters || {}), ids: candidateIds };

      const rows = await search('candidates', st.filters);
      renderSummary(rows);

      // Close the Job Titles modal if it's open
      const btnClose = document.getElementById('btnCloseModal');
      if (btnClose) btnClose.click();
    } catch (e) {
      console.error('Failed to show candidates for job title', e);
      alert('Failed to open Candidates list for this role.');
    }
  };

  const refreshFromCache = async () => {
    S.loading = true;
    S.error = '';
    repaint();
    try {
      // Load ALL titles (including inactive) for Settings
      const cache = await loadJobTitlesTree(true, false);
      S.items = cache.items;
      S.byId = cache.byId;
      S.roots = cache.roots;

      // Seed collapsed state: collapse all non-role nodes that have children
      S.collapsed = {};
      const seedCollapsed = (nodes) => {
        if (!Array.isArray(nodes)) return;
        for (const n of nodes) {
          if (!n) continue;
          if (!n.is_role && Array.isArray(n.children) && n.children.length > 0) {
            S.collapsed[n.id] = true;
            seedCollapsed(n.children);
          }
        }
      };
      seedCollapsed(S.roots);

      // If nothing is selected, pick the first root if any
      if (!S.selectedId && S.roots.length) {
        S.selectedId = S.roots[0].id;
      }
      if (S.selectedId && S.byId[S.selectedId]) {
        S.editing = makeEditingFromNode(S.byId[S.selectedId]);
      } else {
        S.editing = null;
      }
    } catch (e) {
      console.error('[JOB_TITLES] load failed', e);
      S.error = 'Failed to load job titles';
    } finally {
      S.loading = false;
      repaint();
    }
  };

  const wireEvents = () => {
    const root = document.getElementById('jobTitlesSettingsRoot');
    if (!root) return;

    const treeBox = root.querySelector('#jt_tree');
    const addRootBtn = root.querySelector('#jt_add_root');
    const form = root.querySelector('#jt_details_form');
    const saveBtn = root.querySelector('#jt_btn_save');
    const deleteBtn = root.querySelector('#jt_btn_delete');

    if (addRootBtn) {
      addRootBtn.onclick = () => {
        S.selectedId = null;
        S.editing = makeEditingNew(null);
        repaint();
      };
    }

    if (treeBox) {
      treeBox.onclick = (e) => {
        const btn = e.target.closest('button[data-act]');
        if (btn) {
          const act = btn.getAttribute('data-act');
          const id = btn.getAttribute('data-id');
          const node = S.byId[id];
          if (!node) return;

          if (act === 'add-child') {
            S.selectedId = null;
            S.editing = makeEditingNew(node.id);
            repaint();
          } else if (act === 'toggle') {
            S.collapsed[id] = !S.collapsed[id];
            repaint();
          }
          return;
        }

        const nodeEl = e.target.closest('.jt-node[data-id]');
        if (!nodeEl) return;
        const id = nodeEl.getAttribute('data-id');
        const n = S.byId[id];
        if (!n) return;
        S.selectedId = id;
        S.editing = makeEditingFromNode(n);
        repaint();
      };
    }

    if (form && saveBtn) {
      saveBtn.onclick = async () => {
        const v = collectForm('#jt_details_form', false) || {};
        const label = (v.label || '').trim();
        if (!label) {
          alert('Label is required');
          return;
        }

        const nodeType = v.node_type === 'role' ? 'role' : 'group';
        const isRole = nodeType === 'role';

        const requiresProfReg = isRole && v.requires_prof_reg === 'on';
        const profRegType = requiresProfReg ? (v.prof_reg_type || '').trim().toUpperCase() : null;
        const active = v.active === 'on';

        if (requiresProfReg && !profRegType) {
          alert('Please choose a professional registration type (NMC / GMC / HCPC)');
          return;
        }

        const isNew = !S.editing || !S.editing.id;
        const parentId = S.editing ? S.editing.parent_id || null : null;

        try {
          let node;
          if (isNew) {
            node = await apiCreateJobTitle({
              label,
              parent_id: parentId,
              is_role: isRole,
              requires_prof_reg: requiresProfReg,
              prof_reg_type: profRegType,
              active
            });
          } else {
            node = await apiUpdateJobTitle(S.editing.id, {
              label,
              is_role: isRole,
              requires_prof_reg: requiresProfReg,
              prof_reg_type: profRegType,
              active
            });
          }

          // If backend signals that the role is in use, offer to show candidates
          if (node && node.error === 'JOB_TITLE_IN_USE' && Array.isArray(node.candidate_ids)) {
            await showRoleUsageInCandidates(node.candidate_ids);
            return;
          }

          // Refresh cache & select this node
          await refreshFromCache();
          if (node && node.id) {
            S.selectedId = node.id;
            S.editing = makeEditingFromNode(node);
            repaint();
          }
        } catch (err) {
          console.error('job title save failed', err);
          alert('Failed to save job title');
        }
      };
    }

    if (form && deleteBtn && !deleteBtn.disabled) {
      deleteBtn.onclick = async () => {
        if (!S.editing || !S.editing.id) return;
        const node = S.byId[S.editing.id];
        if (!node) return;

        if (!window.confirm(`Delete "${node.label}"?`)) return;

        try {
          const res = await apiDeleteJobTitle(node.id);

          // If backend says job title is in use, offer to show candidates
          if (res && res.error === 'JOB_TITLE_IN_USE' && Array.isArray(res.candidate_ids)) {
            await showRoleUsageInCandidates(res.candidate_ids);
            return;
          }

          await refreshFromCache();
        } catch (err) {
          console.error('job title delete failed', err);
          alert('Failed to delete job title â€“ it may still be in use.');
        }
      };
    }

    // Category Type + registration block behaviour
    if (form) {
      const nodeTypeInputs = form.querySelectorAll('input[name="node_type"]');
      const regBlock = form.querySelector('[data-block="reg"]');
      const reqCb = form.querySelector('input[name="requires_prof_reg"]');
      const regSelect = form.querySelector('select[name="prof_reg_type"]');

      nodeTypeInputs.forEach((el) => {
        el.onchange = () => {
          const v = collectForm('#jt_details_form', false) || {};
          const isRole = v.node_type === 'role';
          if (regBlock) {
            regBlock.style.display = isRole ? '' : 'none';
          }
        };
      });

      if (reqCb && regSelect) {
        reqCb.onchange = () => {
          if (reqCb.checked) {
            regSelect.style.display = '';
          } else {
            regSelect.style.display = 'none';
            regSelect.value = '';
          }
        };
      }
    }
  };

  showModal(
    'Job Titles',
    [{ key: 'main', label: 'Job Titles' }],
    () => buildBody(),
    async () => ({ ok: true }), // All job title actions are immediate
    false,
    async () => {
      await refreshFromCache();
    },
    { kind: 'job-titles', noParentGate: false }
  );

  // Initial load after modal is mounted
  refreshFromCache().catch((e) => console.error('[JOB_TITLES] initial refresh failed', e));
}


// =============== NEW: Job Titles Settings modal (side panel) ===========
// =============== NEW: Job Titles Settings modal (side panel) ===========


function openJobTitlePickerModal(initialJobTitleId, onSelect) {
  const C = window.__jobTitlesCache || {};
  const roots = C.roots || [];
  const byId = C.byId || {};

  let selectedId = initialJobTitleId || null;
  const collapsedById = {};

  // Initial state: collapse all non-role nodes that have children
  const seedCollapsed = (nodes) => {
    if (!Array.isArray(nodes)) return;
    for (const n of nodes) {
      if (!n) continue;
      if (!n.is_role && Array.isArray(n.children) && n.children.length > 0) {
        collapsedById[n.id] = true;
        seedCollapsed(n.children);
      }
    }
  };
  seedCollapsed(roots);

  const renderOptions = (nodes, depth) => {
    if (!nodes || !nodes.length) return '';
    const pad = depth * 16;
    return nodes
      .map((n) => {
        const isRole = !!n.is_role;
        const isSelected = n.id === selectedId;
        const hasChildren = Array.isArray(n.children) && n.children.length > 0;
        const isCollapsed = !!collapsedById[n.id];

        const label = n.label || '';
        const regBadge =
          isRole && n.requires_prof_reg
            ? `<span class="pill mini" style="margin-left:4px">${n.prof_reg_type || 'Reg'}</span>`
            : '';
        const kind = isRole ? 'Role' : 'Group';

        const toggleHtml = hasChildren
          ? `<span class="mini" style="margin-right:4px">${isCollapsed ? '+' : 'âˆ’'}</span>`
          : `<span style="display:inline-block;width:10px"></span>`;

        const childrenHtml =
          hasChildren && !isCollapsed ? renderOptions(n.children || [], depth + 1) : '';

        return `
          <div data-id="${n.id}"
               class="jt-pick-row${isSelected ? ' active' : ''}"
               style="padding:4px 8px;margin-left:${pad}px;cursor:pointer;display:flex;justify-content:space-between;align-items:center;border-radius:6px;">
            <div>
              ${toggleHtml}
              <strong>${escapeHtml(label)}</strong>
              <span class="mini" style="margin-left:6px;opacity:.7">${kind}</span>
            </div>
            <div>${regBadge}</div>
          </div>
          ${childrenHtml}
        `;
      })
      .join('');
  };

  const buildBody = () => {
    const node = selectedId ? byId[selectedId] : null;
    const pathLabels = node ? buildJobTitlePathLabels(selectedId) : [];

    const selectionSummary = (() => {
      if (!node) {
        return '<div class="mini">Nothing selected. Choose a <strong>Role</strong> from the left.</div>';
      }
      const isRole = !!node.is_role;
      if (!isRole) {
        return `
          <div class="mini">
            <div><strong>${escapeHtml(pathLabels.join(' > '))}</strong></div>
            <div style="margin-top:4px;color:#f97316">
              This is a <strong>Group</strong>. Please expand it and select a <strong>Role</strong> underneath.
            </div>
          </div>
        `;
      }
      const regBit = node.requires_prof_reg
        ? `Professional registration: ${node.prof_reg_type || ''} (number captured on candidate)`
        : 'No professional registration required for this role.';
      return `
        <div class="mini">
          <div><strong>${escapeHtml(pathLabels.join(' > '))}</strong></div>
          <div style="margin-top:4px">${escapeHtml(regBit)}</div>
        </div>
      `;
    })();

    return html(`
      <div id="jobTitlePickerRoot">
        <div class="hint" style="margin-bottom:8px">
          Choose <strong>Family â†’ Subfamily â†’ Role</strong>. Only <strong>Roles</strong> can be assigned to candidates.
        </div>

        <div style="display:grid;grid-template-columns:minmax(0,2fr) minmax(0,1.2fr);gap:10px;align-items:stretch">
          <div id="jtPickerTree"
               style="border:1px solid var(--line);border-radius:10px;max-height:360px;overflow:auto">
            ${
              renderOptions(roots, 0) ||
              '<div class="hint" style="padding:8px">No job titles defined yet. Add families and roles in Settings â†’ Job Titles.</div>'
            }
          </div>
          <div style="border:1px solid var(--line);border-radius:10px;padding:8px;font-size:12px">
            <div style="font-weight:600;margin-bottom:4px">Selection</div>
            ${selectionSummary}
          </div>
        </div>
      </div>
    `);
  };

  const wireEvents = () => {
    const root = document.getElementById('jobTitlePickerRoot');
    if (!root) return;

    const tree = root.querySelector('#jtPickerTree');
    if (!tree || tree.__jtWired) return;
    tree.__jtWired = true;

    tree.onclick = (e) => {
      const row = e.target.closest('.jt-pick-row[data-id]');
      if (!row) return;
      const id = row.getAttribute('data-id');
      const node = byId[id];
      if (!node) return;

      if (!node.is_role) {
        // Group / Family / Subfamily â€“ treat click as toggle expand/collapse
        const hasChildren = Array.isArray(node.children) && node.children.length > 0;
        if (!hasChildren) return;
        collapsedById[id] = !collapsedById[id];

        const bodyEl = document.getElementById('modalBody');
        if (!bodyEl) return;
        bodyEl.innerHTML = buildBody();
        const newRoot = document.getElementById('jobTitlePickerRoot');
        const newTree = newRoot && newRoot.querySelector('#jtPickerTree');
        if (newTree) newTree.__jtWired = false;
        wireEvents();
        return;
      }

      // Role â€“ select
      selectedId = id;
      const bodyEl = document.getElementById('modalBody');
      if (!bodyEl) return;
      bodyEl.innerHTML = buildBody();
      const newRoot = document.getElementById('jobTitlePickerRoot');
      const newTree = newRoot && newRoot.querySelector('#jtPickerTree');
      if (newTree) newTree.__jtWired = false;
      wireEvents();
    };
  };

  showModal(
    'Select Job Title',
    [{ key: 'main', label: 'Job Title' }],
    () => buildBody(),
    async () => {
      const node = byId[selectedId];
      if (!node) {
        alert('Please select a job title first.');
        return { ok: false };
      }
      if (!node.is_role) {
        alert('Please select a Role (not just a Group/Category).');
        return { ok: false };
      }
      const pathLabels = buildJobTitlePathLabels(selectedId);
      if (typeof onSelect === 'function') {
        await onSelect({
          jobTitleId: selectedId,
          pathLabels,
          requiresProfReg: !!node.requires_prof_reg,
          profRegType: node.prof_reg_type || null
        });
      }
      return { ok: true };
    },
    false,
    () => {},
    { kind: 'job-title-picker', noParentGate: false }
  );

  // Wire events on initial open
  wireEvents();
}



// =============== NEW: Candidate Job Title picker =======================

// =============== NEW: applySelectedJobTitleToCandidate =================
function applySelectedJobTitleToCandidate(candidateModel, selection) {
  if (!candidateModel || !selection) return;
  candidateModel.job_title_id = selection.jobTitleId;
  candidateModel.job_title_path_display = (selection.pathLabels || []).join(' > ');
  candidateModel.prof_reg_type = selection.profRegType || null;

  if (!selection.requiresProfReg) {
    candidateModel.prof_reg_number = '';
  }
}

// =============== NEW: buildCandidateMainDetailsModel ===================
function buildCandidateMainDetailsModel(row) {
  const r = row || {};
  const model = {
    id: r.id || null,

    // Personal identifiers
    ni_number: r.ni_number || '',
    date_of_birth: r.date_of_birth || null, // ISO date string (YYYY-MM-DD)
    gender: r.gender || '',

    // Registration
    prof_reg_type: r.prof_reg_type || null,
    prof_reg_number: r.prof_reg_number || '',

    // Address
    address_line1: r.address_line1 || '',
    address_line2: r.address_line2 || '',
    address_line3: r.address_line3 || '',
    town_city: r.town_city || '',
    county: r.county || '',
    postcode: r.postcode || '',
    country: r.country || ''
  };

  // Multi job titles from backend (candidate_job_titles)
  // shape: [{ job_title_id, is_primary }, ...]
  let jobs = Array.isArray(r.job_titles)
    ? r.job_titles
        .map((jt) => ({
          job_title_id: jt.job_title_id,
          is_primary: !!jt.is_primary
        }))
        .filter((t) => t.job_title_id)
    : [];

  // Normalise:
  // - if none is primary, make the first primary
  // - if multiple are primary, keep the first as primary and clear the rest
  // - always move the primary to index 0
  if (jobs.length) {
    let primaryIdx = jobs.findIndex((t) => t.is_primary);
    if (primaryIdx === -1) {
      primaryIdx = 0;
    }

    jobs = jobs.map((t, idx) => ({
      ...t,
      is_primary: idx === primaryIdx
    }));

    if (primaryIdx !== 0) {
      const primary = jobs[primaryIdx];
      jobs.splice(primaryIdx, 1);
      jobs.unshift(primary);
    }
  }

  model.job_titles = jobs;
  return model;
}

// =============== NEW: bindCandidateMainFormEvents ======================
// =============== NEW: bindCandidateMainFormEvents ======================

function bindCandidateMainFormEvents(container, model) {
  if (!container || !model) return;

  const q = (sel) => container.querySelector(sel);

  const bind = (selector, key) => {
    const el = q(selector);
    if (!el) return;
    el.value = model[key] || '';
    el.addEventListener('input', () => {
      model[key] = el.value;
    });
  };

  // Small helper to mark current candidate frame dirty
  const markDirty = () => {
    try {
      const fr = window.__getModalFrame?.();
      if (fr && (fr.mode === 'edit' || fr.mode === 'create')) {
        fr.isDirty = true;
        fr._updateButtons?.();
      }
      window.dispatchEvent(new Event('modal-dirty'));
    } catch {}
  };

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ NHSP / HR aliases (hr_name_mappings) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  try {
    const aliasRow    = q('#cand-alias-select-row');
    const aliasSelect = q('#cand-alias-select');
    const aliasEmpty  = q('#cand-alias-empty');

    if (aliasRow && aliasSelect && aliasEmpty) {
      const state = (window.modalCtx && window.modalCtx.hrAliasState) || {
        existing: [],
        stagedDeletes: [],
        selectedId: null
      };

      // Normalise state structure in case it came through a snapshot
      if (!Array.isArray(state.existing))      state.existing      = [];
      if (!Array.isArray(state.stagedDeletes)) state.stagedDeletes = [];
      if (!window.modalCtx.hrAliasState) {
        window.modalCtx.hrAliasState = state;
      }

      const renderAliases = () => {
        const stagedSet = new Set(state.stagedDeletes.map(String));
        const visible   = state.existing.filter(a => a && !stagedSet.has(String(a.id)));

        aliasSelect.innerHTML = '';

        if (!visible.length) {
          aliasRow.style.display   = 'none';
          aliasEmpty.style.display = '';
          state.selectedId         = null;
          return;
        }

        visible.forEach((a) => {
          const opt = document.createElement('option');
          const pieces = [];
          if (a.hr_name_norm) pieces.push(String(a.hr_name_norm));
          if (a.hospital_or_trust) pieces.push(`@ ${a.hospital_or_trust}`);
          opt.value = String(a.id);
          opt.textContent = pieces.join(' ') || String(a.id);
          aliasSelect.appendChild(opt);
        });

        // Choose a sensible selectedId if current is gone
        let currentId = state.selectedId && !stagedSet.has(String(state.selectedId))
          ? String(state.selectedId)
          : (visible[0] && String(visible[0].id)) || '';

        aliasSelect.value = currentId;
        state.selectedId  = currentId || null;

        aliasRow.style.display   = '';
        aliasEmpty.style.display = 'none';
      };

      renderAliases();

      if (!aliasSelect.__wired) {
        aliasSelect.__wired = true;
        aliasSelect.addEventListener('change', () => {
          state.selectedId = aliasSelect.value || null;
          markDirty();
        });
      }

      const delBtn = q('[data-act="delete-cand-alias"]');
      if (delBtn) {
        // Visibility controller: only show the Remove mapping button in edit/create
        const updateAliasDeleteVisibility = () => {
          try {
            const stack = (window.__modalStack || []);
            const fr    = stack[stack.length - 1] || null;
            const mode  = fr ? fr.mode : 'view';
            delBtn.style.display = (mode === 'edit' || mode === 'create') ? '' : 'none';
          } catch {
            // If anything goes wrong, fall back to hiding in view mode conservatively
            delBtn.style.display = 'none';
          }
        };

        // Run once on init
        updateAliasDeleteVisibility();

        if (!delBtn.__visWired) {
          delBtn.__visWired = true;
          // Re-run whenever the frame mode changes
          window.addEventListener('modal-frame-mode-changed', updateAliasDeleteVisibility);
        }

        if (!delBtn.__wired) {
          delBtn.__wired = true;
          delBtn.addEventListener('click', () => {
            const id = state.selectedId && String(state.selectedId);
            if (!id) return;

            if (!state.stagedDeletes.map(String).includes(id)) {
              state.stagedDeletes.push(id);
            }

            renderAliases();
            markDirty();
          });
        }
      }
    }
  } catch (e) {
    console.warn('[CAND][MAIN] alias wiring failed', e);
  }

  // Normalise job_titles:
  // - drop any entries without job_title_id
  // - if none primary, first becomes primary
  // - if multiple primaries, only first stays primary
  // - primary always moved to index 0
  const normaliseJobTitles = () => {
    let items = Array.isArray(model.job_titles) ? model.job_titles.slice() : [];
    items = items.filter((t) => t && t.job_title_id);

    if (!items.length) {
      model.job_titles = [];
      return;
    }

    let primaryIdx = items.findIndex((t) => t.is_primary);
    if (primaryIdx === -1) {
      primaryIdx = 0;
    }

    items = items.map((t, idx) => ({
      ...t,
      is_primary: idx === primaryIdx
    }));

    if (primaryIdx !== 0) {
      const primary = items[primaryIdx];
      items.splice(primaryIdx, 1);
      items.unshift(primary);
    }

    model.job_titles = items;
  };

  // NI
  bind('input[name="ni_number"]', 'ni_number');

  // DOB (model holds ISO)
  const dobEl = q('input[name="date_of_birth"]');
  if (dobEl) {
    dobEl.value = model.date_of_birth
      ? (typeof formatIsoToUk === 'function' ? formatIsoToUk(model.date_of_birth) : model.date_of_birth)
      : '';
    dobEl.addEventListener('change', () => {
      const v = dobEl.value.trim();
      if (!v) {
        model.date_of_birth = null;
        markDirty();
        return;
      }
      if (typeof parseUkDateToIso === 'function') {
        const iso = parseUkDateToIso(v);
        model.date_of_birth = iso || null;
      } else {
        model.date_of_birth = v;
      }
      markDirty();
    });

    if (typeof attachUkDatePicker === 'function') {
      attachUkDatePicker(dobEl);
    }
  }

  // Gender
  const genderEl = q('select[name="gender"]');
  if (genderEl) {
    genderEl.value = model.gender || '';
    genderEl.addEventListener('change', () => {
      model.gender = genderEl.value || '';
      markDirty();
    });
  }

  // Professional registration number
  const profEl = q('input[name="prof_reg_number"]');
  if (profEl) {
    profEl.value = model.prof_reg_number || '';
    profEl.addEventListener('input', () => {
      model.prof_reg_number = profEl.value || '';
      markDirty();
    });
  }

  // ðŸ”¹ Pay method change handler â€” nuke bank details / umbrella_id in modal only
  const payEl = q('select[name="pay_method"]');
  if (payEl) {
    // Normalise initial previous method
    let lastMethod = (model.pay_method || payEl.value || 'UNKNOWN').toString().toUpperCase();
    if (lastMethod === '' || lastMethod === 'UNKNOWN') lastMethod = null;

    payEl.addEventListener('change', () => {
      const raw = payEl.value || '';
      let nextMethod = raw.toUpperCase();
      if (nextMethod === '' || nextMethod === 'UNKNOWN') nextMethod = null;

      const prev = lastMethod;
      const next = nextMethod;

      if (prev === next) return;

      const wasPAYE     = prev === 'PAYE';
      const wasUMBRELLA = prev === 'UMBRELLA';
      const nowPAYE     = next === 'PAYE';
      const nowUMBRELLA = next === 'UMBRELLA';

      // Helper to clear bank fields in the Pay tab + model
      const clearBankFields = () => {
        const acc = document.querySelector('#tab-pay input[name="account_holder"]');
        const bn  = document.querySelector('#tab-pay input[name="bank_name"]');
        const sc  = document.querySelector('#tab-pay input[name="sort_code"]');
        const an  = document.querySelector('#tab-pay input[name="account_number"]');
        if (acc) acc.value = '';
        if (bn)  bn.value  = '';
        if (sc)  sc.value  = '';
        if (an)  an.value  = '';
        model.account_holder = '';
        model.bank_name      = '';
        model.sort_code      = '';
        model.account_number = '';
      };

      // Helper to clear umbrella id + text field in Pay tab + model
      const clearUmbrella = () => {
        const umbId   = document.getElementById('umbrella_id');
        const umbName = document.getElementById('umbrella_name');
        if (umbId)   umbId.value   = '';
        if (umbName) umbName.value = '';
        model.umbrella_id = null;
      };

      // If we are switching channel (PAYE â†” UMBRELLA), wipe bank details in the modal
      if ((wasPAYE && nowUMBRELLA) || (wasUMBRELLA && nowPAYE)) {
        clearBankFields();
      }
      // Specifically for UMBRELLA â†’ PAYE, also clear umbrella_id
      if (wasUMBRELLA && nowPAYE) {
        clearUmbrella();
      }

      // Update model + modalCtx in-memory only (server-side nuking is handled by what we send)
      model.pay_method = next;
      try {
        window.modalCtx = window.modalCtx || {};
        window.modalCtx.data = window.modalCtx.data || {};
        window.modalCtx.data.pay_method = next;
        window.modalCtx.payMethodState = next; // âœ… NEW: track the current (unsaved) pay method

        if (next === 'PAYE') {
          // Keep umbrella_id null in the in-memory candidate once PAYE is chosen
          window.modalCtx.data.umbrella_id = null;
        }
      } catch {}

      // Broadcast so Pay tab can react if it wants to
      try {
        window.dispatchEvent(new CustomEvent('pay-method-changed', {
          detail: { from: prev, to: next }
        }));
      } catch {}

      lastMethod = next;
      markDirty();
    });
  }

  // Address fields
  const addrKeys = [
    'address_line1',
    'address_line2',
    'address_line3',
    'town_city',
    'county',
    'postcode',
    'country'
  ];
  addrKeys.forEach((k) => bind(`input[name="${k}"]`, k));

  // Helper to render current job_titles list
  const jobTitlesHost = q('#jobTitlesList');

  const renderJobTitlesList = () => {
    if (!jobTitlesHost) return;

    // Normalise before rendering
    normaliseJobTitles();

    const C = window.__jobTitlesCache || {};
    const byId = C.byId || {};
    const items = Array.isArray(model.job_titles) ? model.job_titles : [];

    // Check if we are in edit/create mode (for bins + context menu)
    const fr = window.__getModalFrame?.();
    const canEdit =
      !!fr &&
      fr.entity === 'candidates' &&
      fr.currentTabKey === 'main' &&
      (fr.mode === 'edit' || fr.mode === 'create');

    if (!items.length) {
      jobTitlesHost.innerHTML = `<div class="hint">No job titles selected yet.</div>`;
    } else {
      jobTitlesHost.innerHTML = items
        .map((t) => {
          const node = byId[t.job_title_id];
          const isPrimary = !!t.is_primary;
          // Just the leaf label (no full tree)
          const label = node ? (node.label || '') : String(t.job_title_id || '');
          const regBadge =
            node && node.requires_prof_reg
              ? `<span class="pill mini" style="margin-left:4px">${node.prof_reg_type || 'Reg'}</span>`
              : '';

          const pillBase =
            'display:inline-flex;align-items:center;gap:6px;margin:2px 4px 0 0;padding:2px 6px;border-radius:999px;';
          const pillStyle = isPrimary
            ? `${pillBase}border:1px solid var(--ok,#22c55e);background:rgba(34,197,94,0.08);`
            : `${pillBase}border:1px solid var(--line);`;

          const labelHtml = isPrimary
            ? `<span style="color:var(--ok,#22c55e);font-weight:600">${escapeHtml(label)}</span>`
            : `<span>${escapeHtml(label)}</span>`;

          const primaryTag = isPrimary
            ? `<span class="mini" style="margin-left:4px;opacity:.85;color:var(--ok,#22c55e)">Primary</span>`
            : '';

          const binHtml = canEdit
            ? `
              <button type="button"
                      class="btn mini"
                      data-act="remove-job-title"
                      data-id="${t.job_title_id}"
                      title="Remove">
                ðŸ—‘
              </button>`
            : '';

          return `
            <div class="pill"
                 data-role-id="${t.job_title_id}"
                 style="${pillStyle}">
              ${labelHtml}
              ${primaryTag}
              ${regBadge}
              ${binHtml}
            </div>
          `;
        })
        .join('');
    }

    // Recompute whether any role requires registration
    const regWrapper = q('[data-block="prof_reg"]');
    const regLabel = q('[data-field="prof_reg_label"]');
    const anyRequires = items.some((t) => {
      const node = byId[t.job_title_id];
      return node && node.requires_prof_reg;
    });

    if (regWrapper) {
      if (anyRequires) {
        regWrapper.style.display = '';
        if (regLabel) {
          const type = model.prof_reg_type || '';
          regLabel.textContent = type ? `${type} Number` : 'Registration Number';
        }
      } else {
        regWrapper.style.display = 'none';
      }
    }
  };

  // Initial cache + list render
  (async () => {
    try {
      await loadJobTitlesTree(false);
    } catch {}
    renderJobTitlesList();
  })();

  // Wire bins (remove job title)
  if (jobTitlesHost && !jobTitlesHost.__wiredClick) {
    jobTitlesHost.__wiredClick = true;
    jobTitlesHost.addEventListener('click', (e) => {
      const btn = e.target.closest('button[data-act="remove-job-title"]');
      if (!btn) return;
      const id = btn.getAttribute('data-id');
      if (!id) return;

      model.job_titles = (model.job_titles || []).filter(
        (t) => String(t.job_title_id) !== String(id)
      );
      renderJobTitlesList();
      markDirty();
    });
  }

  // Right-click context menu for "Set Primary Job Title"
  if (jobTitlesHost && !jobTitlesHost.__wiredCtx) {
    jobTitlesHost.__wiredCtx = true;

    jobTitlesHost.addEventListener('contextmenu', (e) => {
      const pill = e.target.closest('.pill[data-role-id]');
      if (!pill) return;

      const fr = window.__getModalFrame?.();
      const canEdit =
        !!fr &&
        fr.entity === 'candidates' &&
        fr.currentTabKey === 'main' &&
        (fr.mode === 'edit' || fr.mode === 'create');

      if (!canEdit) return; // no menu in view mode

      e.preventDefault();

      const id = pill.getAttribute('data-role-id');
      if (!id) return;

      // Remove any existing job title context menu
      if (window.__jtContextMenu) {
        try { document.body.removeChild(window.__jtContextMenu); } catch {}
        window.__jtContextMenu = null;
      }

      const menu = document.createElement('div');
      menu.style.cssText =
        'position:fixed;z-index:10000;background:#0b1528;border:1px solid var(--line);' +
        'padding:6px;border-radius:8px;min-width:180px;font-size:12px;';
      menu.innerHTML = `
        <div data-act="set-primary"
             style="padding:6px 10px;cursor:pointer;">
          Set as primary job title
        </div>
      `;

      const closeMenu = () => {
        if (window.__jtContextMenu) {
          try { document.body.removeChild(window.__jtContextMenu); } catch {}
          window.__jtContextMenu = null;
          document.removeEventListener('click', onDocClick, true);
        }
      };

      const onDocClick = (ev) => {
        if (ev.target && ev.target.closest && ev.target.closest('#__jtContextMenu')) return;
        closeMenu();
      };

      menu.id = '__jtContextMenu';
      window.__jtContextMenu = menu;
      document.body.appendChild(menu);

      const x = e.clientX;
      const y = e.clientY;
      menu.style.left = `${x}px`;
      menu.style.top = `${y}px`;

      menu.addEventListener('click', (ev) => {
        const item = ev.target.closest('[data-act="set-primary"]');
        if (!item) return;

        // Set this job title as primary
        let items = Array.isArray(model.job_titles) ? model.job_titles.slice() : [];
        items = items.map((t) => ({
          ...t,
          is_primary: String(t.job_title_id) === String(id)
        }));
        model.job_titles = items;
        renderJobTitlesList();
        markDirty();
        closeMenu();
      });

      document.addEventListener('click', onDocClick, true);
    });
  }

  // Job Title picker button (add another role)
  const jobBtn = q('[data-act="pick-job-title"]');
  if (jobBtn && !jobBtn.__wired) {
    jobBtn.__wired = true;
    jobBtn.addEventListener('click', async () => {
      await loadJobTitlesTree(false).catch(() => {});
      openJobTitlePickerModal(null, (sel) => {
        const id = sel.jobTitleId;
        if (!id) return;

        const existing = Array.isArray(model.job_titles) ? model.job_titles.slice() : [];
        if (existing.some((t) => String(t.job_title_id) === String(id))) {
          alert('This role is already added for this candidate.');
          return;
        }

        const requires = !!sel.requiresProfReg;
        const type = sel.profRegType || null;

        if (requires) {
          if (model.prof_reg_type && model.prof_reg_type !== type) {
            alert('All roles must share the same registration type (NMC / GMC / HCPC).');
            return;
          }
          if (!model.prof_reg_type && type) {
            model.prof_reg_type = type;
          }
        }

        const hasPrimary = existing.some((t) => t.is_primary);
        const newItem = {
          job_title_id: id,
          // First job title ever becomes primary; otherwise only if there was no primary for some reason
          is_primary: !existing.length && !hasPrimary
        };

        model.job_titles = [...existing, newItem];
        renderJobTitlesList();
        markDirty();
      });
    });
  }

  // Postcode lookup icon
  const addrBtn = q('[data-act="postcode-lookup"]');
  if (addrBtn && !addrBtn.__wired) {
    addrBtn.__wired = true;
    addrBtn.addEventListener('click', () => {
      const current = {
        line1: model.address_line1,
        line2: model.address_line2,
        line3: model.address_line3,
        city: model.town_city,
        postcode: model.postcode
      };
      openAddressLookupModal(current, (chosen) => {
        applyAddressToCandidateModel(model, chosen);
        // reflect in inputs
        ['address_line1', 'address_line2', 'address_line3', 'town_city', 'postcode'].forEach((k) => {
          const el = q(`input[name="${k}"]`);
          if (el) el.value = model[k] || '';
        });
        markDirty();
      });
    });
  }
}


// =============== NEW: apiPostcodeLookup (frontend â†’ backend) ===========
async function apiPostcodeLookup(postcode, house) {
  const params = new URLSearchParams();
  if (postcode) params.set('postcode', postcode);
  if (house) params.set('house', house);

  const url = API(`/api/tools/postcode-lookup?${params.toString()}`);
  const res = await authFetch(url);
  if (!res.ok) {
    throw new Error('Postcode lookup failed');
  }
  const data = (await res.json().catch(() => ({}))) || {};
  return data.addresses || [];
}

// =============== NEW: Address lookup modal (candidate/umbrella) ========
function openAddressLookupModal(initialAddress, onSave) {
  const S = {
    line1: initialAddress?.line1 || '',
    line2: initialAddress?.line2 || '',
    line3: initialAddress?.line3 || '',
    city: initialAddress?.city || '',
    postcode: initialAddress?.postcode || '',
    house: '',
    lookupInFlight: false,
    results: [],
    error: ''
  };

  const body = html(`
    <div id="addrLookupRoot" class="form">
      <div class="row">
        <label>Postcode</label>
        <input type="text" name="lookup_postcode" />
      </div>
      <div class="row">
        <label>House number / name (optional)</label>
        <input type="text" name="lookup_house" />
      </div>
      <div class="row">
        <button type="button" id="btnAddrLookup">Lookup</button>
      </div>

      <div class="row" style="grid-column:1/-1">
        <label>Results</label>
        <div id="addrLookupResults"
             style="border:1px solid var(--line);border-radius:8px;max-height:200px;overflow:auto">
          <div class="hint" style="padding:8px">No lookup results yet.</div>
        </div>
      </div>

      <div class="row" style="grid-column:1/-1;margin-top:10px">
        <label>Manual address (you can edit after choosing a result, or ignore lookup entirely)</label>
      </div>
      <div class="row">
        <label>Address line 1</label>
        <input type="text" name="addr_line1" />
      </div>
      <div class="row">
        <label>Address line 2</label>
        <input type="text" name="addr_line2" />
      </div>
      <div class="row">
        <label>Address line 3</label>
        <input type="text" name="addr_line3" />
      </div>
      <div class="row">
        <label>City / Town</label>
        <input type="text" name="addr_city" />
      </div>
      <div class="row">
        <label>Postcode</label>
        <input type="text" name="addr_postcode" />
      </div>
    </div>
  `);

  const renderResults = () => {
    const root = document.getElementById('addrLookupRoot');
    if (!root) return;
    const box = root.querySelector('#addrLookupResults');
    if (!box) return;

    if (S.error) {
      box.innerHTML = `<div class="error" style="padding:8px">${escapeHtml(S.error)}</div>`;
      return;
    }

    if (!S.results.length) {
      box.innerHTML = `<div class="hint" style="padding:8px">No lookup results yet.</div>`;
      return;
    }

    box.innerHTML = S.results
      .map(
        (a, idx) => `
        <div class="addr-row" data-i="${idx}"
             style="padding:6px 8px;border-bottom:1px solid var(--line);cursor:pointer">
          <div>${escapeHtml(a.line1 || '')}</div>
          <div class="mini">${escapeHtml(
            [a.line2, a.line3, a.city, a.postcode].filter(Boolean).join(', ')
          )}</div>
        </div>
      `
      )
      .join('');
  };

  const syncStateToForm = () => {
    const root = document.getElementById('addrLookupRoot');
    if (!root) return;
    const setVal = (name, v) => {
      const el = root.querySelector(`input[name="${name}"]`);
      if (el) el.value = v || '';
    };

    setVal('lookup_postcode', S.postcode);
    setVal('lookup_house', S.house);
    setVal('addr_line1', S.line1);
    setVal('addr_line2', S.line2);
    setVal('addr_line3', S.line3);
    setVal('addr_city', S.city);
    setVal('addr_postcode', S.postcode);
  };

  const syncFormToState = () => {
    const root = document.getElementById('addrLookupRoot');
    if (!root) return;
    const getVal = (name) => {
      const el = root.querySelector(`input[name="${name}"]`);
      return el ? el.value.trim() : '';
    };

    // For lookup purposes, postcode comes only from the lookup_postcode field
    S.postcode = getVal('lookup_postcode') || S.postcode;
    S.house = getVal('lookup_house') || S.house;
    S.line1 = getVal('addr_line1') || S.line1;
    S.line2 = getVal('addr_line2') || S.line2;
    S.line3 = getVal('addr_line3') || S.line3;
    S.city = getVal('addr_city') || S.city;
    // Do NOT overwrite S.postcode from addr_postcode here (Option A)
  };

  const onOpen = () => {
    const root = document.getElementById('addrLookupRoot');
    if (!root) return;

    syncStateToForm();
    renderResults();

    const btn = root.querySelector('#btnAddrLookup');
    if (btn && !btn.__wired) {
      btn.__wired = true;
      btn.addEventListener('click', async () => {
        syncFormToState();
        if (!S.postcode) {
          alert('Please enter a postcode first');
          return;
        }
        S.lookupInFlight = true;
        S.error = '';
        btn.disabled = true;
        btn.textContent = 'Looking upâ€¦';

        const wireResultClicks = () => {
          const box = root.querySelector('#addrLookupResults');
          if (!box || box.__wired) return;
          box.__wired = true;
          box.addEventListener('click', (e) => {
            const row = e.target.closest('.addr-row[data-i]');
            if (!row) return;
            const idx = +row.getAttribute('data-i');
            const a = S.results[idx];
            if (!a) return;
            S.line1 = a.line1 || '';
            S.line2 = a.line2 || '';
            S.line3 = a.line3 || '';
            S.city = a.city || '';
            S.postcode = a.postcode || '';
            syncStateToForm();
          });
        };

        try {
          const results = await apiPostcodeLookup(S.postcode, S.house);
          S.results = results || [];
          if (S.results.length === 1) {
            const a = S.results[0];
            S.line1 = a.line1 || S.line1;
            S.line2 = a.line2 || S.line2;
            S.line3 = a.line3 || S.line3;
            S.city = a.city || S.city;
            S.postcode = a.postcode || S.postcode;
            syncStateToForm();
          }
        } catch (e) {
          console.error('postcode lookup failed', e);
          S.error = 'Lookup failed. Please check the postcode or try again.';
        } finally {
          S.lookupInFlight = false;
          btn.disabled = false;
          btn.textContent = 'Lookup';
          renderResults();
          // ensure row clicks wired after rendering
          const box = root.querySelector('#addrLookupResults');
          if (box && !box.__wired) {
            wireResultClicks();
          }
        }
      });
    }

    // Initial result click wiring (in case results are present already)
    const box = root.querySelector('#addrLookupResults');
    if (box && !box.__wired) {
      box.__wired = true;
      box.addEventListener('click', (e) => {
        const row = e.target.closest('.addr-row[data-i]');
        if (!row) return;
        const idx = +row.getAttribute('data-i');
        const a = S.results[idx];
        if (!a) return;
        S.line1 = a.line1 || '';
        S.line2 = a.line2 || '';
        S.line3 = a.line3 || '';
        S.city = a.city || '';
        S.postcode = a.postcode || '';
        syncStateToForm();
      });
    }
  };

  showModal(
    'Address',
    [{ key: 'main', label: 'Address' }],
    () => body,
    async () => {
      const root = document.getElementById('addrLookupRoot');
      if (!root) return { ok: false };
      syncFormToState();
      const addr = {
        line1: S.line1 || '',
        line2: S.line2 || '',
        line3: S.line3 || '',
        city: S.city || '',
        postcode: S.postcode || ''
      };
      if (typeof onSave === 'function') {
        onSave(addr);
      }
      return { ok: true };
    },
    false,
    onOpen,
    { kind: 'address-lookup', noParentGate: false }
  );

  // Wire up button + results on first open
  onOpen();
}

// =============== NEW: applyAddress* helpers ============================
function applyAddressToCandidateModel(model, addr) {
  if (!model || !addr) return;
  model.address_line1 = addr.line1 || '';
  model.address_line2 = addr.line2 || '';
  model.address_line3 = addr.line3 || '';
  model.town_city = addr.city || '';
  model.postcode = addr.postcode || '';
}

function applyAddressToUmbrellaModel(model, addr) {
  if (!model || !addr) return;
  model.address_line1 = addr.line1 || '';
  model.address_line2 = addr.line2 || '';
  model.address_line3 = addr.line3 || '';
  model.town_city = addr.city || '';
  model.postcode = addr.postcode || '';
}

// =============== NEW: buildUmbrellaDetailsModel ========================
function buildUmbrellaDetailsModel(row) {
  const r = row || {};
  return {
    id: r.id || null,
    name: r.name || '',
    remittance_email: r.remittance_email || '',
    bank_name: r.bank_name || '',
    sort_code: r.sort_code || '',
    account_number: r.account_number || '',
    vat_chargeable: !!r.vat_chargeable,
    enabled: r.enabled === false ? false : true,

    address_line1: r.address_line1 || '',
    address_line2: r.address_line2 || '',
    address_line3: r.address_line3 || '',
    town_city: r.town_city || '',
    county: r.county || '',
    postcode: r.postcode || '',
    country: r.country || '',
    company_number: r.company_number || ''
  };
}

// =============== NEW: bindUmbrellaAddressEvents ========================
function bindUmbrellaAddressEvents(container, model) {
  if (!container || !model) return;
  const q = (sel) => container.querySelector(sel);

  const bind = (selector, key) => {
    const el = q(selector);
    if (!el) return;
    el.value = model[key] || '';
    el.addEventListener('input', () => {
      model[key] = el.value;
    });
  };

  // Address fields
  bind('input[name="address_line1"]', 'address_line1');
  bind('input[name="address_line2"]', 'address_line2');
  bind('input[name="address_line3"]', 'address_line3');
  bind('input[name="town_city"]', 'town_city');
  bind('input[name="county"]', 'county');
  bind('input[name="postcode"]', 'postcode');
  bind('input[name="country"]', 'country');

  // Company registration number
  bind('input[name="company_number"]', 'company_number');

  // Optional postcode lookup
  const btn = q('[data-act="umbrella-postcode-lookup"]');
  if (btn && !btn.__wired) {
    btn.__wired = true;
    btn.addEventListener('click', () => {
      const curr = {
        line1: model.address_line1,
        line2: model.address_line2,
        line3: model.address_line3,
        city: model.town_city,
        postcode: model.postcode
      };
      openAddressLookupModal(curr, (addr) => {
        applyAddressToUmbrellaModel(model, addr);
        ['address_line1', 'address_line2', 'address_line3', 'town_city', 'postcode'].forEach((k) => {
          const el = q(`input[name="${k}"]`);
          if (el) el.value = model[k] || '';
        });
      });
    });
  }
}


















// ==== FIXED MODAL FRAMEWORK: close only on explicit success from onSave ====
// ==== FIXED MODAL FRAMEWORK: close only on explicit success from onSave ====

// FRONTEND â€” UPDATED
// showModal: ignore non-trusted events for dirty; ensure drag handlers cleared early on close
// ================== FRONTEND: renderSummary (UPDATED to jump & highlight pending focus) ==================

// ===== UPDATED: renderSummary â€” if pending focus row isn't visible, try one auto-relax/reload pass, then highlight when found

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// FIX 4: Bucket labels preview derived for contracts listing
// (cosmetic only; other sections unchanged)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UPDATED: renderSummary(rows)
// - Writes/refreshes summary membership cache fingerprint for current section
// - Prepares candidate role projection as before
// - Hooks page-size change as before
// - Triggers background membership priming (ALL IDs for current filters)
// - (Sorting of summary grid can be added here if/when you enable header clicks)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


// Close any existing floating menu
function closeRelatedMenu(){
  const m = document.getElementById('relatedMenu');
  if (m) m.remove();
  document.removeEventListener('click', closeRelatedMenu, { capture: true });
  document.removeEventListener('keydown', escCloseRelatedMenu, true);
}
function escCloseRelatedMenu(ev){
  if (ev.key === 'Escape') closeRelatedMenu();
}

// Create & show a context menu near (x,y)
// ========================= showRelatedMenu (FIXED) =========================
// Create & show a context menu near (x,y)
function showRelatedMenu(x, y, counts, entity, id){
  closeRelatedMenu();

  const obj = (counts && typeof counts === 'object') ? counts : {};
  const entries = Object.entries(obj).filter(([k]) => k && String(k).trim().length > 0);

  const menu = document.createElement('div');
  menu.id = 'relatedMenu';
  menu.style.position = 'fixed';
  menu.style.left = x + 'px';
  menu.style.top  = y + 'px';
  menu.style.zIndex = 1000;
  menu.style.minWidth = '220px';
  menu.style.maxWidth = '280px';
  menu.style.background = '#0b1221';
  menu.style.border = '1px solid #334155';
  menu.style.borderRadius = '10px';
  menu.style.boxShadow = '0 10px 24px rgba(0,0,0,.35)';
  menu.style.padding = '6px';
  menu.style.color = '#f8fafc';
  menu.style.font = '14px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial';

  const toInt = (v) => {
    const n = Number(v);
    return Number.isFinite(n) ? Math.max(0, Math.trunc(n)) : 0;
  };

  const plural = (n, one, many) => (n === 1 ? one : many);

  const resolveTargetSection = (relationType) => {
    const t = String(relationType || '').toLowerCase();
    switch (t) {
      case 'timesheet':
      case 'timesheets':
      case 'series':
        return 'timesheets';
      case 'invoice':
      case 'invoices':
        return 'invoices';
      case 'client':
      case 'clients':
        return 'clients';
      case 'candidate':
      case 'candidates':
        return 'candidates';
      case 'umbrella':
      case 'umbrellas':
        return 'umbrellas';
      case 'contract':
      case 'contracts':
        return 'contracts';
      default:
        return currentSection || null;
    }
  };

  const item = (label, disabled, relationType) => {
    const it = document.createElement('div');
    it.textContent = label;
    it.style.padding = '8px 10px';
    it.style.borderRadius = '8px';
    it.style.cursor = disabled ? 'default' : 'pointer';
    it.style.opacity = disabled ? '.6' : '1';
    it.onmouseenter = ()=>{ if (!disabled) it.style.background = 'rgba(255,255,255,06)'; };
    it.onmouseleave = ()=>{ it.style.background = 'transparent'; };

    if (!disabled) {
      it.onclick = async (ev)=>{
        ev.stopPropagation();

        // âœ… Close menu BEFORE switching (prevents overlay/state glitches)
        closeRelatedMenu();

        // Tear down any open modal before switching section
        if ((window.__modalStack?.length || 0) > 0 || window.modalCtx?.entity) {
          discardAllModalsAndState();
        }

        const targetSection = resolveTargetSection(relationType);
        if (!targetSection) return;

        // âœ… Persist related view mode into section list-state filters (EXCLUSIVE; do not merge)
        window.__listState = window.__listState || {};
        const st = (window.__listState[targetSection] ||= {
          page: 1,
          pageSize: 50,
          total: null,
          hasMore: false,
          filters: null,
          sort: { key: null, dir: 'asc' }
        });

        st.page = 1;
        st.total = null;
        st.hasMore = false;

        st.filters = {
          related: {
            source_entity: String(entity || ''),
            source_id: String(id || ''),
            relation_type: String(relationType || '')
          }
        };

        // âœ… Reset selection state for target section (prevents mixed-grid weirdness)
        window.__selection = window.__selection || {};
        window.__selection[targetSection] = window.__selection[targetSection] || { fingerprint:'', ids:new Set() };

        // âœ… Switch section and force full app render path (nav highlight + correct columns/data)
        currentSection   = targetSection;
        currentRows      = [];
        currentSelection = null;

        try { await renderAll(); } catch (e) {
          console.warn('[RELATED] failed to render related view', e);
        }
      };
    }

    menu.appendChild(it);
  };

  if (!entries.length) {
    item('No related records', true, '');
  } else {
    // Sort by count desc
    entries.sort((a,b)=> (toInt(b[1]) - toInt(a[1])));

    entries.forEach(([rawType, rawCount])=>{
      const type = String(rawType || '').trim();
      const count = toInt(rawCount);

      // âœ… No UI-side "series minus 1" (server already returns "other timesheets in series")
      // Friendly label + plural
      let label = '';
      const t = type.toLowerCase();

      if (t === 'series') {
        label = `${count} ${plural(count, 'other timesheet in series', 'other timesheets in series')}`;
      } else if (t === 'invoice' || t === 'invoices') {
        label = `${count} ${plural(count, 'related invoice', 'related invoices')}`;
      } else if (t === 'timesheet' || t === 'timesheets') {
        label = `${count} ${plural(count, 'related timesheet', 'related timesheets')}`;
      } else if (t === 'client' || t === 'clients') {
        label = `${count} ${plural(count, 'related client', 'related clients')}`;
      } else if (t === 'candidate' || t === 'candidates') {
        label = `${count} ${plural(count, 'related candidate', 'related candidates')}`;
      } else if (t === 'umbrella' || t === 'umbrellas') {
        label = `${count} ${plural(count, 'related umbrella', 'related umbrellas')}`;
      } else if (t === 'contract' || t === 'contracts') {
        label = `${count} ${plural(count, 'related contract', 'related contracts')}`;
      } else {
        // Fallback
        label = `${count} related ${type}`;
      }

      const disabled = (count === 0);
      item(label, disabled, type);
    });
  }

  document.body.appendChild(menu);
  setTimeout(()=>{
    document.addEventListener('click', closeRelatedMenu, { capture: true, once: true });
    document.addEventListener('keydown', escCloseRelatedMenu, true);
  }, 0);

  menu.addEventListener('click', ev => ev.stopPropagation());
}


// ===== Quick search =====
// âœ… Quick search: build minimal per-section filters (with timesheet heuristic)
// âœ… Quick search: build minimal per-section filters (with timesheet heuristic)
// Helper to build minimal quick-search filters per section
function buildQuickFilters(section, text) {
  const q = String(text || '').trim();
  if (!q) return {};

  switch (section) {
    case 'clients':
    case 'umbrellas':
    case 'invoices':
      // backend supports ?q=... (ilike on name / invoice_no depending on endpoint)
      return { q: q };

    case 'timesheets': {
      // Pick ONE field to avoid AND-ing and missing matches
      const looksLikeUUID   = /^[0-9a-f-]{10,}$/i.test(q);
      const looksLikeBkId   = /^[A-Za-z0-9-]{6,}$/.test(q);
      const looksLikeOccKey = /^[A-Za-z0-9_.-]{4,}$/.test(q);

      if (looksLikeBkId || looksLikeUUID) return { booking_id: q };
      if (looksLikeOccKey)                return { occupant_key_norm: q };
      return { hospital_norm: q };
    }

    case 'candidates':
      return { first_name: q, last_name: q, email: q, phone: q };

    default:
      return {};
  }
}

// âœ… Quick search: use heuristic builder (includes timesheets fix)

async function openSearch() {
  const q = prompt('Search text:');
  if (!q) return;

  // reflect in the quick box for consistency
  const box = byId('quickSearch');
  if (box) box.value = q;

  const filters = buildQuickFilters(currentSection, q);
  const rows = await search(currentSection, filters);
  if (rows) renderSummary(rows);
}

// OPTIONAL: open ALT+F for fast search
document.addEventListener('keydown', (e) => {
  if (e.altKey && (e.key === 'f' || e.key === 'F')) {
    e.preventDefault();
    openSearchModal();
  }
});

// ================== NEW: openSettings (parent modal; opens in View) ==================
async function openSettings() {
  const deep = (o)=> JSON.parse(JSON.stringify(o || {}));

  // Hydrate settings + finance windows
  let settings = null;
  let finance_windows = [];

  try {
    const res = await getSettings(); // may return {settings, finance_windows} or just settings (legacy)
    if (res && typeof res === 'object' && res.settings && typeof res.settings === 'object') {
      settings = res.settings;
      finance_windows = Array.isArray(res.finance_windows) ? res.finance_windows : [];
    } else {
      settings = res; // legacy behaviour
      finance_windows = Array.isArray(res?.finance_windows) ? res.finance_windows : [];
    }
  } catch (e) {
    alert('Could not load settings.');
    return;
  }

  // Preserve draft across re-opens (prefer window.modalCtx because showModal uses it)
  const prevCtx =
    (window.modalCtx && typeof window.modalCtx === 'object')
      ? window.modalCtx
      : ((typeof modalCtx !== 'undefined' && modalCtx && typeof modalCtx === 'object') ? modalCtx : null);

  const prevDraft =
    (prevCtx && prevCtx.entity === 'settings' && prevCtx.finance_new_draft)
      ? deep(prevCtx.finance_new_draft)
      : { date_from:'', date_to:'', vat:'', hol:'', erni:'' };

  // Seed modal context (IMPORTANT: showModal reads window.modalCtx)
  window.modalCtx = modalCtx = {
    entity: 'settings',
    data: deep(settings || {}),              // settings_defaults (non-finance) remain the modal's main data
    finance_windows: deep(finance_windows),  // finance windows live alongside data (so we donâ€™t accidentally POST them to /defaults)
    finance_new_draft: prevDraft,
    formState: { __forId: 'global', main:{} },
    openToken: 'settings:' + Date.now()
  };

  // Open in VIEW mode (hasId=true) and let showModal manage Edit/Cancel/Discard/Save
  showModal(
    'Settings',
    [{ key:'main', label:'Defaults' }],
    renderSettingsTab,
    handleSaveSettings,
    true // hasId â†’ opens in View mode
  );

  // Wire finance window behaviours (delegated, survives re-renders)
  try { __ensureSettingsFinanceWindowsWiring(); } catch {}
  // Best-effort: initial sync/bounds after render
  setTimeout(() => { try { __settingsFinanceSync(); } catch {} }, 0);
}
function __ensureSettingsFinanceWindowsWiring() {
  if (window.__settingsFinanceWindowsWired) return;
  window.__settingsFinanceWindowsWired = true;

  // Attach UK datepicker lazily on focus
  document.addEventListener('focusin', (e) => {
    const el = e.target;
    if (!el) return;
    if (!el.classList || !el.classList.contains('js-ukdp')) return;
    try { attachUkDatePicker(el, {}); } catch {}
  });

  // âœ… Helper: normalise mileage defaults to 2dp and enforce > 0
  // - "45"   -> "0.45"
  // - "1.00" -> "1.00"
  // - <= 0 clears
  // (kept small + defensive; does not throw)
  const normPence2dpNonZero = (el) => {
    if (!el) return;
    const raw = String(el.value ?? '').trim();
    if (!raw) return;

    const cleaned = raw.replace(/[^0-9.]/g, '');
    if (!cleaned) { el.value = ''; return; }

    const hasDot = cleaned.includes('.');
    let n = Number(cleaned);
    if (!Number.isFinite(n)) { el.value = ''; return; }

    if (!hasDot) n = n / 100; // pence -> pounds

    if (!(n > 0)) { el.value = ''; return; }

    el.value = n.toFixed(2);
  };

  const isMileageId = (id) => (
    id === 'fw_cur_mpay' || id === 'fw_cur_mcharge' ||
    id === 'fw_fut_mpay' || id === 'fw_fut_mcharge' ||
    id === 'fw_new_mpay' || id === 'fw_new_mcharge'
  );

  // Keep draft fields in modalCtx and enforce no-overlap auto-adjust rules
  document.addEventListener('input', (e) => {
    const el = e.target;
    if (!modalCtx || modalCtx.entity !== 'settings') return;
    if (!el || !el.id) return;

    // Persist Add-new draft values live (including mileage)
    if (el.id.startsWith('fw_new_')) {
      modalCtx.finance_new_draft = modalCtx.finance_new_draft || { date_from:'', date_to:'', vat:'', hol:'', erni:'', mpay:'', mcharge:'' };

      if (el.id === 'fw_new_from')     modalCtx.finance_new_draft.date_from = el.value || '';
      if (el.id === 'fw_new_to')       modalCtx.finance_new_draft.date_to   = el.value || '';
      if (el.id === 'fw_new_vat')      modalCtx.finance_new_draft.vat       = el.value;
      if (el.id === 'fw_new_hol')      modalCtx.finance_new_draft.hol       = el.value;
      if (el.id === 'fw_new_erni')     modalCtx.finance_new_draft.erni      = el.value;
      if (el.id === 'fw_new_mpay')     modalCtx.finance_new_draft.mpay      = el.value;
      if (el.id === 'fw_new_mcharge')  modalCtx.finance_new_draft.mcharge   = el.value;
    }

    // âœ… Live-normalise mileage defaults as user types (current/future/new)
    // Avoid fighting the cursor: only auto-normalise integer-like inputs (no dot) once >=2 chars.
    if (isMileageId(el.id)) {
      const v = String(el.value ?? '').trim();
      if (v && !v.includes('.') && v.length >= 2) {
        normPence2dpNonZero(el);
      }
    }
  });

  // âœ… On blur, always enforce formatting for mileage defaults
  document.addEventListener('focusout', (e) => {
    if (!modalCtx || modalCtx.entity !== 'settings') return;
    const el = e.target;
    if (!el || !el.id) return;
    if (isMileageId(el.id)) {
      normPence2dpNonZero(el);
    }
  });

  document.addEventListener('change', (e) => {
    if (!modalCtx || modalCtx.entity !== 'settings') return;
    const el = e.target;
    if (!el || !el.id) return;

    // âœ… Ensure mileage defaults are normalised before any save/auto-adjust logic runs
    // Also: do NOT trigger __settingsFinanceSync for mileage-only edits (prevents wiping draft fields).
    if (isMileageId(el.id)) {
      normPence2dpNonZero(el);

      // Keep new draft mileage persisted even if future sync runs later
      if (el.id === 'fw_new_mpay' || el.id === 'fw_new_mcharge') {
        modalCtx.finance_new_draft = modalCtx.finance_new_draft || { date_from:'', date_to:'', vat:'', hol:'', erni:'', mpay:'', mcharge:'' };
        if (el.id === 'fw_new_mpay')    modalCtx.finance_new_draft.mpay = el.value;
        if (el.id === 'fw_new_mcharge') modalCtx.finance_new_draft.mcharge = el.value;
      }

      return;
    }

    if (!/^fw_(cur|fut|new)_/.test(el.id)) return;
    __settingsFinanceSync();
  });
}

function __settingsFinanceSync() {
  const byId = (id) => document.getElementById(id);

  const curTo   = byId('fw_cur_to');
  const futFrom = byId('fw_fut_from');
  const newFrom = byId('fw_new_from');
  const hint    = byId('fw_hint');

  if (!curTo || (!futFrom && !newFrom)) return;

  const toIso = (ukVal) => {
    if (!ukVal) return null;
    try { return parseUkDateToIso(String(ukVal).trim()) || null; } catch { return null; }
  };

  const toUk = (iso) => {
    if (!iso) return '';
    try { return formatIsoToUk(iso); } catch { return iso; }
  };

  const addDays = (iso, delta) => {
    const d = new Date(`${iso}T00:00:00Z`);
    if (Number.isNaN(d.getTime())) return iso;
    d.setUTCDate(d.getUTCDate() + delta);
    const yyyy = d.getUTCFullYear();
    const mm = String(d.getUTCMonth() + 1).padStart(2, '0');
    const dd = String(d.getUTCDate()).padStart(2, '0');
    return `${yyyy}-${mm}-${dd}`;
  };

  const curToIso   = toIso(curTo.value);
  const futFromIso = futFrom ? toIso(futFrom.value) : null;
  const newFromIso = newFrom ? toIso(newFrom.value) : null;

  let msg = '';

  // Rule A: If new start is set and would overlap current (open-ended or current end >= new start),
  // auto-set current end = day before new start.
  if (newFromIso) {
    if (!curToIso || (curToIso >= newFromIso)) {
      const nextCurTo = addDays(newFromIso, -1);
      curTo.value = toUk(nextCurTo);
      msg = `Adjusted Current end to ${curTo.value} (day before new start) to prevent overlap.`;
    }
  }

  // Refresh after possible change
  const curToIso2 = toIso(curTo.value);

  // Rule B: If future start exists and overlaps current end (or current end open), auto-adjust:
  // - if current end is empty -> set current end to day before future start
  // - else if current end >= future start -> move future start to day after current end
  if (futFromIso) {
    if (!curToIso2) {
      curTo.value = toUk(addDays(futFromIso, -1));
      msg = msg || `Adjusted Current end to ${curTo.value} to avoid overlap with Future start.`;
    } else if (curToIso2 >= futFromIso) {
      const nextFutFrom = addDays(curToIso2, +1);
      futFrom.value = toUk(nextFutFrom);
      msg = msg || `Adjusted Future start to ${futFrom.value} (day after Current end) to prevent overlap.`;
    }
  }

  // Update datepicker constraints (best-effort)
  try {
    // Current end max date = min(futureStart-1, newStart-1) if either exists
    let maxIso = null;
    const fIso = futFrom ? toIso(futFrom.value) : null;
    const nIso = newFrom ? toIso(newFrom.value) : null;
    if (fIso) maxIso = addDays(fIso, -1);
    if (nIso) maxIso = maxIso ? (nIso < fIso ? addDays(nIso, -1) : maxIso) : addDays(nIso, -1);

    if (typeof curTo.setMaxDate === 'function') curTo.setMaxDate(maxIso);

    // Future start min date = current end + 1 (if current end exists)
    if (futFrom && typeof futFrom.setMinDate === 'function') {
      const cIso = toIso(curTo.value);
      futFrom.setMinDate(cIso ? addDays(cIso, +1) : null);
    }

    // New start min date = current end + 1 (if current end exists)
    if (newFrom && typeof newFrom.setMinDate === 'function') {
      const cIso = toIso(curTo.value);
      newFrom.setMinDate(cIso ? addDays(cIso, +1) : null);
    }
  } catch {}

  if (hint) {
    hint.textContent = msg || 'Tip: selecting a new Start date will automatically adjust the Current End date to avoid overlaps.';
  }
}


// ================== NEW: renderSettingsTab (tab renderer; showModal controls read-only) ==================
function renderSettingsTab(key, s = {}) {
  if (key !== 'main') return '';

  // Finance windows are now loaded separately (handleGetSettings returns { settings, finance_windows }).
  // We keep settings_defaults fields here for non-finance settings only.
  const fws = (modalCtx && Array.isArray(modalCtx.finance_windows)) ? modalCtx.finance_windows : [];

  // Determine "today" (YYYY-MM-DD). Prefer existing helper if present.
  let todayYmd = null;
  try { todayYmd = (typeof toLocalParts === 'function') ? (toLocalParts(new Date().toISOString(), null)?.ymd || null) : null; } catch {}
  if (!todayYmd) todayYmd = new Date().toISOString().slice(0, 10);

  const asYmd = (v) => {
    if (!v) return null;
    const s = String(v).slice(0, 10);
    return /^\d{4}-\d{2}-\d{2}$/.test(s) ? s : null;
  };

  const sortDesc = (a, b) => (asYmd(b?.date_from) || '').localeCompare(asYmd(a?.date_from) || '');
  const sortAsc  = (a, b) => (asYmd(a?.date_from) || '').localeCompare(asYmd(b?.date_from) || '');

  const current = (fws || [])
    .filter(w => {
      const df = asYmd(w?.date_from);
      const dt = asYmd(w?.date_to);
      return df && df <= todayYmd && (!dt || dt >= todayYmd);
    })
    .sort(sortDesc)[0] || null;

  const futureList = (fws || [])
    .filter(w => {
      const df = asYmd(w?.date_from);
      return df && df > todayYmd;
    })
    .sort(sortAsc);

  const future = futureList[0] || null;
  const futureExtraCount = Math.max(0, futureList.length - 1);

  const uk = (iso) => {
    try { return iso ? formatIsoToUk(String(iso).slice(0, 10)) : ''; } catch { return iso ? String(iso).slice(0, 10) : ''; }
  };

  const fmt2 = (v) => {
    const n = Number(v);
    return Number.isFinite(n) ? n.toFixed(2) : '';
  };

  const cur = {
    id: current?.id || null,
    date_from: uk(current?.date_from || ''),
    date_to: uk(current?.date_to || ''),
    vat: (current?.vat_rate_pct ?? ''),
    hol: (current?.holiday_pay_pct ?? ''),
    erni: (current?.erni_pct ?? ''),

    // âœ… NEW (date-linked per finance window)
    mpay: (current?.mileage_pay_defaults ?? ''),
    mchg: (current?.mileage_charge_defaults ?? '')
  };

  const fut = {
    id: future?.id || null,
    date_from: uk(future?.date_from || ''),
    date_to: uk(future?.date_to || ''),
    vat: (future?.vat_rate_pct ?? ''),
    hol: (future?.holiday_pay_pct ?? ''),
    erni: (future?.erni_pct ?? ''),

    // âœ… NEW (date-linked per finance window)
    mpay: (future?.mileage_pay_defaults ?? ''),
    mchg: (future?.mileage_charge_defaults ?? '')
  };

  // Draft "Add new" values live on modalCtx so they survive re-renders
  const draft = (modalCtx && modalCtx.finance_new_draft && typeof modalCtx.finance_new_draft === 'object')
    ? modalCtx.finance_new_draft
    : (modalCtx.finance_new_draft = { date_from: '', date_to: '', vat: '', hol: '', erni: '', mpay: '', mchg: '' });

  const financeCard = `
    <div class="row" style="grid-column:1/-1">
      <div id="settingsFinanceWindows" style="padding:12px;border:1px solid rgba(255,255,255,0.12);border-radius:12px;background:rgba(255,255,255,0.04)">
        <div style="display:flex;align-items:flex-start;justify-content:space-between;gap:12px;margin-bottom:10px">
          <div>
            <div style="font-weight:700;font-size:14px">Finance windows</div>
            <div style="font-size:12px;color:rgba(255,255,255,0.7)">
              VAT / Holiday pay / ERNI / Mileage defaults are controlled by date windows. Windows cannot overlap.
              ${futureExtraCount ? `<span style="margin-left:6px;color:rgba(255,200,120,0.95)">(+${futureExtraCount} more future window${futureExtraCount>1?'s':''} not shown)</span>` : ``}
            </div>
          </div>
          <div style="font-size:12px;color:rgba(255,255,255,0.6);text-align:right">
            Today: <strong>${todayYmd}</strong><br/>
            UK dates (DD/MM/YYYY)
          </div>
        </div>

        <div style="display:grid;grid-template-columns: 140px 150px 150px 95px 110px 95px 140px 140px;gap:8px;align-items:end">
          <div style="font-size:12px;color:rgba(255,255,255,0.7)">Type</div>
          <div style="font-size:12px;color:rgba(255,255,255,0.7)">Start</div>
          <div style="font-size:12px;color:rgba(255,255,255,0.7)">End</div>
          <div style="font-size:12px;color:rgba(255,255,255,0.7)">VAT %</div>
          <div style="font-size:12px;color:rgba(255,255,255,0.7)">Holiday %</div>
          <div style="font-size:12px;color:rgba(255,255,255,0.7)">ERNI %</div>
          <div style="font-size:12px;color:rgba(255,255,255,0.7)">Mileage Pay</div>
          <div style="font-size:12px;color:rgba(255,255,255,0.7)">Mileage Charge</div>

          <!-- CURRENT -->
          <div style="font-weight:600">Current</div>
          <input id="fw_cur_from" class="js-ukdp" type="text" value="${cur.date_from}" placeholder="DD/MM/YYYY" disabled
                 style="opacity:0.7" />
          <input id="fw_cur_to" class="js-ukdp" type="text" value="${cur.date_to}" placeholder="(open)"
                 data-row="current" />
          <input id="fw_cur_vat" type="number" step="0.01" value="${cur.vat}" placeholder="e.g. 20" data-row="current" />
          <input id="fw_cur_hol" type="number" step="0.01" value="${cur.hol}" placeholder="e.g. 12.07" data-row="current" />
          <input id="fw_cur_erni" type="number" step="0.01" value="${cur.erni}" placeholder="e.g. 15" data-row="current" />

          <input
            id="fw_cur_mpay"
            type="number"
            inputmode="decimal"
            step="0.01"
            min="0.01"
            placeholder="0.00"
            value="${fmt2(cur.mpay)}"
            data-row="current"
            data-norm="pence2dp_nonzero"
            onblur="window.__normPence2dpNonZero && window.__normPence2dpNonZero(this)"
          />
          <input
            id="fw_cur_mcharge"
            type="number"
            inputmode="decimal"
            step="0.01"
            min="0.01"
            placeholder="0.00"
            value="${fmt2(cur.mchg)}"
            data-row="current"
            data-norm="pence2dp_nonzero"
            onblur="window.__normPence2dpNonZero && window.__normPence2dpNonZero(this)"
          />

          <!-- FUTURE (next upcoming only) -->
          <div style="font-weight:600">Future</div>
          <input id="fw_fut_from" class="js-ukdp" type="text" value="${fut.date_from}" placeholder="DD/MM/YYYY"
                 data-row="future" ${fut.id ? '' : 'disabled style="opacity:0.6"'} />
          <input id="fw_fut_to" class="js-ukdp" type="text" value="${fut.date_to}" placeholder="(open)"
                 data-row="future" ${fut.id ? '' : 'disabled style="opacity:0.6"'} />
          <input id="fw_fut_vat" type="number" step="0.01" value="${fut.vat}" placeholder="e.g. 20"
                 data-row="future" ${fut.id ? '' : 'disabled style="opacity:0.6"'} />
          <input id="fw_fut_hol" type="number" step="0.01" value="${fut.hol}" placeholder="e.g. 12.07"
                 data-row="future" ${fut.id ? '' : 'disabled style="opacity:0.6"'} />
          <input id="fw_fut_erni" type="number" step="0.01" value="${fut.erni}" placeholder="e.g. 15"
                 data-row="future" ${fut.id ? '' : 'disabled style="opacity:0.6"'} />

          <input
            id="fw_fut_mpay"
            type="number"
            inputmode="decimal"
            step="0.01"
            min="0.01"
            placeholder="0.00"
            value="${fmt2(fut.mpay)}"
            data-row="future"
            ${fut.id ? '' : 'disabled style="opacity:0.6"'}
            data-norm="pence2dp_nonzero"
            onblur="window.__normPence2dpNonZero && window.__normPence2dpNonZero(this)"
          />
          <input
            id="fw_fut_mcharge"
            type="number"
            inputmode="decimal"
            step="0.01"
            min="0.01"
            placeholder="0.00"
            value="${fmt2(fut.mchg)}"
            data-row="future"
            ${fut.id ? '' : 'disabled style="opacity:0.6"'}
            data-norm="pence2dp_nonzero"
            onblur="window.__normPence2dpNonZero && window.__normPence2dpNonZero(this)"
          />

          <!-- ADD NEW (draft) -->
          <div style="font-weight:600">Add new</div>
          <input id="fw_new_from" class="js-ukdp" type="text" value="${draft.date_from || ''}" placeholder="DD/MM/YYYY"
                 data-row="new" />
          <input id="fw_new_to" class="js-ukdp" type="text" value="${draft.date_to || ''}" placeholder="(open)"
                 data-row="new" />
          <input id="fw_new_vat" type="number" step="0.01" value="${draft.vat ?? ''}" placeholder="e.g. 20" data-row="new" />
          <input id="fw_new_hol" type="number" step="0.01" value="${draft.hol ?? ''}" placeholder="e.g. 12.07" data-row="new" />
          <input id="fw_new_erni" type="number" step="0.01" value="${draft.erni ?? ''}" placeholder="e.g. 15" data-row="new" />

          <input
            id="fw_new_mpay"
            type="number"
            inputmode="decimal"
            step="0.01"
            min="0.01"
            placeholder="0.00"
            value="${fmt2(draft.mpay ?? '')}"
            data-row="new"
            data-norm="pence2dp_nonzero"
            onblur="window.__normPence2dpNonZero && window.__normPence2dpNonZero(this)"
          />
          <input
            id="fw_new_mcharge"
            type="number"
            inputmode="decimal"
            step="0.01"
            min="0.01"
            placeholder="0.00"
            value="${fmt2(draft.mchg ?? '')}"
            data-row="new"
            data-norm="pence2dp_nonzero"
            onblur="window.__normPence2dpNonZero && window.__normPence2dpNonZero(this)"
          />
        </div>

        <div id="fw_hint" style="margin-top:10px;font-size:12px;color:rgba(255,255,255,0.65)">
          Tip: selecting a new Start date will automatically adjust the Current End date to avoid overlaps.
        </div>

        <!-- hidden ids for save logic (handled in handleSaveSettings later) -->
        <input type="hidden" id="fw_cur_id" value="${cur.id || ''}" />
        <input type="hidden" id="fw_fut_id" value="${fut.id || ''}" />
      </div>
    </div>
  `;

  return html(`
    <div class="form" id="settingsForm">
      ${input('timezone_id','Timezone', s.timezone_id || 'Europe/London')}

      ${input('day_start','Day shift starts',  s.day_start  || '06:00')}
      ${input('day_end','Day shift ends',      s.day_end    || '20:00')}
      ${input('night_start','Night shift starts', s.night_start || '20:00')}
      ${input('night_end','Night shift ends',     s.night_end   || '06:00')}

      ${input('sat_start','Saturday starts',  s.sat_start || '00:00')}
      ${input('sat_end','Saturday ends',      s.sat_end   || '00:00')}
      ${input('sun_start','Sunday starts',    s.sun_start || '00:00')}
      ${input('sun_end','Sunday ends',        s.sun_end   || '00:00')}

      ${select('bh_source','Bank Holidays source', s.bh_source || 'MANUAL', ['MANUAL','FEED'])}
      <div class="row" style="grid-column:1/-1">
        <label>Bank Holidays list (JSON dates)</label>
        <textarea name="bh_list">${JSON.stringify(s.bh_list || [], null, 2)}</textarea>
      </div>
      ${input('bh_feed_url','BH feed URL', s.bh_feed_url || '')}

      ${financeCard}
    </div>
  `);
}

/**
 * âœ… Add this once (global) somewhere in your FE file:
 * - If user enters "45" => "0.45"
 * - Always formats to 2dp
 * - Rejects <= 0 (clears input)
 */
window.__normPence2dpNonZero = function __normPence2dpNonZero(el) {
  if (!el) return;

  const raw = String(el.value ?? '').trim();
  if (!raw) return;

  // keep digits + optional dot
  const cleaned = raw.replace(/[^0-9.]/g, '');
  if (!cleaned) { el.value = ''; return; }

  const hasDot = cleaned.includes('.');
  let n = Number(cleaned);
  if (!Number.isFinite(n)) { el.value = ''; return; }

  // If user typed an integer-like value (no dot), treat as pence: 45 -> 0.45
  if (!hasDot) n = n / 100;

  // Cannot be zero or negative
  if (!(n > 0)) { el.value = ''; return; }

  el.value = n.toFixed(2);
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Finance windows API helpers (minimise calls; direct to broker)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function createFinanceWindow(payload){
  const r = await authFetch(API('/api/settings/finance-windows'), {
    method:'POST',
    headers:{'content-type':'application/json'},
    body: JSON.stringify(payload)
  });
  if (!r.ok) {
    const t = await r.text().catch(()=> '');
    throw new Error(t || 'Create finance window failed');
  }
  return true;
}

async function patchFinanceWindow(id, patch){
  const r = await authFetch(API(`/api/settings/finance-windows/${encodeURIComponent(id)}`), {
    method:'PATCH',
    headers:{'content-type':'application/json'},
    body: JSON.stringify(patch)
  });
  if (!r.ok) {
    const t = await r.text().catch(()=> '');
    throw new Error(t || 'Update finance window failed');
  }
  return true;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UPDATED: Save Settings modal (non-finance via /defaults, finance via /finance-windows)
// - Finance windows are saved in this order (to avoid overlap constraint failures):
//   1) PATCH Current (end/value changes)   2) POST New   3) PATCH Future
// - Clears __SETTINGS_CACHE__ and refreshes modalCtx with latest settings + windows
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function handleSaveSettings() {
  const byId = (id) => document.getElementById(id);

  // âœ… Preserve the singleton modal id across save/refresh
  const keepId = String(
    (window.modalCtx && window.modalCtx.data && window.modalCtx.data.id) ||
    (modalCtx && modalCtx.data && modalCtx.data.id) ||
    'global'
  );

  // Collect non-finance settings_defaults fields only (bh_list parsed etc.)
  const payload = collectForm('#settingsForm', true) || {};

  // âœ… Never send modal-only id to backend
  try { delete payload.id; } catch {}

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Read finance window inputs (Current / Future / Add new)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const ukToIsoOrNull = (uk) => {
    const v = String(uk || '').trim();
    if (!v) return null;
    const iso = parseUkDateToIso(v);
    return iso || null;
  };

  const mustIso = (uk, label) => {
    const iso = ukToIsoOrNull(uk);
    if (!iso) throw new Error(`Invalid ${label} date`);
    return iso;
  };

  const numOrNull = (v) => {
    if (v == null) return null;
    const s = String(v).trim();
    if (s === '') return null;
    const n = Number(s);
    return Number.isFinite(n) ? n : null;
  };

  const mustNum = (v, label) => {
    const n = numOrNull(v);
    if (n == null) throw new Error(`Invalid ${label} value`);
    return n;
  };

  // âœ… Mileage defaults normaliser (must be > 0)
  // - "45"   -> 0.45   (pence)
  // - "1.00" -> 1.00   (as-is)
  const mustMileageNonZero = (v, label) => {
    const raw = String(v ?? '').trim();
    if (!raw) throw new Error(`Invalid ${label} value`);

    const cleaned = raw.replace(/[^0-9.]/g, '');
    if (!cleaned) throw new Error(`Invalid ${label} value`);

    const hasDot = cleaned.includes('.');
    let n = Number(cleaned);
    if (!Number.isFinite(n)) throw new Error(`Invalid ${label} value`);

    // If user typed integer-like (no dot), interpret as pence (45 -> 0.45)
    if (!hasDot) n = n / 100;

    // Must be > 0 (cannot be zero or negative)
    if (!(n > 0)) throw new Error(`${label} must be greater than 0`);

    // Round to 2dp
    n = Math.round(n * 100) / 100;

    if (!(n > 0)) throw new Error(`${label} must be greater than 0`);
    return n;
  };

  // IDs
  const curId = String(byId('fw_cur_id')?.value || '').trim() || null;
  const futId = String(byId('fw_fut_id')?.value || '').trim() || null;

  // Current (start disabled; but values + end editable)
  const cur_to_uk    = byId('fw_cur_to')?.value || '';
  const cur_vat_raw  = byId('fw_cur_vat')?.value;
  const cur_hol_raw  = byId('fw_cur_hol')?.value;
  const cur_erni_raw = byId('fw_cur_erni')?.value;

  // Current mileage defaults
  const cur_mpay_raw     = byId('fw_cur_mpay')?.value;
  const cur_mcharge_raw  = byId('fw_cur_mcharge')?.value;

  // Future (optional)
  const fut_from_uk = byId('fw_fut_from')?.value || '';
  const fut_to_uk   = byId('fw_fut_to')?.value || '';
  const fut_vat_raw = byId('fw_fut_vat')?.value;
  const fut_hol_raw = byId('fw_fut_hol')?.value;
  const fut_erni_raw= byId('fw_fut_erni')?.value;

  // âœ… NEW: future mileage defaults
  const fut_mpay_raw     = byId('fw_fut_mpay')?.value;
  const fut_mcharge_raw  = byId('fw_fut_mcharge')?.value;

  // New (draft)
  const new_from_uk = byId('fw_new_from')?.value || '';
  const new_to_uk   = byId('fw_new_to')?.value || '';
  const new_vat_raw = byId('fw_new_vat')?.value;
  const new_hol_raw = byId('fw_new_hol')?.value;
  const new_erni_raw= byId('fw_new_erni')?.value;

  // âœ… NEW: new draft mileage defaults
  const new_mpay_raw     = byId('fw_new_mpay')?.value;
  const new_mcharge_raw  = byId('fw_new_mcharge')?.value;

  // Build finance operations
  let patchCurrent = null;
  let patchFuture  = null;
  let createNew    = null;

  try {
    // Current must exist if UI is showing it
    if (curId) {
      patchCurrent = {
        // date_from is not editable; date_to is optional (null = open ended)
        date_to: (cur_to_uk && String(cur_to_uk).trim()) ? mustIso(cur_to_uk, 'Current end') : null,

        vat_rate_pct: mustNum(cur_vat_raw, 'Current VAT %'),
        holiday_pay_pct: mustNum(cur_hol_raw, 'Current Holiday %'),
        erni_pct: mustNum(cur_erni_raw, 'Current ERNI %'),

        // Mileage defaults (must be > 0)
        mileage_pay_defaults: mustMileageNonZero(cur_mpay_raw, 'Default Mileage Pay'),
        mileage_charge_defaults: mustMileageNonZero(cur_mcharge_raw, 'Default Mileage Charge')
      };
    }

    // Future: only patch if there is an actual future row (id present)
    if (futId) {
      patchFuture = {
        date_from: mustIso(fut_from_uk, 'Future start'),
        date_to: (fut_to_uk && String(fut_to_uk).trim()) ? mustIso(fut_to_uk, 'Future end') : null,

        vat_rate_pct: mustNum(fut_vat_raw, 'Future VAT %'),
        holiday_pay_pct: mustNum(fut_hol_raw, 'Future Holiday %'),
        erni_pct: mustNum(fut_erni_raw, 'Future ERNI %'),

        // âœ… NEW: future mileage defaults (must be > 0)
        mileage_pay_defaults: mustMileageNonZero(fut_mpay_raw, 'Future Default Mileage Pay'),
        mileage_charge_defaults: mustMileageNonZero(fut_mcharge_raw, 'Future Default Mileage Charge')
      };
    }

    // New: only create if start date is provided
    const newFromIso = ukToIsoOrNull(new_from_uk);
    if (newFromIso) {
      createNew = {
        date_from: newFromIso,
        date_to: (new_to_uk && String(new_to_uk).trim()) ? mustIso(new_to_uk, 'New end') : null,

        vat_rate_pct: mustNum(new_vat_raw, 'New VAT %'),
        holiday_pay_pct: mustNum(new_hol_raw, 'New Holiday %'),
        erni_pct: mustNum(new_erni_raw, 'New ERNI %'),

        // âœ… NEW: new mileage defaults (must be > 0)
        mileage_pay_defaults: mustMileageNonZero(new_mpay_raw, 'New Default Mileage Pay'),
        mileage_charge_defaults: mustMileageNonZero(new_mcharge_raw, 'New Default Mileage Charge'),

        // Optional (not exposed in UI yet; keep null)
        apply_holiday_to: null,
        apply_erni_to: null,
        margin_includes: null
      };
    }
  } catch (e) {
    alert(e?.message || 'Invalid finance window values');
    return { ok:false };
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Save (minimise calls; enforce safe order)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  try {
    // 1) Save non-finance settings_defaults
    await saveSettings(payload);

    // 2) Finance windows updates (order matters)
    if (curId && patchCurrent) {
      await patchFinanceWindow(curId, patchCurrent);
    }

    if (createNew) {
      await createFinanceWindow(createNew);
    }

    if (futId && patchFuture) {
      await patchFinanceWindow(futId, patchFuture);
    }

  } catch (e) {
    alert('Save failed: ' + (e?.message || 'Unknown error'));
    return { ok:false };
  }

  // Bust FE cache so next loads are fresh
  try { __SETTINGS_CACHE__ = null; } catch {}

  // Refresh modalCtx from server so the modal flips to View and repaints correctly
  try {
    const res = await getSettings(); // returns { settings, finance_windows }
    const freshSettings = res?.settings || {};
    const freshWindows  = Array.isArray(res?.finance_windows) ? res.finance_windows : [];

    modalCtx.data = JSON.parse(JSON.stringify(freshSettings));
    modalCtx.data = modalCtx.data || {};
    modalCtx.data.id = keepId; // âœ… critical: keep singleton id

    modalCtx.finance_windows = JSON.parse(JSON.stringify(freshWindows));

    // âœ… Clear draft "Add new" row after successful save (including mileage)
    modalCtx.finance_new_draft = { date_from:'', date_to:'', vat:'', hol:'', erni:'', mpay:'', mcharge:'' };

    return { ok:true, saved: modalCtx.data };
  } catch {
    // Fallback: keep current modalCtx.data and return merged payload (non-finance only)
    const saved = { ...(modalCtx.data || {}), ...payload, id: keepId };
    modalCtx.data = saved;

    // âœ… still clear draft locally (including mileage) to avoid â€œghostâ€ draft values after save
    try {
      modalCtx.finance_new_draft = { date_from:'', date_to:'', vat:'', hol:'', erni:'', mpay:'', mcharge:'' };
    } catch {}

    return { ok:true, saved };
  }
}


// ================== NEW: handleSaveSettings (parent onSave; persist then stay open in View) ==================



async function commitContractCalendarStage(contractId) {
  const LOG_CAL = (typeof window.__LOG_CAL === 'boolean') ? window.__LOG_CAL : true;
  const L = (...a)=> { if (LOG_CAL) console.log('[CAL][commit]', ...a); };
  const W = (...a)=> { if (LOG_CAL) console.warn('[CAL][commit]', ...a); };
  const E = (...a)=> { if (LOG_CAL) console.error('[CAL][commit]', ...a); };

  // âœ… NEW: UI helper
  const showUnplanSummary = (resp, opts = {}) => {
    try {
      const blocked = Array.isArray(resp?.blocked_weeks) ? resp.blocked_weeks : [];

      let msg = '';
      if (!blocked.length) {
        msg = (opts.removeAll)
          ? `All unsubmitted weeks were removed successfully.`
          : `Calendar updated successfully.`;
      } else {
        const statusLabel = (b) => {
          if (b?.paid) return 'PAID';
          if (b?.invoiced) return 'INVOICED';
          if (b?.authorised) return 'AUTHORISED';
          if (b?.tsfin_processing_status) return String(b.tsfin_processing_status).toUpperCase();
          if (b?.contract_week_status) return String(b.contract_week_status).toUpperCase();
          return 'HAS_TIMESHEET';
        };

        const lines = blocked
          .slice(0, 12)
          .map(b => `â€¢ W/E ${String(b.week_ending_date || '')} (${statusLabel(b)})`)
          .join('\n');

        msg =
          (opts.removeAll)
            ? `Unsubmitted weeks were removed, but ${blocked.length} week(s) were kept because they already have a timesheet:\n\n${lines}`
            : `Some dates could not be removed because a timesheet already exists (${blocked.length} week(s)):\n\n${lines}`;

        if (blocked.length > 12) msg += `\n\nâ€¦and ${blocked.length - 12} more.`;
      }

      if (typeof showModalHint === 'function') {
        showModalHint(msg, blocked.length ? 'warn' : 'ok');
      } else if (typeof window.__toast === 'function') {
        window.__toast(blocked.length ? 'Removed (some weeks kept)' : 'Removed');
      } else {
        alert(msg);
      }
    } catch {}
  };

  const { addRanges, removeRanges, additionals, removeAll } = buildPlanRangesFromStage(contractId);
  L('BEGIN', { contractId, addRanges, removeRanges, additionals, removeAll });

  // If "remove all" is staged, we only perform the single bulk unplan and exit.
  if (removeAll) {
    let resp = null;

    if (removeRanges.length) {
      const payload = {
        when_timesheet_exists: 'skip',
        empty_week_action: 'delete',
        ranges: removeRanges
      };
      L('DELETE /plan-ranges (removeAll)', payload);
      try {
        resp = await contractsUnplanRanges(contractId, payload);
        L('DELETE /plan-ranges â†', resp);
      } catch (err) {
        E('unplan-ranges (removeAll) failed', err);
        throw err;
      }
    } else {
      L('removeAll=true but no removeRanges built');
    }

    // âœ… NEW: show message
    if (resp) showUnplanSummary(resp, { removeAll: true });

    clearContractCalendarStageState(contractId);
    L('DONE: stage cleared for', contractId);
    return { ok: true, detail: 'calendar saved', removedAll: true, unplan_result: resp || null };
  }

  // Otherwise, proceed with normal sequence: adds â†’ removes â†’ additionals.
  if (addRanges.length) {
    const payload = {
      extend_contract_window: true,
      ranges: addRanges
    };
    L('POST /plan-ranges', payload);
    try {
      const resp = await contractsPlanRanges(contractId, payload);
      L('POST /plan-ranges â†', resp);
      if (!resp || typeof resp !== 'object') W('plan-ranges returned unexpected response', resp);
    } catch (err) {
      E('plan-ranges failed', err);
      throw err;
    }
  } else {
    L('No addRanges to commit');
  }

  if (removeRanges.length) {
    const payload = {
      when_timesheet_exists: 'skip',
      empty_week_action: 'cancel',
      ranges: removeRanges
    };
    L('DELETE /plan-ranges', payload);
    try {
      const resp = await contractsUnplanRanges(contractId, payload);
      L('DELETE /plan-ranges â†', resp);

      // âœ… NEW: show message if blocked weeks exist
      if (resp) showUnplanSummary(resp, { removeAll: false });

    } catch (err) {
      E('unplan-ranges failed', err);
      throw err;
    }
  } else {
    L('No removeRanges to commit');
  }

  if (additionals.length) {
    L('Committing additional weeksâ€¦', { count: additionals.length });
    for (const g of additionals) {
      try {
        L('Create additional for baseWeekId', g.baseWeekId, 'dates=', g.dates);
        const addRow = await contractWeekCreateAdditional(g.baseWeekId);
        L('additional created â†', addRow);
        const payload = { add: g.dates.map(d => ({ date: d })), merge: 'append' };
        L('PATCH /contract-weeks/:id/plan', { week_id: addRow.id, payload });
        const resp = await contractWeekPlanPatch(addRow.id, payload);
        L('PATCH /contract-weeks/:id/plan â†', resp);
      } catch (err) {
        E('additional week flow failed', err);
        throw err;
      }
    }
  } else {
    L('No additional week patches to commit');
  }

  clearContractCalendarStageState(contractId);
  L('DONE: stage cleared for', contractId);
  return { ok: true, detail: 'calendar saved', removedAll: false };
}



async function duplicateContract(contractId, { count } = {}) {
  const n = Number(count || 1);
  if (!Number.isInteger(n) || n < 1 || n > 10) {
    return { ok: false, message: 'count must be an integer between 1 and 10' };
  }

  try {
    const url = API(`/api/contracts/${encodeURIComponent(contractId)}/duplicate`);
    const res = await authFetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ count: n })
    });

    // Non-2xx â†’ try to surface a useful error
    if (!res.ok) {
      let msg = `Duplicate failed (${res.status})`;
      try {
        const txt = await res.text();
        if (txt) msg = txt;
      } catch {}
      return { ok: false, message: msg };
    }

    let data = null;
    try {
      data = await res.json();
    } catch {
      data = null;
    }

    // Backend returns: { source_contract_id, count, duplicates: [...] }
    return {
      ok: true,
      ...(data || {}),
    };
  } catch (e) {
    return {
      ok: false,
      message: e?.message || 'Duplicate failed'
    };
  }
}














































































// ================== Timesheet helpers ==================
async function fetchTimesheetDetails(timesheetId) {
  const LOGM = (typeof window.__LOG_MODAL === 'boolean') ? window.__LOG_MODAL : false;
  const L    = (...a) => { if (LOGM) console.log('[TS][DETAILS]', ...a); };
  const GC   = (label) => { if (LOGM) console.groupCollapsed('[TS][DETAILS]', label); };
  const GE   = () => { if (LOGM) console.groupEnd(); };

  if (!timesheetId) {
    throw new Error('fetchTimesheetDetails: timesheetId is required');
  }

  const encId = encodeURIComponent(timesheetId);
  const url   = API(`/api/timesheets/${encId}/details`);
  GC('request');
  L('â†’ GET', { url, timesheetId });

  let res;
  try {
    res = await authFetch(url);
  } catch (err) {
    L('network error', { url, error: err });
    GE();
    throw err;
  }

  const text = await res.text().catch(() => '');
  let json = null;
  try { json = text ? JSON.parse(text) : {}; } catch { json = null; }

  if (!res.ok) {
    const msg =
      (json && typeof json === 'object' && (json.message || json.error))
        ? String(json.message || json.error)
        : (text || `Timesheet details failed (${res.status})`);

    const err = new Error(msg);
    err.status = res.status;
    err.body = text || '';
    err.json = json;
    L('server error', { status: res.status, bodyPreview: (text || '').slice(0, 400), json });
    GE();
    throw err;
  }

  // If parse failed but HTTP was OK, treat as empty object (defensive)
  if (!json || typeof json !== 'object') json = {};

  const timesheet   = json.timesheet  || null;
  const tsfin       = json.tsfin      || null;
  const validations = Array.isArray(json.validations) ? json.validations : [];
  const shifts      = Array.isArray(json.shifts)      ? json.shifts      : [];

  // âœ… Rotation resolution metadata from backend
  const booking_id             = json.booking_id || (timesheet ? (timesheet.booking_id || null) : null);
  const requested_timesheet_id = json.requested_timesheet_id || timesheetId;
  const current_timesheet_id   =
    json.current_timesheet_id ||
    (timesheet ? (timesheet.timesheet_id || null) : null) ||
    timesheetId;

  const current_version =
    (json.current_version != null)
      ? json.current_version
      : (timesheet ? (timesheet.version ?? null) : null);

  const was_stale = !!json.was_stale;

  // Derive invoice breakdown + segments
  const ib   = tsfin && tsfin.invoice_breakdown_json && typeof tsfin.invoice_breakdown_json === 'object'
    ? tsfin.invoice_breakdown_json
    : null;

  const mode = ib && typeof ib.mode === 'string' ? ib.mode : null;
  const rawSegments = (ib && Array.isArray(ib.segments)) ? ib.segments : [];

  // Normalise segments:
  // - keep segment_id stable if backend provides one
  // - else create a stable fallback based on booking_id + index (NOT timesheet id)
  const segments = rawSegments.map((seg, idx) => {
    const s = (seg && typeof seg === 'object') ? { ...seg } : {};
    const existingId = (s.segment_id != null) ? String(s.segment_id).trim() : '';
    const fallbackId = `seg:${booking_id || 'noBooking'}:${idx}`;
    s.segment_id = existingId || fallbackId;
    s.exclude_from_pay = !!s.exclude_from_pay;
    return s;
  });

  const isSegments = (mode === 'SEGMENTS');

  // âœ… Pass-through + include resolver metadata
  const detail = {
    timesheet,
    tsfin,
    validations,
    shifts,
    segments,
    invoiceBreakdown: ib,
    isSegmentsMode: isSegments,

    // Convenience: surface key fields that backend already returned
    sheet_scope: json.sheet_scope || (timesheet ? (timesheet.sheet_scope || null) : null),
    qr_status: json.qr_status || (timesheet ? (timesheet.qr_status || null) : null),
    qr_generated_at: json.qr_generated_at || null,
    qr_scanned_at: json.qr_scanned_at || null,
    manual_pdf_r2_key: json.manual_pdf_r2_key || (timesheet ? (timesheet.manual_pdf_r2_key || null) : null),

    ready_to_pay: (typeof json.ready_to_pay === 'boolean') ? json.ready_to_pay : null,

    contract_week_id: json.contract_week_id || null,
    contract_week: json.contract_week || null,
    policy: json.policy || null,
    action_flags: (json.action_flags && typeof json.action_flags === 'object') ? json.action_flags : null,

    // âœ… Rotation metadata for callers (openTimesheet + guarded writes)
    booking_id,
    requested_timesheet_id,
    current_timesheet_id,
    current_version,
    was_stale
  };

  L('parsed payload snapshot', {
    hasTimesheet: !!timesheet,
    hasTsfin: !!tsfin,
    validationsCount: validations.length,
    shiftsCount: shifts.length,
    segmentsCount: segments.length,
    mode,
    sheet_scope: detail.sheet_scope,
    qr_status: detail.qr_status,

    ready_to_pay: detail.ready_to_pay,
    hasPolicy: !!detail.policy,
    hasActionFlags: !!detail.action_flags,
    contract_week_id: detail.contract_week_id || null,
    hasContractWeek: !!detail.contract_week,

    booking_id: detail.booking_id,
    requested_timesheet_id: detail.requested_timesheet_id,
    current_timesheet_id: detail.current_timesheet_id,
    current_version: detail.current_version,
    was_stale: detail.was_stale
  });

  GE();
  return detail;
}

async function fetchTimesheetSourceRows(timesheetId, opts = {}) {
  const LOGM = (typeof window.__LOG_MODAL === 'boolean') ? window.__LOG_MODAL : false;
  const L    = (...a) => { if (LOGM) console.log('[TS][SOURCE]', ...a); };
  const GC   = (label) => { if (LOGM) console.groupCollapsed('[TS][SOURCE]', label); };
  const GE   = () => { if (LOGM) console.groupEnd(); };

  if (!timesheetId) {
    throw new Error('fetchTimesheetSourceRows: timesheetId is required');
  }

  const scopeRaw = (opts.scope || 'all').toLowerCase();
  const scope    = scopeRaw === 'shift' ? 'shift' : 'all';
  const shiftId  = scope === 'shift' ? (opts.shiftId || opts.shift_id || '') : '';
  const includeExcluded = !!opts.includeExcluded || !!opts.include_excluded;

  // âœ… NEW: optional filter to fetch only a specific import batch
  const importId = String(opts.importId || opts.import_id || '').trim();

  const qp = new URLSearchParams();
  qp.set('scope', scope);
  if (scope === 'shift' && shiftId) qp.set('shift_id', String(shiftId));
  if (includeExcluded) qp.set('include_excluded', 'true');
  if (importId) qp.set('import_id', importId);

  const encId = encodeURIComponent(timesheetId);
  const url   = API(`/api/timesheets/${encId}/source-print?${qp.toString()}`);

  GC('request');
  L('â†’ GET', { url, timesheetId, scope, shiftId: shiftId || null, includeExcluded, importId: importId || null });

  let res;
  try {
    res = await authFetch(url);
  } catch (err) {
    L('network error', { url, error: err });
    GE();
    throw err;
  }

  let json;
  try {
    const text = await res.text();
    if (!res.ok) {
      L('server error', { status: res.status, bodyPreview: text.slice(0, 400) });
      GE();
      throw new Error(text || `Source rows failed (${res.status})`);
    }
    json = text ? JSON.parse(text) : {};
  } catch (err) {
    L('parse error', { status: res.status, error: err });
    GE();
    throw err;
  }

  const imports = Array.isArray(json.imports) ? json.imports : [];
  const summary = imports.map(i => ({
    source_system: i.source_system,
    import_id: i.import_id,
    header_rows: Array.isArray(i.header_rows) ? i.header_rows.length : 0,
    header_columns: Array.isArray(i.header_columns) ? i.header_columns.length : 0,
    rows: Array.isArray(i.rows) ? i.rows.length : 0
  }));

  L('RESULT', {
    timesheet_id: json.timesheet_id || timesheetId,
    scope: json.scope || scope,
    includes_excluded: json.includes_excluded ?? includeExcluded,
    importsCount: imports.length,
    importsSummary: summary
  });
  GE();
  return json;
}


async function fetchTimesheetRelated(timesheetId) {
  const LOGM = (typeof window.__LOG_MODAL === 'boolean') ? window.__LOG_MODAL : false;
  const L    = (...a) => { if (LOGM) console.log('[TS][RELATED]', ...a); };
  const GC   = (label) => { if (LOGM) console.groupCollapsed('[TS][RELATED]', label); };
  const GE   = () => { if (LOGM) console.groupEnd(); };

  if (!timesheetId) {
    throw new Error('fetchTimesheetRelated: timesheetId is required');
  }

  GC('fetchTimesheetRelated');
  L('START', { timesheetId });

  // 1) Get counts so we know what to request
  let counts = {};
  try {
    counts = await fetchRelatedCounts('timesheet', timesheetId) || {};
    L('counts', counts);
  } catch (err) {
    L('fetchRelatedCounts failed, proceeding with empty counts', err);
    counts = {};
  }

  const toInt = (v) => {
    const n = Number(v);
    return Number.isFinite(n) ? Math.max(0, Math.trunc(n)) : 0;
  };

  // Normalize count keys (backend may emit singular/plural aliases)
  const countCandidate = toInt(counts.candidate ?? counts.candidates ?? 0);
  const countClient    = toInt(counts.client    ?? counts.clients    ?? 0);
  const countInvoice   = toInt(counts.invoice   ?? counts.invoices   ?? counts.invoice_count ?? 0);
  const countUmbrella  = toInt(counts.umbrella  ?? counts.umbrellas  ?? 0);
  const countContract  = toInt(counts.contract  ?? counts.contracts  ?? 0);
  const countSeries    = toInt(counts.series    ?? 0);

  const out = {
    counts,

    candidate: null,
    client:    null,

    // âœ… NEW: many-to-many invoices
    invoices: [],
    // Back-compat single invoice (do not rely on this; kept for legacy readers)
    invoice: null,

    // âœ… NEW: invoice id -> invoice no (used by Lines tab "Invoiced â€“ INV...")
    invoice_no_by_invoice_id: {},

    umbrella:  null,
    contract:  null,
    series:    []
  };

  // Helper to safely fetch related items (tolerate both list shapes)
  const safeFetch = async (typeKey, label) => {
    try {
      const res = await fetchRelated('timesheet', timesheetId, typeKey);

      // tolerate both shapes: array OR {items,total}
      const items = Array.isArray(res?.items) ? res.items : (Array.isArray(res) ? res : []);
      L(`related[${label}]`, { count: items.length, sample: items[0] || null });

      return items;
    } catch (err) {
      L(`related[${label}] failed`, err);
      return [];
    }
  };

  // Candidate (0/1)
  if (countCandidate > 0) {
    const items = await safeFetch('candidate', 'candidate');
    out.candidate = items[0] || null;
  }

  // Client (0/1)
  if (countClient > 0) {
    const items = await safeFetch('client', 'client');
    out.client = items[0] || null;
  }

  // âœ… Invoices (0..n) â€” segment-aware many-to-many
  if (countInvoice > 0) {
    const items = await safeFetch('invoice', 'invoice');

    out.invoices = Array.isArray(items) ? items : [];
    out.invoice  = out.invoices[0] || null; // back-compat only

    // Build invoice_no_by_invoice_id map for downstream use
    const map = {};
    for (const it of out.invoices) {
      if (!it || typeof it !== 'object') continue;

      // tolerate possible keys
      const iid =
        (it.invoice_id != null ? String(it.invoice_id) : '') ||
        (it.id != null ? String(it.id) : '');

      if (!iid) continue;

      const ino =
        (it.invoice_no != null && String(it.invoice_no).trim())
          ? String(it.invoice_no).trim()
          : '';

      if (ino) map[iid] = ino;
    }
    out.invoice_no_by_invoice_id = map;
  }

  // Umbrella (0/1)
  if (countUmbrella > 0) {
    const items = await safeFetch('umbrella', 'umbrella');
    out.umbrella = items[0] || null;
  }

  // Contract (0/1)
  if (countContract > 0) {
    const items = await safeFetch('contract', 'contract');
    out.contract = items[0] || null;
  }

  // Series (already "other timesheets in series" from SQL; do not subtract in UI)
  if (countSeries > 0) {
    const items = await safeFetch('series', 'series');
    out.series = Array.isArray(items) ? items : [];
  }

  L('RESULT', {
    hasCandidate: !!out.candidate,
    hasClient: !!out.client,
    invoiceCount: out.invoices.length,
    hasUmbrella: !!out.umbrella,
    hasContract: !!out.contract,
    seriesCount: out.series.length,
    invoiceNoMapKeys: Object.keys(out.invoice_no_by_invoice_id || {}).length
  });
  GE();
  return out;
}


// NEW: Electronic signatures evidence viewer
// Expects backend evidence item with preview_mode: 'SIGNATURES' and meta/meta_json containing booking_id,
// authorised_at_server, auth_name, auth_job_title, and (optionally) worked/weekly details.
async function openTimesheetEvidenceViewerSignatures(ev) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][EVIDENCE][SIG_VIEW]');
  GC('openTimesheetEvidenceViewerSignatures');

  if (!ev || typeof ev !== 'object') {
    GE();
    throw new Error('Evidence item is required.');
  }

  const mc = window.modalCtx || {};
  const ts = mc?.timesheetDetails?.timesheet || null;

  const meta =
    (ev && typeof ev.meta === 'object' && ev.meta) ? ev.meta :
    (ev && typeof ev.meta_json === 'object' && ev.meta_json) ? ev.meta_json :
    {};

  const bookingId = meta.booking_id ? String(meta.booking_id).trim() : '';
  if (!bookingId) {
    GE();
    throw new Error('Electronic evidence missing booking_id.');
  }

  const version = (meta.version != null && Number.isFinite(Number(meta.version))) ? Number(meta.version) : null;

  const authName = meta.auth_name ? String(meta.auth_name) : '';
  const authJob  = meta.auth_job_title ? String(meta.auth_job_title) : '';
  const authAt   = meta.authorised_at_server ? String(meta.authorised_at_server) : (ev.created_at ? String(ev.created_at) : '');

  const fmtUkDateTime = (iso) => {
    if (!iso) return 'â€”';
    const d = new Date(iso);
    if (Number.isNaN(d.getTime())) return String(iso);
    try {
      return d.toLocaleString('en-GB', {
        timeZone: 'Europe/London',
        weekday: 'short',
        day: '2-digit',
        month: 'short',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        hour12: false
      });
    } catch {
      return d.toISOString();
    }
  };

  // Shift summary: prefer loaded timesheetDetails, fallback to meta fields.
  const scope = String((ts?.sheet_scope || meta.sheet_scope || '')).toUpperCase();
  const summaryLines = [];

  if (scope === 'DAILY') {
    const s = (ts?.worked_start_iso || meta.worked_start_iso) ? String(ts?.worked_start_iso || meta.worked_start_iso) : '';
    const e = (ts?.worked_end_iso || meta.worked_end_iso) ? String(ts?.worked_end_iso || meta.worked_end_iso) : '';
    const bs = (ts?.break_start_iso || meta.break_start_iso) ? String(ts?.break_start_iso || meta.break_start_iso) : '';
    const be = (ts?.break_end_iso || meta.break_end_iso) ? String(ts?.break_end_iso || meta.break_end_iso) : '';
    const bm = (ts?.break_minutes != null ? ts.break_minutes : meta.break_minutes) != null
      ? String(ts?.break_minutes != null ? ts.break_minutes : meta.break_minutes)
      : '';

    if (s && e) summaryLines.push(`Worked: ${s} â†’ ${e}`);
    if (bs && be) summaryLines.push(`Break: ${bs} â†’ ${be}`);
    else if (bm) summaryLines.push(`Break minutes: ${bm}`);
  } else if (scope === 'WEEKLY') {
    const we = (ts?.week_ending_date || meta.week_ending_date) ? String(ts?.week_ending_date || meta.week_ending_date) : '';
    if (we) summaryLines.push(`Week ending: ${we}`);

    const sched = Array.isArray(ts?.actual_schedule_json) ? ts.actual_schedule_json :
                  Array.isArray(meta.actual_schedule_json) ? meta.actual_schedule_json :
                  null;
    if (sched) summaryLines.push(`Shifts: ${sched.length}`);
  }

  // Presign signature URLs (batch)
  let nurseUrl = null;
  let authUrl = null;

  try {
    const presRes = await authFetch(API('/signatures/presign-get/batch'), {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        items: [
          { booking_id: bookingId, which: 'nurse', ...(version != null ? { version } : {}) },
          { booking_id: bookingId, which: 'authoriser', ...(version != null ? { version } : {}) }
        ],
        expires_seconds: 600
      })
    });

    const presTxt = await presRes.text().catch(() => '');
    if (!presRes.ok) throw new Error(presTxt || 'Failed to presign signature URLs');

    const presJson = presTxt ? JSON.parse(presTxt) : {};
    const links = Array.isArray(presJson.links) ? presJson.links : [];

    nurseUrl = (links.find(x => String(x?.which || '') === 'nurse') || {}).get_url || null;
    authUrl  = (links.find(x => String(x?.which || '') === 'authoriser') || {}).get_url || null;
  } catch (e) {
    // We still render modal with metadata; panels will show Not available.
    try { window.__toast && window.__toast(e?.message || 'Failed to load signatures'); } catch {}
  }

  const title = `Electronic evidence ${String((ts?.timesheet_id || mc?.data?.timesheet_id || '')).slice(0, 8)}â€¦`;

  const bodyHtml = `
    <div class="tabc">
      <div class="card">
        <div class="row">
          <label>Authorised at server</label>
          <div class="controls">
            <span class="mini">${escapeHtml(fmtUkDateTime(authAt))}</span>
          </div>
        </div>
        <div class="row">
          <label>Authoriser</label>
          <div class="controls">
            <span class="mini">${escapeHtml([authName, authJob].filter(Boolean).join(' â€” ') || 'â€”')}</span>
          </div>
        </div>
        <div class="row">
          <label>Shift details</label>
          <div class="controls">
            <div class="mini" style="opacity:.9;">
              ${summaryLines.length ? summaryLines.map(x => `<div>${escapeHtml(x)}</div>`).join('') : 'â€”'}
            </div>
          </div>
        </div>
      </div>

      <div class="card" style="margin-top:10px;">
        <div class="row">
          <label>Signatures</label>
          <div class="controls" style="display:flex; gap:12px; flex-wrap:wrap;">
            <div style="flex:1; min-width:240px;">
              <div class="mini" style="opacity:.85; margin-bottom:6px;">Nurse signature</div>
          ${nurseUrl
  ? `
    <div style="background:#fff; padding:10px; border:1px solid var(--line); border-radius:8px; display:inline-block;">
      <img
        src="${nurseUrl}"
        style="display:block; max-width:100%; max-height:260px; background:transparent; filter:brightness(0) contrast(1.35);"
      />
    </div>
  `
  : `<div class="mini" style="opacity:.85;">Not available</div>`}

            </div>

            <div style="flex:1; min-width:240px;">
              <div class="mini" style="opacity:.85; margin-bottom:6px;">Authoriser signature</div>
            ${authUrl
  ? `
    <div style="background:#fff; padding:10px; border:1px solid var(--line); border-radius:8px; display:inline-block;">
      <img
        src="${authUrl}"
        style="display:block; max-width:100%; max-height:260px; background:transparent; filter:brightness(0) contrast(1.35);"
      />
    </div>
  `
  : `<div class="mini" style="opacity:.85;">Not available</div>`}

            </div>
          </div>
        </div>
      </div>
    </div>
  `;

  showModal(
    title,
    [{ key: 'view', title: 'Evidence' }],
    () => bodyHtml,
    async () => ({ ok: true }),
    false,
    undefined,
    { kind: 'timesheet-evidence-signatures', noParentGate: true, forceEdit: true }
  );

  GE();
}





// ======== Timesheet tab helpers ========

function getTsLoggers(ns) {
  const LOGM = (typeof window.__LOG_MODAL === 'boolean') ? window.__LOG_MODAL : false;
  return {
    LOGM,
    L:  (...a) => { if (LOGM) console.log(ns, ...a); },
    GC: (label) => { if (LOGM) console.groupCollapsed(ns, label); },
    GE: () => { if (LOGM) console.groupEnd(); }
  };
}


function normaliseTimesheetCtx(ctx) {
  const baseCtx = ctx || {};
  const mc = window.modalCtx || {};

  // Summary row from v_timesheets_summary
  const row =
    baseCtx.row ||
    baseCtx.data ||
    mc.data ||
    {};

  // Details from fetchTimesheetDetails
  const details =
    baseCtx.details ||
    mc.timesheetDetails ||
    {
      timesheet: null,
      tsfin: null,
      validations: [],
      shifts: [],
      segments: [],
      isSegmentsMode: false,
      invoiceBreakdown: null,
      sheet_scope: row.sheet_scope || null,
      qr_status: row.qr_status || null,

      // âœ… carry-through ready_to_pay so Overview can use it even without TSFIN
      ready_to_pay: (typeof row.ready_to_pay === 'boolean') ? row.ready_to_pay : null,

      // âœ… keep optional enriched fields consistent with fetchTimesheetDetails()
      contract_week_id: row.contract_week_id || null,
      contract_week: null,
      policy: null,
      action_flags: null
    };

  // âœ… if details didn't include ready_to_pay (older backend), fall back to row
  if (typeof details.ready_to_pay !== 'boolean' && typeof row.ready_to_pay === 'boolean') {
    details.ready_to_pay = row.ready_to_pay;
  }

  // Related entities from fetchTimesheetRelated
  const related =
    baseCtx.related ||
    mc.timesheetRelated ||
    {
      counts: {},
      candidate: null,
      client: null,
      invoice: null,
      umbrella: null,
      contract: null,
      series: []
    };

  // Timesheet-ui state (staging for future Save)
  if (!mc.timesheetState || typeof mc.timesheetState !== 'object') {
    mc.timesheetState = {
      reference: null,
      payHoldDesired: null,
      payHoldReason: '',
      markPaid: false,
      segmentOverrides: {},
      nhspDeferrals: {},
      additionalRates: {},

      weeklyLinesByDate: {},
      extraShiftCount: 0,

      scheduleHasErrors: false,
      scheduleErrorsByDate: {},

      // âœ… Expenses always present (stable shape)
      expensesDraft: null,
      expensesBaseline: null,

      // âœ… internal marker to avoid re-seeding on every render
      __expensesSeededFromTsfinCols: false
    };
  } else {
    if (!mc.timesheetState.additionalRates || typeof mc.timesheetState.additionalRates !== 'object') {
      mc.timesheetState.additionalRates = {};
    }

    if (!mc.timesheetState.weeklyLinesByDate || typeof mc.timesheetState.weeklyLinesByDate !== 'object') {
      mc.timesheetState.weeklyLinesByDate = {};
    }

    if (!Number.isFinite(Number(mc.timesheetState.extraShiftCount))) {
      mc.timesheetState.extraShiftCount = 0;
    } else {
      mc.timesheetState.extraShiftCount = Number(mc.timesheetState.extraShiftCount);
    }

    if (typeof mc.timesheetState.scheduleHasErrors !== 'boolean') {
      mc.timesheetState.scheduleHasErrors = false;
    }
    if (!mc.timesheetState.scheduleErrorsByDate || typeof mc.timesheetState.scheduleErrorsByDate !== 'object') {
      mc.timesheetState.scheduleErrorsByDate = {};
    }

    if (!mc.timesheetState.expensesDraft || typeof mc.timesheetState.expensesDraft !== 'object') {
      mc.timesheetState.expensesDraft = null;
    }
    if (!mc.timesheetState.expensesBaseline || typeof mc.timesheetState.expensesBaseline !== 'object') {
      mc.timesheetState.expensesBaseline = null;
    }
    if (typeof mc.timesheetState.__expensesSeededFromTsfinCols !== 'boolean') {
      mc.timesheetState.__expensesSeededFromTsfinCols = false;
    }
  }

  const state = mc.timesheetState;

  // Ensure modalCtx has these attached for other code to use
  window.modalCtx = mc;
  if (!mc.timesheetDetails) mc.timesheetDetails = details;
  if (!mc.timesheetRelated) mc.timesheetRelated = related;

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // âœ… Expenses draft/baseline
  // - Amounts are seeded ONLY from TSFIN numeric columns
  // - expenses_description is treated as notes/meta only (optional)
  // - Backward-compat amounts-from-JSON is NOT used (per your instruction)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const tsfinLocal = (details && details.tsfin && typeof details.tsfin === 'object') ? details.tsfin : null;

  // Stable draft shape used by UI
  const defaultDraft = {
    mileage_units: 0,
    travel_pay: 0,
    travel_charge: 0,
    accommodation_pay: 0,
    accommodation_charge: 0,
    other_pay: 0,
    other_charge: 0,

    // optional notes/meta (safe even if UI doesn't render it yet)
    note: ''
  };

  const num0 = (v) => {
    const n = Number(v);
    return Number.isFinite(n) ? n : 0;
  };

  const extractNote = (desc) => {
    // notes/meta only; do NOT interpret legacy JSON as amounts
    if (desc == null) return '';
    if (typeof desc === 'string') {
      const s = desc.trim();
      if (!s) return '';
      // if it's JSON, only accept {note} / {notes}; otherwise treat as plain text
      try {
        const j = JSON.parse(s);
        if (j && typeof j === 'object') {
          const n1 = (typeof j.note === 'string') ? j.note.trim() : '';
          const n2 = (!n1 && typeof j.notes === 'string') ? j.notes.trim() : '';
          return n1 || n2 || '';
        }
      } catch {}
      return s;
    }
    if (typeof desc === 'object') {
      const n1 = (typeof desc.note === 'string') ? desc.note.trim() : '';
      const n2 = (!n1 && typeof desc.notes === 'string') ? desc.notes.trim() : '';
      return n1 || n2 || '';
    }
    return '';
  };

  // Draft derived from TSFIN numeric columns (canonical source)
  const draftFromTsfinCols = (() => {
    if (!tsfinLocal) return { ...defaultDraft };

    return {
      mileage_units: num0(tsfinLocal.mileage_units ?? 0),

      // âœ… NEW canonical TSFIN columns
      travel_pay: num0(tsfinLocal.travel_pay_ex_vat ?? 0),
      travel_charge: num0(tsfinLocal.travel_charge_ex_vat ?? 0),

      accommodation_pay: num0(tsfinLocal.accommodation_pay_ex_vat ?? 0),
      accommodation_charge: num0(tsfinLocal.accommodation_charge_ex_vat ?? 0),

      other_pay: num0(tsfinLocal.other_pay_ex_vat ?? 0),
      other_charge: num0(tsfinLocal.other_charge_ex_vat ?? 0),

      // notes/meta only
      note: extractNote(tsfinLocal.expenses_description)
    };
  })();

  // Helper: compare only the canonical numeric fields (ignore note)
  const sameCoreNumbers = (a, b) => {
    const keys = [
      'mileage_units',
      'travel_pay','travel_charge',
      'accommodation_pay','accommodation_charge',
      'other_pay','other_charge'
    ];
    for (const k of keys) {
      if (num0(a?.[k]) !== num0(b?.[k])) return false;
    }
    return true;
  };

  // Seed/migrate state.expensesDraft + baseline:
  // - If missing => seed from TSFIN columns
  // - If present but untouched (draft == baseline) AND not yet seeded-from-cols => migrate to TSFIN cols
  if (!state.expensesDraft || typeof state.expensesDraft !== 'object') {
    state.expensesDraft = JSON.parse(JSON.stringify(draftFromTsfinCols));
    state.__expensesSeededFromTsfinCols = true;
  } else {
    // Ensure required keys exist (and keep any user-added keys)
    for (const k of Object.keys(defaultDraft)) {
      if (!Object.prototype.hasOwnProperty.call(state.expensesDraft, k)) {
        state.expensesDraft[k] = defaultDraft[k];
      }
    }

    // One-time migration if the existing draft looks like an initial seed (not edited)
    if (
      tsfinLocal &&
      state.expensesBaseline &&
      typeof state.expensesBaseline === 'object' &&
      !state.__expensesSeededFromTsfinCols &&
      sameCoreNumbers(state.expensesDraft, state.expensesBaseline)
    ) {
      state.expensesDraft = JSON.parse(JSON.stringify(draftFromTsfinCols));
      state.expensesBaseline = JSON.parse(JSON.stringify(draftFromTsfinCols));
      state.__expensesSeededFromTsfinCols = true;
    }
  }

  // Baseline (for save diff) â€” seed if missing
  if (!state.expensesBaseline || typeof state.expensesBaseline !== 'object') {
    state.expensesBaseline = JSON.parse(JSON.stringify(state.expensesDraft));
  } else {
    // Ensure required keys exist in baseline too
    for (const k of Object.keys(defaultDraft)) {
      if (!Object.prototype.hasOwnProperty.call(state.expensesBaseline, k)) {
        state.expensesBaseline[k] = defaultDraft[k];
      }
    }
  }

  return { row, details, related, state };
}


function renderTimesheetExpensesTab(ctx) {
  const c = normaliseTimesheetCtx(ctx);
  const row     = c.row || {};
  const details = c.details || {};
  const state   = c.state || {};

  const ts   = (details.timesheet && typeof details.timesheet === 'object') ? details.timesheet : null;
  const tf   = (details.tsfin && typeof details.tsfin === 'object') ? details.tsfin : null;

  const hasTs  = !!(ts && ts.timesheet_id);
  const hasFin = !!tf;

  const subMode = String(ts?.submission_mode || row.submission_mode || '').toUpperCase();
  const qrStatusRaw = (ts && Object.prototype.hasOwnProperty.call(ts, 'qr_status')) ? ts.qr_status : (row.qr_status ?? null);
  const hasQr = !!(qrStatusRaw && String(qrStatusRaw).trim());

  const enabled = !!(hasTs && hasFin && (subMode === 'MANUAL' || hasQr));
  const locked  = !!(tf && (tf.locked_by_invoice_id || tf.paid_at_utc));

  const draft = (state.expensesDraft && typeof state.expensesDraft === 'object')
    ? state.expensesDraft
    : {
        mileage_units: 0,
        travel_pay: 0, travel_charge: 0,
        accommodation_pay: 0, accommodation_charge: 0,
        other_pay: 0, other_charge: 0,
        note: ''
      };

  const round2 = (n) => Math.round((Number(n) || 0) * 100) / 100;
  const fmt2 = (n) => {
    const x = Number(n);
    return Number.isFinite(x) ? x.toFixed(2) : '0.00';
  };

  const mileagePayRate    = (tf && tf.mileage_pay_rate != null) ? Number(tf.mileage_pay_rate) : null;
  const mileageChargeRate = (tf && tf.mileage_charge_rate != null) ? Number(tf.mileage_charge_rate) : null;

  const mileageRatesOk =
    Number.isFinite(mileagePayRate) &&
    Number.isFinite(mileageChargeRate) &&
    mileagePayRate > 0 &&
    mileageChargeRate > 0;

  const mileageUnits = Number(draft.mileage_units || 0);
  const mileagePay   = mileageRatesOk ? round2(mileageUnits * mileagePayRate) : 0;
  const mileageChg   = mileageRatesOk ? round2(mileageUnits * mileageChargeRate) : 0;

  const travelPay = round2(draft.travel_pay || 0);
  const travelChg = round2(draft.travel_charge || 0);

  const accomPay = round2(draft.accommodation_pay || 0);
  const accomChg = round2(draft.accommodation_charge || 0);

  const otherPay = round2(draft.other_pay || 0);
  const otherChg = round2(draft.other_charge || 0);

  const totalPay = round2(mileagePay + travelPay + accomPay + otherPay);
  const totalChg = round2(mileageChg + travelChg + accomChg + otherChg);

  // Evidence requirements (UX guidance only; hard enforcement happens on Save)
  const needsMileageEvidence = mileageUnits > 0;
  const needsTravelEvidence  = travelChg > 0;
  const needsAccomEvidence   = accomChg > 0;
  const needsOtherEvidence   = otherChg > 0;

  const evidenceLines = [];
  if (needsMileageEvidence) evidenceLines.push('â€¢ Mileage requires evidence kind MILEAGE (when units > 0).');
  if (needsTravelEvidence)  evidenceLines.push('â€¢ Travel requires evidence kind TRAVEL (when charge > Â£0.00).');
  if (needsAccomEvidence)   evidenceLines.push('â€¢ Accommodation requires evidence kind ACCOMMODATION (when charge > Â£0.00).');
  if (needsOtherEvidence)   evidenceLines.push('â€¢ Other requires evidence kind OTHER (when charge > Â£0.00).');

  const evidenceHint =
    evidenceLines.length
      ? `<div class="mini" style="margin-top:8px;color:rgba(255,200,120,0.95)">${evidenceLines.join('<br/>')}</div>`
      : `<div class="mini" style="margin-top:8px;color:rgba(255,255,255,0.7)">Tip: upload receipts in the Evidence tab. Evidence is required only when you claim mileage/charges.</div>`;

  if (!enabled) {
    const reason =
      !hasTs ? 'Expenses are available once a timesheet exists.' :
      (!hasFin ? 'Expenses are unavailable until a TSFIN snapshot exists.' :
      'Expenses are available for Manual or QR timesheets.');

    return `
      <div class="tabc">
        <div class="card">
          <div class="row" style="grid-column:1/-1">
            <label>Expenses</label>
            <div class="controls">
              <span class="mini">${reason}</span>
              <div class="mini" style="margin-top:6px;opacity:.85">
                Tip: use <strong>Add additional manual timesheet</strong> to process expenses when the original sheet is locked or non-manual.
              </div>
            </div>
          </div>
        </div>
      </div>
    `;
  }

  const ro = locked ? 'disabled' : '';
  const roStyle = locked ? 'style="opacity:0.7"' : '';

  const mileageUnitsDisabled = (!mileageRatesOk || locked) ? 'disabled' : '';
  const mileageHint =
    !mileageRatesOk
      ? `<div class="mini" style="margin-top:6px;color:rgba(255,200,120,0.95)">Mileage rates not set (contract/global fallback missing). Mileage is disabled.</div>`
      : `<div class="mini" style="margin-top:6px;color:rgba(255,255,255,0.7)">Mileage pay Â£${fmt2(mileagePayRate)} Â· Charge Â£${fmt2(mileageChargeRate)}</div>`;

  const lockHint = locked
    ? `<div class="mini" style="margin-top:8px;color:rgba(255,200,120,0.95)">This timesheet is locked (paid or invoiced). Expenses are read-only.</div>`
    : ``;

  const noteVal = String(draft.note ?? '').trim();

  return `
    <div class="tabc">
      <div class="card">
        <div class="row" style="grid-column:1/-1">
          <label>Expenses</label>
          <div class="controls">
            <span class="mini">Edit expenses and mileage. Charges with Â£0.00 will not appear on invoices.</span>
            ${lockHint}
          </div>
        </div>

        <div class="row" style="grid-column:1/-1;margin-top:10px">
          <div style="overflow:auto;border:1px solid var(--line);border-radius:10px">
            <table class="grid" style="min-width:720px;table-layout:auto">
              <thead>
                <tr>
                  <th style="width:220px">Expense Type</th>
                  <th style="width:140px">Units</th>
                  <th style="width:160px">Pay</th>
                  <th style="width:160px">Charge</th>
                </tr>
              </thead>
              <tbody>

                <!-- Mileage -->
                <tr>
                  <td><strong>Mileage</strong></td>
                  <td>
                    <input
                      class="input"
                      type="number"
                      step="0.01"
                      min="0"
                      name="exp_mileage_units"
                      value="${String(mileageUnits)}"
                      ${mileageUnitsDisabled}
                      ${roStyle}
                      data-exp-field="mileage_units"
                      placeholder="0"
                    />
                  </td>
                  <td><span class="mini" data-exp-out="mileage_pay">Â£${fmt2(mileagePay)}</span></td>
                  <td><span class="mini" data-exp-out="mileage_charge">Â£${fmt2(mileageChg)}</span></td>
                </tr>
                <tr>
                  <td colspan="4" style="padding-top:6px;padding-bottom:10px">
                    ${mileageHint}
                  </td>
                </tr>

                <!-- Travel -->
                <tr>
                  <td><strong>Travel</strong></td>
                  <td><span class="mini" style="opacity:.7">â€”</span></td>
                  <td>
                    <input class="input" type="number" step="0.01" name="exp_travel_pay"
                      value="${fmt2(travelPay)}" ${ro} ${roStyle} data-exp-field="travel_pay" />
                  </td>
                  <td>
                    <input class="input" type="number" step="0.01" name="exp_travel_charge"
                      value="${fmt2(travelChg)}" ${ro} ${roStyle} data-exp-field="travel_charge" />
                  </td>
                </tr>

                <!-- Accommodation -->
                <tr>
                  <td><strong>Accommodation</strong></td>
                  <td><span class="mini" style="opacity:.7">â€”</span></td>
                  <td>
                    <input class="input" type="number" step="0.01" name="exp_accom_pay"
                      value="${fmt2(accomPay)}" ${ro} ${roStyle} data-exp-field="accommodation_pay" />
                  </td>
                  <td>
                    <input class="input" type="number" step="0.01" name="exp_accom_charge"
                      value="${fmt2(accomChg)}" ${ro} ${roStyle} data-exp-field="accommodation_charge" />
                  </td>
                </tr>

                <!-- Other -->
                <tr>
                  <td><strong>Other</strong></td>
                  <td><span class="mini" style="opacity:.7">â€”</span></td>
                  <td>
                    <input class="input" type="number" step="0.01" name="exp_other_pay"
                      value="${fmt2(otherPay)}" ${ro} ${roStyle} data-exp-field="other_pay" />
                  </td>
                  <td>
                    <input class="input" type="number" step="0.01" name="exp_other_charge"
                      value="${fmt2(otherChg)}" ${ro} ${roStyle} data-exp-field="other_charge" />
                  </td>
                </tr>

                <!-- Total -->
                <tr>
                  <td><strong>Total</strong></td>
                  <td></td>
                  <td><strong class="mini" data-exp-out="total_pay">Â£${fmt2(totalPay)}</strong></td>
                  <td><strong class="mini" data-exp-out="total_charge">Â£${fmt2(totalChg)}</strong></td>
                </tr>

              </tbody>
            </table>
          </div>
        </div>

        <div class="row" style="grid-column:1/-1;margin-top:10px">
          <div class="mini" style="color:rgba(255,255,255,0.7)">
            Notes (optional). Notes do not affect totals or invoice maths.
          </div>
        </div>

        <div class="row" style="grid-column:1/-1;margin-top:6px">
          <textarea
            class="input"
            style="width:100%;min-height:90px;resize:vertical"
            name="exp_note"
            placeholder="Add any notes about these expenses (optional)â€¦"
            data-exp-field="note"
            ${ro}
            ${roStyle}
          >${noteVal}</textarea>
        </div>

        <div class="row" style="grid-column:1/-1;margin-top:10px">
          <div class="mini" style="color:rgba(255,255,255,0.7)">
            Note: Evidence enforcement happens on Save. If required evidence is missing, Save will fail with an â€œEvidence requiredâ€ message and you should upload receipts in the Evidence tab.
          </div>
          ${evidenceHint}
        </div>
      </div>
    </div>
  `;
}



// Utility: map route_type / status to pill CSS classes
function classifyTimesheetPill(kind, value) {
  const v = String(value || '').toUpperCase();
  switch (kind) {
    case 'stage':
      if (v === 'PAID') return 'pill pill-ok';
      if (v === 'INVOICED') return 'pill pill-info';
      if (v === 'READY_FOR_INVOICE') return 'pill pill-info';
      if (v === 'READY_FOR_HR') return 'pill pill-info';
      if (v === 'PENDING_AUTH') return 'pill pill-warn';
      if (v === 'NEEDS_ATTENTION') return 'pill pill-bad';
      return 'pill pill-muted';

    case 'route':
      if (v.startsWith('WEEKLY_NHSP')) return 'pill pill-nhsp';
      if (v === 'WEEKLY_HEALTHROSTER') return 'pill pill-hr';
      if (v.startsWith('WEEKLY')) return 'pill pill-weekly';
      if (v.startsWith('DAILY')) return 'pill pill-daily';
      return 'pill pill-muted';

    case 'scope':
      return (v === 'WEEKLY')
        ? 'pill pill-weekly'
        : (v === 'DAILY' ? 'pill pill-daily' : 'pill pill-muted');

    case 'mode':
      return (v === 'ELECTRONIC')
        ? 'pill pill-elec'
        : (v === 'MANUAL' ? 'pill pill-manual' : 'pill pill-muted');

    default:
      return 'pill pill-muted';
  }
}

function computeRequiresTimesheetAuthorisation(details, row) {
  const ts = (details && details.timesheet) ? details.timesheet : {};
  const tsfin = (details && details.tsfin) ? details.tsfin : {};

  const authorisedAt =
    (ts && ts.authorised_at_server) ||
    (row && row.authorised_at_server) ||
    null;

  const authorised = !!authorisedAt;

  const procStatusRaw =
    (tsfin && tsfin.processing_status) ||
    (details && details.processing_status) ||
    (row && row.processing_status) ||
    '';

  const procStatus = String(procStatusRaw || '').toUpperCase();

  const policy =
    (details && details.policy) ||
    (details && details.tsfin_policy) ||
    {};

  const boolish = (v) => {
    if (v === true) return true;
    if (v === false) return false;
    if (v == null) return false;
    const s = String(v).trim().toLowerCase();
    return (s === 'true' || s === '1' || s === 'yes' || s === 'y' || s === 'on');
  };

  // âœ… Prefer contract-resolved effective flags from the SUMMARY ROW
  // âœ… Fallback to policy using boolish (not !!) to avoid "false" -> true
  const requiresHr =
    (row && Object.prototype.hasOwnProperty.call(row, 'client_requires_hr'))
      ? boolish(row.client_requires_hr)
      : boolish(policy && policy.requires_hr);

  const autoprocessHr =
    (row && Object.prototype.hasOwnProperty.call(row, 'client_autoprocess_hr'))
      ? boolish(row.client_autoprocess_hr)
      : boolish(policy && policy.autoprocess_hr);

  const requires =
    (procStatus === 'PENDING_AUTH') ||
    (requiresHr && !autoprocessHr && procStatus === 'READY_FOR_HR');

  const showAwaitingBadge = requires && !authorised;

  return { requires, authorised, showAwaitingBadge };
}

function computeTimesheetProcessingState(details, row) {
  const ts = (details && details.timesheet) ? details.timesheet : {};
  const tsfin = (details && details.tsfin) ? details.tsfin : {};

  const authInfo = (typeof computeRequiresTimesheetAuthorisation === 'function')
    ? computeRequiresTimesheetAuthorisation(details, row)
    : { requires: false, authorised: false, showAwaitingBadge: false };

  const requiresAuth = !!authInfo.requires;
  const authorised = !!authInfo.authorised;

  const invoiced =
    !!((tsfin && tsfin.locked_by_invoice_id) || (row && row.locked_by_invoice_id));

  const paid =
    !!((tsfin && tsfin.paid_at_utc) || (row && row.paid_at_utc));

  // Determine if this is a planned/unprocessed week (no real timesheet exists)
  // We treat â€œreal timesheet existsâ€ as: timesheet_id present either on details.timesheet or row.
  const hasRealTs =
    !!((ts && ts.timesheet_id) || (row && row.timesheet_id));

  // Priority order (must be mutually exclusive)
  if (requiresAuth && !authorised) {
    return { key: 'AWAITING_AUTHORISATION', label: 'Awaiting Authorisation' };
  }

  if (authorised && invoiced && paid) {
    return { key: 'AUTH_INVOICED_PAID', label: 'Authorised, Invoiced & Paid' };
  }

  if (authorised && invoiced && !paid) {
    return { key: 'AUTH_INVOICED_NOT_PAID', label: 'Authorised, Invoiced but not yet Paid' };
  }

  if (authorised && paid && !invoiced) {
    return { key: 'AUTH_PAID_NOT_INVOICED', label: 'Authorised, Paid but not yet Invoiced' };
  }

  if (authorised && !invoiced && !paid) {
    return { key: 'AUTH_NOT_INVOICED_NOT_PAID', label: 'Authorised, not invoiced, not paid' };
  }

  if (invoiced && !authorised) {
    return { key: 'INVOICED', label: 'Invoiced' };
  }

  if (paid && !authorised) {
    return { key: 'PAID', label: 'Paid' };
  }

  if (hasRealTs) {
    return { key: 'PROCESSED', label: 'Processed' };
  }

  return { key: 'UNPROCESSED', label: 'Unprocessed' };
}

async function openTimesheetEvidenceViewerExisting(evidenceItem) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][EVIDENCE][VIEWER]');
  GC('openTimesheetEvidenceViewerExisting');

  if (!evidenceItem || typeof evidenceItem !== 'object') {
    GE();
    throw new Error('Evidence item is required.');
  }

  const mc = window.modalCtx || {};
  const tsId =
    mc.data?.timesheet_id ||
    mc.data?.id ||
    (mc.timesheetDetails && mc.timesheetDetails.timesheet && mc.timesheetDetails.timesheet.timesheet_id) ||
    null;

  if (!tsId) {
    GE();
    throw new Error('Timesheet context missing; cannot view evidence.');
  }

  const tsIdNow = () =>
    window.modalCtx?.data?.timesheet_id ||
    window.modalCtx?.data?.id ||
    null;

  const expectedNow = () =>
    window.modalCtx?.timesheetMeta?.expected_timesheet_id ||
    tsIdNow();

  const handleMovedInViewer = async (err, label) => {
    const st = err?.status ?? null;
    const j  = err?.json || null;

    if (!(st === 409 && j && j.error === 'TIMESHEET_MOVED' && j.current_timesheet_id)) {
      return false;
    }

    const newId = String(j.current_timesheet_id);

    try {
      window.modalCtx ||= {};
      window.modalCtx.data ||= {};
      window.modalCtx.timesheetMeta ||= {};

      window.modalCtx.data.timesheet_id = newId;
      window.modalCtx.data.id = newId;
      window.modalCtx.timesheetMeta.expected_timesheet_id = newId;
    } catch {}

    // Refresh details + evidence list on the new id
    try {
      const fresh = await fetchTimesheetDetails(newId);
      window.modalCtx.timesheetDetails = fresh;
    } catch {}

    try {
      if (typeof refreshTimesheetEvidenceIntoModalState === 'function') {
        await refreshTimesheetEvidenceIntoModalState(newId);
      }
    } catch {}

    try {
      if (typeof refreshTimesheetsSummaryAfterRotation === 'function') {
        refreshTimesheetsSummaryAfterRotation(newId);
      }
    } catch {}

    try { window.__toast && window.__toast('This timesheet changed while you were editing; review and try again.'); } catch {}

    // Close viewer (parent will be set to Evidence tab by onDismiss)
    try { document.getElementById('btnCloseModal')?.click(); } catch {}

    return true;
  };

  const evidenceId = evidenceItem.id != null ? String(evidenceItem.id) : '';
  const previewMode = String(evidenceItem.preview_mode || evidenceItem.preview_kind || '').trim().toUpperCase();

  const isSystem =
    (typeof evidenceItem.system === 'boolean') ? evidenceItem.system : String(evidenceId).startsWith('SYS:');

  const canDelete = (typeof evidenceItem.can_delete === 'boolean')
    ? evidenceItem.can_delete
    : !isSystem;

  // Allow type editing only for real user evidence (uuid ids + not system)
  const uuidRe =
    /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
  const canEditType = (!isSystem) && uuidRe.test(String(evidenceId));

  const kind = (evidenceItem.kind != null) ? String(evidenceItem.kind) : 'Evidence';
  const dtRaw = evidenceItem.uploaded_at_utc || evidenceItem.uploaded_at || evidenceItem.created_at || null;

  const fmtUkDateTime = (iso) => {
    if (!iso) return 'â€”';
    const d = new Date(iso);
    if (Number.isNaN(d.getTime())) return String(iso);
    try {
      return d.toLocaleString('en-GB', {
        timeZone: 'Europe/London',
        weekday: 'short',
        day: '2-digit',
        month: 'short',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        hour12: false
      });
    } catch {
      return d.toISOString();
    }
  };

  const presignDownload = async (key) => {
    const cleanKey = String(key || '').trim().replace(/^\/+/, '');
    const res = await authFetch(API('/api/files/presign-download'), {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ key: cleanKey })
    });
    const text = await res.text().catch(() => '');
    if (!res.ok) throw new Error(text || 'Failed to presign download URL');
    const json = text ? JSON.parse(text) : {};
    const url = json.url || json.signed_url || null;
    if (!url) throw new Error('No URL returned from presign-download');
    return url;
  };

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // IMPORT TABLE preview (raw table: multi-row header_rows + raw_columns)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (previewMode === 'IMPORT_TABLE') {
    const importId =
      (evidenceItem?.meta_json && evidenceItem.meta_json.import_id != null && String(evidenceItem.meta_json.import_id).trim())
        ? String(evidenceItem.meta_json.import_id).trim()
        : (() => {
            // Fallback: parse import id from SYS:*:* id (backend uses SYS:<kind>:<importId>)
            const s = String(evidenceId || '');
            const parts = s.split(':');
            return (parts.length >= 3) ? String(parts[parts.length - 1]) : null;
          })();

    if (!importId) {
      GE();
      throw new Error('Import evidence is missing import_id.');
    }

    const tsIdForPrint = tsIdNow() || tsId;

    // fetch rows (scoped to this import_id)
    const res = await authFetch(
      API(`/api/timesheets/${encodeURIComponent(String(tsIdForPrint))}/source-print?import_id=${encodeURIComponent(String(importId))}&include_excluded=true`)
    );
    const txt = await res.text().catch(() => '');
    if (!res.ok) {
      GE();
      throw new Error(txt || 'Failed to load import rows');
    }
    const json = txt ? JSON.parse(txt) : {};
    const imports = Array.isArray(json.imports) ? json.imports : [];
    const imp = imports.find(x => String(x?.import_id) === String(importId)) || imports[0] || null;

    const headerRowsRaw = Array.isArray(imp?.header_rows) ? imp.header_rows : [];
    const headerColsRaw = Array.isArray(imp?.header_columns) ? imp.header_columns : [];
    const rows = Array.isArray(imp?.rows) ? imp.rows : [];

    // Normalise headers:
    // - Prefer header_rows (multi-row). Preserve blanks (do NOT drop).
    // - Else fallback to single-row header_columns.
    let headerRows = [];
    if (Array.isArray(headerRowsRaw) && headerRowsRaw.length) {
      headerRows = headerRowsRaw.map(r => (Array.isArray(r) ? r : []));
    } else if (Array.isArray(headerColsRaw) && headerColsRaw.length) {
      headerRows = [headerColsRaw];
    } else {
      headerRows = [];
    }

    // Column count:
    // max(header_rows widths) -> else header_columns length -> else first row raw_columns length -> else 0
    let colCount = 0;
    for (const r of headerRows) {
      if (Array.isArray(r) && r.length > colCount) colCount = r.length;
    }
    if (colCount === 0 && Array.isArray(headerColsRaw) && headerColsRaw.length) colCount = headerColsRaw.length;
    if (colCount === 0 && Array.isArray(rows?.[0]?.raw_columns)) colCount = rows[0].raw_columns.length;

    if (!Number.isFinite(colCount) || colCount < 0) colCount = 0;

    // Pad header rows to colCount with blanks (preserve alignment)
    const headerRowsPadded = headerRows.map(r =>
      Array.from({ length: colCount }, (_, i) => (i < (r?.length || 0) ? r[i] : ''))
    );

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Formatting helpers (match PDF renderer behaviour)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const pad2 = (n) => String(n).padStart(2, '0');

    const toNum = (v) => {
      if (typeof v === 'number') return Number.isFinite(v) ? v : null;
      const s = String(v ?? '').trim();
      if (!s) return null;
      const n = Number(s);
      return Number.isFinite(n) ? n : null;
    };

    const excelSerialToDmy = (v) => {
      const n = toNum(v);
      if (n == null) return String(v ?? '');
      if (n < 20000 || n > 90000) return String(v ?? '');
      const base = Date.UTC(1899, 11, 30, 0, 0, 0, 0);
      const ms = base + Math.round(n) * 86400000;
      if (!Number.isFinite(ms)) return String(v ?? '');
      const d = new Date(ms);
      if (Number.isNaN(d.getTime())) return String(v ?? '');
      return `${pad2(d.getUTCDate())}/${pad2(d.getUTCMonth() + 1)}/${d.getUTCFullYear()}`;
    };

    const excelFracToHHMM = (v) => {
      const n = toNum(v);
      if (n == null) {
        const s = String(v ?? '').trim();
        if (/^\d{1,2}:\d{2}(:\d{2})?$/.test(s)) {
          const parts = s.split(':');
          const hh = pad2(Number(parts[0]) || 0);
          const mm = pad2(Number(parts[1]) || 0);
          return `${hh}:${mm}`;
        }
        return String(v ?? '');
      }
      if (n < 0 || n > 2) return String(v ?? '');
      const mins = Math.round(n * 1440);
      const hh = Math.floor(mins / 60);
      const mm = mins % 60;
      return `${pad2(hh)}:${pad2(mm)}`;
    };

    const fmtInt = (v) => {
      const n = toNum(v);
      if (n == null) return String(v ?? '');
      return String(Math.round(n));
    };

    const fmtMoney = (v) => {
      if (typeof v === 'string') {
        const s = v.trim();
        if (s && Number.isFinite(Number(s))) return s; // preserve numeric strings like "50.7"
        return String(v ?? '');
      }
      const n = toNum(v);
      if (n == null) return String(v ?? '');
      return n.toFixed(2);
    };

    const normH = (s) => String(s || '').trim().toLowerCase().replace(/\s+/g, ' ');

    // Determine per-column meaning using headers (prefer header_rows bottom-up, else header_columns)
    const labelAt = (i) => {
      for (let r = headerRowsPadded.length - 1; r >= 0; r--) {
        const row = headerRowsPadded[r];
        if (!Array.isArray(row)) continue;
        const v = (i < row.length) ? String(row[i] ?? '').trim() : '';
        if (v) return v;
      }
      if (Array.isArray(headerColsRaw) && i < headerColsRaw.length) {
        const v2 = String(headerColsRaw[i] ?? '').trim();
        if (v2) return v2;
      }
      return '';
    };

    const colKinds = [];
    for (let i = 0; i < colCount; i++) {
      const hn = normH(labelAt(i));
      let kind = 'text';
      if (hn.includes('date')) kind = 'date';
      else if (hn === 'start' || hn === 'end' || hn === 'total') kind = 'time';
      else if (hn.includes('break') && hn.includes('minute')) kind = 'break';
      else if (hn === 'commission' || hn.includes('commission') || hn === 'total cost' || hn.includes('total cost')) kind = 'money';
      colKinds.push(kind);
    }

    // Download key
    const downloadKeyRaw =
      (evidenceItem.download_storage_key != null && String(evidenceItem.download_storage_key).trim())
        ? String(evidenceItem.download_storage_key).trim()
        : (evidenceItem.storage_key != null && String(evidenceItem.storage_key).trim())
          ? String(evidenceItem.storage_key).trim()
          : '';

    const downloadKey = downloadKeyRaw.replace(/^\/+/, '').trim();

    const commonWrapStyle = `
      <style>
        .ts-import-wrap {
          max-height:520px;
          overflow:auto;
          border:1px solid var(--line);
          border-radius:8px;
          background:#000;
        }
        table.ts-import-table {
          width:100%;
          border-collapse:collapse;
        }
        table.ts-import-table th,
        table.ts-import-table td {
          padding:6px 8px;
          vertical-align:top;
          border:1px solid rgba(255,255,255,.16);
        }
        table.ts-import-table thead th {
          background:#0f0f0f;
          position:sticky;
          z-index:5;
          border:1px solid rgba(255,255,255,.22);
          text-align:left;
          white-space:normal;
        }
        table.ts-import-table td {
          white-space:normal;
        }
      </style>
    `;

    const mkTableRawImport = () => {
      const hdrRows =
        (headerRowsPadded.length && colCount > 0)
          ? headerRowsPadded
          : (colCount > 0 ? [Array.from({ length: colCount }, (_, i) => `Column ${i + 1}`)] : []);

      const head = hdrRows.length
        ? `
          <thead>
            ${hdrRows.map((rowArr, rowIdx) => `
              <tr>
                ${rowArr.map((cell, colIdx) => {
                  const topPx = rowIdx * 32;
                  const z = 10 - rowIdx;
                  const v = (cell == null) ? '' : String(cell);
                  return `<th style="top:${topPx}px; z-index:${z};">${escapeHtml(v)}</th>`;
                }).join('')}
              </tr>
            `).join('')}
          </thead>
        `
        : '';

      const body = rows.length
        ? rows.map((r) => {
            const raw = Array.isArray(r?.raw_columns) ? r.raw_columns : [];
            const cells = [];
            for (let i = 0; i < colCount; i++) {
              const v0 = (i < raw.length) ? raw[i] : '';
              const k = colKinds[i] || 'text';

              let out = '';
              if (k === 'date') out = excelSerialToDmy(v0);
              else if (k === 'time') out = excelFracToHHMM(v0);
              else if (k === 'break') out = fmtInt(v0);
              else if (k === 'money') out = fmtMoney(v0);
              else out = String(v0 ?? '');

              cells.push(`<td>${escapeHtml(out)}</td>`);
            }
            return `<tr>${cells.join('')}</tr>`;
          }).join('')
        : `<tr><td colspan="${escapeHtml(String(Math.max(colCount, 1)))}" style="padding:10px; opacity:.85;">No rows found for this import.</td></tr>`;

      return `
        ${commonWrapStyle}
        <div class="ts-import-wrap">
          <table class="ts-import-table">
            ${head}
            <tbody>${body}</tbody>
          </table>
        </div>
      `;
    };

    const title = `Import evidence ${String(tsIdForPrint).slice(0, 8)}â€¦`;
    const dlBtnId = `tsImportDl_${Date.now()}_${Math.random().toString(36).slice(2)}`;

    const downloadBtn = downloadKey
      ? `<button type="button"
                 id="${dlBtnId}"
                 class="pill"
                 style="cursor:pointer;border:1px solid var(--line);background:transparent;color:inherit;padding:6px 10px;border-radius:999px;">
           Download full file
         </button>`
      : `<span class="mini" style="opacity:.85;">No downloadable import file key</span>`;

    const rowsMatched = Array.isArray(rows) ? rows.length : 0;
    const sourceLabel = String(imp?.source_system || evidenceItem.kind || 'IMPORT');
    const headerRowsCount = Array.isArray(headerRowsRaw) ? headerRowsRaw.length : 0;

    const bodyHtml = `
      <div class="tabc">
        <div class="card">
          <div class="row">
            <label>Source</label>
            <div class="controls">
              <span class="mini">${escapeHtml(sourceLabel)}</span>
              <div class="mini" style="opacity:.75; margin-top:2px;">
                Raw import view (no derived columns)
              </div>
            </div>
          </div>
          <div class="row">
            <label>Rows matched</label>
            <div class="controls">
              <span class="mini">${escapeHtml(String(rowsMatched))}</span>
            </div>
          </div>
          <div class="row">
            <label>Header rows</label>
            <div class="controls">
              <span class="mini">${escapeHtml(String(headerRowsCount || (headerColsRaw.length ? 1 : 0)))}</span>
            </div>
          </div>
          <div class="row">
            <label>Date</label>
            <div class="controls">
              <span class="mini">${escapeHtml(fmtUkDateTime(dtRaw))}</span>
            </div>
          </div>
          <div class="row">
            <label>Download</label>
            <div class="controls">
              ${downloadBtn}
            </div>
          </div>
        </div>

        <div class="card" style="margin-top:10px;">
          <div class="row">
            <label>Rows (this timesheet only)</label>
            <div class="controls">
              ${mkTableRawImport()}
            </div>
          </div>
        </div>
      </div>
    `;

    showModal(
      title,
      [{ key: 'view', title: 'Evidence' }],
      () => bodyHtml,
      async () => ({ ok: true }),
      false,
      undefined,
      { kind: 'timesheet-evidence-viewer', noParentGate: true, forceEdit: true }
    );

    // Wire download (best-effort)
    try {
      if (downloadKey) {
        const wire = async () => {
          const btn = document.getElementById(dlBtnId);
          if (!btn || btn.__wired) return;
          btn.__wired = true;
          btn.addEventListener('click', async () => {
            try {
              const u = await presignDownload(downloadKey);
              window.open(u, '_blank', 'noopener,noreferrer');
            } catch (e) {
              try { window.__toast && window.__toast(e?.message || 'Download failed'); } catch {}
            }
          });
        };
        try { requestAnimationFrame(() => requestAnimationFrame(wire)); } catch { wire(); }
      }
    } catch {}

    GE();
    return;
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // SIGNATURES preview (Electronic submission evidence)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (previewMode === 'SIGNATURES') {
    const meta = (evidenceItem && evidenceItem.meta_json && typeof evidenceItem.meta_json === 'object')
      ? evidenceItem.meta_json
      : {};

    const bookingId = meta.booking_id ? String(meta.booking_id) : '';
    if (!bookingId) {
      GE();
      throw new Error('Electronic evidence missing booking_id.');
    }

    const version = (meta.version != null && Number.isFinite(Number(meta.version))) ? Number(meta.version) : null;

    // Presign signature GETs
    const presRes = await authFetch(API('/signatures/presign-get/batch'), {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        items: [
          { booking_id: bookingId, which: 'nurse', ...(version != null ? { version } : {}) },
          { booking_id: bookingId, which: 'authoriser', ...(version != null ? { version } : {}) }
        ],
        expires_seconds: 600
      })
    });

    const presTxt = await presRes.text().catch(() => '');
    if (!presRes.ok) {
      GE();
      throw new Error(presTxt || 'Failed to presign signature URLs');
    }

    const presJson = presTxt ? JSON.parse(presTxt) : {};
    const links = Array.isArray(presJson.links) ? presJson.links : [];

    const nurseUrl = (links.find(x => String(x?.which || '') === 'nurse') || {}).get_url || null;
    const authUrl  = (links.find(x => String(x?.which || '') === 'authoriser') || {}).get_url || null;

    const authName = meta.auth_name ? String(meta.auth_name) : '';
    const authJob  = meta.auth_job_title ? String(meta.auth_job_title) : '';
    const authAt   = meta.authorised_at_server ? String(meta.authorised_at_server) : (dtRaw ? String(dtRaw) : '');

    const scope = String(meta.sheet_scope || '').toUpperCase();
    const summaryLines = [];

    if (scope === 'DAILY') {
      const s = meta.worked_start_iso ? String(meta.worked_start_iso) : '';
      const e = meta.worked_end_iso ? String(meta.worked_end_iso) : '';
      const bs = meta.break_start_iso ? String(meta.break_start_iso) : '';
      const be = meta.break_end_iso ? String(meta.break_end_iso) : '';
      const bm = (meta.break_minutes != null) ? String(meta.break_minutes) : '';
      if (s && e) summaryLines.push(`Worked: ${s} â†’ ${e}`);
      if (bs && be) summaryLines.push(`Break: ${bs} â†’ ${be}`);
      else if (bm) summaryLines.push(`Break minutes: ${bm}`);
    } else if (scope === 'WEEKLY') {
      const we = meta.week_ending_date ? String(meta.week_ending_date) : '';
      if (we) summaryLines.push(`Week ending: ${we}`);
      const sched = meta.actual_schedule_json;
      if (Array.isArray(sched)) summaryLines.push(`Shifts: ${sched.length}`);
    }

    const title = `Electronic evidence ${String(tsId).slice(0, 8)}â€¦`;

    const bodyHtml = `
      <div class="tabc">
        <div class="card">
          <div class="row">
            <label>Authorised at server</label>
            <div class="controls">
              <span class="mini">${escapeHtml(fmtUkDateTime(authAt))}</span>
            </div>
          </div>
          <div class="row">
            <label>Authoriser</label>
            <div class="controls">
              <span class="mini">${escapeHtml([authName, authJob].filter(Boolean).join(' â€” ') || 'â€”')}</span>
            </div>
          </div>
          <div class="row">
            <label>Shift summary</label>
            <div class="controls">
              <div class="mini" style="opacity:.9;">
                ${summaryLines.length ? summaryLines.map(x => `<div>${escapeHtml(x)}</div>`).join('') : 'â€”'}
              </div>
            </div>
          </div>
        </div>

        <div class="card" style="margin-top:10px;">
          <div class="row">
            <label>Signatures</label>
            <div class="controls" style="display:flex; gap:12px; flex-wrap:wrap;">
              <div style="flex:1; min-width:240px;">
                <div class="mini" style="opacity:.85; margin-bottom:6px;">Nurse</div>
               ${nurseUrl
  ? `<img src="${nurseUrl}" style="max-width:100%; max-height:260px; border:1px solid var(--line); border-radius:8px; background:#fff;" />`
  : `<div class="mini" style="opacity:.85;">Not available</div>`}
              </div>

              <div style="flex:1; min-width:240px;">
                <div class="mini" style="opacity:.85; margin-bottom:6px;">Authoriser</div>
                ${authUrl
                  ? `<img src="${authUrl}" style="max-width:100%; max-height:260px; border:1px solid var(--line); border-radius:8px; background:#fff;" />`
                  : `<div class="mini" style="opacity:.85;">Not available</div>`}


              </div>
            </div>
          </div>
        </div>
      </div>
    `;

    showModal(
      title,
      [{ key: 'view', title: 'Evidence' }],
      () => bodyHtml,
      async () => ({ ok: true }),
      false,
      undefined,
      { kind: 'timesheet-evidence-viewer', noParentGate: true, forceEdit: true }
    );

    GE();
    return;
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Default: PDF/file preview
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const storageKeyRaw = evidenceItem.storage_key ? String(evidenceItem.storage_key).trim() : '';
  if (!storageKeyRaw) {
    GE();
    throw new Error('Evidence item missing storage_key.');
  }
  const storageKey = storageKeyRaw.replace(/^\/+/, '');

  L('ENTRY', {
    tsId,
    evidenceId,
    storageKeyRaw,
    storageKey,
    kind,
    canDelete,
    canEditType,
    dt: dtRaw,
    previewMode: previewMode || 'PDF'
  });

  const signedUrl = await presignDownload(storageKey);

  const instanceId = `ts-ev-view-${Date.now()}-${Math.random().toString(36).slice(2)}`;
  const iframeId    = `${instanceId}-iframe`;
  const deleteBtnId = `${instanceId}-delete`;
  const selId       = `${instanceId}-type`;
  const otherId     = `${instanceId}-other`;

  const title = `Evidence ${String(tsId).slice(0, 8)}â€¦`;

  const OPTIONS = ['Timesheet', 'Mileage', 'Travel', 'Accommodation', 'Other'];

  const kindTrim = String(kind || '').trim();
  const kindUpper = kindTrim.toUpperCase();

  const kindToUi = (k) => {
    const u = String(k || '').trim().toUpperCase();
    if (u === 'TIMESHEET') return 'Timesheet';
    if (u === 'MILEAGE') return 'Mileage';
    if (u === 'TRAVEL') return 'Travel';
    if (u === 'ACCOMMODATION') return 'Accommodation';
    if (u === 'OTHER') return 'Other';
    return null;
  };

  const uiToKind = (label, otherText) => {
    const v = String(label || '').trim().toUpperCase();

    if (v === 'TIMESHEET') return 'TIMESHEET';
    if (v === 'MILEAGE') return 'MILEAGE';
    if (v === 'TRAVEL') return 'TRAVEL';
    if (v === 'ACCOMMODATION') return 'ACCOMMODATION';
    if (v === 'OTHER') return 'OTHER';

    const txt = String(otherText || '').trim();
    return txt || 'OTHER';
  };

  const matchOpt = kindToUi(kindUpper);
  const initialSelect = matchOpt ? matchOpt : 'Other';
  const initialOther  = matchOpt ? '' : kindTrim;

  const typeControlHtml = canEditType ? `
    <div class="row">
      <label>Evidence Type</label>
      <div class="controls" style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
        <select
          id="${selId}"
          class="input"
          style="min-width:220px;color-scheme:dark;"
        >
          <option value="Timesheet" ${initialSelect === 'Timesheet' ? 'selected' : ''}>Timesheet</option>
          <option value="Mileage" ${initialSelect === 'Mileage' ? 'selected' : ''}>Mileage</option>
          <option value="Travel" ${initialSelect === 'Travel' ? 'selected' : ''}>Travel</option>
          <option value="Accommodation" ${initialSelect === 'Accommodation' ? 'selected' : ''}>Accommodation</option>
          <option value="Other" ${initialSelect === 'Other' ? 'selected' : ''}>Other</option>
        </select>

        <input
          id="${otherId}"
          type="text"
          class="input"
          placeholder="Enter evidence type"
          style="min-width:260px;${initialSelect === 'Other' ? '' : 'display:none;'}"
          value="${escapeHtml(initialOther)}"
        />
        <span class="mini" style="opacity:.85;">Change type then click Save.</span>
        <div class="mini" style="margin-top:4px;opacity:.75;">
          Only <strong>Timesheet / Mileage / Travel / Accommodation / Other</strong> satisfy invoice readiness checks.
          Free-text types are allowed for labelling but wonâ€™t satisfy evidence requirements unless mapped to one of those kinds.
        </div>
      </div>
    </div>
  ` : `
    <div class="row">
      <label>Evidence Type</label>
      <div class="controls">
        <span class="mini">${escapeHtml(kindTrim || 'Evidence')}</span>
        <div class="mini" style="margin-top:4px;opacity:.85;">
          ${isSystem ? 'System evidence cannot be re-typed.' : 'This evidence item cannot be edited.'}
        </div>
      </div>
    </div>
  `;

  const bodyHtml = `
    <div class="tabc">
      <div class="card">
        ${typeControlHtml}
        <div class="row">
          <label>Date Uploaded</label>
          <div class="controls">
            <span class="mini">${escapeHtml(fmtUkDateTime(dtRaw))}</span>
          </div>
        </div>
        <div class="row">
          <label>Download</label>
          <div class="controls">
            <a class="pill"
               href="${signedUrl}"
               target="_blank"
               rel="noopener noreferrer"
               style="display:inline-block;border:1px solid var(--line);background:transparent;color:inherit;padding:6px 10px;border-radius:999px;text-decoration:none;">
              Open / Download
            </a>
          </div>
        </div>
      </div>

      <div class="card" style="margin-top:10px;">
        <div class="row">
          <label>Preview</label>
          <div class="controls">
            <iframe
              id="${iframeId}"
              src="${signedUrl}"
              style="width:100%;height:520px;border:1px solid var(--line);border-radius:8px;background:#000;"
            ></iframe>

            ${canDelete ? `
              <div style="margin-top:10px;display:flex;gap:8px;align-items:center;">
                <button type="button"
                        id="${deleteBtnId}"
                        class="pill pill-warn"
                        style="cursor:pointer;border:1px solid var(--line);background:transparent;color:inherit;padding:6px 10px;border-radius:999px;">
                  Delete evidence
                </button>
                <span class="mini" style="opacity:.85;">This will permanently remove this evidence item.</span>
              </div>
            ` : `
              <div class="mini" style="margin-top:10px;opacity:.85;">
                This evidence item cannot be deleted.
              </div>
            `}
          </div>
        </div>
      </div>
    </div>
  `;

  let __tsDelPrev = null;
  const __hideTsDelete = () => {
    try {
      const b = document.getElementById('btnTsDeleteTimesheet');
      if (!b) return;
      if (__tsDelPrev == null) __tsDelPrev = b.style.display;
      b.style.display = 'none';
    } catch {}
  };
  __hideTsDelete();

  const onDismiss = () => {
    try {
      const b = document.getElementById('btnTsDeleteTimesheet');
      if (b) b.style.display = (__tsDelPrev != null ? __tsDelPrev : '');
    } catch {}

    try {
      const st = (window.__modalStack && Array.isArray(window.__modalStack)) ? window.__modalStack : null;
      const fr = (st && st.length) ? st[st.length - 1] : null;
      if (fr && fr.entity === 'timesheets') fr.currentTabKey = 'evidence';
    } catch {}
  };

  const onSave = async () => {
    const { LOGM, L, GC, GE } = getTsLoggers('[TS][EVIDENCE][VIEWER][SAVE]');
    GC('onSave (evidence viewer)');

    if (!canEditType) {
      GE();
      return { ok: true };
    }

    try {
      const sel = document.getElementById(selId);
      const other = document.getElementById(otherId);

      const selVal = sel ? String(sel.value || '').trim() : '';
      const otherVal = other ? String(other.value || '').trim() : '';

      let newKind = uiToKind(selVal, otherVal);

      if (!newKind) {
        alert('Please select an evidence type.');
        GE();
        return { ok: false };
      }

      newKind = String(newKind || '').trim().toUpperCase();

      if (!newKind) {
        alert('Please select an evidence type.');
        GE();
        return { ok: false };
      }

      if (String(selVal || '').trim().toLowerCase() === 'other') {
        if (!otherVal) {
          alert('Please enter an evidence type (or enter "Other").');
          GE();
          return { ok: false };
        }
      }

      if (String(newKind) === String(kindTrim).trim().toUpperCase()) {
        GE();
        return { ok: true };
      }

      const enc = encodeURIComponent;
      const idNow = tsIdNow();
      if (!idNow) throw new Error('Timesheet id missing.');

      await apiPatchJson(
        `/api/timesheets/${enc(idNow)}/evidence/${enc(evidenceId)}`,
        { expected_timesheet_id: expectedNow(), kind: newKind }
      );

      try {
        if (typeof refreshTimesheetEvidenceIntoModalState === 'function') {
          await refreshTimesheetEvidenceIntoModalState(idNow);
        }
      } catch {}

      if (window.__toast) window.__toast('Evidence type updated');

      GE();
      return { ok: true };
    } catch (err) {
      if (await handleMovedInViewer(err, 'evidence-viewer-save')) {
        GE();
        return { ok: false };
      }

      const msg = String(err?.message || 'Failed to update evidence type.');
      if (/invoiced|paid|locked/i.test(msg)) {
        try { window.__toast && window.__toast(msg); } catch {}
      } else {
        alert(msg);
      }

      L('update kind failed', err);
      GE();
      return { ok: false };
    }
  };

  showModal(
    title,
    [{ key: 'view', title: 'Evidence' }],
    () => bodyHtml,
    onSave,
    false,
    undefined,
    {
      kind: 'timesheet-evidence-viewer',
      noParentGate: true,
      forceEdit: true,
      onDismiss
    }
  );

  try { requestAnimationFrame(() => __hideTsDelete()); } catch {}

  try {
    if (canEditType) {
      const sel = document.getElementById(selId);
      const other = document.getElementById(otherId);

      if (sel && !sel.__tsEvViewerTypeWired) {
        sel.__tsEvViewerTypeWired = true;

        const sync = () => {
          const v = String(sel.value || '').trim().toLowerCase();
          const isOther = (v === 'other');
          if (other) {
            other.style.display = isOther ? '' : 'none';
            if (!isOther) other.value = '';
          }
        };

        sel.addEventListener('change', sync);
        sync();
      }
    }

    if (canDelete) {
      const delBtn = document.getElementById(deleteBtnId);
      if (delBtn && !delBtn.__tsEvDelWired) {
        delBtn.__tsEvDelWired = true;

        delBtn.addEventListener('click', async () => {
          const ok = window.confirm('Delete this evidence item?');
          if (!ok) return;

          try {
            const enc = encodeURIComponent;
            const idNow = tsIdNow();
            if (!idNow) throw new Error('Timesheet id missing.');

            await apiDeleteJson(
              `/api/timesheets/${enc(idNow)}/evidence/${enc(evidenceId)}`,
              { expected_timesheet_id: expectedNow() }
            );

            try {
              if (typeof refreshTimesheetEvidenceIntoModalState === 'function') {
                await refreshTimesheetEvidenceIntoModalState(idNow);
              }
            } catch {}

            if (window.__toast) window.__toast('Evidence removed');

            try { document.getElementById('btnCloseModal')?.click(); } catch {}
          } catch (err) {
            if (await handleMovedInViewer(err, 'evidence-viewer-delete')) return;

            const msg = String(err?.message || 'Failed to delete evidence item.');
            if (/invoiced|paid|locked/i.test(msg)) {
              try { window.__toast && window.__toast(msg); } catch {}
              return;
            }

            L('delete from viewer failed', err);
            alert(msg);
          }
        });
      }
    }
  } catch (e) {
    L('viewer wiring failed (non-fatal)', e);
  }

  GE();
}



function renderTimesheetOverviewTab(ctx) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][OVERVIEW]');
  const { row, details, related, state } = normaliseTimesheetCtx(ctx);

  GC('render');

  const ts    = details.timesheet || {};
  const tsfin = details.tsfin     || {};
  const cw    = details.contract_week || {};
  const rCand = related.candidate || {};
  const rCli  = related.client    || {};
  const rCtr  = related.contract  || {};

  const actionFlags = (details.action_flags && typeof details.action_flags === 'object')
    ? details.action_flags
    : {};

  const sheetScope = (details.sheet_scope || row.sheet_scope || ts.sheet_scope || '').toUpperCase();

  // âœ… planned weeks use submission_mode_snapshot (not ts.submission_mode)
  const cwModeSnapshot =
    String(
      cw.submission_mode_snapshot ||
      details.cw_submission_mode_snapshot ||
      row.submission_mode_snapshot ||
      ''
    ).toUpperCase();

  // âœ… prefer backend-resolved current id
  const tsId =
    ts.timesheet_id ||
    details.current_timesheet_id ||
    row.timesheet_id ||
    null;

  // âœ… define effective mode (real TS mode if TS exists; otherwise planned-week snapshot)
  const hasTsNow   = !!tsId;
  const subModeTs  = String(ts.submission_mode || row.submission_mode || '').toUpperCase();
  const subModeEff = hasTsNow ? subModeTs : cwModeSnapshot;

  // keep existing variable name used elsewhere in this function
  const subMode = subModeEff;

  const enc = escapeHtml;

  const candidateName =
    (rCand.display_name && enc(rCand.display_name)) ||
    (row.candidate_name && enc(row.candidate_name)) ||
    (row.occupant_key_norm && enc(row.occupant_key_norm)) ||
    (rCand.first_name || rCand.last_name
      ? enc([rCand.first_name, rCand.last_name].filter(Boolean).join(' '))
      : 'Unknown candidate');

  const clientName =
    (rCli.name && enc(rCli.name)) ||
    (rCtr.display_site && enc(rCtr.display_site)) ||
    (row.client_name && enc(row.client_name)) ||
    (row.client_id ? enc(row.client_id) : 'Unknown client');

  const jobTitle =
    (rCtr.role && enc(rCtr.role)) ||
    (row.job_title_norm && enc(row.job_title_norm)) ||
    null;

  const band =
    (rCtr.band && String(rCtr.band).trim()) ||
    (row.band && String(row.band).trim()) ||
    null;

  const weYmd = ts.week_ending_date || row.week_ending_date || null;

  const fmtYmdToDmy = (ymd) => {
    if (!ymd || typeof ymd !== 'string' || !/^\d{4}-\d{2}-\d{2}$/.test(ymd)) return enc(ymd || '');
    const [y, m, d] = ymd.split('-');
    return `${d}-${m}-${y}`;
  };

  const fmtDow = (ymd) => {
    if (!ymd) return '';
    const d = new Date(`${ymd}T00:00:00Z`);
    if (Number.isNaN(d.getTime())) return '';
    return d.toLocaleDateString('en-GB', { weekday: 'short', timeZone: 'Europe/London' });
  };

  const hasTsfin = !!(
    tsfin &&
    (tsfin.timesheet_id || tsfin.total_hours != null || tsfin.total_pay_ex_vat != null || tsfin.processing_status)
  );

  const hasContractWeek = !!(details.contract_week_id || cw.id || row.contract_week_id);
  const isPlannedOnly   = !hasTsfin && hasContractWeek && !tsId;

  // âœ… planned weeks must NOT read row.processing_status (can be stale after unprocess)
  const stageRaw = hasTsfin
    ? (String(tsfin.processing_status || row.processing_status || '').toUpperCase() || null)
    : null;

  const isPaid     = !!(tsfin.paid_at_utc || row.paid_at_utc);
  const isInvoiced = !!(tsfin.locked_by_invoice_id || row.locked_by_invoice_id);
  const locked     = isPaid || isInvoiced;

  // Sheet-level pay hold (NOT line-level)
  const payOnHold  = !!(tsfin.pay_on_hold ?? row.pay_on_hold);

  const readyToPay =
    (typeof details.ready_to_pay === 'boolean') ? details.ready_to_pay :
    (typeof row.ready_to_pay === 'boolean')     ? row.ready_to_pay :
    false;

  // Total hours (used for QR-friendly messaging)
  const totalHoursNum = Number(tsfin.total_hours ?? row.total_hours ?? 0);
  const hasHours = Number.isFinite(totalHoursNum) && totalHoursNum > 0;

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // âœ… Import-authoritative detection MUST come from SUMMARY ROW fields:
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const baseSummary = (window.modalCtx && window.modalCtx.data) ? window.modalCtx.data : (row || {});
  const rt   = String(baseSummary.route_type || '').toUpperCase();
  const noTs = !!baseSummary.client_no_timesheet_required;

  const importAuthoritative =
    (rt === 'WEEKLY_NHSP') ||
    (rt === 'WEEKLY_NHSP_ADJUSTMENT') ||
    (rt === 'WEEKLY_HEALTHROSTER' && noTs === true);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Other policy flags (still used for authorisation fallback only)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const policy = (details && details.policy && typeof details.policy === 'object') ? details.policy : {};

  const boolish = (v) => {
    if (v === true) return true;
    if (v === false) return false;
    if (v == null) return false;
    const s = String(v).trim().toLowerCase();
    return (s === 'true' || s === '1' || s === 'yes' || s === 'y' || s === 'on');
  };

  // âœ… NEW: adjustment safety flag (defence-in-depth)
  // Only reads fields that exist in your pasted objects.
  const isAdjustment =
    boolish(Object.prototype.hasOwnProperty.call(ts, 'is_adjustment') ? ts.is_adjustment : null) ||
    boolish(Object.prototype.hasOwnProperty.call(cw, 'is_adjustment') ? cw.is_adjustment : null) ||
    boolish(Object.prototype.hasOwnProperty.call(row, 'is_adjustment') ? row.is_adjustment : null) ||
    boolish(Object.prototype.hasOwnProperty.call(baseSummary, 'is_adjustment') ? baseSummary.is_adjustment : null);

  const routeType =
    String(
      row.route_type ??
      row.routeType ??
      policy.route_type ??
      ''
    ).toUpperCase();

  const noTimesheetRequired =
    (row && Object.prototype.hasOwnProperty.call(row, 'client_no_timesheet_required'))
      ? boolish(row.client_no_timesheet_required)
      : (policy && Object.prototype.hasOwnProperty.call(policy, 'no_timesheet_required'))
        ? boolish(policy.no_timesheet_required)
        : false;

  const requiresHr =
    (row && Object.prototype.hasOwnProperty.call(row, 'client_requires_hr'))
      ? boolish(row.client_requires_hr)
      : (policy && Object.prototype.hasOwnProperty.call(policy, 'requires_hr'))
        ? boolish(policy.requires_hr)
        : false;

  const autoprocessHr =
    (row && Object.prototype.hasOwnProperty.call(row, 'client_autoprocess_hr'))
      ? boolish(row.client_autoprocess_hr)
      : (policy && Object.prototype.hasOwnProperty.call(policy, 'autoprocess_hr'))
        ? boolish(policy.autoprocess_hr)
        : false;

  let authInfo = { requires: false, authorised: false, showAwaitingBadge: false };
  if (typeof computeRequiresTimesheetAuthorisation === 'function') {
    try {
      const x = computeRequiresTimesheetAuthorisation(details, row);
      if (x && typeof x === 'object') authInfo = { ...authInfo, ...x };
    } catch {}
  } else {
    const authorisedAt = ts.authorised_at_server || row.authorised_at_server || null;
    const authorised   = !!authorisedAt;
    const requiresAuth =
      (stageRaw === 'PENDING_AUTH') ||
      (requiresHr && !autoprocessHr && stageRaw === 'READY_FOR_HR');
    authInfo = { requires: requiresAuth, authorised, showAwaitingBadge: (requiresAuth && !authorised) };
  }

  const isManualOnly = !!actionFlags.is_manual_only;

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // âœ… Invoice issuing delay badge (SEGMENTS mode, matches SQL rule)
  // + âœ… Line-level pay hold badge (SEGMENTS mode, matches SQL: seg.exclude_from_pay)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let invoiceDelayBadge = null; // { label, cls, title } | null
  let payLineHoldBadge  = null; // { label, cls, title } | null

  try {
    let inv = tsfin.invoice_breakdown_json ?? null;
    if (typeof inv === 'string') {
      try { inv = JSON.parse(inv); } catch { inv = null; }
    }

    const mode = String(inv?.mode || '').toUpperCase();
    const segs = Array.isArray(inv?.segments) ? inv.segments : [];

    const addDaysYmd = (ymd, deltaDays) => {
      if (!ymd || typeof ymd !== 'string' || !/^\d{4}-\d{2}-\d{2}$/.test(ymd)) return null;
      const [yy, mm, dd] = ymd.split('-').map(Number);
      const dt = new Date(Date.UTC(yy, mm - 1, dd));
      dt.setUTCDate(dt.getUTCDate() + Number(deltaDays || 0));
      return dt.toISOString().slice(0, 10);
    };

    const weekStartMondayYmd = (ymd) => {
      if (!ymd || typeof ymd !== 'string' || !/^\d{4}-\d{2}-\d{2}$/.test(ymd)) return null;
      const [yy, mm, dd] = ymd.split('-').map(Number);
      const dt = new Date(Date.UTC(yy, mm - 1, dd));
      const jsDow = dt.getUTCDay();
      const monIndex = (jsDow + 6) % 7;
      dt.setUTCDate(dt.getUTCDate() - monIndex);
      return dt.toISOString().slice(0, 10);
    };

    const baselineWeekStart =
      (weYmd && /^\d{4}-\d{2}-\d{2}$/.test(String(weYmd))) ? addDaysYmd(String(weYmd), -6) : null;

    if (hasTsfin && mode === 'SEGMENTS' && segs.length) {
      const delayedSegs = segs.filter(seg => {
        if (!seg || typeof seg !== 'object') return false;

        const lockedIdRaw = seg.invoice_locked_invoice_id;
        const lockedId = (lockedIdRaw == null) ? '' : String(lockedIdRaw).trim();

        const targetRaw = seg.invoice_target_week_start;
        const target = (targetRaw == null) ? '' : String(targetRaw).trim();

        const segDateRaw = seg.date;
        const segDate = (segDateRaw == null) ? '' : String(segDateRaw).trim();

        const baseStart = baselineWeekStart || weekStartMondayYmd(segDate);

        const hasLocked = !!lockedId;
        const hasTarget = !!target;

        if (hasLocked) return false;
        if (!hasTarget) return false;
        if (!baseStart) return false;

        return target !== baseStart;
      });

      if (delayedSegs.length) {
        const allDelayed = (delayedSegs.length === segs.length);
        invoiceDelayBadge = {
          label: allDelayed ? 'Whole Invoice is Delayed' : 'Some Invoice Issuing Delays',
          cls:   allDelayed ? 'pill-bad' : 'pill-warn',
          title: allDelayed
            ? `All ${segs.length} segment(s) are delayed from their baseline invoice week.`
            : `${delayedSegs.length} of ${segs.length} segment(s) are delayed from their baseline invoice week.`
        };
      }

      const heldSegs = segs.filter(seg => {
        if (!seg || typeof seg !== 'object') return false;
        return boolish(seg.exclude_from_pay);
      });

      if (heldSegs.length) {
        const allHeld = (heldSegs.length === segs.length);
        payLineHoldBadge = {
          label: allHeld ? 'All Pay on hold' : 'Some Pay on hold',
          cls:   allHeld ? 'pill-bad' : 'pill-warn',
          title: allHeld
            ? `All ${segs.length} segment(s) are excluded from pay.`
            : `${heldSegs.length} of ${segs.length} segment(s) are excluded from pay.`
        };
      }
    }
  } catch {}

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Stage badges + tooltips
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const stageBadges = [];
  const seenStage   = new Set();

  const addStage = (label, cls, title) => {
    const key = String(label || '').trim();
    if (!key) return;
    if (seenStage.has(key)) return;
    seenStage.add(key);

    stageBadges.push(
      `<span class="pill ${cls || 'pill-info'}" ` +
      `style="font-weight:600;${title ? `" title="${enc(title)}"` : '"'}>` +
      `${enc(key)}</span>`
    );
  };

  // âœ… NEW: Reference blocker pill (Option A: DB emits these exact strings into issue_codes)
  // Show at most one (DB should already guarantee this; we apply precedence defensively).
  try {
    const rawCodes =
      Array.isArray(row?.issue_codes) ? row.issue_codes :
      (Array.isArray(details?.issue_codes) ? details.issue_codes : []);

    const codes = rawCodes.map(x => String(x || '').trim()).filter(Boolean);

    const REF_PRECEDENCE = [
      'Refs (Invoice and Issue Blocked)',
      'Refs (Invoicing Blocked)',
      'Refs (Issue Invoice Blocked)'
    ];

    let refChosen = '';
    for (const k of REF_PRECEDENCE) {
      if (codes.includes(k)) { refChosen = k; break; }
    }

    if (refChosen) {
      const title =
        (refChosen === 'Refs (Invoice and Issue Blocked)')
          ? 'Reference numbers are missing. This blocks both creating invoices and issuing invoices until references are added.'
          : (refChosen === 'Refs (Invoicing Blocked)')
            ? 'Reference numbers are missing. This blocks creating invoices until references are added.'
            : 'Reference numbers are missing. Invoices can be created, but cannot be issued until references are added.';

      addStage(refChosen, 'pill-bad', title);
    }
  } catch {}

    // âœ… map TSFIN.UNASSIGNED to "Unprocessed" (never show UNASSIGNED to admins)
  if (hasTsfin && stageRaw === 'UNASSIGNED') {
    addStage(
      'Unprocessed',
      'pill-info',
      'This timesheet has been reset or currently has no valid hours recorded yet. Enter/submit hours to continue.'
    );
  } else if (!hasTsfin) {
    addStage(
      'Unprocessed',
      'pill-info',
      'This timesheet is unprocessed. No real hours have been entered yet (the Lines tab shows the default contract schedule until you enter actual hours).'
    );
  }


  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // âœ… Invoice issuance overlay (server-authoritative from SUMMARY row)
  // Rules:
  //  - Only apply if timesheet is invoiced AND locked_invoice_status exists
  //  - Invoice Paid takes precedence and suppresses the separate "Paid" stage
  //  - Otherwise show Invoiced (Issued) / Invoiced (Not issued); else fall back to "Invoiced"
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const lockedInvoiceStatus =
    String(
      (row && Object.prototype.hasOwnProperty.call(row, 'locked_invoice_status'))
        ? (row.locked_invoice_status ?? '')
        : ''
    ).trim().toUpperCase();

  const hasLockedInvoiceStatus = !!lockedInvoiceStatus;
  const invoicePaid = hasLockedInvoiceStatus && (lockedInvoiceStatus === 'PAID');
  const invoiceIssued = hasLockedInvoiceStatus && (lockedInvoiceStatus === 'ISSUED' || lockedInvoiceStatus === 'PAID');

  if (invoicePaid) {
    addStage('Invoice Paid', 'pill-ok', 'This timesheet is on an invoice that has been marked as paid.');
  } else {
    if (isPaid) addStage('Paid', 'pill-ok', 'This timesheet has been marked as paid.');

    if (isInvoiced) {
      if (hasLockedInvoiceStatus) {
        if (invoiceIssued) {
          addStage('Invoiced (Issued)', 'pill-warn', 'This timesheet is invoiced and the invoice has been issued.');
        } else {
          addStage('Invoiced (Not issued)', 'pill-warn', 'This timesheet is invoiced but the invoice has not been issued yet.');
        }
      } else {
        addStage('Invoiced', 'pill-warn', 'This timesheet has been invoiced and is locked for changes.');
      }
    }
  }

  if (hasTsfin && stageRaw === 'READY_FOR_INVOICE') {
    addStage('Ready for Invoicing', 'pill-ok', 'This timesheet is authorised and ready to be added to an invoice.');
  }
  if (hasTsfin && stageRaw === 'READY_FOR_HR') {
    addStage('Ready for HR', 'pill-info', 'This timesheet is authorised and requires HealthRoster validation before it can be invoiced.');
  }

  if (hasTsfin && stageRaw === 'RATE_MISSING') {
    addStage(
      'Rate Missing',
      'pill-bad',
      'Rates are missing for one or more hour buckets used by this timesheet. Add the missing rates before continuing (in some cases you may need to correct the contract and reprocess/recreate unprocessed weeks).'
    );
  }
  if (hasTsfin && stageRaw === 'PAY_CHANNEL_MISSING') {
    addStage('Pay Channel Missing', 'pill-bad', 'The pay channel for this candidate is missing. Set the candidate pay method/channel before continuing.');
  }

  if (authInfo.showAwaitingBadge) {
    addStage('Awaiting Authorisation', 'pill-warn', 'This timesheet requires authorisation before it can proceed.');
  }

  if (payOnHold) {
    addStage('Pay on hold', 'pill-bad', 'Pay is on hold for this timesheet. Remove the hold to allow payment.');
  }

  if (readyToPay && !payOnHold && !isPaid) {
    addStage('Ready to Pay', 'pill-ok', 'This timesheet is ready to be included in the next pay run.');
  }

  if (invoiceDelayBadge && invoiceDelayBadge.label) {
    addStage(invoiceDelayBadge.label, invoiceDelayBadge.cls, invoiceDelayBadge.title);
  }
  if (payLineHoldBadge && payLineHoldBadge.label) {
    addStage(payLineHoldBadge.label, payLineHoldBadge.cls, payLineHoldBadge.title);
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // QR detection + hash-aware truth model
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // IMPORTANT: do not let SUMMARY-row qr_status drive modal actions (can be stale after rotation).
  const qrStatusAny = String(details.qr_status || ts.qr_status || '').toUpperCase();
  const qrTokenAny  = (details.qr_token ?? ts.qr_token ?? null);
  const qrGenAny    = (details.qr_generated_at ?? ts.qr_generated_at ?? null);
  const qrScanAny   = (details.qr_scanned_at ?? ts.qr_scanned_at ?? null);
  const qrLastSentHashAny = (ts.qr_last_sent_hash ?? details?.timesheet?.qr_last_sent_hash ?? null);

  const hasAnyQrToken = !!(qrTokenAny && String(qrTokenAny).trim());
  const hasAnyQrGen   = !!qrGenAny;
  const hasAnyQrScan  = !!qrScanAny;
  const hasAnyLastSentHash = !!(qrLastSentHashAny && String(qrLastSentHashAny).trim());

  // âœ… FIX: do NOT rely on ts.is_qr (not a real DB column). Prefer view row.is_qr, then backend hints, then QR fields/hashes.
  const isQr =
    !!row?.is_qr ||
    !!details?.is_qr ||
    !!actionFlags?.is_qr ||
    !!qrStatusAny ||
    hasAnyQrToken ||
    hasAnyQrGen ||
    hasAnyQrScan ||
    hasAnyLastSentHash;

  const qrStatus = isQr ? qrStatusAny : '';
  const hasQrToken = isQr ? hasAnyQrToken : false;
  const hasQrGen   = isQr ? hasAnyQrGen   : false;
  const hasQrScan  = isQr ? hasAnyQrScan  : false;
  const hasQrLastSentHash = isQr ? hasAnyLastSentHash : false;

  const qrIsCancelled = (qrStatus === 'CANCELLED');
  const qrIsExpired   = (qrStatus === 'EXPIRED');

  // âœ… â€œissued/awaiting signatureâ€ is true if (token+gen) OR last_sent_hash exists.
  const hasIssuedProof = (hasQrToken && hasQrGen) || hasQrLastSentHash;

  const qrNotYetSentToCandidate =
    (qrStatus === 'PENDING') && !hasIssuedProof && !hasQrScan;

  const qrWaitingForSignatureUpload =
    (qrStatus === 'PENDING') && hasIssuedProof && !hasQrScan;

  const qrSignedReceived =
    (qrStatus === 'USED') || hasQrScan;

  const signedPdfKey =
    details.manual_pdf_r2_key ||
    ts.manual_pdf_r2_key ||
    null;

  const hasSignedPdf = !!(signedPdfKey && String(signedPdfKey).trim());
  const hasScan      = !!hasQrScan;

  // Prefer backend boolean; if missing, fallback so UI updates immediately after /qr-resend.
  const qrCanResendSameHours =
    (typeof actionFlags.qr_can_resend_same_hours === 'boolean')
      ? actionFlags.qr_can_resend_same_hours
      : (qrWaitingForSignatureUpload && hasQrLastSentHash);

  const qrSignedMatchesHours =
    (typeof actionFlags.qr_completed_matches_hours === 'boolean')
      ? actionFlags.qr_completed_matches_hours
      : false;

  // QR-friendly stage badges
  if (isQr && qrStatus) {
    if (qrIsCancelled) {
      addStage('QR Cancelled', 'pill-warn', 'The QR route is cancelled. Issue a new QR timesheet if you want to continue via QR.');
    } else if (qrIsExpired) {
      addStage('QR Expired', 'pill-warn', 'The QR route is expired. You must issue a new QR timesheet.');
    } else if (qrNotYetSentToCandidate && qrStatus === 'PENDING') {
      if (!hasHours) {
        addStage(
          'QR Timesheet not yet issued â€“ Awaiting Hours from Candidate',
          'pill-info',
          'No hours are recorded for this QR timesheet yet. The candidate must enter hours in the app before a QR timesheet can be issued.'
        );
      } else {
        addStage(
          'QR Timesheet ready to send',
          'pill-info',
          'Hours are recorded, but no valid QR timesheet has been sent for the current hours. Use â€œSend New QR Timesheetâ€¦â€ to issue the printable QR PDF and email it to the candidate.'
        );
      }
    } else if (qrWaitingForSignatureUpload && qrStatus === 'PENDING') {
      if (qrCanResendSameHours) {
        addStage(
          'QR Timesheet Hours received â€“ Awaiting signature',
          'pill-warn',
          'Hours are recorded and a QR timesheet has been issued. The candidate/manager must sign and upload the signed copy.'
        );
      } else if (hasHours) {
        addStage(
          'QR Timesheet ready to send',
          'pill-info',
          'Hours have changed since the last QR was sent, so the previous QR is no longer valid for the current hours. Use â€œSend New QR Timesheetâ€¦â€ to issue a new QR PDF.'
        );
      }
    } else if (qrSignedReceived && hasScan && hasSignedPdf) {
      if (qrSignedMatchesHours) {
        addStage(
          'QR Completed â€“ Signed timesheet matches current hours',
          'pill-ok',
          'A signed QR timesheet has been received and it matches the hours currently recorded in the system.'
        );
      } else {
        addStage(
          'QR Signed upload received â€“ Does not match current hours',
          'pill-warn',
          'A signed QR timesheet exists, but it does not match the current hours. If hours were changed after signing, send a new QR timesheet and have it re-signed.'
        );
      }
    }
  }

  if (isManualOnly) {
    addStage(
      'Candidate submission disabled',
      'pill-warn',
      'Candidate submission is disabled for this timesheet. To involve the candidate again, use â€œAllow electronic againâ€ / â€œAllow Candidate to submit QR Timesheet hours againâ€ (if available), or â€œRevert to electronicâ€ where applicable.'
    );
  }

  const STAGES_WITH_FRIENDLY_BADGE = new Set([
    'READY_FOR_INVOICE',
    'READY_FOR_HR',
    'RATE_MISSING',
    'PAY_CHANNEL_MISSING',
    'AWAITING_MANUAL_SIGNATURE',
    'UNASSIGNED'
  ]);

  if (hasTsfin && stageRaw && !STAGES_WITH_FRIENDLY_BADGE.has(stageRaw)) {
    if (stageRaw !== 'PENDING_AUTH') addStage(stageRaw, 'pill-info');
  }

  if (!stageBadges.length) addStage('Unknown', 'pill-info', 'No stage could be determined for this timesheet.');

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Route label (stable; never show action text here)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const routeLabel = (() => {
    if (isQr && qrStatus) return 'QR';

    if (sheetScope === 'WEEKLY') {
      if (routeType === 'WEEKLY_NHSP' || routeType === 'WEEKLY_NHSP_ADJUSTMENT') return 'NHSP';
      if (routeType === 'WEEKLY_HEALTHROSTER') {
        return noTimesheetRequired ? 'HealthRoster (no timesheets)' : 'HealthRoster (timesheets required)';
      }
      if (routeType === 'WEEKLY_ELECTRONIC') return 'Electronic';
      if (routeType === 'WEEKLY_MANUAL') return 'Manual';
    }

    if (subModeEff === 'ELECTRONIC') return 'Electronic';
    return 'Manual';
  })();

  const routeTitle = (() => {
    if (isQr && qrStatus) {
      if (qrIsCancelled) return 'QR route is cancelled. You will need to issue a new QR if you want to continue the QR process.';
      if (qrIsExpired)   return 'QR route is expired. You must issue a new QR timesheet.';
      if (qrNotYetSentToCandidate && !hasHours) return 'QR route is enabled but no hours have been entered yet.';
      if (qrNotYetSentToCandidate && hasHours)  return 'QR route is ready to send for the current hours.';
      if (qrWaitingForSignatureUpload) return 'QR timesheet issued. Awaiting signed upload.';
      if (qrSignedReceived) return 'QR signed upload has been received.';
      return 'QR timesheet route.';
    }

    if (routeLabel === 'Electronic') {
      return 'Hours and signatures are submitted electronically by the candidate via the app. The candidate can also choose to complete a QR Timesheet if they prefer.';
    }

    if (routeLabel === 'Manual') {
      return isManualOnly
        ? 'Manual (candidate submission disabled). Admin will manage hours and evidence manually. To involve the candidate again you must explicitly re-enable submission.'
        : 'Manual (admin-managed). Admin can adjust hours/schedule internally; to return to candidate evidence use â€œRevert to electronicâ€ or re-enable submission where appropriate.';
    }

    if (routeLabel.startsWith('HealthRoster')) {
      return noTimesheetRequired
        ? 'HealthRoster is authoritative and no weekly timesheet evidence is required.'
        : 'HealthRoster is used and a weekly timesheet is required for evidence/processing.';
    }

    if (routeLabel === 'NHSP') return 'NHSP is the authoritative source for this week.';
    return '';
  })();

  const routePillClass =
    (routeLabel === 'Manual') ? 'pill-manual' :
    (routeLabel === 'Electronic') ? 'pill-elec' :
    'pill-info';

  const scopeLabel =
    (sheetScope === 'WEEKLY') ? 'Weekly' :
    (sheetScope === 'DAILY')  ? 'Daily'  :
    (sheetScope ? sheetScope : 'Unknown');

  const scopePillClass =
    (sheetScope === 'WEEKLY') ? 'pill-weekly' :
    (sheetScope === 'DAILY')  ? 'pill-daily'  :
    'pill-info';

  const headerHtml = `
    <div class="card">
      <div class="row">
        <label>Timesheet</label>
        <div class="controls">
          <div style="font-size:15px;font-weight:600;margin-bottom:2px;">${candidateName}</div>
          <div class="mini">Client: ${clientName}</div>
          <div class="mini">
            ${
              weYmd
                ? `Week ending: ${fmtDow(weYmd)} ${fmtYmdToDmy(weYmd)}`
                : '<span class="mini">Week ending: Unknown</span>'
            }
          </div>
          <div class="mini">
            ${
              jobTitle
                ? (band ? `${jobTitle} (Band ${enc(band)})` : jobTitle)
                : (band ? `Band ${enc(band)}` : '<span class="mini">No job title</span>')
            }
          </div>
        </div>
      </div>
    </div>
  `;

  const badgeBtnStyle = 'cursor:pointer;border:1px solid var(--line);background:transparent;color:inherit;padding:6px 10px;border-radius:999px;';

  const actionsHtml = (() => {
    const btns = [];

    const canRestorePending = !!actionFlags.can_restore_qr_pending;
    const canRestoreSigned  = !!actionFlags.can_restore_qr_signed;
    const canRevertToElec   = !!actionFlags.can_revert_to_electronic;

    const canAllowQrAgain   = !!actionFlags.can_allow_qr_again;
    const canAllowElecAgain = !!actionFlags.can_allow_electronic_again;

    const weekId =
      details.contract_week_id ||
      cw.id ||
      row.contract_week_id ||
      null;

    const isWeekly = (sheetScope === 'WEEKLY');
    const isDaily  = (sheetScope === 'DAILY');

    // âœ… NEW: Add additional manual timesheet (always available weekly/daily, not blocked by importAuthoritative)
    if (isWeekly && weekId) {
      const title = 'Create an additional manual adjustment timesheet for this week (use for expenses or corrections without altering the original sheet).';
      btns.push(`
        <button type="button" class="pill pill-info" style="${badgeBtnStyle}" data-ts-action="add-additional-manual" title="${enc(title)}">
          Add additional manual timesheet
        </button>
      `);
    }
    if (isDaily && tsId) {
      const title = 'Create an additional manual daily timesheet for this shift (use for expenses or corrections without altering the original sheet).';
      btns.push(`
        <button type="button" class="pill pill-info" style="${badgeBtnStyle}" data-ts-action="add-additional-manual" title="${enc(title)}">
          Add additional manual timesheet
        </button>
      `);
    }

    const isPlannedWeeklyManual =
      isWeekly &&
      !tsId &&
      !!weekId &&
      !locked &&
      (cwModeSnapshot === 'MANUAL');

    const isPlannedWeeklyElectronic =
      isWeekly &&
      !tsId &&
      !!weekId &&
      !locked &&
      (cwModeSnapshot === 'ELECTRONIC');

    const isWeeklyElectronicWithTs =
      isWeekly &&
      !!tsId &&
      !locked &&
      (subModeEff === 'ELECTRONIC');

    const isDailyElectronicWithTs =
      isDaily &&
      !!tsId &&
      !locked &&
      (subModeEff === 'ELECTRONIC');

    // âœ… Adjustment safety: NEVER show conversion/QR/electronic controls on adjustment sheets
    if (!isAdjustment) {

      if (!importAuthoritative && (isWeeklyElectronicWithTs || isPlannedWeeklyElectronic || isDailyElectronicWithTs)) {
        const title = 'Switch this timesheet into admin-managed Manual mode so you can adjust hours/schedule internally.';
        btns.push(`
          <button type="button" class="pill pill-info" style="${badgeBtnStyle}" data-ts-action="switch-manual" title="${enc(title)}">
            Convert to Manual so you can enter hours on behalf of candidate
          </button>
        `);
      }

      if (!importAuthoritative && isPlannedWeeklyManual) {
        const title = 'Switch this planned manual week back to Electronic (read-only) behaviour.';
        btns.push(`
          <button type="button" class="pill pill-info" style="${badgeBtnStyle}" data-ts-action="switch-electronic-planned" title="${enc(title)}">
            Switch week back to electronic
          </button>
        `);
      }

      if (isDaily && tsId && subMode === 'ELECTRONIC' && !locked) {
        const title = 'Generate and email a daily QR timesheet for printing/signature, then upload the signed copy.';
        btns.push(`
          <button type="button" class="pill pill-info" style="${badgeBtnStyle}" data-ts-action="send-daily-qr" title="${enc(title)}">
            Send daily QR timesheet
          </button>
        `);
      }

      // QR send / resend (only when QR is actually enabled: qr_status=PENDING on CURRENT row)
      // âœ… This prevents calling /qr-resend when backend has qr_status=NULL (manual-only).
      if (tsId && !locked && !isManualOnly && isQr && qrStatus === 'PENDING') {
        if (qrNotYetSentToCandidate) {
          if (hasHours) {
            const title = 'Issue a new printable QR PDF for the current hours and email it to the candidate.';
            btns.push(`
              <button type="button" class="pill pill-info" style="${badgeBtnStyle}" data-ts-action="qr-resend" title="${enc(title)}">
                Send New QR Timesheetâ€¦
              </button>
            `);
          }
        }

        if (qrWaitingForSignatureUpload) {
          if (qrCanResendSameHours) {
            const title = 'Resend the previously-issued QR PDF for the same hours (no changes). This does not issue a new token.';
            btns.push(`
              <button type="button" class="pill pill-info" style="${badgeBtnStyle}" data-ts-action="qr-resend" title="${enc(title)}">
                Resend QR Timesheetâ€¦
              </button>
            `);
          } else if (hasHours) {
            const title = 'Hours have changed since the last QR was sent. Issue a new QR PDF for the current hours and email it to the candidate.';
            btns.push(`
              <button type="button" class="pill pill-info" style="${badgeBtnStyle}" data-ts-action="qr-resend" title="${enc(title)}">
                Send New QR Timesheetâ€¦
              </button>
            `);
          }
        }
      }

      if (tsId && !locked && !isManualOnly && isQr && qrStatus === 'PENDING' && qrWaitingForSignatureUpload) {
        const title = 'Reject the submitted QR hours and reset the QR route so the candidate must re-submit their hours again (email will be queued to the candidate if configured).';
        btns.push(`
          <button type="button" class="pill pill-warn" style="${badgeBtnStyle}" data-ts-action="qr-refuse" title="${enc(title)}">
            Refuse hours & request resubmission
          </button>
        `);
      }

      if (tsId && !locked && !isManualOnly && isQr && qrStatus === 'USED' && qrSignedReceived) {
        const title = 'Revoke the signed QR evidence and request the candidate resubmit hours/signatures again (use when signed evidence is incorrect or hours changed).';
        btns.push(`
          <button type="button" class="pill pill-warn" style="${badgeBtnStyle}" data-ts-action="qr-reissue-request" title="${enc(title)}">
            Revoke signed QR & request resubmission
          </button>
        `);
      }

      // Convert QR route â†’ manual-only
      if (tsId && !locked && isQr && qrStatus) {
        const title = 'Convert to Manual (candidate submission disabled). Admin will manage hours and evidence manually from this point.';
        btns.push(`
          <button type="button" class="pill pill-info" style="${badgeBtnStyle}" data-ts-action="qr-convert-manual-only" title="${enc(title)}">
            Convert to Manual so you can enter hours on behalf of candidate
          </button>
        `);
      }

      if (tsId && !locked && canRestorePending) {
        const title = 'Restore the most recently revoked pending QR version as current (you may need to resend the QR PDF afterwards).';
        btns.push(`
          <button type="button" class="pill pill-info" style="${badgeBtnStyle}" data-ts-action="qr-restore-pending" title="${enc(title)}">
            Restore revoked QR (pending)
          </button>
        `);
      }

      if (tsId && !locked && canRestoreSigned) {
        const title = 'Restore the most recently revoked signed QR version as current (only valid if it matches current hours).';
        btns.push(`
          <button type="button" class="pill pill-info" style="${badgeBtnStyle}" data-ts-action="qr-restore-signed" title="${enc(title)}">
            Restore revoked QR (signed)
          </button>
        `);
      }

      if (!importAuthoritative && tsId && !locked && isManualOnly && canAllowQrAgain) {
        const title = 'Create a new current QR-enabled state so the candidate can submit QR hours again.';
        btns.push(`
          <button type="button" class="pill pill-info" style="${badgeBtnStyle}" data-ts-action="allow-qr-again" title="${enc(title)}">
            Allow Candidate to submit QR Timesheet hours again
          </button>
        `);
      }

      if (!importAuthoritative && tsId && !locked && isManualOnly && canAllowElecAgain) {
        const title = 'Create a new current ELECTRONIC version. The candidate must re-submit hours and signatures in the app.';
        btns.push(`
          <button type="button" class="pill pill-info" style="${badgeBtnStyle}" data-ts-action="allow-electronic-again" title="${enc(title)}">
            Allow electronic again
          </button>
        `);
      }

      if (!importAuthoritative && tsId && !locked && canRevertToElec) {
        const title = 'Return to the previously submitted ELECTRONIC version without asking the candidate to resubmit. Recheck the hours afterwards.';
        btns.push(`
          <button type="button" class="pill pill-info" style="${badgeBtnStyle}" data-ts-action="revert-electronic" title="${enc(title)}">
            Revert to electronic
          </button>
        `);
      }
    }

    const FOOTER_ONLY_ACTION_RE =
      /data-ts-action="(?:delete-permanent|delete-manual-reopen)"/i;

    const safeBtns = btns.filter(html => !FOOTER_ONLY_ACTION_RE.test(String(html || '')));

    if (!safeBtns.length) return `<span class="mini">No actions available.</span>`;
    return `<div style="display:flex;flex-wrap:wrap;gap:8px;">${safeBtns.join('')}</div>`;
  })();

   // âœ… NEW: delete-policy badge (backend-authoritative; does not change existing route text)
  const dp =
    (window.modalCtx && window.modalCtx.timesheetDeletePreview && typeof window.modalCtx.timesheetDeletePreview === 'object')
      ? window.modalCtx.timesheetDeletePreview
      : null;

  const dpKind = String((dp && dp.kind) ? dp.kind : '').toUpperCase();
  const dpEligible = (dp && typeof dp.eligible === 'boolean') ? dp.eligible : false;

   const deletePolicyBadgeHtml = (() => {
    if (dpKind === 'IMPORT_CHILD_ADJUSTMENT') {
      const t = 'This is an NHSP/HR child adjustment and cannot be deleted directly. Delete must be performed via the parent timesheet (if eligible).';
      return `<span class="pill pill-bad" style="font-weight:600;" title="${enc(t)}">${enc("Adjustment â€“ Can't Delete")}</span>`;
    }

    if (dpKind === 'WEEKLY_CHAIN_DELETE_PARENT') {
      if (dpEligible) {
        const t = 'This is the weekly parent; it can be deleted (and will delete related import adjustments) when the chain is safe.';
        return `<span class="pill pill-ok" style="font-weight:600;" title="${enc(t)}">${enc('Parent Adjustment â€“ Can Delete')}</span>`;
      } else {
        const reasons =
          (dp && Array.isArray(dp.blocked_reasons) && dp.blocked_reasons.length)
            ? dp.blocked_reasons
                .map(r => (r && r.message) ? String(r.message) : '')
                .filter(Boolean)
                .join(' ')
            : '';

        const t = reasons
          ? `Can't delete yet. ${reasons}`
          : "Can't delete yet. This parent (or a related adjustment) is locked, invoiced, paid, or otherwise not eligible.";

        return `<span class="pill pill-bad" style="font-weight:600;" title="${enc(t)}">${enc("Parent Adjustment â€“ Can't delete yet")}</span>`;
      }
    }

    return '';
  })();


  const routeHtml = `
    <div class="card" style="margin-top:10px;">
      <div class="row">
        <label>Stage</label>
        <div class="controls" style="display:flex;flex-wrap:wrap;gap:6px;">
          ${stageBadges.join('')}
        </div>
      </div>

      <div class="row">
        <label>Route</label>
        <div class="controls" style="display:flex;flex-wrap:wrap;gap:6px;align-items:center;">
          ${deletePolicyBadgeHtml}
          <span class="pill ${routePillClass}" style="font-weight:600;" ${routeTitle ? `title="${enc(routeTitle)}"` : ''}>${enc(routeLabel)}</span>
          <span class="pill ${scopePillClass}" style="font-weight:600;">${enc(scopeLabel)}</span>
        </div>
      </div>

      <div class="row" data-view-only="true">
        <label>Actions</label>
        <div class="controls">${actionsHtml}</div>
      </div>
    </div>
  `;


  GE();

  return `
    <div class="tabc">
      ${headerHtml}
      ${routeHtml}
    </div>
  `;
}



async function openHrRotaAssignRoleModal(importId, rowIndex) {
  const impId = String(importId || '').trim();
  const idx = Number(rowIndex);
  if (!impId) {
    alert('Missing import_id for role assignment.');
    return;
  }
  if (!Number.isFinite(idx) || idx < 0) {
    alert('Invalid row index for role assignment.');
    return;
  }

  const enc = (typeof escapeHtml === 'function')
    ? escapeHtml
    : (s) => String(s ?? '').replace(/[&<>"']/g, (c) => ({
        '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
      }[c]));

  const st = window.__importSummaryState && window.__importSummaryState['HR_ROTA_DAILY'];
  const rows = st && Array.isArray(st.rows) ? st.rows : [];
  const row = (idx >= 0 && idx < rows.length) ? rows[idx] : null;
  if (!row) {
    alert('Row not found for role assignment.');
    return;
  }

  const hrRowId = row.hr_row_id ? String(row.hr_row_id).trim() : '';
  if (!hrRowId) {
    alert('This row has no hr_row_id, so a role assignment cannot be saved safely.');
    return;
  }

  const staff = String(row.staff_name || row.staff_raw || '').trim();
  const unit  = String(row.unit || row.hospital_or_trust || row.hospital_norm || '').trim();
  const date  = String(row.date_local || row.date || row.shift_date || row.work_date || '').trim();
  const grade = String(row.grade_raw || row.incoming_code || row.assignment_code || '').trim();

  const optionsRaw =
    (Array.isArray(row.timesheet_target_options) ? row.timesheet_target_options :
     Array.isArray(row.timesheetTargetOptions) ? row.timesheetTargetOptions :
     Array.isArray(row.target_options) ? row.target_options :
     Array.isArray(row.targetOptions) ? row.targetOptions :
     []);

  const options = (Array.isArray(optionsRaw) ? optionsRaw : []).map((o) => {
    const obj = (o && typeof o === 'object') ? o : {};
    const id =
      String(
        obj.target_id ??
        obj.targetId ??
        obj.timesheet_target_id ??
        obj.timesheetTargetId ??
        obj.timesheet_id ??
        obj.timesheetId ??
        obj.contract_id ??
        obj.contractId ??
        ''
      ).trim();

    const label =
      String(
        obj.label ??
        obj.display_label ??
        obj.displayLabel ??
        obj.band_label ??
        obj.bandLabel ??
        obj.role_label ??
        obj.roleLabel ??
        obj.contract_label ??
        obj.contractLabel ??
        ''
      ).trim();

    const extra = {
      candidate_id: obj.candidate_id ?? obj.candidateId ?? null,
      client_id: obj.client_id ?? obj.clientId ?? null,
      band: obj.band ?? obj.band_text ?? obj.bandText ?? null,
      role: obj.role ?? obj.role_text ?? obj.roleText ?? null
    };

    return { id, label, extra };
  }).filter(x => x.id);

  if (!options.length) {
    alert('No role/timesheet target options were provided for this row.');
    return;
  }

  // Persistent selection store per import
  window.__hrRotaRoleSelections = window.__hrRotaRoleSelections || {};
  if (!window.__hrRotaRoleSelections[impId] || typeof window.__hrRotaRoleSelections[impId] !== 'object') {
    window.__hrRotaRoleSelections[impId] = {};
  }

  const existing = window.__hrRotaRoleSelections[impId][hrRowId] || null;
  const initialSelectedId = existing && existing.target_id ? String(existing.target_id).trim() : '';

  window.__hrRotaAssignRoleState = {
    importId: impId,
    rowIndex: idx,
    hr_row_id: hrRowId,
    selectedTargetId: initialSelectedId || (options.length === 1 ? options[0].id : ''),
    options
  };

  const state = () => window.__hrRotaAssignRoleState || {};

  const renderTab = (key) => {
    if (key !== 'main') return '';
    const s = state();
    const selected = String(s.selectedTargetId || '').trim();

    const rowsHtml = s.options.map((o) => {
      const isSel = String(o.id) === selected;
      const band = o.extra && o.extra.band ? String(o.extra.band) : '';
      const role = o.extra && o.extra.role ? String(o.extra.role) : '';
      const metaBits = [];
      if (role) metaBits.push(role);
      if (band) metaBits.push(band);

      return `
        <tr class="${isSel ? 'active' : ''}"
            style="cursor:pointer;"
            data-act="hr-rota-role-pick"
            data-target-id="${enc(o.id)}">
          <td class="mini" style="white-space:normal;word-break:break-word;">
            <strong>${enc(o.label || o.id)}</strong>
            ${metaBits.length ? `<div class="mini" style="opacity:.8;margin-top:2px;">${enc(metaBits.join(' â€¢ '))}</div>` : ``}
          </td>
          <td class="mini" style="width:220px;white-space:nowrap;">
            <span class="mono">${enc(o.id)}</span>
          </td>
        </tr>
      `;
    }).join('');

    return html(`
      <div class="form" id="hrRotaAssignRole">
        <div class="card">
          <div class="row">
            <label>Assign role / target</label>
            <div class="controls">
              <div class="mini">
                Import: <span class="mono">${enc(impId)}</span><br/>
                Staff: <strong>${enc(staff || 'â€”')}</strong><br/>
                Unit / Site: <span class="mini">${enc(unit || 'â€”')}</span><br/>
                Date: <span class="mini">${enc(date || 'â€”')}</span>
                ${grade ? `<br/>Grade: <span class="mono">${enc(grade)}</span>` : ``}
              </div>
              <div class="hint mini" style="margin-top:6px;">
                Choose the correct role/timesheet target for this day. This selection will be saved and used for future imports.
              </div>
            </div>
          </div>
        </div>

        <div class="card" style="margin-top:10px;">
          <div class="row">
            <label>Targets</label>
            <div class="controls">
              <div style="max-height:300px; overflow:auto; border:1px solid var(--line); border-radius:10px; padding:6px;">
                <table class="grid" style="table-layout:auto; width:100%;">
                  <thead>
                    <tr>
                      <th>Target</th>
                      <th style="width:220px;">ID</th>
                    </tr>
                  </thead>
                  <tbody id="hrRotaRoleTargets">
                    ${rowsHtml}
                  </tbody>
                </table>
              </div>

              <div class="row" style="margin-top:10px;">
                <label></label>
                <div class="controls">
                  <button type="button" class="btn btn-primary" data-act="hr-rota-role-save">
                    Save selection
                  </button>
                  <button type="button" class="btn" style="margin-left:8px;" data-act="hr-rota-role-cancel">
                    Cancel
                  </button>
                  <span class="mini" style="margin-left:8px;">
                    After saving, the daily preview will reclassify.
                  </span>
                </div>
              </div>

            </div>
          </div>
        </div>
      </div>
    `);
  };

  showModal(
    'Assign role (HR Rota Daily)',
    [{ key: 'main', label: 'Assign role' }],
    renderTab,
    null,
    false,
    null,
    { kind: 'hr-rota-assign-role', noParentGate: true, stayOpenOnSave: false }
  );

  setTimeout(() => {
    const root = document.getElementById('modalBody');
    if (!root) return;

    const fr = (typeof window.__getModalFrame === 'function') ? window.__getModalFrame() : null;
    if (!fr || fr.kind !== 'hr-rota-assign-role') return;

    const host = root.querySelector('#hrRotaAssignRole');
    if (!host) return;

    // De-dupe
    root.__hrRotaAssignRoleWired ||= new Set();
    const wKey = `hr-rota-assign-role:${impId}:${hrRowId}`;
    if (root.__hrRotaAssignRoleWired.has(wKey)) return;
    root.__hrRotaAssignRoleWired.add(wKey);

    host.addEventListener('click', async (ev) => {
      const tr = ev.target && ev.target.closest ? ev.target.closest('tr[data-act="hr-rota-role-pick"]') : null;
      if (tr) {
        const targetId = String(tr.getAttribute('data-target-id') || '').trim();
        if (!targetId) return;
        window.__hrRotaAssignRoleState = state();
        window.__hrRotaAssignRoleState.selectedTargetId = targetId;

        // Re-render selection highlight
        try {
          const fr2 = (typeof window.__getModalFrame === 'function') ? window.__getModalFrame() : null;
          if (fr2 && fr2.kind === 'hr-rota-assign-role' && typeof fr2.setTab === 'function') fr2.setTab('main');
        } catch {}
        return;
      }

      const btn = ev.target && ev.target.closest ? ev.target.closest('button[data-act]') : null;
      if (!btn) return;
      const act = String(btn.getAttribute('data-act') || '');

      if (act === 'hr-rota-role-cancel') {
        const closeBtn = document.getElementById('btnCloseModal');
        if (closeBtn) closeBtn.click();
        return;
      }

      if (act === 'hr-rota-role-save') {
        const s = state();
        const selectedId = String(s.selectedTargetId || '').trim();
        if (!selectedId) {
          alert('Select a target first.');
          return;
        }

        // Find selected option (for label persistence)
        const chosen = (s.options || []).find(o => String(o.id) === selectedId) || null;
        const chosenLabel = chosen ? (chosen.label || chosen.id) : selectedId;

        // Persist locally (survives rerender)
        window.__hrRotaRoleSelections = window.__hrRotaRoleSelections || {};
        if (!window.__hrRotaRoleSelections[impId] || typeof window.__hrRotaRoleSelections[impId] !== 'object') {
          window.__hrRotaRoleSelections[impId] = {};
        }
        window.__hrRotaRoleSelections[impId][hrRowId] = {
          target_id: selectedId,
          label: String(chosenLabel || selectedId)
        };

        // Persist to backend for future imports + reclassify correctness
        // Expected helper exists per your plan: postHrRotaResolveMappings(importId, payload)
        // Payload includes stable hr_row_id -> selected target id plus useful context.
        if (typeof postHrRotaResolveMappings !== 'function') {
          alert('postHrRotaResolveMappings is not defined (cannot persist role mapping to backend).');
          return;
        }

        const payload = {
          role_mappings: [{
            hr_row_id: hrRowId,
            target_id: selectedId,
            candidate_id: row.candidate_id || null,
            client_id: row.client_id || null,
            work_date: row.work_date || row.date_local || row.date || row.shift_date || null,
            grade_raw: row.grade_raw || row.incoming_code || row.assignment_code || null
          }]
        };

        try {
          await postHrRotaResolveMappings(impId, payload);

          window.__toast && window.__toast('Role mapping saved. Reclassifyingâ€¦');

          if (typeof refreshHrRotaSummary === 'function') {
            await refreshHrRotaSummary(impId);
          }

          const closeBtn = document.getElementById('btnCloseModal');
          if (closeBtn) closeBtn.click();
        } catch (err) {
          console.error('[HR_ROTA][ROLE] save failed', err);
          alert(err?.message || 'Failed to save role mapping.');
        }
      }
    });
  }, 0);
}

function renderHrRotaDailySummary(type, importId, rows, ss) {
  const enc = (typeof escapeHtml === 'function')
    ? escapeHtml
    : (s) => String(s ?? '').replace(/[&<>"']/g, (c) => ({
        '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
      }[c]));

  const summary = (ss && typeof ss.summary === 'object' && ss.summary) ? ss.summary : {};
  const total   = summary.total_rows || rows.length || 0;

  const impKey = String(importId || '').trim();

  const counts = { OK: 0, FAILED: 0, UNMATCHED: 0 };
  rows.forEach(r => {
    const st = String(r.status || '').toUpperCase();
    if (st === 'OK' || st === 'VALIDATION_OK') counts.OK++;
    else if (st === 'UNMATCHED') counts.UNMATCHED++;
    else counts.FAILED++;
  });

  // âœ… Persist email selections across rerender/refresh (do NOT reset every render)
  window.__hrRotaEmailSelections = window.__hrRotaEmailSelections || {};
  if (!window.__hrRotaEmailSelections[impKey] || !(window.__hrRotaEmailSelections[impKey] instanceof Set)) {
    window.__hrRotaEmailSelections[impKey] = new Set();
  }
  const emailSel = window.__hrRotaEmailSelections[impKey];

  // âœ… Persist role selections across rerender/refresh (hr_row_id -> {target_id,label})
  window.__hrRotaRoleSelections = window.__hrRotaRoleSelections || {};
  if (!window.__hrRotaRoleSelections[impKey] || typeof window.__hrRotaRoleSelections[impKey] !== 'object') {
    window.__hrRotaRoleSelections[impKey] = {};
  }
  const roleSel = window.__hrRotaRoleSelections[impKey];

  // âœ… Reconcile email selection set to only contain REAL hr_row_id values present in this render
  const validHrRowIds = new Set();
  for (const r of (rows || [])) {
    const hrid = r && r.hr_row_id ? String(r.hr_row_id).trim() : '';
    if (hrid) validHrRowIds.add(hrid);
  }
  for (const id of Array.from(emailSel)) {
    const s = String(id || '').trim();
    if (!s || !validHrRowIds.has(s)) emailSel.delete(id);
  }
  for (const k of Object.keys(roleSel || {})) {
    if (!validHrRowIds.has(String(k))) {
      delete roleSel[k];
    }
  }

  const needsRoleResolve = (r) => {
    if (!r) return false;
    const flag = (r.role_resolution_required === true) || (r.roleResolutionRequired === true);
    if (flag) return true;

    const reasonCode = String(r.reason_code || r.failure_reason || r.reason || '').toLowerCase();
    if (reasonCode === 'role_unresolved' ||
        reasonCode === 'role_ambiguous' ||
        reasonCode === 'timesheet_target_unresolved' ||
        reasonCode === 'timesheet_target_ambiguous' ||
        reasonCode === 'band_unresolved' ||
        reasonCode === 'band_ambiguous') return true;

    const opts =
      (Array.isArray(r.timesheet_target_options) ? r.timesheet_target_options :
       Array.isArray(r.timesheetTargetOptions) ? r.timesheetTargetOptions :
       Array.isArray(r.target_options) ? r.target_options :
       Array.isArray(r.targetOptions) ? r.targetOptions :
       []);
    return Array.isArray(opts) && opts.length > 1;
  };

  const selectedRoleLabelFor = (hrRowId) => {
    const rec = roleSel && hrRowId ? roleSel[String(hrRowId)] : null;
    if (!rec || typeof rec !== 'object') return '';
    const lbl = String(rec.label || '').trim();
    return lbl;
  };

  const rowsHtml = rows.length
    ? rows.map((r, idx) => {
        const staff = r.staff_name || r.staff_raw || '';
        const unit  = r.unit || r.hospital_or_trust || r.hospital_norm || '';
        const date  = r.date_local || r.date || r.shift_date || '';
        const stRaw = r.status || '';
        const st    = String(stRaw || '').toUpperCase();
        const reasonCode = String(r.reason_code || r.failure_reason || r.reason || '').toLowerCase();

        const canAssignCand   = (reasonCode === 'candidate_unresolved');
        const canAssignClient = (reasonCode === 'client_unresolved');

        const needRole = needsRoleResolve(r);

        const isTimeMismatch =
          reasonCode === 'actual_hours_mismatch' ||
          reasonCode === 'start_end_mismatch' ||
          reasonCode === 'break_minutes_mismatch';

        let stCls = 'pill-info';
        if (st === 'OK' || st === 'VALIDATION_OK') {
          stCls = 'pill-ok';
        } else if (reasonCode === 'candidate_unresolved' || reasonCode === 'client_unresolved') {
          stCls = 'pill-bad';
        } else if (needRole) {
          stCls = 'pill-bad';
        } else if (isTimeMismatch) {
          stCls = 'pill-warn';
        }

        // Normalised, human-readable label text
        let pillLabel;
        if (st === 'OK' || st === 'VALIDATION_OK') {
          pillLabel = 'OK';
        } else if (reasonCode === 'candidate_unresolved') {
          pillLabel = 'CANDIDATE UNMATCHED';
        } else if (reasonCode === 'client_unresolved') {
          pillLabel = 'CLIENT UNMATCHED';
        } else if (needRole) {
          pillLabel = 'ROLE/TARGET UNRESOLVED';
        } else if (reasonCode === 'actual_hours_mismatch') {
          pillLabel = 'HOURS MISMATCH';
        } else if (reasonCode === 'start_end_mismatch') {
          pillLabel = 'START/END MISMATCH';
        } else if (reasonCode === 'break_minutes_mismatch') {
          pillLabel = 'BREAK MISMATCH';
        } else {
          pillLabel = (reasonCode || 'UNKNOWN').replace(/_/g, ' ').toUpperCase();
        }

        // âœ… New backend fields
        const canEmail = (r.can_email === true);
        const recipientMissing = (r.recipient_missing === true);
        const recipientEmail = (r.recipient_email != null) ? String(r.recipient_email).trim() : '';
        const emailAlreadySent = (r.email_already_sent === true);

        // âœ… Must only ever use REAL hr_row_id for email selection
        const hrRowId = r.hr_row_id ? String(r.hr_row_id).trim() : '';

        let emailCellHtml;

        // If we cannot identify a real row id, never allow selecting it.
        if (!hrRowId) {
          emailCellHtml = '<span class="mini">â€”</span>';
        } else if (recipientMissing) {
          const title = recipientEmail
            ? `Recipient email present but marked missing: ${recipientEmail}`
            : 'Recipient email missing (clients.ts_queries_email not set).';
          const iconHtml = emailAlreadySent
            ? `<span class="email-icon" title="Email previously sent" style="font-size:0.8rem;opacity:0.7;">&#x2709;&#x2713;</span>`
            : '';
          emailCellHtml = `
            <div class="hr-email-cell" style="display:flex;align-items:center;justify-content:center;gap:6px;">
              <span class="pill pill-bad" title="${enc(title)}">RECIPIENT MISSING</span>
              ${iconHtml}
            </div>
          `;
        } else if (!canEmail) {
          const iconHtml = emailAlreadySent
            ? `<span class="email-icon" title="Email previously sent" style="font-size:0.8rem;opacity:0.7;">&#x2709;&#x2713;</span>`
            : '';
          emailCellHtml = `
            <div class="hr-email-cell" style="display:flex;align-items:center;justify-content:center;gap:4px;">
              <span class="mini">â€”</span>
              ${iconHtml}
            </div>
          `;
        } else {
          const checked = (emailSel instanceof Set && emailSel.has(hrRowId)) ? 'checked' : '';
          const iconHtml = emailAlreadySent
            ? `<span class="email-icon" title="Email previously sent" style="font-size:0.8rem;opacity:0.7;">&#x2709;&#x2713;</span>`
            : '';

          emailCellHtml = `
            <div class="hr-email-cell" style="display:flex;align-items:center;justify-content:center;gap:4px;">
              <input type="checkbox"
                     data-act="hr-rota-email"
                     data-row-id="${enc(hrRowId)}"
                     data-row-idx="${idx}"
                     ${checked} />
              ${iconHtml}
            </div>
          `;
        }

        const roleLabel = hrRowId ? selectedRoleLabelFor(hrRowId) : '';
        const roleMini = roleLabel
          ? `<div class="mini" style="margin-top:4px;opacity:.85;">Selected: ${enc(roleLabel)}</div>`
          : '';

        return `
          <tr>
            <td><span class="mini">${enc(staff || 'â€”')}</span></td>
            <td><span class="mini">${enc(unit || 'â€”')}</span></td>
            <td><span class="mini">${enc(date || 'â€”')}</span></td>
            <td>
              <span
                class="pill ${stCls}"
                style="
                  white-space: normal;
                  word-break: break-word;
                  display: inline-block;
                  max-width: 170px;
                  text-align: center;
                "
              >
                ${enc(pillLabel || 'UNKNOWN')}
              </span>
            </td>
            <td>
              ${
                canAssignCand
                  ? `<button type="button"
                             class="btn mini"
                             data-act="resolve-candidate"
                             data-row-idx="${idx}">
                       Assign candidateâ€¦
                     </button>`
                  : ''
              }
              ${
                canAssignClient
                  ? `<button type="button"
                             class="btn mini"
                             style="margin-left:4px;"
                             data-act="resolve-client"
                             data-row-idx="${idx}">
                       Assign clientâ€¦
                     </button>`
                  : ''
              }
              ${
                needRole
                  ? `<button type="button"
                             class="btn mini"
                             style="${(canAssignCand || canAssignClient) ? 'margin-left:4px;' : ''}"
                             data-act="resolve-role"
                             data-row-idx="${idx}">
                       Assign roleâ€¦
                     </button>
                     ${roleMini}`
                  : roleMini
              }
            </td>
            <td>${emailCellHtml}</td>
          </tr>
        `;
      }).join('')
    : `
      <tr>
        <td colspan="6">
          <span class="mini">No rows to show.</span>
        </td>
      </tr>
    `;

  const markup = html(`
    <div class="form" id="hrRotaSummary">
      <div class="card hr-rota-full">
        <div class="row">
          <label>Overview</label>
          <div class="controls">
            <div class="mini">
              Import ID: <span class="mono">${enc(importId || 'â€”')}</span><br/>
              Total rows: ${total}<br/>
              OK: ${counts.OK} &nbsp; Failed: ${counts.FAILED} &nbsp; Unmatched: ${counts.UNMATCHED}
            </div>
          </div>
        </div>

        <div class="row" style="margin-top:10px;">
          <label>Rows</label>
          <div class="controls">
            <div class="hr-rota-table-wrap" style="max-height:420px; overflow-y:auto;">
              <table class="grid">
                <thead>
                  <tr>
                    <th>Staff</th>
                    <th>Unit / Site</th>
                    <th>Date</th>
                    <th>Status</th>
                    <th>Resolve</th>
                    <th>Send email</th>
                  </tr>
                </thead>
                <tbody>
                  ${rowsHtml}
                </tbody>
              </table>
            </div>
          </div>
        </div>

        <div class="row hr-rota-footer" style="margin-top:8px;">
          <label></label>
          <div class="controls">
            <button type="button"
                    class="btn"
                    data-act="hr-rota-reclassify">
              Reclassify
            </button>
            <button type="button"
                    class="btn btn-primary"
                    style="margin-left:8px;"
                    data-act="hr-rota-apply">
              Finalise validations
            </button>
            <span class="mini" style="margin-left:8px;">
              "Reclassify" re-runs checks and refreshes this summary.
              "Finalise validations" updates validation status and, if boxes are ticked,
              queues emails to Temp Staffing.
            </span>
          </div>
        </div>
      </div>
    </div>
  `);

  // Wiring (extended to include role resolve + apply gating)
  setTimeout(() => {
    try {
      const root = document.getElementById('hrRotaSummary');
      if (!root || type !== 'HR_ROTA_DAILY') return;

      // Helper: build a minimal hint object from HR row staff fields (for seeding candidate picker)
      const buildHintFromHrRow = (row) => {
        const staff = String(row.staff_name || row.staff_raw || '').trim();
        if (!staff) return null;

        const parts = staff.split(/\s+/).filter(Boolean);
        const first = parts.length ? parts[0] : '';
        const sur   = parts.length > 1 ? parts[parts.length - 1] : '';

        const email = String(row.staff_email || row.email || row.worker_email || '').trim();

        const hint = {
          source: 'hr_rota_daily',
          display_name: staff,
          first_name: first,
          surname: sur
        };
        if (email) hint.email = email;

        Object.keys(hint).forEach(k => { if (!hint[k]) delete hint[k]; });
        return Object.keys(hint).length ? hint : null;
      };

      root.addEventListener('click', (ev) => {
        const btn = ev.target.closest('button[data-act]');
        if (!btn) return;
        const act = btn.getAttribute('data-act');

        const st = window.__importSummaryState && window.__importSummaryState['HR_ROTA_DAILY'];
        if (!st) return;

        const rows = Array.isArray(st.rows) ? st.rows : [];
        const idx  = Number(btn.getAttribute('data-row-idx') || '-1');
        const row  = (idx >= 0 && idx < rows.length) ? rows[idx] : null;
        if (!row) return;

        const reasonCode   = String(row.reason_code || row.failure_reason || row.reason || '').toLowerCase();
        const hasTimesheet = !!row.timesheet_id;

        const unit = row.unit || row.hospital_or_trust || row.hospital_norm || '';
        const staff = row.staff_name || row.staff_raw || '';

        if (act === 'resolve-role') {
          if (typeof openHrRotaAssignRoleModal !== 'function') {
            alert('Role assignment modal is not available.');
            return;
          }
          openHrRotaAssignRoleModal(importId, idx);
          return;
        }

        if (act === 'resolve-candidate') {
          // HR-row resolution path (no TS / still candidate_unresolved)
          if (reasonCode === 'candidate_unresolved' || !hasTimesheet) {
            openHrRotaAssignCandidateModal(importId, idx);
            return;
          }

          // Timesheet-backed resolution path
          if (hasTimesheet) {
            const hint = buildHintFromHrRow(row);

            if (typeof openResolveCandidatePicker === 'function') {
              openResolveCandidatePicker({
                timesheet_id: row.timesheet_id,
                hospital_norm: unit,
                occupant_key_norm: staff,
                candidate_hint_text: hint
              });
              return;
            }

            if (typeof openResolveCandidateModal === 'function') {
              openResolveCandidateModal({
                timesheet_id:      row.timesheet_id,
                occupant_key_norm: staff,
                hospital_norm:     unit
              });
              return;
            }

            alert('Candidate resolve picker is not available.');
          } else {
            alert('No timesheet matched for this row; resolve candidate via imports/aliases instead.');
          }
        }

        if (act === 'resolve-client') {
          // HR-row resolution path (no TS / still client_unresolved)
          if (reasonCode === 'client_unresolved' || !hasTimesheet) {
            openHrRotaAssignClientModal(importId, idx);
            return;
          }

          // Timesheet-backed resolution path
          if (hasTimesheet) {
            if (typeof openResolveClientPicker === 'function') {
              openResolveClientPicker({
                timesheet_id:  row.timesheet_id,
                hospital_norm: unit
              });
              return;
            }

            if (typeof openResolveClientModal === 'function') {
              openResolveClientModal({
                timesheet_id:  row.timesheet_id,
                hospital_norm: unit
              });
              return;
            }

            alert('Client resolve picker is not available.');
          } else {
            alert('No timesheet matched for this row; resolve client/site via imports/aliases instead.');
          }
        }
      });

      root.addEventListener('change', (ev) => {
        const cb = ev.target.closest('input[data-act="hr-rota-email"]');
        if (!cb) return;

        const rowId = String(cb.getAttribute('data-row-id') || '').trim();
        if (!rowId) return;

        window.__hrRotaEmailSelections = window.__hrRotaEmailSelections || {};
        if (!window.__hrRotaEmailSelections[impKey] || !(window.__hrRotaEmailSelections[impKey] instanceof Set)) {
          window.__hrRotaEmailSelections[impKey] = new Set();
        }

        if (cb.checked) {
          window.__hrRotaEmailSelections[impKey].add(rowId);
        } else {
          window.__hrRotaEmailSelections[impKey].delete(rowId);
        }
      });

      const btnReclass = root.querySelector('button[data-act="hr-rota-reclassify"]');
      if (btnReclass && !btnReclass.__hrRotaReclassWired) {
        btnReclass.__hrRotaReclassWired = true;
        btnReclass.addEventListener('click', async () => {
          try {
            if (!importId) {
              alert('No import_id in summary; cannot reclassify.');
              return;
            }
            await refreshHrRotaSummary(importId);
          } catch (err) {
            console.error('[IMPORTS][HR_ROTA] reclassify failed', err);
            alert(err?.message || 'Reclassify failed.');
          }
        });
      }

      const btnApply = root.querySelector('button[data-act="hr-rota-apply"]');
      if (btnApply && !btnApply.__hrRotaApplyWired) {
        btnApply.__hrRotaApplyWired = true;
        btnApply.addEventListener('click', async () => {
          try {
            if (!importId) {
              alert('No import_id in summary; cannot finalise.');
              return;
            }

            // âœ… Gate apply: must not finalise while candidate or role/target resolution is missing
            const st = window.__importSummaryState && window.__importSummaryState['HR_ROTA_DAILY'];
            const rowsNow = st && Array.isArray(st.rows) ? st.rows : [];

            let missingCand = 0;
            let missingRole = 0;

            for (const r of rowsNow) {
              const reasonCode = String(r?.reason_code || r?.failure_reason || r?.reason || '').toLowerCase();
              const candUnresolved = (reasonCode === 'candidate_unresolved') && !(r && r.candidate_id);
              if (candUnresolved) missingCand++;

              const needRole = needsRoleResolve(r);
              if (needRole) {
                const hrid = r && r.hr_row_id ? String(r.hr_row_id).trim() : '';
                const picked = hrid && roleSel && roleSel[hrid] && String(roleSel[hrid].target_id || '').trim();
                if (!picked) missingRole++;
              }
            }

            if (missingCand || missingRole) {
              const parts = [];
              if (missingCand) parts.push(`Candidate unresolved: ${missingCand}`);
              if (missingRole) parts.push(`Role/target unresolved: ${missingRole}`);
              alert(`Cannot finalise yet.\n\n${parts.join('\n')}\n\nResolve these rows first, then reclassify.`);
              return;
            }

            const ok = window.confirm('Are you sure you are ready to finalise?');
            if (!ok) return;

            // âœ… Only REAL hr_row_id values are sent
            const sel = window.__hrRotaEmailSelections && window.__hrRotaEmailSelections[impKey];
            const sendEmailRowIds = (sel instanceof Set) ? Array.from(sel).map(x => String(x).trim()).filter(Boolean) : [];

            const result = await applyHrRotaValidation(importId, sendEmailRowIds) || {};

            const lines = [];
            lines.push(`HR Rota validations for import ${result.import_id || importId} have been processed.`);

            if (typeof result.validations_ok === 'number') {
              lines.push(`Valid rows: ${result.validations_ok}`);
            }
            if (typeof result.validations_failed === 'number') {
              lines.push(`Rows still unresolved: ${result.validations_failed}`);
            }
            if (typeof result.emails_queued === 'number') {
              lines.push(`Emails queued: ${result.emails_queued}`);
            }

            if (Array.isArray(result.reasons) && result.reasons.length) {
              lines.push('');
              lines.push('Remaining issues:');
              for (const r of result.reasons) {
                const rc    = String(r.reason_code || '').toLowerCase();
                const count = r.count ?? 0;
                let nice;
                if      (rc === 'candidate_unresolved')         nice = 'Candidate unmatched';
                else if (rc === 'client_unresolved')            nice = 'Client unmatched';
                else if (rc === 'role_unresolved')              nice = 'Role/target unresolved';
                else if (rc === 'timesheet_target_unresolved')  nice = 'Role/target unresolved';
                else if (rc === 'actual_hours_mismatch')       nice = 'Hours mismatch';
                else if (rc === 'start_end_mismatch')          nice = 'Start/end mismatch';
                else if (rc === 'break_minutes_mismatch')      nice = 'Break mismatch';
                else                                           nice = (rc || 'other').replace(/_/g, ' ');
                lines.push(`- ${nice}: ${count}`);
              }
            }

            alert(lines.join('\n'));
            await refreshHrRotaSummary(importId);
          } catch (err) {
            console.error('[IMPORTS][HR_ROTA] apply failed', err);
            alert(err?.message || 'Apply validations failed.');
          }
        });
      }
    } catch (e) {
      console.warn('[IMPORTS] HR_ROTA wiring failed', e);
    }
  }, 0);

  return markup;
}

async function switchContractWeekToManual(weekId) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][CW-SWITCH-MANUAL]');
  GC('switchContractWeekToManual');

  if (!weekId) {
    GE();
    throw new Error('switchContractWeekToManual: weekId is required');
  }

  const encId = encodeURIComponent(weekId);
  const url   = API(`/api/contract-weeks/${encId}/switch-mode`);

  L('REQUEST', { url, weekId });

  let res, text;
  try {
    res  = await authFetch(url, { method: 'POST' });
    text = await res.text();
  } catch (err) {
    L('network error', err);
    GE();
    throw err;
  }

  if (!res.ok) {
    L('server error', { status: res.status, bodyPreview: text.slice(0, 400) });
    GE();
    throw new Error(text || `Failed to switch contract week ${weekId} to manual`);
  }

  let json = {};
  try {
    json = text ? JSON.parse(text) : {};
  } catch (err) {
    L('parse error', err);
  }

  L('RESULT', json);
  GE();
  return json;
}


function renderTimesheetFinanceTab(ctx) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][FINANCE]');
  const { row, details, related, state } = normaliseTimesheetCtx(ctx);

  GC('render');
  const ts    = details.timesheet || {};
  const tsfin = details.tsfin     || {};
  const enc   = escapeHtml;

  const fmtMoney = (v) =>
    isNaN(Number(v)) ? 'â€”' : `Â£${(Math.round(Number(v) * 100) / 100).toFixed(2)}`;

  const round2 = (n) => Math.round((Number(n) || 0) * 100) / 100;

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // ERNI-aware margin helpers (UI must not "recompute margin wrong")
  // - Prefer server-provided tsfin.margin_ex_vat where available
  // - For per-bucket display, compute pay-cost inc ERNI when policy says so
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const pctToMultiplier = (pctMaybe) => {
    let p = Number(pctMaybe);
    if (!Number.isFinite(p) || p <= 0) return 1;
    if (p > 1) p = p / 100; // treat as percent if stored like 15.00
    const m = 1 + p;
    return (Number.isFinite(m) && m > 0) ? m : 1;
  };

  const getErniCtxFromPolicy = (policyObj, payMethodUpper) => {
    const pol = (policyObj && typeof policyObj === 'object') ? policyObj : {};
    const applyTo = String(pol.apply_erni_to || 'PAYE_ONLY').toUpperCase();
    const erniPct = (pol.erni_pct != null) ? Number(pol.erni_pct) : NaN;

    const erniMult = pctToMultiplier(erniPct);
    const applies =
      (applyTo === 'ALL') ||
      (applyTo === 'PAYE_ONLY' && payMethodUpper === 'PAYE');

    return { applies: !!applies, erni_pct: Number.isFinite(erniPct) ? erniPct : null, erni_mult: erniMult };
  };

  const payMethodUpper = String(tsfin.pay_method || ts.pay_method || '').toUpperCase();
  const policySnap = tsfin.policy_snapshot_json || null;
  const erniCtx = getErniCtxFromPolicy(policySnap, payMethodUpper);

  const applyErniToPayEx = (payEx) => {
    const p = Number(payEx || 0);
    if (!Number.isFinite(p)) return 0;
    return erniCtx.applies ? (p * erniCtx.erni_mult) : p;
  };

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Staged Expenses/Mileage (live preview before Save)
  // Source of truth for "live preview" = modal state (expensesDraft)
  // In view mode it matches TSFIN because normaliseTimesheetCtx seeds it from TSFIN.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const mc = window.modalCtx || {};
  const st = mc.timesheetState || state || {};

  const expDraft = (st.expensesDraft && typeof st.expensesDraft === 'object')
    ? st.expensesDraft
    : {
        mileage_units: 0,
        travel_pay: 0, travel_charge: 0,
        accommodation_pay: 0, accommodation_charge: 0,
        other_pay: 0, other_charge: 0
      };

  const travelPay = round2(expDraft.travel_pay || 0);
  const travelChg = round2(expDraft.travel_charge || 0);
  const accomPay  = round2(expDraft.accommodation_pay || 0);
  const accomChg  = round2(expDraft.accommodation_charge || 0);
  const otherPay  = round2(expDraft.other_pay || 0);
  const otherChg  = round2(expDraft.other_charge || 0);

  const expensesPayLive   = round2(travelPay + accomPay + otherPay);
  const expensesChargeLive= round2(travelChg + accomChg + otherChg);
  const expensesMarginLive= round2(expensesChargeLive - expensesPayLive);

  const mileagePayRate    = (tsfin.mileage_pay_rate != null) ? Number(tsfin.mileage_pay_rate) : null;
  const mileageChargeRate = (tsfin.mileage_charge_rate != null) ? Number(tsfin.mileage_charge_rate) : null;

  const mileageRatesOk =
    Number.isFinite(mileagePayRate) &&
    Number.isFinite(mileageChargeRate) &&
    mileagePayRate > 0 &&
    mileageChargeRate > 0;

  const mileageUnitsLive  = Number(expDraft.mileage_units || 0) || 0;
  const mileagePayLive    = mileageRatesOk ? round2(mileageUnitsLive * mileagePayRate) : 0;
  const mileageChargeLive = mileageRatesOk ? round2(mileageUnitsLive * mileageChargeRate) : 0;
  const mileageMarginLive = round2(mileageChargeLive - mileagePayLive);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Core TSFIN-derived buckets (actual snapshot)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const hours = {
    day:   Number(tsfin.hours_day   || 0),
    night: Number(tsfin.hours_night || 0),
    sat:   Number(tsfin.hours_sat   || 0),
    sun:   Number(tsfin.hours_sun   || 0),
    bh:    Number(tsfin.hours_bh    || 0)
  };

  const pay = {
    day:   tsfin.pay_day,
    night: tsfin.pay_night,
    sat:   tsfin.pay_sat,
    sun:   tsfin.pay_sun,
    bh:    tsfin.pay_bh
  };

  const chg = {
    day:   tsfin.charge_day,
    night: tsfin.charge_night,
    sat:   tsfin.charge_sat,
    sun:   tsfin.charge_sun,
    bh:    tsfin.charge_bh
  };

  const buckets = ['day','night','sat','sun','bh'];
  const bucketLabel = {
    day:  'Day',
    night:'Night',
    sat:  'Saturday',
    sun:  'Sunday',
    bh:   'Bank Holiday'
  };

  const computeStandardFromRates = ({ hoursObj, payObj, chgObj, erniApplies, erniMult }) => {
    let missing = false;
    let payExSum = 0;
    let chgExSum = 0;
    let marSum   = 0;

    for (const b of buckets) {
      const hrs = Number(hoursObj?.[b] || 0) || 0;
      const payR = (payObj?.[b] != null && Number.isFinite(Number(payObj[b]))) ? Number(payObj[b]) : null;
      const chgR = (chgObj?.[b] != null && Number.isFinite(Number(chgObj[b]))) ? Number(chgObj[b]) : null;

      if (hrs > 0 && (payR == null || chgR == null)) missing = true;

      const payEx = (payR != null) ? (hrs * payR) : 0;
      const chgEx = (chgR != null) ? (hrs * chgR) : 0;

      const payCost = erniApplies ? (payEx * (Number.isFinite(Number(erniMult)) ? Number(erniMult) : 1)) : payEx;
      const marEx   = chgEx - payCost;

      payExSum += payEx;
      chgExSum += chgEx;
      marSum   += marEx;
    }

    return {
      missingRates: !!missing,
      pay_ex_vat: round2(payExSum),
      charge_ex_vat: round2(chgExSum),
      margin_ex_vat: round2(marSum)
    };
  };

  // âœ… IMPORTANT: margin column must reflect TSFIN logic (PAYE may include ERNI).
  const tsfinBucketRows = buckets.map(b => {
    const hrs   = hours[b] || 0;
    const payR  = pay[b] != null ? Number(pay[b]) : null;
    const chgR  = chg[b] != null ? Number(chg[b]) : null;

    const payEx = (payR != null) ? (hrs * payR) : null;
    const chgEx = (chgR != null) ? (hrs * chgR) : null;

    const payCostEx = (payEx != null) ? applyErniToPayEx(payEx) : null;
    const marEx = (payCostEx != null && chgEx != null) ? (chgEx - payCostEx) : null;

    return `
      <tr>
        <td>${bucketLabel[b]}</td>
        <td>${hrs || 0}</td>
        <td>${payR != null ? fmtMoney(payR) : 'â€”'}</td>
        <td>${chgR != null ? fmtMoney(chgR) : 'â€”'}</td>
        <td>${payEx != null ? fmtMoney(payEx) : 'â€”'}</td>
        <td>${chgEx != null ? fmtMoney(chgEx) : 'â€”'}</td>
        <td>${marEx != null ? fmtMoney(marEx) : 'â€”'}</td>
      </tr>
    `;
  }).join('');

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Additional rates (snapshot table remains as-is)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let addUnits = tsfin.additional_units_json || {};
  if (typeof addUnits === 'string') {
    try { addUnits = JSON.parse(addUnits); } catch { addUnits = {}; }
  }
  if (!addUnits || typeof addUnits !== 'object') addUnits = {};

  const additionalRows = Object.entries(addUnits).map(([code, ex]) => {
    if (!ex || typeof ex !== 'object') return '';
    const bucketName = (ex.bucket_name || code || '').trim();
    const unitName   = (ex.unit_name || 'units').trim();
    const unitCount  = Number(ex.unit_count || 0) || 0;

    const payEx      = Number(ex.pay_ex_vat    || 0);
    const chgEx      = Number(ex.charge_ex_vat || 0);

    const hasServerMargin = (ex.margin_ex_vat != null && Number.isFinite(Number(ex.margin_ex_vat)));
    const marEx = hasServerMargin
      ? Number(ex.margin_ex_vat)
      : (chgEx - applyErniToPayEx(payEx));

    if (!unitCount && !payEx && !chgEx) return '';

    return `
      <tr>
        <td>${enc(bucketName || code)}</td>
        <td>${unitCount}</td>
        <td>${enc(unitName)}</td>
        <td>${fmtMoney(ex.pay_rate    ?? null)}</td>
        <td>${fmtMoney(ex.charge_rate ?? null)}</td>
        <td>${fmtMoney(payEx)}</td>
        <td>${fmtMoney(chgEx)}</td>
        <td>${fmtMoney(marEx)}</td>
      </tr>
    `;
  }).filter(Boolean).join('');

  const hasAdditional = !!additionalRows;

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Determine mode & schedule state
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let frameMode = 'view';
  try {
    if (typeof window.__getModalFrame === 'function') {
      const fr = window.__getModalFrame();
      if (fr && typeof fr.mode === 'string') frameMode = fr.mode;
    }
  } catch {}

  const meta           = mc.timesheetMeta || {};
  const isPlannedWeek  = !!meta.isPlannedWeek;
  const isEditing      = (frameMode === 'edit' || frameMode === 'create');

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ensure schedule is fresh (weekly manual) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const sheetScope = (details.sheet_scope || row.sheet_scope || ts.sheet_scope || '').toUpperCase();
  const subMode    = (row.submission_mode || ts.submission_mode || '').toUpperCase();

  const recomputeScheduleIfPossible = () => {
    try {
      if (typeof buildWeeklyScheduleFromLinesAndValidate !== 'function') return null;
      if (!st || !st.weeklyLinesByDate || typeof st.weeklyLinesByDate !== 'object') return null;
      const wd = Array.isArray(st.__weekDaysForSchedule) && st.__weekDaysForSchedule.length ? st.__weekDaysForSchedule : null;
      const out = buildWeeklyScheduleFromLinesAndValidate(st.weeklyLinesByDate, wd || undefined, {
        allowOvernight: true,
        allowBreakMins: true
      });
      st.schedule = Array.isArray(out?.schedule) ? out.schedule : [];
      st.scheduleErrorsByDate = (out?.errorsByDate && typeof out.errorsByDate === 'object') ? out.errorsByDate : {};
      st.scheduleHasErrors = !!out?.hasErrors;
      st.__scheduleUpdatedAt = Date.now();
      return out;
    } catch {
      return null;
    }
  };

  if (sheetScope === 'WEEKLY' && subMode === 'MANUAL') {
    const hasLines = !!(st.weeklyLinesByDate && typeof st.weeklyLinesByDate === 'object' && Object.keys(st.weeklyLinesByDate).length);
    const hasScheduleAlready = Array.isArray(st.schedule);
    const hasErrFlags = (typeof st.scheduleHasErrors === 'boolean') && (st.scheduleErrorsByDate && typeof st.scheduleErrorsByDate === 'object');
    if (hasLines && (!hasScheduleAlready || !hasErrFlags)) {
      recomputeScheduleIfPossible();
    }
  }

  const schedule = Array.isArray(st.schedule) ? st.schedule : null;
  const hasSchedule = !!(schedule && schedule.length);

  // Proposed buckets are a live preview for:
  // - EDIT/CREATE
  // - VIEW planned weeks (contract_week only)
  const useProposedBuckets = hasSchedule && (isEditing || isPlannedWeek);

  const scheduleHasErrors = !!st.scheduleHasErrors;
  const scheduleErrorsByDate = (st.scheduleErrorsByDate && typeof st.scheduleErrorsByDate === 'object')
    ? st.scheduleErrorsByDate
    : {};

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Summary table (Standard / Additional / Expenses / Mileage / Totals)
  // - Standard is snapshot by default; if Proposed Buckets loads successfully weâ€™ll update Standard + Totals.
  // - Additional uses TSFIN snapshot fields (no â€œunsaved additional previewâ€ in this pass).
  // - Expenses/Mileage use staged draft (live).
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const addPayEx    = Number(tsfin.additional_pay_ex_vat    || 0) || 0;
  const addChgEx    = Number(tsfin.additional_charge_ex_vat || 0) || 0;

  const addMarginEx =
    (tsfin.additional_margin_ex_vat != null && Number.isFinite(Number(tsfin.additional_margin_ex_vat)))
      ? Number(tsfin.additional_margin_ex_vat)
      : round2(addChgEx - applyErniToPayEx(addPayEx));

  const stdFromSnapshot = computeStandardFromRates({
    hoursObj: hours,
    payObj: pay,
    chgObj: chg,
    erniApplies: erniCtx.applies,
    erniMult: erniCtx.erni_mult
  });

  // For the initial render:
  // - If snapshot has missing rates, show â€” for Standard and Totals (but still show Expenses/Mileage).
  const stdPayInit   = stdFromSnapshot.missingRates ? null : stdFromSnapshot.pay_ex_vat;
  const stdChgInit   = stdFromSnapshot.missingRates ? null : stdFromSnapshot.charge_ex_vat;
  const stdMarInit   = stdFromSnapshot.missingRates ? null : stdFromSnapshot.margin_ex_vat;

  // Totals:
  // - In â€œActualâ€ mode (no proposed buckets), prefer TSFIN totals/margin if available.
  // - In proposed mode, compute totals from components (standard will be updated when preview returns).
  const serverTotalPay   = (tsfin.total_pay_ex_vat    != null && Number.isFinite(Number(tsfin.total_pay_ex_vat)))    ? Number(tsfin.total_pay_ex_vat)    : null;
  const serverTotalChg   = (tsfin.total_charge_ex_vat != null && Number.isFinite(Number(tsfin.total_charge_ex_vat))) ? Number(tsfin.total_charge_ex_vat) : null;
  const serverTotalMar   = (tsfin.margin_ex_vat       != null && Number.isFinite(Number(tsfin.margin_ex_vat)))       ? Number(tsfin.margin_ex_vat)       : null;

  const buildSummaryTableHtml = (vals) => {
    const v = vals || {};

    const cell = (n) => (n == null ? 'â€”' : fmtMoney(n));
    const rowHtml = (label, payV, chgV, marV, isTotal) => `
      <tr ${isTotal ? 'style="font-weight:700"' : ''}>
        <td>${label}</td>
        <td>${cell(payV)}</td>
        <td>${cell(chgV)}</td>
        <td>${cell(marV)}</td>
      </tr>
    `;

    return `
      <table class="grid mini">
        <thead>
          <tr>
            <th style="width:240px">Category</th>
            <th style="width:160px">Pay (ex VAT)</th>
            <th style="width:160px">Charge (ex VAT)</th>
            <th style="width:160px">Margin (ex VAT)</th>
          </tr>
        </thead>
        <tbody>
          ${rowHtml('Standard hours', v.std_pay, v.std_chg, v.std_mar, false)}
          ${rowHtml('Additional',      v.add_pay, v.add_chg, v.add_mar, false)}
          ${rowHtml('Expenses',        v.exp_pay, v.exp_chg, v.exp_mar, false)}
          ${rowHtml('Mileage',         v.mil_pay, v.mil_chg, v.mil_mar, false)}
          ${rowHtml('Totals',          v.tot_pay, v.tot_chg, v.tot_mar, true)}
        </tbody>
      </table>
    `;
  };

  const computeTotals = (stdPay, stdChg, stdMar) => {
    const standardPay   = (stdPay == null ? null : Number(stdPay));
    const standardChg   = (stdChg == null ? null : Number(stdChg));
    const standardMar   = (stdMar == null ? null : Number(stdMar));

    // If standard is missing, totals are missing unless weâ€™re in â€œActual snapshotâ€ mode
    // and can use server totals.
    if (!useProposedBuckets) {
      // Prefer server totals in actual snapshot mode
      return {
        std_pay: standardPay, std_chg: standardChg, std_mar: standardMar,
        add_pay: addPayEx, add_chg: addChgEx, add_mar: addMarginEx,
        exp_pay: expensesPayLive, exp_chg: expensesChargeLive, exp_mar: expensesMarginLive,
        mil_pay: mileagePayLive, mil_chg: mileageChargeLive, mil_mar: mileageMarginLive,
        tot_pay: (serverTotalPay != null ? serverTotalPay : (standardPay != null ? round2(standardPay + addPayEx + expensesPayLive + mileagePayLive) : null)),
        tot_chg: (serverTotalChg != null ? serverTotalChg : (standardChg != null ? round2(standardChg + addChgEx + expensesChargeLive + mileageChargeLive) : null)),
        tot_mar: (serverTotalMar != null ? serverTotalMar : (standardMar != null ? round2(standardMar + addMarginEx + expensesMarginLive + mileageMarginLive) : null)),
      };
    }

    // Proposed mode: compute totals from components (standard may be replaced when preview returns)
    return {
      std_pay: standardPay, std_chg: standardChg, std_mar: standardMar,
      add_pay: addPayEx, add_chg: addChgEx, add_mar: addMarginEx,
      exp_pay: expensesPayLive, exp_chg: expensesChargeLive, exp_mar: expensesMarginLive,
      mil_pay: mileagePayLive, mil_chg: mileageChargeLive, mil_mar: mileageMarginLive,
      tot_pay: (standardPay != null ? round2(standardPay + addPayEx + expensesPayLive + mileagePayLive) : null),
      tot_chg: (standardChg != null ? round2(standardChg + addChgEx + expensesChargeLive + mileageChargeLive) : null),
      tot_mar: (standardMar != null ? round2(standardMar + addMarginEx + expensesMarginLive + mileageMarginLive) : null),
    };
  };

  const summaryInnerId = 'tsFinanceSummaryInner';
  const summaryInitVals = computeTotals(stdPayInit, stdChgInit, stdMarInit);
  const summaryInitHtml = buildSummaryTableHtml(summaryInitVals);

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Preview from current Lines schedule (total hours) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let previewHoursHtml = '';
  let bucketCardHtml = '';

  const buildProposedBucketTable = (preview) => {
    if (!preview || typeof preview !== 'object') {
      return `<span class="mini">Bucket preview unavailable.</span>`;
    }

    const h = preview.hours  || {};
    const p = preview.pay    || {};
    const c = preview.charge || {};

    const f = (preview.finance && typeof preview.finance === 'object') ? preview.finance : {};
    const erniApplies = f.erni_applies === true;
    const erniMult = Number.isFinite(Number(f.erni_multiplier)) ? Number(f.erni_multiplier) : 1;

    const applyErniPreview = (payEx) => {
      const x = Number(payEx || 0);
      if (!Number.isFinite(x)) return 0;
      return erniApplies ? (x * erniMult) : x;
    };

    const rows = buckets.map(b => {
      const hrs   = Number(h[b] || 0);
      const payR  = p[b] != null ? Number(p[b]) : null;
      const chgR  = c[b] != null ? Number(c[b]) : null;

      const payEx = payR != null ? hrs * payR : null;
      const chgEx = chgR != null ? hrs * chgR : null;

      const payCostEx = (payEx != null) ? applyErniPreview(payEx) : null;
      const marEx = (payCostEx != null && chgEx != null) ? (chgEx - payCostEx) : null;

      return `
        <tr>
          <td>${bucketLabel[b]}</td>
          <td>${hrs || 0}</td>
          <td>${payR  != null ? fmtMoney(payR)  : 'â€”'}</td>
          <td>${chgR  != null ? fmtMoney(chgR)  : 'â€”'}</td>
          <td>${payEx != null ? fmtMoney(payEx) : 'â€”'}</td>
          <td>${chgEx != null ? fmtMoney(chgEx) : 'â€”'}</td>
          <td>${marEx != null ? fmtMoney(marEx) : 'â€”'}</td>
        </tr>
      `;
    }).join('');

    return `
      <table class="grid mini">
        <thead>
          <tr>
            <th>Bucket</th>
            <th>Hours</th>
            <th>Pay rate</th>
            <th>Charge rate</th>
            <th>Pay (ex VAT)</th>
            <th>Charge (ex VAT)</th>
            <th>Margin (ex VAT)</th>
          </tr>
        </thead>
        <tbody>${rows}</tbody>
      </table>
      <span class="mini" style="display:block;margin-top:4px;">
        Based on the current Lines schedule (unsaved). For planned weeks this is a live preview;
        for existing timesheets it reflects any staged schedule changes once saved.
      </span>
    `;
  };

  try {
    const tsId   = mc.data?.timesheet_id || row.timesheet_id || null;
    const weekId = mc.data?.contract_week_id || row.contract_week_id || null;

    if (schedule && schedule.length) {
      const hhmmToMinutes = (hhmm) => {
        if (!hhmm || typeof hhmm !== 'string') return null;
        const m = hhmm.trim();
        const parts = m.split(':');
        if (parts.length !== 2) return null;
        const h = Number(parts[0]);
        const mm = Number(parts[1]);
        if (!Number.isFinite(h) || !Number.isFinite(mm)) return null;
        return h * 60 + mm;
      };

      let totalPaidMinutes = 0;
      schedule.forEach(seg => {
        const startStr = seg.start || null;
        const endStr   = seg.end   || null;
        const sMin = hhmmToMinutes(startStr);
        const eMin = hhmmToMinutes(endStr);
        if (sMin == null || eMin == null) return;

        let shiftMinutes = eMin - sMin;
        if (shiftMinutes < 0) shiftMinutes += 24 * 60;

        const breakMinutes = Number(seg.break_mins || seg.break_minutes || 0) || 0;
        const paidMin = Math.max(0, shiftMinutes - breakMinutes);
        totalPaidMinutes += paidMin;
      });

      const totalPaidHours = totalPaidMinutes > 0
        ? (Math.round((totalPaidMinutes / 60) * 100) / 100).toFixed(2)
        : '0.00';

      previewHoursHtml = `
        <div class="card" style="margin-top:10px;">
          <div class="row">
            <label>Preview from Lines</label>
            <div class="controls">
              <div class="mini">
                Total paid hours from current Lines schedule (unsaved): <strong>${totalPaidHours}</strong><br/>
                The bucketed pay/charge ${useProposedBuckets ? 'below' : 'above'} will reflect this
                schedule once the timesheet is saved and TSFIN is recomputed.
              </div>
            </div>
          </div>
        </div>
      `;

      if (useProposedBuckets && (tsId || weekId)) {
        const containerId = 'tsBucketPreview';
        const innerId = 'tsBucketPreviewInner';

        if (scheduleHasErrors) {
          const errDates = Object.keys(scheduleErrorsByDate || {});
          const errHint = errDates.length
            ? `Fix schedule errors on: ${errDates.map(d => enc(d)).join(', ')}`
            : 'Fix schedule errors in Lines before previewing buckets.';

          bucketCardHtml = `
            <div class="card">
              <div class="row">
                <label>Core hours & rates</label>
                <div class="controls">
                  <span class="pill pill-bad">Proposed Buckets</span>
                  <div class="hint mini" style="margin-top:6px;">
                    <span class="warn-icon" title="Schedule errors">&#9888;</span>
                    ${errHint}
                  </div>
                </div>
              </div>
            </div>
          `;
        } else {
          bucketCardHtml = `
            <div class="card">
              <div class="row">
                <label>Core hours & rates</label>
                <div class="controls">
                  <span class="pill pill-bad">Proposed Buckets</span>
                  <div id="${containerId}">
                    <div id="${innerId}">
                      <span class="mini" id="tsBucketPreviewStatus">Loading bucket preview from Linesâ€¦</span>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          `;

          try {
            const additionalUnitsWeek = {};
            if (st.additionalRates && typeof st.additionalRates === 'object') {
              Object.entries(st.additionalRates).forEach(([code, r]) => {
                if (!r) return;
                const units = Number(r.units_week || 0);
                if (!Number.isFinite(units) || units === 0) return;
                additionalUnitsWeek[code] = units;
              });
            }

            const payload = {
              timesheet_id:         tsId || null,
              contract_week_id:     tsId ? null : (weekId || null),
              actual_schedule_json: schedule,
              additional_units_week: additionalUnitsWeek
            };

            const url = API('/api/timesheets/bucket-preview');
            authFetch(url, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload)
            })
              .then(res => {
                if (!res.ok) {
                  return res.text().then(msg => { throw new Error(msg || 'Bucket preview failed'); });
                }
                return res.json();
              })
              .then(data => {
                try {
                  const cacheKey = tsId || `cw:${weekId || 'unknown'}`;
                  window.__tsBucketPreviewCache = window.__tsBucketPreviewCache || {};
                  window.__tsBucketPreviewCache[String(cacheKey)] = { ok: true, data };
                } catch {}

                const container = document.getElementById(innerId);
                if (container) {
                  container.innerHTML = buildProposedBucketTable(data);
                }

                // âœ… ALSO update the new finance summary table Standard + Totals using the preview payload
                try {
                  const h = data?.hours  || {};
                  const p = data?.pay    || {};
                  const c = data?.charge || {};
                  const f = (data?.finance && typeof data.finance === 'object') ? data.finance : {};

                  const erniApplies = (f.erni_applies === true);
                  const erniMult    = Number.isFinite(Number(f.erni_multiplier)) ? Number(f.erni_multiplier) : 1;

                  const stdFromPreview = computeStandardFromRates({
                    hoursObj: h,
                    payObj: p,
                    chgObj: c,
                    erniApplies,
                    erniMult
                  });

                  // Re-read latest expensesDraft (user might have typed since the request fired)
                  const mc2 = window.modalCtx || {};
                  const st2 = mc2.timesheetState || {};
                  const ed2 = (st2.expensesDraft && typeof st2.expensesDraft === 'object') ? st2.expensesDraft : expDraft;

                  const tp = round2(Number(ed2.travel_pay || 0));
                  const tc = round2(Number(ed2.travel_charge || 0));
                  const ap = round2(Number(ed2.accommodation_pay || 0));
                  const ac = round2(Number(ed2.accommodation_charge || 0));
                  const op = round2(Number(ed2.other_pay || 0));
                  const oc = round2(Number(ed2.other_charge || 0));

                  const expPay2 = round2(tp + ap + op);
                  const expChg2 = round2(tc + ac + oc);
                  const expMar2 = round2(expChg2 - expPay2);

                  const mu2 = Number(ed2.mileage_units || 0) || 0;
                  const pr2 = (mc2.timesheetDetails?.tsfin?.mileage_pay_rate != null) ? Number(mc2.timesheetDetails.tsfin.mileage_pay_rate) : mileagePayRate;
                  const cr2 = (mc2.timesheetDetails?.tsfin?.mileage_charge_rate != null) ? Number(mc2.timesheetDetails.tsfin.mileage_charge_rate) : mileageChargeRate;

                  const ratesOk2 =
                    Number.isFinite(pr2) && Number.isFinite(cr2) && pr2 > 0 && cr2 > 0;

                  const milPay2 = ratesOk2 ? round2(mu2 * pr2) : 0;
                  const milChg2 = ratesOk2 ? round2(mu2 * cr2) : 0;
                  const milMar2 = round2(milChg2 - milPay2);

                  const stdPay2 = stdFromPreview.missingRates ? null : stdFromPreview.pay_ex_vat;
                  const stdChg2 = stdFromPreview.missingRates ? null : stdFromPreview.charge_ex_vat;
                  const stdMar2 = stdFromPreview.missingRates ? null : stdFromPreview.margin_ex_vat;

                  const vals2 = {
                    std_pay: stdPay2, std_chg: stdChg2, std_mar: stdMar2,
                    add_pay: addPayEx, add_chg: addChgEx, add_mar: addMarginEx,
                    exp_pay: expPay2, exp_chg: expChg2, exp_mar: expMar2,
                    mil_pay: milPay2, mil_chg: milChg2, mil_mar: milMar2,
                    tot_pay: (stdPay2 != null ? round2(stdPay2 + addPayEx + expPay2 + milPay2) : null),
                    tot_chg: (stdChg2 != null ? round2(stdChg2 + addChgEx + expChg2 + milChg2) : null),
                    tot_mar: (stdMar2 != null ? round2(stdMar2 + addMarginEx + expMar2 + milMar2) : null),
                  };

                  const sumEl = document.getElementById(summaryInnerId);
                  if (sumEl) sumEl.innerHTML = buildSummaryTableHtml(vals2);
                } catch {}
              })
              .catch(err => {
                const msg = err?.message || 'Bucket preview failed';
                try {
                  const cacheKey = tsId || `cw:${weekId || 'unknown'}`;
                  window.__tsBucketPreviewCache = window.__tsBucketPreviewCache || {};
                  window.__tsBucketPreviewCache[String(cacheKey)] = { error: msg };
                } catch {}
                const statusEl = document.getElementById('tsBucketPreviewStatus');
                if (statusEl) {
                  const safeMsg = enc(msg);
                  statusEl.innerHTML = `<span class="warn-icon" title="${safeMsg}">&#9888;</span>`;
                }
              });
          } catch (e) {
            if (LOGM) L('[FINANCE] bucket-preview wiring failed', e);
          }
        }
      }
    }
  } catch (e) {
    if (LOGM) L('[FINANCE] preview wiring failed', e);
  }

  // If not using proposed buckets, show TSFIN snapshot as Actual Buckets
  if (!useProposedBuckets) {
    bucketCardHtml = `
      <div class="card">
        <div class="row">
          <label>Core hours & rates</label>
          <div class="controls">
            <span class="pill pill-ok">Actual Buckets</span>
            <table class="grid mini">
              <thead>
                <tr>
                  <th>Bucket</th>
                  <th>Hours</th>
                  <th>Pay rate</th>
                  <th>Charge rate</th>
                  <th>Pay (ex VAT)</th>
                  <th>Charge (ex VAT)</th>
                  <th>Margin (ex VAT)</th>
                </tr>
              </thead>
              <tbody>
                ${tsfinBucketRows}
              </tbody>
            </table>
            <span class="mini" style="display:block;margin-top:4px;">
              These values come from the current financial snapshot (TSFIN).
              If you change the Lines schedule and then click <strong>Save</strong>, a new snapshot will be generated.
            </span>
          </div>
        </div>
      </div>
    `;
  }

  // Summary card content
  const erniNote =
    erniCtx.applies
      ? `<div class="mini" style="margin-top:6px;color:#888">
           PAYE margin includes ERNI (${Number.isFinite(Number(erniCtx.erni_pct)) ? `${Number(erniCtx.erni_pct).toFixed(2)}%` : 'configured'}).
         </div>`
      : '';

  GE();

  return `
    <div class="tabc">
      ${bucketCardHtml}

      <div class="card" style="margin-top:10px;">
        <div class="row">
          <label>Additional rates</label>
          <div class="controls">
            ${
              hasAdditional
                ? `
                  <table class="grid mini">
                    <thead>
                      <tr>
                        <th>Bucket</th>
                        <th>Units</th>
                        <th>Unit name</th>
                        <th>Pay rate</th>
                        <th>Charge rate</th>
                        <th>Pay (ex VAT)</th>
                        <th>Charge (ex VAT)</th>
                        <th>Margin (ex VAT)</th>
                      </tr>
                    </thead>
                    <tbody>${additionalRows}</tbody>
                  </table>
                `
                : '<span class="mini">No additional rate units recorded on this snapshot.</span>'
            }
          </div>
        </div>
      </div>

      <div class="card" style="margin-top:10px;">
        <div class="row">
          <label>Summary</label>
          <div class="controls">
            <div id="${summaryInnerId}">
              ${summaryInitHtml}
            </div>
            ${erniNote}
            <div class="mini" style="margin-top:8px;color:rgba(255,255,255,0.7)">
              In <strong>Edit</strong>, Expenses/Mileage reflect staged values (before Save). Standard hours may show as â€œProposedâ€ once the bucket preview loads.
            </div>
          </div>
        </div>
      </div>

      ${previewHoursHtml}
    </div>
  `;
}



async function getTimesheetPdfUrl(timesheetId) {
  const LOGM = (typeof window.__LOG_MODAL === 'boolean') ? window.__LOG_MODAL : false;
  const L    = (...a) => { if (LOGM) console.log('[TS][PDF][GET]', ...a); };
  const GC   = (label) => { if (LOGM) console.groupCollapsed('[TS][PDF][GET]', label); };
  const GE   = () => { if (LOGM) console.groupEnd(); };

  if (!timesheetId) {
    throw new Error('getTimesheetPdfUrl: timesheetId is required');
  }

  GC('getTimesheetPdfUrl');
  L('START', { timesheetId });

  const encId = encodeURIComponent(timesheetId);
  const metaUrl = API(`/api/timesheets/${encId}/pdf`);

  let pdfMeta;
  try {
    const res  = await authFetch(metaUrl);
    const text = await res.text();

    if (!res.ok) {
      // Treat any non-OK as "no CURRENT pdf" for the purposes of the Evidence dialog
      L('timesheet pdf meta failed', { status: res.status, bodyPreview: text.slice(0, 400) });
      GE();
      return null;
    }

    pdfMeta = text ? JSON.parse(text) : {};
  } catch (err) {
    // Network / parse errors â†’ treat as "no pdf" for the dialog
    L('meta fetch error', err);
    GE();
    return null;
  }

  const r2Key =
    pdfMeta.r2_key ||
    pdfMeta.key ||
    pdfMeta.manual_pdf_r2_key ||
    null;

  if (!r2Key) {
    L('no r2_key in pdfMeta', pdfMeta);
    GE();
    return null;
  }

  L('meta resolved', { r2Key, rotation_degrees: pdfMeta.rotation_degrees });

  // Ask files API for a presigned download URL
  const presignUrl = API('/api/files/presign-download');
  let signed;
  try {
    const res  = await authFetch(presignUrl, {
      method: 'POST',
      headers: { 'Content-Type':'application/json' },
      body: JSON.stringify({ key: r2Key })
    });
    const text = await res.text();

    if (!res.ok) {
      L('presign-download failed', { status: res.status, bodyPreview: text.slice(0, 400) });
      GE();
      return null;
    }

    signed = text ? JSON.parse(text) : {};
  } catch (err) {
    L('presign error', err);
    GE();
    return null;
  }

  const url = signed.url || signed.signed_url || null;
  if (!url) {
    L('no URL in presign response', signed);
    GE();
    return null;
  }

  L('RESOLVE OK', { url });
  GE();

  return {
    url,
    r2_key: r2Key,
    rotation_degrees: pdfMeta.rotation_degrees ?? 0,
    meta: pdfMeta
  };
}

async function openUiConfirmModal(opts = {}) {
  const enc = (typeof escapeHtml === 'function')
    ? escapeHtml
    : (s) => String(s ?? '')
        .replaceAll('&','&amp;')
        .replaceAll('<','&lt;')
        .replaceAll('>','&gt;')
        .replaceAll('"','&quot;')
        .replaceAll("'","&#39;");

  const htmlWrap = (typeof html === 'function') ? html : (s) => String(s ?? '');

  const title = String(opts.title ?? 'Confirm').trim() || 'Confirm';

  // message can be plain text or pre-rendered html
  const messageHtml =
    (opts.message_html != null && String(opts.message_html).trim() !== '')
      ? String(opts.message_html)
      : (opts.message != null && String(opts.message).trim() !== '')
        ? `<div class="mini" style="white-space:pre-wrap;">${enc(String(opts.message))}</div>`
        : `<div class="mini">Are you sure?</div>`;

  const extraHtml =
    (opts.extra_html != null && String(opts.extra_html).trim() !== '')
      ? String(opts.extra_html)
      : '';

  const confirmLabel = String(opts.confirm_label ?? 'Confirm').trim() || 'Confirm';
  const cancelLabel  = String(opts.cancel_label  ?? 'Cancel').trim()  || 'Cancel';

  const confirmBtnClass = String(opts.confirm_class ?? 'btn btn-primary').trim() || 'btn btn-primary';
  const cancelBtnClass  = String(opts.cancel_class  ?? 'btn btn-outline').trim() || 'btn btn-outline';

  // âœ… Use import-summary-* so showModal treats it as a utility child:
  //  - footer Save hidden by default
  //  - close does not trigger parent restore beyond renderTop()
  const kind = 'import-summary-ui-confirm';

  const instanceId = `uicf_${Date.now()}_${Math.random().toString(36).slice(2)}`;
  const rootId = `${instanceId}_root`;

  return await new Promise((resolve) => {
    let done = false;
    let ownerToken = null;
    let watchTimer = 0;

    const resolveOnce = (confirmed) => {
      if (done) return;
      done = true;
      try { cleanup(); } catch {}
      resolve({ confirmed: !!confirmed });
    };

    const topFrameIsMine = (token) => {
      try {
        const fr = (typeof window.__getModalFrame === 'function') ? window.__getModalFrame() : null;
        return !!(fr && fr.kind === kind && fr._token === token);
      } catch {
        return false;
      }
    };

    const closeModalBtnClick = () => {
      try {
        const btn = document.getElementById('btnCloseModal');
        if (btn) btn.click();
        else if (typeof closeModal === 'function') closeModal();
      } catch {
        try { if (typeof closeModal === 'function') closeModal(); } catch {}
      }
    };

    const onBodyClick = (ev) => {
      if (done) return;
      if (ownerToken && !topFrameIsMine(ownerToken)) return;

      const btn = ev?.target && ev.target.closest ? ev.target.closest('button[data-act]') : null;
      if (!btn) return;

      const act = String(btn.getAttribute('data-act') || '');
      if (act !== 'uicf-confirm' && act !== 'uicf-cancel') return;

      if (act === 'uicf-cancel') {
        resolveOnce(false);
        closeModalBtnClick();
        return;
      }

      // confirm
      resolveOnce(true);
      closeModalBtnClick();
    };

    const onHeaderCloseCapture = (ev) => {
      if (done) return;
      const btn = document.getElementById('btnCloseModal');
      const bound = btn?.dataset?.ownerToken || null;
      if (!ownerToken || !bound) return;
      if (String(bound) !== String(ownerToken)) return;
      if (!topFrameIsMine(ownerToken)) return;
      resolveOnce(false);
      // do NOT prevent default; showModal will close it
    };

    const cleanup = () => {
      try {
        const body = document.getElementById('modalBody');
        if (body) body.removeEventListener('click', onBodyClick);
      } catch {}
      try {
        const closeBtn = document.getElementById('btnCloseModal');
        if (closeBtn) closeBtn.removeEventListener('click', onHeaderCloseCapture, true);
      } catch {}
      try { if (watchTimer) clearInterval(watchTimer); } catch {}
      watchTimer = 0;
    };

    const renderTab = (key) => {
      if (key !== 'main') return '';
      const extraBlock = extraHtml
        ? `<div style="margin-top:10px;">${extraHtml}</div>`
        : '';

      return htmlWrap(`
        <div class="tabc" id="${enc(rootId)}">
          <div class="card">
            <div class="row">
              <label></label>
              <div class="controls">
                <div style="font-size:14px;font-weight:700;margin-bottom:6px;">${enc(title)}</div>
                ${messageHtml}
                ${extraBlock}

                <div style="display:flex;gap:10px;margin-top:14px;align-items:center;">
                  <button type="button" class="${enc(confirmBtnClass)}" data-act="uicf-confirm">${enc(confirmLabel)}</button>
                  <button type="button" class="${enc(cancelBtnClass)}" data-act="uicf-cancel">${enc(cancelLabel)}</button>
                </div>

                <div class="mini" style="margin-top:10px;opacity:.75;">
                  You can also close this dialog to cancel.
                </div>
              </div>
            </div>
          </div>
        </div>
      `);
    };

    // Open modal
    showModal(
      title,
      [{ key: 'main', label: 'Confirm' }],
      renderTab,
      null,
      false,
      null,
      {
        kind,
        noParentGate: true,
        showSave: false,
        showApply: false,
        onDismiss: () => resolveOnce(false)
      }
    );

    // Capture token for this frame so we can gate events safely
    try {
      const fr = (typeof window.__getModalFrame === 'function') ? window.__getModalFrame() : null;
      ownerToken = fr && fr.kind === kind ? fr._token : null;
    } catch {
      ownerToken = null;
    }

    // Wire DOM events (delegated to modalBody; gated by top frame token + kind)
    try {
      const body = document.getElementById('modalBody');
      if (body) body.addEventListener('click', onBodyClick);
    } catch {}

    // Ensure closing via the header Close button resolves as Cancel too (no hang)
    try {
      const closeBtn = document.getElementById('btnCloseModal');
      if (closeBtn) closeBtn.addEventListener('click', onHeaderCloseCapture, true);
    } catch {}

    // Safety: if frame is closed by any other route, resolve as Cancel (no hang)
    watchTimer = setInterval(() => {
      if (done) return;
      const stk = window.__modalStack || [];
      const stillThere = ownerToken && stk.some(fr => fr && fr._token === ownerToken);
      if (!stillThere) resolveOnce(false);
    }, 250);
  });
}


async function openTimesheet(row) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][OPEN]');
  GC('openTimesheet');

  try {
    if (!row || typeof row !== 'object') {
      alert('No timesheet row provided.');
      GE();
      return;
    }

    const baseRow = { ...row };

    const realTsId = baseRow.timesheet_id || null;
    const weekId   = baseRow.contract_week_id || null;
    const hasTs    = !!realTsId;
    const isPlannedWeek = !hasTs && !!weekId;

    if (!hasTs && !isPlannedWeek) {
      L('ERROR: missing timesheet_id / contract_week_id on row', { row });
      GE();
      alert('Timesheet or week id missing.');
      return;
    }
let tsId = hasTs ? realTsId : null;
baseRow.id = hasTs ? realTsId : (weekId || baseRow.id);


    const sheetScopeRaw = (baseRow.sheet_scope || '').toUpperCase();
    const subModeRaw    = (baseRow.submission_mode || '').toUpperCase();
    const basisRaw      = (baseRow.basis || '').toUpperCase();
    const routeTypeRaw  = (baseRow.route_type || '').toUpperCase();

    L('ENTRY', { tsId, weekId, isPlannedWeek, sheetScopeRaw, subModeRaw, basisRaw, routeTypeRaw, rowKeys: Object.keys(baseRow || {}) });

let details;
let evidence = [];
let plannedContract = null;

// âœ… NEW: delete preview payload (used for delete gating + friendly warning modal + route labels)
let deletePreview = null;

if (hasTs) {
  try {
    details = await fetchTimesheetDetails(tsId);

    // âœ… adopt resolved current id (stale-safe)
    if (details && details.current_timesheet_id && String(details.current_timesheet_id) !== String(tsId)) {
      const newId = String(details.current_timesheet_id);
      tsId = newId;
      baseRow.timesheet_id = newId;
      baseRow.id = newId;

      if (details.timesheet && typeof details.timesheet === 'object') {
        details.timesheet.timesheet_id = newId;
      }

      details.current_timesheet_id = newId;

      try { await refreshTimesheetsSummaryAfterRotation(newId); } catch {}
    }

    // âœ… NEW: fetch delete preview (non-fatal; used by modal footer + overview route label + warning modal)
    try {
      const encTsIdPrev = encodeURIComponent(tsId);
      const resPrev = await authFetch(API(`/api/timesheets/${encTsIdPrev}/delete-preview`));
      const txtPrev = await resPrev.text().catch(() => '');
      if (!resPrev.ok) throw new Error(txtPrev || 'Failed to fetch delete preview');

      let parsedPrev = null;
      try { parsedPrev = txtPrev ? JSON.parse(txtPrev) : null; } catch { parsedPrev = null; }
      deletePreview = (parsedPrev && typeof parsedPrev === 'object') ? parsedPrev : null;

      // If preview indicates a different current id (should be rare because we already stale-resolved),
      // adopt it consistently so subsequent calls are aligned.
      const movedIdPrev =
        deletePreview && deletePreview.current_timesheet_id
          ? String(deletePreview.current_timesheet_id)
          : null;

      if (movedIdPrev && String(movedIdPrev) !== String(tsId)) {
        tsId = movedIdPrev;
        baseRow.timesheet_id = movedIdPrev;
        baseRow.id = movedIdPrev;

        // Re-fetch details so UI state matches the resolved id
        try {
          details = await fetchTimesheetDetails(tsId);
          if (details && details.current_timesheet_id) {
            details.current_timesheet_id = String(details.current_timesheet_id);
          }
        } catch {}

        try { await refreshTimesheetsSummaryAfterRotation(movedIdPrev); } catch {}
      }

    } catch (err) {
      // Non-fatal: UI will fall back to existing gating; delete preview can be retried later.
      L('fetch delete preview FAILED (non-fatal)', err);
      deletePreview = null;
    }

    // âœ… NEW: fetch contract for gating (NHSP / HR CREATE) even when hasTs
    try {
      const contractId =
        (details && details.timesheet && details.timesheet.contract_id) ||
        baseRow.contract_id ||
        null;

      if (contractId && typeof getContract === 'function') {
        const cRes = await getContract(contractId);
        plannedContract = (cRes && cRes.contract) ? cRes.contract : (cRes || null);
      }
    } catch {
      plannedContract = null;
    }

    // âœ… Optional: mirror into details.policy so gating can read it from details as well
    try {
      details.policy = (details.policy && typeof details.policy === 'object') ? details.policy : {};
      if (plannedContract) {
        if (details.policy.weekly_mode == null && plannedContract.weekly_mode != null) {
          details.policy.weekly_mode = plannedContract.weekly_mode;
        }
        if (details.policy.hr_weekly_behaviour == null && plannedContract.hr_weekly_behaviour != null) {
          details.policy.hr_weekly_behaviour = plannedContract.hr_weekly_behaviour;
        }
      }
    } catch {}

    L('details fetched', {
      hasTimesheet: !!details.timesheet,
      hasTsfin: !!details.tsfin,
      segments: (details.segments || []).length,
      shifts: (details.shifts || []).length,
      isSegmentsMode: !!details.isSegmentsMode,
      contract_week_id: details.contract_week_id || null,
      hasPolicy: !!details.policy,
      hasActionFlags: !!details.action_flags,
      hasContractWeek: !!details.contract_week,
      ready_to_pay: (details && typeof details.ready_to_pay === 'boolean') ? details.ready_to_pay : null
    });

  } catch (err) {
    L('fetchTimesheetDetails FAILED', err);
    GE();
    alert(err?.message || 'Failed to load timesheet details.');
    return;
  }

  try {
    const encTsId = encodeURIComponent(tsId);
    const res  = await authFetch(API(`/api/timesheets/${encTsId}/evidence`));
    const txt  = await res.text().catch(() => '');
    if (!res.ok) {
      L('fetch evidence FAILED', { status: res.status, bodyPreview: (txt || '').slice(0, 400) });
      throw new Error(txt || 'Failed to fetch evidence');
    }


    let parsed = null;
    try { parsed = txt ? JSON.parse(txt) : null; } catch { parsed = null; }

    // âœ… Support both legacy list response and future object response
    const movedId =
      parsed && typeof parsed === 'object' && !Array.isArray(parsed) && parsed.current_timesheet_id
        ? String(parsed.current_timesheet_id)
        : null;

    if (movedId && String(movedId) !== String(tsId)) {
      tsId = movedId;
      baseRow.timesheet_id = movedId;
      baseRow.id = movedId;
      try { await refreshTimesheetsSummaryAfterRotation(movedId); } catch {}
    }

    const list =
      Array.isArray(parsed)
        ? parsed
        : (parsed && typeof parsed === 'object' && Array.isArray(parsed.evidence))
          ? parsed.evidence
          : [];

    evidence = list.map(ev => {
      const out = { ...(ev || {}) };

      if (typeof out.system !== 'boolean') out.system = false;
      if (typeof out.can_delete !== 'boolean') out.can_delete = !out.system;

      if (!out.uploaded_at_utc && out.created_at) out.uploaded_at_utc = out.created_at;

      return out;
    });

    L('evidence fetched', { timesheet_id: tsId, count: evidence.length });

  } catch (err) {
    L('fetch evidence FAILED (non-fatal)', err);
    evidence = [];
  }

 } else {
  let contractWeek = null;
  try {
    const qs = new URLSearchParams();
    if (baseRow.contract_id) qs.set('contract_id', baseRow.contract_id);

    const we = baseRow.contract_week_ending_date || baseRow.week_ending_date || null;
    if (we) { qs.set('week_ending_from', we); qs.set('week_ending_to', we); }

    qs.set('include_plan', 'true');

    const url = API(`/api/contract-weeks?${qs.toString()}`);
    const res = await authFetch(url);
    const rows = await toList(res);

    contractWeek =
      (rows || []).find(w => String(w.id) === String(weekId)) ||
      (rows || [])[0] ||
      null;
  } catch (e) {
    if (LOGM) L('failed to load contract_week for planned week (non-fatal)', e);
  }

  // âœ… NEW: fetch contract so planned-week can be gated (NHSP / HR CREATE)
  // IMPORTANT: do NOT redeclare plannedContract here (no shadowing).
  try {
    const contractId =
      baseRow.contract_id ||
      (contractWeek && contractWeek.contract_id) ||
      null;

    if (contractId && typeof getContract === 'function') {
      const cRes = await getContract(contractId);
      plannedContract = (cRes && cRes.contract) ? cRes.contract : (cRes || null);
    }
  } catch {
    plannedContract = null;
  }

     // âœ… NEW: global BH list for planned weeks (BH are not per-client)
  let globalBhList = [];
  try {
    if (typeof getSettingsCached === 'function') {
      const s = await getSettingsCached();

      // getSettingsCached now returns { settings: {...}, finance_windows: [...] }
      const bhRaw = (s && s.settings) ? s.settings.bh_list : (s ? s.bh_list : null);

      if (Array.isArray(bhRaw)) globalBhList = bhRaw;
      else if (typeof bhRaw === 'string') {
        try {
          const p = JSON.parse(bhRaw || '[]');
          if (Array.isArray(p)) globalBhList = p;
        } catch {}
      }
    }
  } catch {
    globalBhList = [];
  }


  details = {
    timesheet: null,
    tsfin: null,
    validations: [],
    shifts: [],
    segments: [],
    isSegmentsMode: false,
    invoiceBreakdown: null,
    sheet_scope: sheetScopeRaw || 'WEEKLY',
    qr_status: null,
    qr_generated_at: null,
    qr_scanned_at: null,
    manual_pdf_r2_key: null,
    contract_week_id: weekId,
    contract_week: contractWeek,

    // âœ… NEW: carry policy hints for gating in Overview
    policy: {
      weekly_mode:
        (plannedContract && plannedContract.weekly_mode != null)
          ? plannedContract.weekly_mode
          : null,
      hr_weekly_behaviour:
        (plannedContract && plannedContract.hr_weekly_behaviour != null)
          ? plannedContract.hr_weekly_behaviour
          : null,

      // âœ… NEW: required for BH row filtering + BH bucket logic in UI
      bh_list: globalBhList
    }
  };

  evidence = [];
  L('details stubbed for planned week', {
    weekId,
    details_scope: details.sheet_scope,
    hasContractWeek: !!contractWeek,
    weekly_mode: details.policy?.weekly_mode || null,
    hr_weekly_behaviour: details.policy?.hr_weekly_behaviour || null
  });
}

    let related;
    if (hasTs) {
      try {
        related = await fetchTimesheetRelated(tsId);

        // âœ… Ensure required new shape exists even if an older fetcher version is still in memory
        if (!Array.isArray(related.invoices)) related.invoices = [];
        if (!related.invoice_no_by_invoice_id || typeof related.invoice_no_by_invoice_id !== 'object') {
          related.invoice_no_by_invoice_id = {};
        }

        L('related fetched', {
          candidate: !!related.candidate,
          client: !!related.client,
          contract: !!related.contract,
          invoiceCount: Array.isArray(related.invoices) ? related.invoices.length : 0,
          umbrella: !!related.umbrella,
          series: (related.series || []).length
        });
      } catch (err) {
        L('fetchTimesheetRelated FAILED (non-fatal)', err);
        related = {
          counts: {},
          candidate: null,
          client: null,

          // âœ… new shape (required)
          invoices: [],
          invoice_no_by_invoice_id: {},

          // legacy/back-compat
          invoice: null,

          umbrella: null,
          contract: null,
          series: []
        };
      }
    } else {
      related = {
        counts: {},
        candidate: (baseRow.candidate_id || baseRow.candidate_name || baseRow.occupant_key_norm)
          ? { id: baseRow.candidate_id || null, display_name: baseRow.candidate_name || baseRow.occupant_key_norm || null, first_name: null, last_name: null }
          : null,
        client: (baseRow.client_id || baseRow.client_name)
          ? { id: baseRow.client_id || null, name: baseRow.client_name || null }
          : null,

        // âœ… new shape (required)
        invoices: [],
        invoice_no_by_invoice_id: {},

        // legacy/back-compat
        invoice: null,

        umbrella: null,
        contract: plannedContract || null,
        series: []
      };
    }



       const tsLocal    = details.timesheet || {};
    const tsfinLocal = details.tsfin     || {};

    const sheetScope = (details.sheet_scope || baseRow.sheet_scope || tsLocal.sheet_scope || sheetScopeRaw || '').toUpperCase();
    const subMode    = ((tsLocal.submission_mode || baseRow.submission_mode || subModeRaw || '')).toUpperCase();
    const basis      = ((tsfinLocal.basis || baseRow.basis || basisRaw || '')).toUpperCase();
    const qrStatus   = String(details.qr_status || tsLocal.qr_status || '').toUpperCase();

const hasFin = !!(details && details.tsfin);

// âœ… IMPORTANT: hasTs must be derived from DETAILS (post-stale-resolution), not from the summary row
const hasTsForExpenses = !!(tsLocal && tsLocal.timesheet_id);

// Eligible when real TS + TSFIN and (MANUAL OR QR exists)
const qrStatusRaw = (details && (details.qr_status ?? (tsLocal && tsLocal.qr_status))) ?? null;
const hasQr = !!(qrStatusRaw && String(qrStatusRaw).trim());

const expensesTabEnabled =
  !!hasTsForExpenses &&
  !!hasFin &&
  (sheetScope !== 'SEGMENT') &&
  (subMode === 'MANUAL' || hasQr);

const expensesTabReason = !hasTsForExpenses
  ? 'Expenses are available once a timesheet exists.'
  : (!hasFin
      ? 'Expenses unavailable until TSFIN snapshot exists.'
      : ((sheetScope === 'SEGMENT')
          ? 'Expenses must be added via Manual Timesheet for Segment Timesheets'
          : (!(subMode === 'MANUAL' || hasQr)
              ? 'Expenses are available for Manual or QR timesheets.'
              : '')));


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// âœ… Expenses draft seed (derived from TSFIN)
// (Safe even if tab disabled; keeps state shape stable.)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Notes/meta only (do NOT use expenses_description for amounts)
const _extractExpenseNote = (desc) => {
  try {
    if (desc == null) return '';
    if (typeof desc === 'string') {
      const s = String(desc || '').trim();
      if (!s) return '';
      // If it's JSON, only accept {note}/{notes} as meta
      try {
        const j = JSON.parse(s);
        if (j && typeof j === 'object') {
          const n1 = (typeof j.note === 'string') ? j.note.trim() : '';
          const n2 = (!n1 && typeof j.notes === 'string') ? j.notes.trim() : '';
          return n1 || n2 || '';
        }
      } catch {}
      // Otherwise treat as plain text note
      return s;
    }
    if (typeof desc === 'object') {
      const n1 = (typeof desc.note === 'string') ? desc.note.trim() : '';
      const n2 = (!n1 && typeof desc.notes === 'string') ? desc.notes.trim() : '';
      return n1 || n2 || '';
    }
  } catch {}
  return '';
};

const expensesDraft = {
  mileage_units: Number(tsfinLocal?.mileage_units ?? 0) || 0,

  // âœ… NEW canonical TSFIN numeric columns (amount carriers)
  travel_pay: Number(tsfinLocal?.travel_pay_ex_vat ?? 0) || 0,
  travel_charge: Number(tsfinLocal?.travel_charge_ex_vat ?? 0) || 0,

  accommodation_pay: Number(tsfinLocal?.accommodation_pay_ex_vat ?? 0) || 0,
  accommodation_charge: Number(tsfinLocal?.accommodation_charge_ex_vat ?? 0) || 0,

  other_pay: Number(tsfinLocal?.other_pay_ex_vat ?? 0) || 0,
  other_charge: Number(tsfinLocal?.other_charge_ex_vat ?? 0) || 0,

  // notes/meta only
  note: _extractExpenseNote(tsfinLocal?.expenses_description)
};

const expensesBaseline = JSON.parse(JSON.stringify(expensesDraft));




    const isWeeklyManualContext =
      sheetScope === 'WEEKLY' &&
      (subMode === 'MANUAL' || (isPlannedWeek && !hasTs));

    const initialReference = tsLocal.reference_number || baseRow.reference_number || '';

  let manualHours = {};

  let contractTemplateSchedule = null;
let additionalRates = {};
try {
  let units = null;

  // âœ… NEW: staged/per-day units source (map: CODE -> { 'YYYY-MM-DD': number })
  let unitsPerDay = {};

  const normaliseUnitsPerDay = (src) => {
    const out = {};
    if (!src || typeof src !== 'object') return out;

    for (const [codeRaw, dayMap] of Object.entries(src)) {
      const code = String(codeRaw || '').toUpperCase().trim();
      if (!code) continue;

      if (!dayMap || typeof dayMap !== 'object') continue;

      const outDays = {};
      for (const [dRaw, vRaw] of Object.entries(dayMap)) {
        const ymd = String(dRaw || '').slice(0, 10);
        if (!/^\d{4}-\d{2}-\d{2}$/.test(ymd)) continue;

        const n = Number(vRaw || 0);
        if (!Number.isFinite(n) || n <= 0) continue;

        outDays[ymd] = n;
      }

      if (Object.keys(outDays).length) out[code] = outDays;
    }

    return out;
  };

  const sumPerDay = (m) => {
    if (!m || typeof m !== 'object') return 0;
    return Object.values(m).reduce((acc, v) => acc + (Number(v) || 0), 0);
  };

    // âœ… NEW: weekly totals stored on the timesheet row (preferred over TSFIN snapshot)
  let unitsWeekStored = {};
  const normaliseUnitsWeekMap = (src) => {
    const out = {};
    if (!src || typeof src !== 'object') return out;
    for (const [k, v] of Object.entries(src)) {
      const code = String(k || '').toUpperCase().trim();
      if (!code) continue;
      const n = Number(v || 0);
      if (!Number.isFinite(n) || n <= 0) continue;
      out[code] = n;
    }
    return out;
  };

  // â”€â”€ Existing timesheet: seed from TSFIN additional_units_json (unchanged) â”€â”€
  // âœ… PLUS: seed per-day from timesheet.additional_units_per_day
  if (hasTs) {
    // Weekly totals: read from TS storage first
    let aw = (tsLocal && tsLocal.additional_units_week != null) ? tsLocal.additional_units_week : null;
    if (typeof aw === 'string') { try { aw = JSON.parse(aw); } catch { aw = null; } }
    unitsWeekStored = normaliseUnitsWeekMap(aw && typeof aw === 'object' ? aw : {});

    units = tsfinLocal.additional_units_json;
    if (!units && tsfinLocal.invoice_breakdown_json && typeof tsfinLocal.invoice_breakdown_json === 'object') {
      units = tsfinLocal.invoice_breakdown_json.additional && tsfinLocal.invoice_breakdown_json.additional.units;
    }

    let apd = (tsLocal && tsLocal.additional_units_per_day != null) ? tsLocal.additional_units_per_day : null;
    if (typeof apd === 'string') { try { apd = JSON.parse(apd); } catch { apd = null; } }
    unitsPerDay = normaliseUnitsPerDay(apd);
  } else {

    // â”€â”€ Planned week (no TS yet): seed from contract_week.totals_json.additional_units_week â”€â”€
    let au =
      (details && details.contract_week && details.contract_week.totals_json && typeof details.contract_week.totals_json === 'object')
        ? details.contract_week.totals_json.additional_units_week
        : null;

    if (typeof au === 'string') {
      try { au = JSON.parse(au); } catch { au = null; }
    }

    // Normalise into the same shape as TSFIN additional_units_json:
    // { EX1: { unit_count: 2 }, EX2: { unit_count: 1 }, ... }
    const norm = {};
    if (au && typeof au === 'object') {
      for (const [k, v] of Object.entries(au)) {
        const code = String(k || '').toUpperCase().trim();
        if (!code) continue;
        const n = Number(v || 0);
        if (!Number.isFinite(n) || !n) continue;
        norm[code] = { unit_count: n };
      }
    }
    units = norm;

    // âœ… NEW: planned per-day from contract_weeks.totals_json.additional_units_per_day
    let apd =
      (details && details.contract_week && details.contract_week.totals_json && typeof details.contract_week.totals_json === 'object')
        ? details.contract_week.totals_json.additional_units_per_day
        : null;

    if (typeof apd === 'string') {
      try { apd = JSON.parse(apd); } catch { apd = null; }
    }
    unitsPerDay = normaliseUnitsPerDay(apd);
  }

  if (typeof units === 'string') { try { units = JSON.parse(units); } catch { units = {}; } }
  if (!units || typeof units !== 'object') units = {};

  // â”€â”€ Config (contract.additional_rates_json): prefer related.contract when present,
  //    otherwise (planned week) fetch contract by id and read additional_rates_json â”€â”€
  let cfgArr = related && related.contract && related.contract.additional_rates_json;


  if ((!cfgArr || (typeof cfgArr !== 'string' && !Array.isArray(cfgArr))) && !hasTs) {
    try {
      const contractId =
        baseRow.contract_id ||
        (details && details.contract_week ? details.contract_week.contract_id : null) ||
        null;

      if (contractId && typeof getContract === 'function') {
        const c = await getContract(contractId);
        if (c && Object.prototype.hasOwnProperty.call(c, 'additional_rates_json')) {
          cfgArr = c.additional_rates_json;
        }
        if (c && Object.prototype.hasOwnProperty.call(c, 'std_schedule_json')) {
          contractTemplateSchedule = c.std_schedule_json;
        }
      }
    } catch {
      // non-fatal; config may remain empty
    }
  }


      if (typeof cfgArr === 'string') { try { cfgArr = JSON.parse(cfgArr); } catch { cfgArr = []; } }
      if (!Array.isArray(cfgArr)) cfgArr = [];

         const codes = new Set();
      Object.keys(units || {}).forEach(k => { if (k) codes.add(String(k).toUpperCase()); });

      // âœ… NEW: also include codes that only exist in per-day storage
      Object.keys(unitsPerDay || {}).forEach(k => { if (k) codes.add(String(k).toUpperCase()); });

      cfgArr.forEach(cfg => { if (cfg && cfg.code) codes.add(String(cfg.code).toUpperCase()); });

      codes.forEach(code => {

        const cfg = cfgArr.find(c => c && String(c.code).toUpperCase() === code) || {};
        let existing = units[code];
        if (!existing) {
          const matchKey = Object.keys(units || {}).find(k => String(k).toUpperCase() === code);
          if (matchKey) existing = units[matchKey];
        }
          existing = existing || {};

        // âœ… NEW: case-insensitive per-day lookup
        let perDay = unitsPerDay[code] || null;
        if (!perDay) {
          const hit = Object.keys(unitsPerDay || {}).find(k => String(k).toUpperCase() === code);
          if (hit) perDay = unitsPerDay[hit];
        }
        if (!perDay || typeof perDay !== 'object') perDay = {};

            // If we have per-day units but no unit_count, derive units_week from the sum.
        const derivedWeek = sumPerDay(perDay);

        // âœ… Prefer stored weekly totals from timesheet.additional_units_week when present
        const storedWeekUnits =
          (unitsWeekStored && Object.prototype.hasOwnProperty.call(unitsWeekStored, code))
            ? Number(unitsWeekStored[code] || 0)
            : 0;

        const weekUnits =
          (Number.isFinite(storedWeekUnits) && storedWeekUnits > 0)
            ? storedWeekUnits
            : (Number(existing.unit_count ?? 0) || derivedWeek || 0);

        additionalRates[code] = {
          code,
          bucket_name: existing.bucket_name ?? cfg.bucket_name ?? null,
          unit_name:   existing.unit_name   ?? cfg.unit_name   ?? null,
          frequency:   existing.frequency   ?? cfg.frequency   ?? null,
          units_week:  weekUnits,
          units_per_day: perDay,
          pay_rate:    existing.pay_rate    ?? cfg.pay_rate    ?? null,
          charge_rate: existing.charge_rate ?? cfg.charge_rate ?? null
        };


      });
    } catch {
      additionalRates = {};
    }


   let schedule = null;
try {
  if (hasTs && tsLocal.actual_schedule_json) {
    if (Array.isArray(tsLocal.actual_schedule_json) || typeof tsLocal.actual_schedule_json === 'object') {
      schedule = JSON.parse(JSON.stringify(tsLocal.actual_schedule_json));
    } else if (typeof tsLocal.actual_schedule_json === 'string') {
      try {
        const parsed = JSON.parse(tsLocal.actual_schedule_json);
        if (Array.isArray(parsed) || typeof parsed === 'object') schedule = parsed;
      } catch {}
    }
  }
  if (!hasTs && !schedule) {
    const cw2 = (details && details.contract_week) ? details.contract_week : null;

    const src = (cw2 && cw2.planned_schedule_json != null) ? cw2.planned_schedule_json
             : (cw2 && cw2.std_schedule_json != null) ? cw2.std_schedule_json
             : (contractTemplateSchedule != null) ? contractTemplateSchedule
             : (baseRow.std_schedule_json != null) ? baseRow.std_schedule_json
             : null;

    if (src) {
      if (Array.isArray(src) || typeof src === 'object') schedule = JSON.parse(JSON.stringify(src));
      else if (typeof src === 'string') { try { const p = JSON.parse(src); if (Array.isArray(p) || typeof p === 'object') schedule = p; } catch {} }
    }
  }
} catch {
  schedule = null;
}


  const hasWeeklySchedule = Array.isArray(schedule) && schedule.length > 0;

if (!hasWeeklySchedule && sheetScope === 'WEEKLY' && subMode === 'MANUAL' && !isPlannedWeek && tsfinLocal && (tsfinLocal.hours_day != null || tsfinLocal.hours_night != null || tsfinLocal.hours_sat != null || tsfinLocal.hours_sun != null || tsfinLocal.hours_bh != null)) {
  manualHours = {
    day:   Number(tsfinLocal.hours_day   ?? 0),
    night: Number(tsfinLocal.hours_night ?? 0),
    sat:   Number(tsfinLocal.hours_sat   ?? 0),
    sun:   Number(tsfinLocal.hours_sun   ?? 0),
    bh:    Number(tsfinLocal.hours_bh    ?? 0)
  };
}

const ignoreLegacyWeeklyRefs =
  (sheetScope === 'WEEKLY') &&
  (isPlannedWeek || (subMode === 'MANUAL' && hasWeeklySchedule));

let dayReferences = {};
try {
  if (!ignoreLegacyWeeklyRefs) {
    const tsDayRefs = tsLocal && tsLocal.day_references_json && typeof tsLocal.day_references_json === 'object'
      ? tsLocal.day_references_json
      : null;
    if (tsDayRefs) dayReferences = { ...tsDayRefs };
  }
} catch { dayReferences = {}; }

try {
  if (!ignoreLegacyWeeklyRefs && !Object.keys(dayReferences).length && tsfinLocal && tsfinLocal.external_source_rows_json) {
    const ext = tsfinLocal.external_source_rows_json || {};
    const hrRows   = Array.isArray(ext.HR_WEEKLY)   ? ext.HR_WEEKLY   : [];
    const nhspRows = Array.isArray(ext.NHSP_WEEKLY) ? ext.NHSP_WEEKLY : [];
    [...hrRows, ...nhspRows].forEach(r => {
      const date = r && r.date;
      const ref  = r && r.reference;
      if (date && ref && !dayReferences[date]) dayReferences[date] = ref;
    });
  }
} catch { /* non-fatal */ }


    const isPaid     = !!tsfinLocal.paid_at_utc;
    const isInvoiced = !!tsfinLocal.locked_by_invoice_id;
    const canDeletePerm = !!(hasTs && !isPaid && !isInvoiced);

     const cwId =
      (details && details.contract_week_id) ||
      (details && details.contract_week && details.contract_week.id) ||
      baseRow.contract_week_id ||
      null;


    const cwSubSnapRaw =
      (details.contract_week && details.contract_week.submission_mode_snapshot) ||
      baseRow.submission_mode ||
      '';
    const cwSubSnap = String(cwSubSnapRaw || '').toUpperCase();

 window.modalCtx = {
  ...(window.modalCtx || {}),
  entity: 'timesheets',

  // âœ… Always open in VIEW; Edit gating (including planned weeks) is handled by showModal/_updateButtons.
  mode: 'view',

  // âœ… NEW: expenses tab state (always visible, disabled unless eligible)
  expenses_tab_enabled: !!expensesTabEnabled,
  expenses_tab_reason: String(expensesTabReason || ''),

  data: {
    ...baseRow,
    timesheet_id: tsId || null,
    contract_week_id: weekId || baseRow.contract_week_id || null
  },

  timesheetDetails: details,
  timesheetRelated: related,

  // âœ… NEW: delete preview policy payload (kind/eligible/blocked_reasons/delete_items)
  timesheetDeletePreview: deletePreview,

  timesheetState: {
    reference: initialReference,
    payHoldDesired: null,
    payHoldReason: '',
    markPaid: false,
    segmentOverrides: {},
    segmentInvoiceTargets: {},
    manualHours,
    additionalRates,
    schedule,
    dayReferences,
    evidence,

    // âœ… NEW (stable shape; used by Expenses tab + save tasks later)
    expensesDraft,
    expensesBaseline
  },

  timesheetMeta: {
    hasTs,
    isPlannedWeek,
    sheetScope,
    subMode,
    basis,
    qrStatus,
    isPaid,
    isInvoiced,
    isLocked: (isPaid || isInvoiced),
    canDeletePermanently: canDeletePerm,
    contract_week_id: cwId,
    cw_submission_mode_snapshot: cwSubSnap,

    // âœ… NEW: required for guarded-write endpoints (optimistic concurrency)
    expected_timesheet_id: (hasTs ? (tsId || null) : null),

    // Use backend-derived action flags (enriched above). This is what your footer gating expects.
    hasElectronicOriginal: !!(details && details.action_flags && details.action_flags.can_revert_to_electronic)
  }
};



const tabDefs = [
  { key: 'overview', title: 'Overview' },
  { key: 'lines',    title: 'Lines' },

  // âœ… NEW: always visible; disabled unless eligible (non-clickable via render bounce)
  { key: 'expenses', title: 'Expenses', disabled: !expensesTabEnabled, disabled_reason: expensesTabReason },

  { key: 'evidence', title: 'Evidence' },
  { key: 'issues',   title: 'Issues' },
  { key: 'finance',  title: 'Finance' },
  { key: 'audit',    title: 'Audit' }
];


const renderTab = (key, mergedRow) => {
  const ctxForTab = {
    row: mergedRow || window.modalCtx.data || baseRow,
    details: window.modalCtx.timesheetDetails || details,
    related: window.modalCtx.timesheetRelated || related,
    state: window.modalCtx.timesheetState
  };

  // NEW: audit fetch on tab open (best-effort, non-fatal)
  if (key === 'audit') {
    try {
      const mc = window.modalCtx || {};
      const tsId = mc.data?.timesheet_id || ctxForTab.row?.timesheet_id || null;
      if (tsId && typeof fetchTimesheetAudit === 'function') {
        const cacheKey = String(tsId);

        // Create cache store
        mc.timesheetAuditCache ||= {};

        // Fetch only if not already cached for this timesheet id
        if (!mc.timesheetAuditCache[cacheKey]) {
          // Fire and forget; rerender once loaded
          Promise.resolve()
            .then(async () => {
              const items = await fetchTimesheetAudit(tsId);
              mc.timesheetAuditCache[cacheKey] = Array.isArray(items) ? items : (items?.items || []);
            })
            .then(() => {
              // Repaint current tab if still on audit
              try {
                if (typeof window.__getModalFrame === 'function') {
                  const fr = window.__getModalFrame();
                  if (fr && fr.entity === 'timesheets' && fr.currentTabKey === 'audit') {
                    fr._suppressDirty = true;
                    fr.setTab('audit');
                    fr._suppressDirty = false;
                  }
                }
              } catch {}
            })
            .catch(() => {});
        }
      }
    } catch {}
  }
  switch (key) {
    case 'overview': return renderTimesheetOverviewTab(ctxForTab);
    case 'lines':    return renderTimesheetLinesTab(ctxForTab);

    case 'expenses': {
      const enabled = !!(window.modalCtx && window.modalCtx.expenses_tab_enabled);

      // âœ… non-responsive: bounce back to overview if disabled
      if (!enabled) {
        try {
          const fr = (typeof window.__getModalFrame === 'function') ? window.__getModalFrame() : null;
          if (fr && fr.entity === 'timesheets' && typeof fr.setTab === 'function') {
            Promise.resolve().then(() => { try { fr.setTab('overview'); } catch {} });
          }
        } catch {}

        const why = (window.modalCtx && window.modalCtx.expenses_tab_reason) ? String(window.modalCtx.expenses_tab_reason) : '';
        return `<div class="tabc"><div class="card"><div class="row"><label>Expenses</label><div class="controls"><span class="mini">${why || 'Expenses are not available for this timesheet.'}</span></div></div></div></div>`;
      }

      // âœ… assumes renderer will exist per your plan
      return renderTimesheetExpensesTab(ctxForTab);
    }

    case 'evidence': return renderTimesheetEvidenceTab(ctxForTab);
    case 'issues':   return renderTimesheetIssuesTab(ctxForTab);
    case 'finance':  return renderTimesheetFinanceTab(ctxForTab);
    case 'audit':    return renderTimesheetAuditTab(ctxForTab);

    default:
      return `<div class="tabc"><div class="card"><div class="row"><label>Timesheet</label><div class="controls"><span class="mini">Unknown tab: ${key}</span></div></div></div></div>`;
  }

};

// âœ… Replace your existing `const onSaveTimesheet = async () => { ... }` inside openTimesheet(...) with this:

// âœ… REPLACE your existing `const onSaveTimesheet = async () => { ... }` inside openTimesheet(...) with this:
const onSaveTimesheet = async () => {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][SAVE]');
  GC('onSaveTimesheet');

  const mc     = window.modalCtx || {};
  const rowNow = mc.data || {};
  const det    = mc.timesheetDetails || {};
  const st     = mc.timesheetState || {};

  // HARD BLOCK if we already know schedule is invalid
  if (st && st.scheduleHasErrors) {
    alert('Fix the highlighted shift/break times first (overlaps, partial times, or breaks outside the shift).');
    GE();
    return { ok: false };
  }

  const stableStringify = (obj) => { try { return JSON.stringify(obj); } catch { return ''; } };
  const deepEqualJson   = (a, b) => stableStringify(a) === stableStringify(b);

  const normaliseScheduleJson = (x) => {
    if (x == null) return null;
    if (Array.isArray(x) || typeof x === 'object') return x;
    if (typeof x === 'string') {
      try { const p = JSON.parse(x); if (Array.isArray(p) || typeof p === 'object') return p; } catch {}
    }
    return null;
  };

  const parseHHMM = (s) => {
    const m = String(s || '').trim().match(/^(\d{1,2}):(\d{2})$/);
    if (!m) return null;
    const hh = Number(m[1]), mm = Number(m[2]);
    if (!Number.isFinite(hh) || !Number.isFinite(mm)) return null;
    if (hh < 0 || hh > 23 || mm < 0 || mm > 59) return null;
    return hh * 60 + mm;
  };

  const diffMins = (a, b) => {
    const am = parseHHMM(a);
    const bm = parseHHMM(b);
    if (am == null || bm == null) return null;
    let d = bm - am;
    if (d < 0) d += 1440;
    return d;
  };

  const sortScheduleStable = (arr) => {
    const out = Array.isArray(arr) ? arr.slice() : [];
    out.sort((A, B) => {
      const da = String(A?.date || A?.work_date || A?.date_ymd || '');
      const db = String(B?.date || B?.work_date || B?.date_ymd || '');
      if (da !== db) return da.localeCompare(db);
      const sa = parseHHMM(A?.start) ?? -1;
      const sb = parseHHMM(B?.start) ?? -1;
      if (sa !== sb) return sa - sb;
      const ea = parseHHMM(A?.end) ?? -1;
      const eb = parseHHMM(B?.end) ?? -1;
      if (ea !== eb) return ea - eb;
      const ra = String(A?.ref_num ?? A?.reference ?? '');
      const rb = String(B?.ref_num ?? B?.reference ?? '');
      return ra.localeCompare(rb);
    });
    return out;
  };

  const getWeekDays = (weekEndingYmd) => {
    const out = [];
    if (!weekEndingYmd) return out;
    try {
      const base = new Date(`${String(weekEndingYmd)}T00:00:00Z`);
      if (Number.isNaN(base.getTime())) return out;
      const dowShort = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
      const toYmd = (d) => {
        const yyyy = d.getUTCFullYear();
        const mm   = String(d.getUTCMonth() + 1).padStart(2, '0');
        const dd   = String(d.getUTCDate()).toString().padStart(2, '0');
        return `${yyyy}-${mm}-${dd}`;
      };
      for (let offset = 6; offset >= 0; offset--) {
        const d = new Date(base);
        d.setUTCDate(base.getUTCDate() - offset);
        out.push({ ymd: toYmd(d), dow: dowShort[d.getUTCDay()] });
      }
    } catch {}
    return out;
  };

  // DOM fallback (ONLY if Lines tab DOM is currently mounted)
  const readWeeklyLinesFromDomIfPresent = () => {
    try {
      const body = document.getElementById('modalBody');
      if (!body) return null;
      const rows = body.querySelectorAll('tr[data-weekly-line="1"][data-date][data-line-idx]');
      if (!rows || !rows.length) return null;

      const out = {};
      rows.forEach(tr => {
        const date = String(tr.getAttribute('data-date') || '');
        const idx  = Number(tr.getAttribute('data-line-idx') || '0');
        if (!date) return;

        out[date] ||= [];
        out[date][idx] ||= { ref:'', start:'', end:'', break_start:'', break_end:'', break_mins:'' };

        tr.querySelectorAll('input[data-weekly-field]').forEach(inp => {
          const f = String(inp.getAttribute('data-weekly-field') || '');
          if (!f) return;

          // âœ… donâ€™t let UI-only mins leak into state via DOM fallback
          if (
            f === 'break_mins' &&
            (inp.dataset.autocalc === '1' || inp.dataset.breaklock === '1')
          ) {
            return;
          }

          out[date][idx][f] = String(inp.value || '').trim();
        });

      });

      for (const d of Object.keys(out)) {
        const arr = Array.isArray(out[d]) ? out[d] : [];
        for (let i = 0; i < arr.length; i++) {
          if (!arr[i]) arr[i] = { ref:'', start:'', end:'', break_start:'', break_end:'', break_mins:'' };
        }
        out[d] = arr;
      }
      return out;
    } catch {
      return null;
    }
  };

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Context flags
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  const tsLocal    = det.timesheet || {};
  const tsfinLocal = det.tsfin     || {};

  const currentRef = tsLocal.reference_number || rowNow.reference_number || '';
  const stagedRef  = (st.reference != null) ? st.reference : currentRef;
  const refChanged = stagedRef !== currentRef;

  const sheetScopeSave = (det.sheet_scope || rowNow.sheet_scope || tsLocal.sheet_scope || '').toUpperCase();
  const subModeSave    = (tsLocal.submission_mode || rowNow.submission_mode || '').toUpperCase();

  const weekIdSave     = rowNow.contract_week_id || det.contract_week_id || null;
  let   tsIdSave       = (tsLocal.timesheet_id || rowNow.timesheet_id || null);

  const isPlannedWeeklyWithoutTs =
    sheetScopeSave === 'WEEKLY' &&
    !!weekIdSave &&
    !tsLocal.timesheet_id;

  const isWeeklyManualContext =
    sheetScopeSave === 'WEEKLY' &&
    !!weekIdSave &&
    (subModeSave === 'MANUAL' || isPlannedWeeklyWithoutTs);

  const isDailyManualContext =
    sheetScopeSave === 'DAILY' &&
    subModeSave === 'MANUAL' &&
    !!tsLocal.timesheet_id;

  const weekEndingYmd =
    tsLocal.week_ending_date ||
    rowNow.week_ending_date ||
    det?.contract_week?.week_ending_date ||
    null;

  const weekDays = isWeeklyManualContext ? getWeekDays(weekEndingYmd) : [];

  // Baseline for change detection:
  // - real TS: actual_schedule_json
  // - planned week: planned_schedule_json else std_schedule_json
  const currentWeeklyScheduleBaseline = normaliseScheduleJson(
    (tsLocal && tsLocal.timesheet_id)
      ? tsLocal.actual_schedule_json
      : (
          det && det.contract_week
            ? (det.contract_week.planned_schedule_json != null ? det.contract_week.planned_schedule_json : det.contract_week.std_schedule_json)
            : null
        )
  );
  const baselineSorted = sortScheduleStable(Array.isArray(currentWeeklyScheduleBaseline) ? currentWeeklyScheduleBaseline : []);

  // Primary source: timesheetState.weeklyLinesByDate (ONLY if it looks seeded for this week)
  const looksSeededForWeek = (linesObj) => {
    if (!linesObj || typeof linesObj !== 'object') return false;
    if (!Array.isArray(weekDays) || !weekDays.length) return false;
    return weekDays.some(wd => Array.isArray(linesObj[wd.ymd]));
  };

  let linesByDate =
    (st.weeklyLinesByDate && typeof st.weeklyLinesByDate === 'object') ? st.weeklyLinesByDate : null;

  if (!looksSeededForWeek(linesByDate)) {
    linesByDate = null;
  }

  // DOM fallback only if Lines tab is mounted
  if (!linesByDate) {
    const domLines = readWeeklyLinesFromDomIfPresent();
    if (looksSeededForWeek(domLines)) linesByDate = domLines;
  }

  // Build schedule from lines if we can; otherwise fall back to existing schedule/baseline (no-op safe).
  let scheduleToSave = null;

  if (isWeeklyManualContext && weekDays.length && linesByDate) {
    if (typeof buildWeeklyScheduleFromLinesAndValidate !== 'function') {
      alert('Internal error: buildWeeklyScheduleFromLinesAndValidate is missing.');
      GE();
      return { ok: false };
    }

    const cleanLinesByDate = (() => {
      const src = (linesByDate && typeof linesByDate === 'object') ? linesByDate : {};
      const clone = JSON.parse(JSON.stringify(src || {}));

      for (const d of Object.keys(clone)) {
        const arr = Array.isArray(clone[d]) ? clone[d] : [];
        for (const ln of arr) {
          const hasWindow =
            !!(String(ln?.break_start || '').trim() || String(ln?.break_end || '').trim());

          // âœ… if window mode, mins must NOT be sent/validated as â€œchosenâ€
          if (hasWindow) ln.break_mins = '';
        }
        clone[d] = arr;
      }
      return clone;
    })();

    const out = buildWeeklyScheduleFromLinesAndValidate(
      cleanLinesByDate,
      weekDays,
      { allowOvernight: true, allowBreakMins: true }
    );

    if (out && out.hasErrors) {
      st.scheduleHasErrors = true;
      st.scheduleErrorsByDate = (out.errorsByDate && typeof out.errorsByDate === 'object') ? out.errorsByDate : {};

      try {
        const fr = (typeof window.__getModalFrame === 'function') ? window.__getModalFrame() : null;
        if (fr && fr.entity === 'timesheets') {
          fr._suppressDirty = true;
          await fr.setTab('lines');
          fr._suppressDirty = false;
          fr._updateButtons && fr._updateButtons();
        }
      } catch {}

      // Build a friendly error list (cap at 12)
      const flat = [];
      try {
        for (const [d, msgs] of Object.entries(st.scheduleErrorsByDate || {})) {
          (Array.isArray(msgs) ? msgs : []).forEach(m => flat.push(`${d}: ${m}`));
        }
      } catch {}

      alert(
        'Fix these schedule issues first:\n\n' +
        flat.slice(0, 12).map(x => `- ${x}`).join('\n') +
        (flat.length > 12 ? `\n\n(and ${flat.length - 12} more)` : '')
      );

      GE();
      return { ok: false };
    }

    st.scheduleHasErrors = false;
    st.scheduleErrorsByDate = {};

    scheduleToSave = Array.isArray(out?.schedule) ? out.schedule : [];
  }
  else if (isWeeklyManualContext) {
    const fallback = normaliseScheduleJson(st.schedule) || baselineSorted;
    scheduleToSave = sortScheduleStable(Array.isArray(fallback) ? fallback : []);
  }

  if (isWeeklyManualContext) {
    st.schedule = Array.isArray(scheduleToSave) ? scheduleToSave : [];
  }

  const scheduleChangedWeekly =
    isWeeklyManualContext &&
    !deepEqualJson(sortScheduleStable(st.schedule || []), baselineSorted);

  // Extras diff (weekly + per-day)
  const normExtrasWeek = (extrasMapOrUnitsWeek) => {
    const out = {};
    const src = extrasMapOrUnitsWeek || {};
    for (const [codeRaw, r] of Object.entries(src)) {
      const code = String(codeRaw || '').toUpperCase().trim();
      if (!code) continue;

      if (r && typeof r === 'object' && Object.prototype.hasOwnProperty.call(r, 'units_week')) {
        const u = Number(r.units_week || 0);
        out[code] = Number.isFinite(u) ? u : 0;
        continue;
      }

      const u2 = Number(r || 0);
      out[code] = Number.isFinite(u2) ? u2 : 0;
    }

    for (const k of Object.keys(out)) if (!out[k]) delete out[k];

    const sorted = {};
    Object.keys(out).sort().forEach(k => { sorted[k] = out[k]; });
    return sorted;
  };

  const normExtrasPerDay = (extrasMap) => {
    const out = {};
    const src = (extrasMap && typeof extrasMap === 'object') ? extrasMap : {};

    const codes = Object.keys(src).map(k => String(k || '').toUpperCase().trim()).filter(Boolean).sort();
    for (const code of codes) {
      const r = src[code] || src[Object.keys(src).find(k => String(k).toUpperCase() === code)] || null;
      if (!r || typeof r !== 'object') continue;

      const per = (r.units_per_day && typeof r.units_per_day === 'object') ? r.units_per_day : {};
      const days = {};
      Object.keys(per).sort().forEach(dRaw => {
        const ymd = String(dRaw || '').slice(0, 10);
        if (!/^\d{4}-\d{2}-\d{2}$/.test(ymd)) return;

        const n = Number(per[dRaw] || 0);
        if (!Number.isFinite(n) || n <= 0) return;

        days[ymd] = n;
      });

      if (Object.keys(days).length) out[code] = days;
    }

    return out;
  };

  const getCurrentExtrasWeek = () => {
    // âœ… Prefer stored TS values when a real timesheet exists
    let awTs = tsLocal?.additional_units_week ?? null;
    if (typeof awTs === 'string') { try { awTs = JSON.parse(awTs); } catch { awTs = null; } }
    if (awTs && typeof awTs === 'object') {
      const out = {};
      for (const [codeRaw, v] of Object.entries(awTs)) {
        const code = String(codeRaw || '').toUpperCase().trim();
        if (!code) continue;
        const n = Number(v || 0);
        if (Number.isFinite(n) && n) out[code] = n;
      }
      const sorted = {};
      Object.keys(out).sort().forEach(k => { sorted[k] = out[k]; });
      return sorted;
    }

    // Fallback: TSFIN snapshot (older / missing TS fields)
    const au = tsfinLocal?.additional_units_json;
    if (au && typeof au === 'object') {
      const out = {};
      for (const [codeRaw, v] of Object.entries(au)) {
        const code = String(codeRaw || '').toUpperCase().trim();
        if (!code) continue;
        const u = Number(v?.unit_count ?? v?.units_week ?? 0);
        if (Number.isFinite(u) && u) out[code] = u;
      }
      const sorted = {};
      Object.keys(out).sort().forEach(k => { sorted[k] = out[k]; });
      return sorted;
    }

    // Planned week baseline
    let au2 = det?.contract_week?.totals_json?.additional_units_week ?? null;
    if (typeof au2 === 'string') { try { au2 = JSON.parse(au2); } catch { au2 = null; } }
    if (au2 && typeof au2 === 'object') {
      const out = {};
      for (const [codeRaw, v] of Object.entries(au2)) {
        const code = String(codeRaw || '').toUpperCase().trim();
        if (!code) continue;
        const n = (v && typeof v === 'object') ? Number(v.unit_count ?? v.units_week ?? 0) : Number(v ?? 0);
        if (Number.isFinite(n) && n) out[code] = n;
      }
      const sorted = {};
      Object.keys(out).sort().forEach(k => { sorted[k] = out[k]; });
      return sorted;
    }

    return {};
  };

  const getCurrentExtrasPerDay = () => {
    // Existing TS baseline
    let apdTs = tsLocal?.additional_units_per_day ?? null;
    if (typeof apdTs === 'string') { try { apdTs = JSON.parse(apdTs); } catch { apdTs = null; } }
    if (apdTs && typeof apdTs === 'object') {
      const tmp = {};
      for (const [codeRaw, dayMap] of Object.entries(apdTs)) {
        const code = String(codeRaw || '').toUpperCase().trim();
        if (!code) continue;
        if (!dayMap || typeof dayMap !== 'object') continue;
        tmp[code] = dayMap;
      }
      return normExtrasPerDay(tmp);
    }

    // Planned week baseline
    let apdCw = det?.contract_week?.totals_json?.additional_units_per_day ?? null;
    if (typeof apdCw === 'string') { try { apdCw = JSON.parse(apdCw); } catch { apdCw = null; } }
    if (apdCw && typeof apdCw === 'object') {
      const tmp = {};
      for (const [codeRaw, dayMap] of Object.entries(apdCw)) {
        const code = String(codeRaw || '').toUpperCase().trim();
        if (!code) continue;
        if (!dayMap || typeof dayMap !== 'object') continue;
        tmp[code] = dayMap;
      }
      return normExtrasPerDay(tmp);
    }

    return {};
  };

  const extrasMap = st.additionalRates || {};
  const stagedExtrasWeek   = normExtrasWeek(extrasMap);
  const stagedExtrasPerDay = normExtrasPerDay(extrasMap);
  const currentExtrasWeek  = getCurrentExtrasWeek();
  const currentExtrasPerDay= getCurrentExtrasPerDay();

  const extrasChangedWeekly =
    isWeeklyManualContext &&
    (
      stableStringify(currentExtrasWeek)   !== stableStringify(stagedExtrasWeek) ||
      stableStringify(currentExtrasPerDay) !== stableStringify(stagedExtrasPerDay)
    );

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // âœ… Expenses diff (NEW): compare draft vs baseline (tsfin-seeded)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const round2 = (n) => Math.round((Number(n) || 0) * 100) / 100;

  const normExpenses = (x) => {
    const d = (x && typeof x === 'object') ? x : {};
    return {
      mileage_units: Number(d.mileage_units ?? 0) || 0,

      travel_pay: round2(d.travel_pay ?? 0),
      travel_charge: round2(d.travel_charge ?? 0),

      accommodation_pay: round2(d.accommodation_pay ?? 0),
      accommodation_charge: round2(d.accommodation_charge ?? 0),

      other_pay: round2(d.other_pay ?? 0),
      other_charge: round2(d.other_charge ?? 0),

      // âœ… include notes/meta in diff so â€œnote-onlyâ€ edits are saved
      note: String(d.note ?? '').trim()
    };
  };

  const stagedExpenses   = normExpenses(st.expensesDraft);
  const baselineExpenses = normExpenses(st.expensesBaseline);
  const expensesChanged  = stableStringify(stagedExpenses) !== stableStringify(baselineExpenses);

  // Daily schedule change detection (unchanged)
  const stagedSchedule   = (st.schedule != null) ? st.schedule : null;
  const currentSchedule  = tsLocal.actual_schedule_json || null;
  const scheduleChangedDaily =
    isDailyManualContext &&
    !!stagedSchedule &&
    !deepEqualJson(stagedSchedule, currentSchedule);

  const lockedNow = !!(tsfinLocal.locked_by_invoice_id || tsfinLocal.paid_at_utc);

  // Segments staging
  const segOverrides    = st.segmentOverrides || {};
  const segTargets      = st.segmentInvoiceTargets || {};
  const hasSegOverrides = !!Object.keys(segOverrides).length;
  const hasSegTargets   = !!Object.keys(segTargets).length;

  // QR-sensitive change (weekly schedule + weekly extras + daily schedule)
  const qrSensitiveChange = scheduleChangedWeekly || scheduleChangedDaily || extrasChangedWeekly;

  const isContentChangeAttempt =
    qrSensitiveChange ||
    expensesChanged ||
    (det.isSegmentsMode && (hasSegOverrides || hasSegTargets)) ||
    refChanged;

  if (lockedNow && isContentChangeAttempt) {
    alert('This timesheet is locked (invoiced or paid). You cannot change schedule, references, segments, or expenses.');
    GE();
    return { ok: false };
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // QR after-save decision (invalidate / manual-only / optionally send new)
  // Only applies when: real TS exists + QR-sensitive content changed + not locked.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // QR after-save decision (NEW):
  // If QR-sensitive content changed on a real QR-enabled timesheet, we must:
  //  - invalidate any old QR state (backend qr_action='INVALIDATE'), OR
  //  - convert to manual-only (backend qr_action='REVOKE_TO_MANUAL')
  // and optionally send a new QR immediately after save.
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  const qrStatusRaw = String(det?.qr_status || tsLocal?.qr_status || '').toUpperCase();

  let qrAfterSaveAction = null;     // 'SEND_NEW_NOW' | 'SAVE_ONLY_INVALIDATE' | 'CONVERT_TO_MANUAL_ONLY' | null
  let qrActionBackend   = null;     // 'INVALIDATE' | 'REVOKE_TO_MANUAL' | null
  let qrSendNewNow      = false;    // boolean

  // Only prompt when:
  // - we have a real timesheet id (not planned week),
  // - QR is active/known on this timesheet,
  // - not locked,
  // - and QR-sensitive content actually changed.
  if (!!tsIdSave && qrStatusRaw && !lockedNow && qrSensitiveChange) {
    const decision = await openQrAfterSaveModal({
      context: {
        timesheet_id: tsIdSave || null,
        sheet_scope: sheetScopeSave,
        submission_mode: subModeSave,
        qr_status: qrStatusRaw
      }
    });

    if (!decision || decision.cancelled) {
      GE();
      return { ok: false };
    }

    qrAfterSaveAction = String(decision.action || '').toUpperCase();

    if (qrAfterSaveAction === 'CONVERT_TO_MANUAL_ONLY') {
      qrActionBackend = 'REVOKE_TO_MANUAL';
      qrSendNewNow = false;
    } else if (qrAfterSaveAction === 'SEND_NEW_NOW') {
      qrActionBackend = 'INVALIDATE';
      qrSendNewNow = true;
    } else if (qrAfterSaveAction === 'SAVE_ONLY_INVALIDATE') {
      qrActionBackend = 'INVALIDATE';
      qrSendNewNow = false;
    } else {
      alert('Please select an option.');
      GE();
      return { ok: false };
    }
  }

  // Forced QR action (legacy trigger from â€œrevoke signed QR & request resubmissionâ€ flow)
  // Treat it as: invalidate + send new now on save.
  const forced = String(st.__forceQrActionEnum || '').toUpperCase();
  if (!qrActionBackend && !lockedNow && tsIdSave && forced === 'REISSUE_QR') {
    qrActionBackend = 'INVALIDATE';
    qrSendNewNow = true;
    try { st.__forceQrActionEnum = null; } catch {}
  }

  // Pay-hold / mark-paid staging (unchanged)
  const currentOnHold    = !!tsfinLocal.pay_on_hold;
  const payHoldDesired   = (st.payHoldDesired === true || st.payHoldDesired === false) ? st.payHoldDesired : null;
  const payHoldReason    = st.payHoldReason || '';
  const shouldChangeHold =
    (payHoldDesired === true  && !currentOnHold) ||
    (payHoldDesired === false &&  currentOnHold);

  const alreadyPaid      = !!tsfinLocal.paid_at_utc;
  const wantsMarkPaid    = !!st.markPaid;
  const shouldMarkPaid   = wantsMarkPaid && !alreadyPaid;

  L('staged state', {
    tsIdSave,
    weekIdSave,
    sheetScopeSave,
    subModeSave,
    isWeeklyManualContext,
    isDailyManualContext,
    scheduleChangedWeekly,
    extrasChangedWeekly,
    scheduleChangedDaily,
    qrSensitiveChange,
    qrStatusRaw,

    // âœ… NEW: expenses change detection
    expensesChanged,

    // âœ… NEW after-save QR decision fields
    qrAfterSaveAction,
    qrActionBackend,
    qrSendNewNow,

    refChanged,
    lockedNow,
    shouldChangeHold,
    shouldMarkPaid
  });

  const tasks = [];

  // âœ… WEEKLY MANUAL: schedule-driven ONLY (planned: draft endpoint; processed: manualUpsertContractWeek)
  if (isWeeklyManualContext && (scheduleChangedWeekly || extrasChangedWeekly)) {
    tasks.push(async () => {
      const schedulePayload = Array.isArray(st.schedule) ? st.schedule : [];
      if (!weekIdSave) throw new Error('contract_week_id missing; cannot save weekly schedule.');

      if (isPlannedWeeklyWithoutTs) {
        if (typeof contractWeekManualDraftUpsert !== 'function') {
          throw new Error('contractWeekManualDraftUpsert is not defined (required for weekly MANUAL draft save)');
        }

        const payload = {
          planned_schedule_json: schedulePayload
        };

        if (extrasChangedWeekly) payload.additional_units_week = { ...(stagedExtrasWeek || {}) };
        if (extrasChangedWeekly) payload.additional_units_per_day = { ...(stagedExtrasPerDay || {}) };

        await contractWeekManualDraftUpsert(weekIdSave, payload);

        try {
          let contractWeek = null;
          const qs = new URLSearchParams();
          if (rowNow.contract_id) qs.set('contract_id', rowNow.contract_id);

          const we = rowNow.contract_week_ending_date || rowNow.week_ending_date || det?.contract_week?.week_ending_date || null;
          if (we) { qs.set('week_ending_from', we); qs.set('week_ending_to', we); }
          qs.set('include_plan', 'true');

          const url = API(`/api/contract-weeks?${qs.toString()}`);
          const res = await authFetch(url);
          const rows = await toList(res);

          contractWeek =
            (rows || []).find(w => String(w.id) === String(weekIdSave)) ||
            (rows || [])[0] ||
            null;

          if (contractWeek) {
            window.modalCtx.timesheetDetails = window.modalCtx.timesheetDetails || det || {};
            window.modalCtx.timesheetDetails.contract_week = contractWeek;
          }
        } catch {}

        return;
      }

      const expected = window.modalCtx?.timesheetMeta?.expected_timesheet_id || tsIdSave || null;

      const payload = {
        expected_timesheet_id: expected,
        actual_schedule_json: schedulePayload,

        // âœ… NEW backend operations:
        //   - 'INVALIDATE'        (clear token/payload/scanned + clear hashes, stay QR-enabled)
        //   - 'REVOKE_TO_MANUAL'  (convert to manual-only)
        qr_action: qrActionBackend || null,

        // Keep legacy boolean fields present but only set for manual-only.
        // (INVALIDATE is controlled solely by qr_action.)
        issue_qr:         false,
        reissue_qr:       false,
        revoke_to_manual: (qrActionBackend === 'REVOKE_TO_MANUAL'),
        revoke_qr:        (qrActionBackend === 'REVOKE_TO_MANUAL'),
        disable_qr:       false
      };

      if (extrasChangedWeekly) payload.additional_units_week = { ...(stagedExtrasWeek || {}) };
      if (extrasChangedWeekly) payload.additional_units_per_day = { ...(stagedExtrasPerDay || {}) };

      L('weekly manual upsert payload', { weekIdSave, payload });
      const result = await manualUpsertContractWeek(weekIdSave, payload);

      const newTsId = result?.timesheet_id || null;
      if (newTsId && String(newTsId) !== String(tsIdSave || '')) {
        tsIdSave = newTsId;

        if (window.modalCtx?.data) {
          window.modalCtx.data.timesheet_id = newTsId;
          window.modalCtx.data.id = newTsId;
        }
        if (window.modalCtx?.timesheetMeta) {
          window.modalCtx.timesheetMeta.expected_timesheet_id = newTsId;
          window.modalCtx.timesheetMeta.hasTs = true;
          window.modalCtx.timesheetMeta.isPlannedWeek = false;
        }
        try { await refreshTimesheetsSummaryAfterRotation(newTsId); } catch {}
      }

      if (tsIdSave) {
        try {
          const freshDetails = await fetchTimesheetDetails(tsIdSave);
          window.modalCtx.timesheetDetails = freshDetails;
        } catch {}
      }
    });
  }

  // DAILY manual schedule path (unchanged)
  if (isDailyManualContext && tsIdSave && scheduleChangedDaily) {
    tasks.push(async () => {
      const payload = {
        schedule_json: st.schedule || null,

        // âœ… NEW backend operations:
        //   - 'INVALIDATE'
        //   - 'REVOKE_TO_MANUAL'
        qr_action: qrActionBackend || null,

        // Keep legacy boolean fields but only set for manual-only.
        // (INVALIDATE is controlled solely by qr_action.)
        reissue_qr:       false,
        revoke_to_manual: (qrActionBackend === 'REVOKE_TO_MANUAL'),
        revoke_qr:        (qrActionBackend === 'REVOKE_TO_MANUAL')
      };

      payload.expected_timesheet_id = window.modalCtx?.timesheetMeta?.expected_timesheet_id || tsIdSave;

      const upsertRes = await apiPostJson(
        `/api/timesheets/${encodeURIComponent(tsIdSave)}/daily-manual-upsert`,
        payload
      );

      const newId =
        (upsertRes && (upsertRes.current_timesheet_id || upsertRes.timesheet_id)) ||
        null;

      if (newId && String(newId) !== String(tsIdSave)) {
        tsIdSave = newId;
        if (window.modalCtx?.data) {
          window.modalCtx.data.timesheet_id = newId;
          window.modalCtx.data.id = newId;
        }
        if (window.modalCtx?.timesheetMeta) window.modalCtx.timesheetMeta.expected_timesheet_id = newId;
        try { await refreshTimesheetsSummaryAfterRotation(newId); } catch {}
      }

      try {
        const freshDetails = await fetchTimesheetDetails(tsIdSave);
        window.modalCtx.timesheetDetails = freshDetails;
      } catch {}
    });
  }

  // Segments staging apply (FIXED: supports explicit clear + updates in-memory segments)
if (det.isSegmentsMode && (hasSegOverrides || hasSegTargets) && (tsIdSave || rowNow.timesheet_id)) {
  tasks.push(async () => {
    const currentDetails = window.modalCtx.timesheetDetails || det;
    const segments = Array.isArray(currentDetails.segments) ? currentDetails.segments : [];
    if (!segments.length) return;

    const updates = [];
    const overrides = window.modalCtx.timesheetState.segmentOverrides || {};
    const targets   = window.modalCtx.timesheetState.segmentInvoiceTargets || {};

    const normTarget = (v) => {
      if (v == null) return null;
      const s = String(v || '').trim();
      return s ? s : null;
    };

    for (const seg of segments) {
      if (!seg || typeof seg !== 'object') continue;
      const sid = String(seg.segment_id || '').trim();
      if (!sid) continue;

      const o = overrides[sid] || {};
      const hasOverride = Object.prototype.hasOwnProperty.call(o, 'exclude_from_pay');
      const exclude = hasOverride ? !!o.exclude_from_pay : !!seg.exclude_from_pay;

      const originalTarget = normTarget(seg.invoice_target_week_start);

      const hasStagedTarget = Object.prototype.hasOwnProperty.call(targets, sid);
      const stagedTargetRaw = hasStagedTarget ? targets[sid] : undefined;

      // âœ… stagedTarget may be:
      // - 'YYYY-MM-DD'  (delay)
      // - '2099-01-05'  (pause)
      // - null          (explicit clear)
      const desiredTarget = hasStagedTarget ? normTarget(stagedTargetRaw) : originalTarget;

      const update = { segment_id: sid };
      let changed = false;

      // exclude_from_pay (always sent; changed flag only when differs)
      if (exclude !== !!seg.exclude_from_pay) {
        update.exclude_from_pay = exclude;
        changed = true;
      } else {
        update.exclude_from_pay = exclude;
      }

      // âœ… invoice_target_week_start: include whenever staged is present AND differs (including clear-to-null)
      if (hasStagedTarget) {
        const differs =
          (desiredTarget == null && originalTarget != null) ||
          (desiredTarget != null && originalTarget == null) ||
          (desiredTarget != null && originalTarget != null && String(desiredTarget) !== String(originalTarget));

        if (differs) {
          update.invoice_target_week_start = desiredTarget; // may be null
          changed = true;
        }
      }

      if (changed) updates.push(update);
    }

    if (!updates.length) return;

    const res = await apiPatchJson(
      `/api/tsfin/${encodeURIComponent(tsIdSave || rowNow.timesheet_id)}/segments`,
      {
        expected_timesheet_id: (window.modalCtx?.timesheetMeta?.expected_timesheet_id || tsIdSave),
        segments: updates
      }
    );

    // âœ… Update in-memory segments so the Lines tab reflects the save immediately (no close/reopen needed)
    try {
      const detNow = window.modalCtx.timesheetDetails || currentDetails;
      const segsNow = Array.isArray(detNow.segments) ? detNow.segments : [];
      for (const u of updates) {
        const sid = String(u.segment_id || '').trim();
        if (!sid) continue;
        const s = segsNow.find(x => x && String(x.segment_id || '').trim() === sid) || null;
        if (!s) continue;

        if (Object.prototype.hasOwnProperty.call(u, 'exclude_from_pay')) {
          s.exclude_from_pay = !!u.exclude_from_pay;
        }
        if (Object.prototype.hasOwnProperty.call(u, 'invoice_target_week_start')) {
          s.invoice_target_week_start = u.invoice_target_week_start; // may be null
        }
      }
    } catch {}
  });
}


  // Reference update (kept as-is; separate from per-shift refs)
  if (refChanged && tsIdSave) {
    tasks.push(async () => {
      const expected = window.modalCtx?.timesheetMeta?.expected_timesheet_id || tsIdSave;
      await updateTimesheetReference(tsIdSave, stagedRef, expected);
    });
  }

  // Pay-hold
  if (shouldChangeHold && tsIdSave) {
    tasks.push(async () => {
      const expected = window.modalCtx?.timesheetMeta?.expected_timesheet_id || tsIdSave;
      const onHold = !!payHoldDesired;
      const reason = onHold ? payHoldReason : '';
      await toggleTimesheetPayHold(tsIdSave, onHold, reason, expected);
    });
  }

  // Mark paid
  if (shouldMarkPaid && tsIdSave) {
    tasks.push(async () => {
      const expected = window.modalCtx?.timesheetMeta?.expected_timesheet_id || tsIdSave;
      await markTimesheetPaid(tsIdSave, expected);
    });
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // âœ… Expenses save (NEW)
  // - ensures expenses-only edits are not a no-op
  // - triggers backend enforcement (incl. â€œno evidenceâ€ rule) because a real request is made
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (expensesChanged && tsIdSave) {
    tasks.push(async () => {
      const expected = window.modalCtx?.timesheetMeta?.expected_timesheet_id || tsIdSave;

      const d = (window.modalCtx?.timesheetState?.expensesDraft && typeof window.modalCtx.timesheetState.expensesDraft === 'object')
        ? window.modalCtx.timesheetState.expensesDraft
        : {};

      // Pull current TSFIN rates for mileage so backend gets consistent values (units * rate)
      const detNow = window.modalCtx?.timesheetDetails || det || {};
      const finNow = detNow?.tsfin || tsfinLocal || {};

      const mileageUnits = Number(d.mileage_units ?? 0) || 0;
      const mileagePayRate = Number(finNow?.mileage_pay_rate ?? 0) || 0;
      const mileageChargeRate = Number(finNow?.mileage_charge_rate ?? 0) || 0;

      const mileagePayEx = round2(mileageUnits * mileagePayRate);
      const mileageChargeEx = round2(mileageUnits * mileageChargeRate);

      // 1) Patch expense category amounts (TSFIN canonical columns)
      const payloadExpenses = {
        expected_timesheet_id: expected,
        expenses: {
          travel_pay_ex_vat: round2(d.travel_pay ?? 0),
          travel_charge_ex_vat: round2(d.travel_charge ?? 0),

          accommodation_pay_ex_vat: round2(d.accommodation_pay ?? 0),
          accommodation_charge_ex_vat: round2(d.accommodation_charge ?? 0),

          other_pay_ex_vat: round2(d.other_pay ?? 0),
          other_charge_ex_vat: round2(d.other_charge ?? 0),

          // notes/meta only
          description: String(d.note ?? '').trim()
        }
      };

      // 2) Patch mileage (units + derived amounts + rates)
      const payloadMileage = {
        expected_timesheet_id: expected,
        mileage: {
          mileage_units: mileageUnits,
          pay_rate: mileagePayRate,
          charge_rate: mileageChargeRate,
          pay_ex_vat: mileagePayEx,
          charge_ex_vat: mileageChargeEx
        }
      };

      // Helper: handle evidence-required errors in a user-friendly way
      const handleEvidenceRequired = (err) => {
        const j = (err && err.json && typeof err.json === 'object') ? err.json : null;
        if (!(err?.status === 400 && j && j.error === 'EVIDENCE_REQUIRED')) return false;

        const missing = Array.isArray(j.missing) ? j.missing : [];
        const lines = missing.map(m => {
          const cat = String(m?.category || '').trim();
          const kind = String(m?.required_kind || '').trim();
          return `- ${cat || 'Expense'}: upload evidence kind ${kind || 'REQUIRED'}`;
        });

        alert(
          'Evidence is required before you can save these expenses:\n\n' +
          (lines.length ? lines.join('\n') : '- Upload the required evidence in the Evidence tab.') +
          '\n\nGo to the Evidence tab and upload the correct kind(s), then try Save again.'
        );

        try {
          const fr = (typeof window.__getModalFrame === 'function') ? window.__getModalFrame() : null;
          if (fr && fr.entity === 'timesheets' && typeof fr.setTab === 'function') {
            Promise.resolve().then(() => { try { fr.setTab('evidence'); } catch {} });
          }
        } catch {}

        return true;
      };

      // âœ… Use the TSFIN patch endpoints (canonical)
      //    - /api/tsfin/:timesheet_id/expenses
      //    - /api/tsfin/:timesheet_id/mileage
      try {
        const res1 = await apiPatchJson(
          `/api/tsfin/${encodeURIComponent(tsIdSave)}/expenses`,
          payloadExpenses
        );

        const moved1 =
          (res1 && (res1.current_timesheet_id || res1.timesheet_id))
            ? String(res1.current_timesheet_id || res1.timesheet_id)
            : null;

        if (moved1 && String(moved1) !== String(tsIdSave)) {
          tsIdSave = moved1;
          if (window.modalCtx?.data) {
            window.modalCtx.data.timesheet_id = moved1;
            window.modalCtx.data.id = moved1;
          }
          if (window.modalCtx?.timesheetMeta) window.modalCtx.timesheetMeta.expected_timesheet_id = moved1;
          try { await refreshTimesheetsSummaryAfterRotation(moved1); } catch {}
        }
      } catch (err) {
        if (handleEvidenceRequired(err)) { try { err.__handled = true; } catch {} }
        throw err;
      }

      try {
        const res2 = await apiPatchJson(
          `/api/tsfin/${encodeURIComponent(tsIdSave)}/mileage`,
          payloadMileage
        );

        const moved2 =
          (res2 && (res2.current_timesheet_id || res2.timesheet_id))
            ? String(res2.current_timesheet_id || res2.timesheet_id)
            : null;

        if (moved2 && String(moved2) !== String(tsIdSave)) {
          tsIdSave = moved2;
          if (window.modalCtx?.data) {
            window.modalCtx.data.timesheet_id = moved2;
            window.modalCtx.data.id = moved2;
          }
          if (window.modalCtx?.timesheetMeta) window.modalCtx.timesheetMeta.expected_timesheet_id = moved2;
          try { await refreshTimesheetsSummaryAfterRotation(moved2); } catch {}
        }
      } catch (err) {
        if (handleEvidenceRequired(err)) { try { err.__handled = true; } catch {} }
        throw err;
      }

      // Refresh details so totals + tsfin reflect saved expenses immediately
      try {
        const idNow = (window.modalCtx?.data?.timesheet_id || tsIdSave || null);
        if (idNow) {
          const fresh = await fetchTimesheetDetails(idNow);
          window.modalCtx.timesheetDetails = fresh;
        }
      } catch {}

      // Advance baseline so subsequent saves donâ€™t re-send unchanged expenses
      try {
        window.modalCtx.timesheetState.expensesBaseline =
          JSON.parse(JSON.stringify(normExpenses(window.modalCtx.timesheetState.expensesDraft)));
      } catch {}
    });
  }

  // âœ… If user chose "Save changes and send a new QR timesheet now":
  // - we already sent qr_action='INVALIDATE' in the save payload
  // - once the save completes (and any rotation/adoption is done), send the QR now.
  if (qrSendNewNow && tsIdSave && !lockedNow) {
    tasks.push(async () => {
      const idNow = (window.modalCtx?.data?.timesheet_id || tsIdSave || null);
      if (!idNow) throw new Error('Timesheet id missing; cannot send QR.');

      // This endpoint will issue a new token, generate the PDF, queue the email,
      // and set qr_last_sent_* fields (backend enforces resend rules).
      await resendQrTimesheetEmail(idNow);

      // Refresh details so Overview buttons/stage update immediately after the send
      try {
        const id2 = (window.modalCtx?.data?.timesheet_id || idNow);
        if (id2) {
          const fresh = await fetchTimesheetDetails(id2);
          window.modalCtx.timesheetDetails = fresh;
        }
      } catch {}
    });
  }

  if (!tasks.length) {
    L('no staged changes to apply; no-op');
    GE();
    return { ok: true, saved: rowNow };
  }

  // Run tasks with guarded-write conflict handling (409 TIMESHEET_MOVED)
  for (let i = 0; i < tasks.length; i++) {
    try {
      await tasks[i]();
    } catch (err) {

      // âœ… Evidence-required errors are already shown to the user; do not show generic failure
      if (err && err.__handled === true) {
        GE();
        return { ok: false };
      }

      try {
        if (typeof tsHandleMoved409Modal === 'function') {
          const handled = await tsHandleMoved409Modal(err, {
            tabKey: (typeof window.__getModalFrame === 'function' ? (window.__getModalFrame()?.currentTabKey || 'overview') : 'overview'),
            label: 'timesheet-save',
            toast: 'This timesheet changed while you were editing; review and try again.'
          });
          if (handled) {
            GE();
            return { ok: false, reloaded: true };
          }
        }
      } catch {}

      let moved = (err && err.json && typeof err.json === 'object') ? err.json : null;
      if (!moved) {
        try {
          const msg = String(err?.message || '');
          if (msg && msg.trim().startsWith('{')) moved = JSON.parse(msg);
        } catch {}
      }

      if ((err?.status === 409) && moved && moved.error === 'TIMESHEET_MOVED' && moved.current_timesheet_id) {
        const newId = moved.current_timesheet_id;
        tsIdSave = newId;

        if (window.modalCtx?.data) {
          window.modalCtx.data.timesheet_id = newId;
          window.modalCtx.data.id = newId;
        }

        let freshDetails = null;
        try {
          freshDetails = await fetchTimesheetDetails(newId);
          if (window.modalCtx) window.modalCtx.timesheetDetails = freshDetails;
        } catch {}

        try {
          const tsNew   = freshDetails?.timesheet || {};
          const finNew  = freshDetails?.tsfin || {};
          const scopeU  = String(freshDetails?.sheet_scope || tsNew.sheet_scope || '').toUpperCase();
          const subU    = String(tsNew.submission_mode || '').toUpperCase();
          const basisU  = String(finNew.basis || '').toUpperCase();
          const qrU     = String(freshDetails?.qr_status || tsNew.qr_status || '').toUpperCase();
          const paid    = !!finNew.paid_at_utc;
          const invo    = !!finNew.locked_by_invoice_id;

          window.modalCtx.timesheetMeta = {
            ...(window.modalCtx.timesheetMeta || {}),
            hasTs: true,
            isPlannedWeek: false,
            sheetScope: scopeU,
            subMode: subU,
            basis: basisU,
            qrStatus: qrU,
            isPaid: paid,
            isInvoiced: invo,
            isLocked: (paid || invo),
            contract_week_id: freshDetails?.contract_week_id || window.modalCtx?.data?.contract_week_id || null,
            expected_timesheet_id: newId,
            hasElectronicOriginal: !!(freshDetails?.action_flags && freshDetails.action_flags.can_revert_to_electronic)
          };
        } catch {}

        try { await refreshTimesheetsSummaryAfterRotation(newId); } catch {}

        try {
          const fr = (typeof window.__getModalFrame === 'function') ? window.__getModalFrame() : null;
          if (fr && fr.entity === 'timesheets') {
            fr._suppressDirty = true;
            await fr.setTab(fr.currentTabKey || 'overview');
            fr._suppressDirty = false;
            fr._updateButtons && fr._updateButtons();
          }
        } catch {}

        alert('This timesheet changed while you were editing. Reloaded to the latest version. Please review and save again.');
        GE();
        return { ok: false, reloaded: true };
      }

      L('task failed', { index: i, error: err });
      alert(err?.message || 'Failed to save timesheet changes. No changes were fully applied.');
      GE();
      return { ok: false };
    }
  }

  // Post-save row update (same as before)
  const newDetails = window.modalCtx.timesheetDetails || det;
  const newTsfin   = newDetails.tsfin || {};
  const newTs      = newDetails.timesheet || {};
  const finalTsId  = newTs.timesheet_id || tsIdSave || rowNow.timesheet_id;

  const updatedRow = {
    ...(window.modalCtx.data || rowNow),
    timesheet_id:         finalTsId || null,
    total_pay_ex_vat:     newTsfin.total_pay_ex_vat     ?? rowNow.total_pay_ex_vat,
    total_charge_ex_vat:  newTsfin.total_charge_ex_vat  ?? rowNow.total_charge_ex_vat,
    margin_ex_vat:        newTsfin.margin_ex_vat        ?? rowNow.margin_ex_vat,
    pay_on_hold:          newTsfin.pay_on_hold          ?? rowNow.pay_on_hold,
    paid_at_utc:          newTsfin.paid_at_utc          ?? rowNow.paid_at_utc,
    locked_by_invoice_id: newTsfin.locked_by_invoice_id ?? rowNow.locked_by_invoice_id,
    reference_number:     newTs.reference_number        ?? rowNow.reference_number,
    id:                   finalTsId || rowNow.id
  };

  window.modalCtx.data = updatedRow;

  if (window.modalCtx.timesheetState) {
    window.modalCtx.timesheetState.segmentOverrides      = {};
    window.modalCtx.timesheetState.segmentInvoiceTargets = {};
    window.modalCtx.timesheetState.reference             = updatedRow.reference_number;
    window.modalCtx.timesheetState.payHoldDesired        = null;
    window.modalCtx.timesheetState.payHoldReason         = '';
    window.modalCtx.timesheetState.markPaid              = false;
  }

  try {
    const idToRefresh = finalTsId || tsIdSave || null;
    if (idToRefresh) await refreshTimesheetsSummaryAfterRotation(idToRefresh);
  } catch {}

  try {
    if (finalTsId) {
      window.__pendingFocus = {
        section: 'timesheets',
        ids: [String(finalTsId)],
        primaryIds: [String(finalTsId)]
      };
    }
  } catch {}

  L('SAVE OK, updatedRow', { id: updatedRow.id });
  GE();
  return { ok: true, saved: updatedRow };
};



  
    const title = hasTs
      ? `Timesheet ${String(tsId).slice(0, 8)}â€¦`
      : `Weekly timesheet (planned) ${String(weekId).slice(0, 8)}â€¦`;

 const hasRelatedId = !!(tsId || weekId);

showModal(
  title,
  tabDefs,
  renderTab,
  onSaveTimesheet,
  hasRelatedId,
  undefined,
  { kind: 'timesheets' }
);



    GE();
  } catch (err) {
    if (((typeof window.__LOG_MODAL === 'boolean') ? window.__LOG_MODAL : false)) {
      console.error('[TS][OPEN] EXCEPTION', err);
    }
    alert(err?.message || 'Failed to open timesheet.');
    GE();
  }
}
async function refreshTimesheetsSummaryAfterRotation(newId) {
  try {
    window.__pendingFocus = {
      section: 'timesheets',
      ids: [String(newId)],
      primaryIds: [String(newId)]
    };
  } catch {}

  try {
    if (typeof renderAll === 'function') {
      await renderAll();
    }
  } catch {}

  // Best-effort: if a timesheet modal is open, keep its header/actions in sync
  try {
    const fr = (typeof window.__getModalFrame === 'function') ? window.__getModalFrame() : null;
    if (fr && fr.entity === 'timesheets') {
      fr._updateButtons && fr._updateButtons();
    }
  } catch {}
}




async function fetchTimesheetAudit(timesheetId) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][AUDIT][FETCH]');
  GC('fetchTimesheetAudit');

  try {
    if (!timesheetId) {
      throw new Error('fetchTimesheetAudit: timesheetId is required');
    }

    const encId = encodeURIComponent(String(timesheetId));
    const url = API(`/api/timesheets/${encId}/audit-feed`);

    L('REQUEST', { url, timesheetId: String(timesheetId) });

    const res = await authFetch(url, { method: 'GET' });

    // Prefer JSON parse, but fall back to text (so we can show useful errors)
    const ct = String(res.headers?.get?.('content-type') || '');
    let payload = null;
    let text = '';

    try {
      if (ct.includes('application/json')) {
        payload = await res.json();
      } else {
        text = await res.text().catch(() => '');
        payload = text ? JSON.parse(text) : null;
      }
    } catch {
      // If JSON parsing fails, keep raw text for errors
      if (!text) text = await res.text().catch(() => '');
      payload = null;
    }

    if (!res.ok) {
      // Try to extract a meaningful error message
      const msg =
        (payload && typeof payload === 'object' && (payload.message || payload.error)) ||
        (typeof payload === 'string' && payload) ||
        (text && text) ||
        `Failed to fetch audit feed (HTTP ${res.status})`;

      L('server error', { status: res.status, msg, bodyPreview: String(text || msg).slice(0, 500) });
      throw new Error(String(msg));
    }

    // Accept either { items: [...] } or a raw array response
    const items = Array.isArray(payload?.items)
      ? payload.items
      : (Array.isArray(payload) ? payload : []);

    L('RESULT', { count: items.length });

    // Store in modal cache (used by audit tab builder)
    try {
      const mc = window.modalCtx || {};
      mc.timesheetAuditCache ||= {};
      mc.timesheetAuditCache[String(timesheetId)] = items;
    } catch {}

    return items;
  } catch (err) {
    L('error', { err: err?.message || String(err) });
    throw err;
  } finally {
    GE();
  }
}

function openQrAfterSaveModal({ context = {} } = {}) {
  // Return:
  //   { cancelled: true }
  //   OR
  //   { cancelled: false, action: 'SEND_NEW_NOW' | 'SAVE_ONLY_INVALIDATE' | 'CONVERT_TO_MANUAL_ONLY' }
  //
  // IMPORTANT: no "SCENARIO_*" user-facing messaging.
  // This modal is used only when QR-sensitive content changed and we must invalidate any old QR.

  const allowedActions = new Set([
    'SEND_NEW_NOW',
    'SAVE_ONLY_INVALIDATE',
    'CONVERT_TO_MANUAL_ONLY'
  ]);

  // Minimal esc helper (use your existing escapeHtml if present)
  const enc = (typeof escapeHtml === 'function')
    ? escapeHtml
    : (s) => String(s ?? '');

  const hint = context?.timesheet_id
    ? `Timesheet: ${String(context.timesheet_id).slice(0, 8)}â€¦`
    : '';

  // Card renderer with neat radio alignment
  // - fixed-width radio col
  // - fixed-width icon col
  // - content col
  const actionCard = (action, checked) => {
    const a = String(action || '').toUpperCase();
    if (!allowedActions.has(a)) return '';

    const rowStyle =
      `display:grid;grid-template-columns:18px 22px 1fr;column-gap:10px;` +
      `align-items:start;`;

    const radioStyle = `margin-top:3px;`;
    const iconStyle  = `font-size:16px;line-height:1.1;margin-top:1px;`;
    const titleStyle = `font-weight:700;`;
    const descStyle  = `color:#aaa;display:block;margin-top:2px;`;

    if (a === 'SEND_NEW_NOW') {
      return `
        <label class="mini" style="${rowStyle}">
          <span><input type="radio" name="qr_after_choice" value="SEND_NEW_NOW" ${checked ? 'checked' : ''} style="${radioStyle}"/></span>
          <span style="${iconStyle}">ðŸ“©</span>
          <span>
            <span style="${titleStyle}">Save changes and send a new QR timesheet now</span><br/>
            <span style="${descStyle}">This will invalidate any old QR and email a new QR timesheet with the current hours.</span>
          </span>
        </label>
      `;
    }

    if (a === 'SAVE_ONLY_INVALIDATE') {
      return `
        <label class="mini" style="${rowStyle}">
          <span><input type="radio" name="qr_after_choice" value="SAVE_ONLY_INVALIDATE" ${checked ? 'checked' : ''} style="${radioStyle}"/></span>
          <span style="${iconStyle}">ðŸ’¾</span>
          <span>
            <span style="${titleStyle}">Save changes but donâ€™t send yet</span><br/>
            <span style="${descStyle}">This will invalidate any old QR. You can send the new QR from the Overview tab afterwards.</span>
          </span>
        </label>
      `;
    }

    if (a === 'CONVERT_TO_MANUAL_ONLY') {
      return `
        <label class="mini" style="${rowStyle}">
          <span><input type="radio" name="qr_after_choice" value="CONVERT_TO_MANUAL_ONLY" ${checked ? 'checked' : ''} style="${radioStyle}"/></span>
          <span style="${iconStyle}">ðŸ›‘</span>
          <span>
            <span style="${titleStyle}">Convert to Manual-only so you can enter hours on behalf of candidate</span><br/>
            <span style="${descStyle}">This disables candidate QR/electronic submission for this timesheet. Admin will manage evidence manually.</span>
          </span>
        </label>
      `;
    }

    return '';
  };

  return new Promise((resolve) => {
    let done = false;
    const finish = (v) => { if (done) return; done = true; resolve(v); };

    const renderTab = () => {
      // No default selection: force explicit choice
      const cards = [
        actionCard('SEND_NEW_NOW', false),
        actionCard('SAVE_ONLY_INVALIDATE', false),
        actionCard('CONVERT_TO_MANUAL_ONLY', false)
      ].join('');

      return `
        <div id="qrAfterSaveRoot" class="form">
          <div class="card">
            <div class="row">
              <label>QR timesheet</label>
              <div class="controls">
                <div class="mini" style="color:#bbb;margin-bottom:8px;">
                  ${enc(hint)}
                </div>

                <div class="mini" style="margin-bottom:10px;">
                  <strong>QR content has changed</strong><br/>
                  Choose what to do after saving these changes:
                </div>

                <div style="display:flex;flex-direction:column;gap:10px;">
                  ${cards}
                </div>

                <div class="mini" style="margin-top:12px;color:#aaa;">
                  Cancel will stop the save.
                </div>
              </div>
            </div>
          </div>
        </div>
      `;
    };

    const onSave = async () => {
      const fr = (typeof window.__getModalFrame === 'function') ? window.__getModalFrame() : null;
      const choice = fr && fr._qrChoice ? String(fr._qrChoice).toUpperCase() : null;

      if (!choice || !allowedActions.has(choice)) {
        alert('Please select an option.');
        return { ok: false };
      }

      finish({ cancelled: false, action: choice });
      return { ok: true };
    };

    showModal(
      'QR timesheet after-save action',
      [{ key: 'main', label: 'Decision' }],
      renderTab,
      onSave,
      false,
      undefined,
      {
        kind: 'qr-decision',
        noParentGate: true,
        forceEdit: true,
        onDismiss: () => finish({ cancelled: true })
      }
    );

    setTimeout(() => {
      const root = document.getElementById('qrAfterSaveRoot');
      if (!root) return;

      const fr = (typeof window.__getModalFrame === 'function') ? window.__getModalFrame() : null;
      if (fr) fr._qrChoice = null;

      root.addEventListener('change', (ev) => {
        const t = ev && ev.target;
        const inp = (t && typeof t.closest === 'function') ? t.closest('input[name="qr_after_choice"]') : null;
        if (!inp) return;

        const top = (typeof window.__getModalFrame === 'function') ? window.__getModalFrame() : null;
        if (!top) return;

        top._qrChoice = String(inp.value || '').toUpperCase();
        top._updateButtons && top._updateButtons();
      });

      if (fr && typeof fr._updateButtons === 'function') fr._updateButtons();
    }, 0);
  });
}

function renderTimesheetRelatedTab(ctx) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][RELATED-TAB]');
  const { row, related } = normaliseTimesheetCtx(ctx);

  GC('render');
  L('snapshot', {
    tsId: row.timesheet_id,
    counts: related.counts
  });
  GE();

  const candidate = related.candidate;
  const client    = related.client;

  // âœ… NEW: invoices list (many-to-many)
  const invoices  = Array.isArray(related.invoices) ? related.invoices : [];
  // back-compat: if only old shape present, fall back
  const invoiceFallback = related.invoice ? [related.invoice] : [];
  const invoicesEff = invoices.length ? invoices : invoiceFallback;

  const umbrella  = related.umbrella;
  const contract  = related.contract;
  const series    = Array.isArray(related.series) ? related.series : [];

  const renderBlock = (title, bodyHtml) => `
    <div class="card" style="margin-top:10px;">
      <div class="row">
        <label>${title}</label>
        <div class="controls">
          ${bodyHtml}
        </div>
      </div>
    </div>
  `;

  const candidateHtml = candidate
    ? `
      <div>
        <div>${candidate.display_name || '(no name)'}</div>
        <div class="mini">${candidate.email || ''}</div>
        <button type="button" data-ts-related="candidate" data-id="${candidate.id}">Open candidate</button>
      </div>
    `
    : '<span class="mini">No candidate linked.</span>';

  const clientHtml = client
    ? `
      <div>
        <div>${client.name || '(no name)'}</div>
        <div class="mini">${client.cli_ref ? 'Client ref: ' + client.cli_ref : ''}</div>
        <button type="button" data-ts-related="client" data-id="${client.id}">Open client</button>
      </div>
    `
    : '<span class="mini">No client linked.</span>';

  const contractHtml = contract
    ? `
      <div>
        <div>${contract.role || ''}${contract.band ? ' (Band ' + contract.band + ')' : ''}</div>
        <div class="mini">
          ${contract.display_site || ''}<br/>
          ${contract.start_date || ''} â†’ ${contract.end_date || ''}
        </div>
        <button type="button" data-ts-related="contract" data-id="${contract.id}">Open contract</button>
      </div>
    `
    : '<span class="mini">No contract linked for this timesheet.</span>';

  const umbrellaHtml = umbrella
    ? `
      <div>
        <div>${umbrella.name || '(no name)'}</div>
        <button type="button" data-ts-related="umbrella" data-id="${umbrella.id}">Open umbrella</button>
      </div>
    `
    : '<span class="mini">No umbrella linked (PAYE or no umbrella).</span>';

  const invoiceListHtml = (() => {
    if (!invoicesEff.length) {
      return '<span class="mini">No invoice currently linked.</span>';
    }

    const header = `
      <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;">
        <div><b>Invoices (${invoicesEff.length})</b></div>
        <button type="button"
          data-ts-related="invoices-summary"
          data-source-entity="timesheet"
          data-source-id="${row.timesheet_id || ''}"
          data-relation-type="invoice">
          View all in Invoice Summary
        </button>
      </div>
    `;

    const rows = invoicesEff.map(inv => {
      const invoiceId =
        (inv && (inv.invoice_id != null)) ? String(inv.invoice_id)
        : (inv && (inv.id != null)) ? String(inv.id)
        : '';

      const invNo = (inv && inv.invoice_no != null) ? String(inv.invoice_no) : '';
      const status = (inv && inv.status != null) ? String(inv.status) : 'UNKNOWN';
      const issued = (inv && inv.issued_at_utc != null) ? String(inv.issued_at_utc) : 'â€”';
      const total  = (inv && inv.total_inc_vat != null) ? String(inv.total_inc_vat) : 'â€”';

      return `
        <div class="border rounded p-2 mb-2">
          <div style="display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;">
            <div>
              <div><b>Invoice ${invNo || invoiceId}</b></div>
              <div class="mini">Status: ${status} Â· Issued: ${issued} Â· Total inc VAT: ${total}</div>
            </div>
            <div>
              <button type="button" data-ts-related="invoice" data-id="${invoiceId}">Open invoice</button>
            </div>
          </div>
        </div>
      `;
    }).join('');

    return `${header}<div style="margin-top:8px;">${rows}</div>`;
  })();

  const seriesHtml = series.length
    ? `
      <table class="grid mini">
        <thead>
          <tr>
            <th>TS ID</th>
            <th>Seq</th>
            <th>Adj?</th>
            <th>Status</th>
            <th>Basis</th>
            <th>Hours</th>
            <th>Pay ex VAT</th>
            <th></th>
          </tr>
        </thead>
        <tbody>
          ${series.map(s => `
            <tr data-timesheet-id="${s.timesheet_id}">
              <td>${s.timesheet_id.slice(0, 8)}â€¦${s.is_current ? ' <span class="mini">(current)</span>' : ''}</td>
              <td>${s.additional_seq == null ? '0' : s.additional_seq}</td>
              <td>${s.is_adjustment ? 'Yes' : 'No'}</td>
              <td>${s.processing_status || 'â€”'}</td>
              <td>${s.basis || 'â€”'}</td>
              <td>${s.total_hours != null ? s.total_hours : 'â€”'}</td>
              <td>${s.total_pay_ex_vat != null ? s.total_pay_ex_vat : 'â€”'}</td>
              <td>
                <button type="button"
                  data-ts-related="series-timesheet"
                  data-id="${s.timesheet_id}">
                  Open
                </button>
              </td>
            </tr>
          `).join('')}
        </tbody>
      </table>
    `
    : '<span class="mini">No other timesheets in this contract/week series.</span>';

  return `
    <div class="tabc">
      ${renderBlock('Candidate', candidateHtml)}
      ${renderBlock('Client', clientHtml)}
      ${renderBlock('Contract', contractHtml)}
      ${renderBlock('Invoices', invoiceListHtml)}
      ${renderBlock('Umbrella', umbrellaHtml)}
      ${renderBlock('Series (base + adjustments)', seriesHtml)}
    </div>
  `;
}

function renderTimesheetEvidenceTab(ctx) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][EVIDENCE]');
  const { row, details, state } = normaliseTimesheetCtx(ctx);
  GC('render');

  const ts   = details.timesheet || {};
  const tsId = row.timesheet_id || ts.timesheet_id || '';

  const evList = Array.isArray(state.evidence) ? state.evidence : [];

  L('renderEvidenceTab', { tsId, evidenceCount: evList.length });
  GE();

  const getUploadedDt = (ev) => {
    return ev?.uploaded_at_utc || ev?.uploaded_at || ev?.created_at || null;
  };

  // Format: "Mon 1 December 2025" (Europe/London), no time
  const formatEvidenceDate = (iso) => {
    if (!iso) return 'â€”';
    const d = new Date(iso);
    if (Number.isNaN(d.getTime())) return String(iso);

    try {
      const s = d.toLocaleDateString('en-GB', {
        timeZone: 'Europe/London',
        weekday: 'short',
        day: 'numeric',
        month: 'long',
        year: 'numeric'
      });
      return String(s).replace(',', '').replace(/\s+/g, ' ').trim();
    } catch {
      return d.toISOString().slice(0, 10);
    }
  };

  // Format: "23:01hrs" (Europe/London)
  const formatEvidenceTime = (iso) => {
    if (!iso) return 'â€”';
    const d = new Date(iso);
    if (Number.isNaN(d.getTime())) return 'â€”';

    try {
      const t = d.toLocaleTimeString('en-GB', {
        timeZone: 'Europe/London',
        hour: '2-digit',
        minute: '2-digit',
        hour12: false
      });
      const clean = String(t).replace(/\s+/g, '').trim();
      return clean ? `${clean}hrs` : 'â€”';
    } catch {
      const hhmm = d.toISOString().slice(11, 16);
      return hhmm ? `${hhmm}hrs` : 'â€”';
    }
  };

  const isDeletable = (ev) => {
    if (ev && typeof ev.can_delete === 'boolean') return !!ev.can_delete;
    if (ev && typeof ev.system === 'boolean') return !ev.system;
    return false;
  };

 // âœ… Evidence "Type" â€” DO NOT fall back to display_name (that's Filename)
const typeLabel = (ev) => {
  const k = String(ev?.kind || '').trim().toUpperCase();
  if (!k) return 'Unknown';

  const map = {
    TIMESHEET: 'Timesheet',
    MILEAGE: 'Mileage',
    TRAVEL: 'Travel',
    ACCOMMODATION: 'Accommodation',
    OTHER: 'Other',
    QR: 'QR',
    PDF: 'PDF',
    ELECTRONIC_SIGNATURES: 'Electronic signatures',
    HEALTHROSTER: 'HealthRoster',
    NHSP: 'NHSP'
  };

  return map[k] || (k.charAt(0) + k.slice(1).toLowerCase());
};


  // âœ… NEW: Filename column (prefer explicit filename; fall back to display_name as legacy)
  const filenameLabel = (ev) => {
    const fn = String(ev?.filename || '').trim();
    if (fn) return fn;

    // Legacy fallback: many existing rows used display_name as filename
    const dn = String(ev?.display_name || '').trim();
    if (dn) return dn;

    // Last resort: storage_key basename
    const sk = String(ev?.storage_key || ev?.download_storage_key || '').trim();
    if (sk) {
      const parts = sk.split('/');
      const base = parts[parts.length - 1] || '';
      return base || 'â€”';
    }
    return 'â€”';
  };

  // "Uploaded by" comes from backend enrichment (preferred), otherwise falls back
  const uploadedByLabel = (ev) => {
    const isSystem = !!ev?.system;
    if (isSystem) return 'System';

    const by =
      (ev && typeof ev.uploaded_by_display === 'string' && ev.uploaded_by_display.trim())
        ? ev.uploaded_by_display.trim()
        : (ev && typeof ev.created_by_display === 'string' && ev.created_by_display.trim())
          ? ev.created_by_display.trim()
          : null;

    return by || 'â€”';
  };

  const hasDownloadableKey = (ev) => {
    const k1 = (ev?.download_storage_key != null) ? String(ev.download_storage_key).trim() : '';
    const k2 = (ev?.storage_key != null) ? String(ev.storage_key).trim() : '';
    return !!((k1 || k2) && (k1 || k2).replace(/^\/+/, '').trim());
  };

  const rowsHtml = evList.length
    ? evList.map(ev => {
        const id = (ev && ev.id != null) ? String(ev.id) : '';
        const system = !!ev?.system;
        const canDelete = isDeletable(ev);

        const dt = getUploadedDt(ev);
        const uploadedDate = escapeHtml(formatEvidenceDate(dt));
        const uploadedTime = escapeHtml(formatEvidenceTime(dt));

        const fileName = escapeHtml(filenameLabel(ev));
        const type = escapeHtml(typeLabel(ev));
        const uploadedBy = escapeHtml(uploadedByLabel(ev));

        const viewBtn = `
          <button type="button"
                  class="btn mini subtle"
                  style="background:transparent;border:1px solid rgba(255,255,255,.18);"
                  data-evidence-view="${escapeHtml(id)}">
            View
          </button>
        `;

        // âœ… Download button (imports + PDFs) â€” calls the global helper installed by refreshTimesheetEvidenceIntoModalState
        const dlBtn = hasDownloadableKey(ev)
          ? `
            <button type="button"
                    class="btn mini subtle"
                    style="background:transparent;border:1px solid rgba(255,255,255,.18);"
                    onclick="window.__tsEvidenceDownload && window.__tsEvidenceDownload('${escapeHtml(id)}')">
              Download
            </button>
          `
          : '';

        const delBtn = canDelete
          ? `
            <button type="button"
                    class="btn mini subtle danger"
                    style="background:transparent;border:1px solid rgba(255,80,80,.35);"
                    data-evidence-remove="${escapeHtml(id)}">
              Delete
            </button>
          `
          : '';

        return `
          <tr data-evidence-id="${escapeHtml(id)}"
              class="${system ? 'system-evidence' : ''}">
            <td>${fileName}</td>
            <td>${type}</td>
            <td>${uploadedDate}</td>
            <td>${uploadedTime}</td>
            <td>${uploadedBy}</td>
            <td style="text-align:right; white-space:nowrap;">
              ${viewBtn}
              ${dlBtn}
              ${delBtn}
            </td>
          </tr>
        `;
      }).join('')
    : `
      <tr>
        <td colspan="6" class="mini" style="opacity:.85;">
          No evidence uploaded yet. Drag a file anywhere inside this tab to upload.
        </td>
      </tr>
    `;

  const tableHtml = `
    <div class="scrollable-evidence" style="max-height:380px; overflow-y:auto;">
      <table class="ts-evidence-table" style="width:100%; border-collapse:collapse;">
        <thead>
          <tr>
            <th style="text-align:left;">Filename</th>
            <th style="text-align:left;">Type</th>
            <th style="text-align:left;">Date Uploaded</th>
            <th style="text-align:left;">Time</th>
            <th style="text-align:left;">Uploaded by</th>
            <th style="text-align:right;">Actions</th>
          </tr>
        </thead>
        <tbody>${rowsHtml}</tbody>
      </table>
    </div>
  `;

  return `
    <div class="tabc ts-evidence-tab"
         data-ts-drop-zone-root="evidence"
         style="height:100%; display:flex; flex-direction:column;">

      <div class="card" style="flex:1; overflow:hidden;">
        <div class="row">
          <label>Evidence</label>
          <div class="controls" style="width:100%;">
            ${tableHtml}
          </div>
        </div>
      </div>

      <div class="mini" style="margin-top:10px; opacity:.85; text-align:center;">
        Drag a PDF or image anywhere inside this tab to upload new evidence.
      </div>

    </div>
  `;
}

async function openTimesheetEvidenceUploadDialog(file) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][EVIDENCE][UPLOAD_DIALOG]');
  GC('openTimesheetEvidenceUploadDialog');

  const mc = window.modalCtx || {};

  // âœ… NEW: planned-week guard (contract_weeks context => no real timesheet yet)
  // If the modal is showing a planned contract_week (no timesheet_id), block evidence upload.
  const hasRealTimesheetId =
    !!(
      (mc.timesheetDetails && mc.timesheetDetails.timesheet && mc.timesheetDetails.timesheet.timesheet_id) ||
      mc.data?.timesheet_id
    );

  const hasContractWeekContext =
    !!(
      mc.timesheetMeta?.isPlannedWeek ||
      (!hasRealTimesheetId && (mc.data?.contract_week_id || mc.data?.id))
    );

  if (!hasRealTimesheetId && hasContractWeekContext) {
    GE();
    throw new Error('You need to process this timesheet before you can add evidence to this timesheet');
  }

  const tsId =
    mc.data?.timesheet_id ||
    mc.data?.id ||
    (mc.timesheetDetails && mc.timesheetDetails.timesheet && mc.timesheetDetails.timesheet.timesheet_id) ||
    null;

  if (!tsId) {
    GE();
    throw new Error('Timesheet context missing; cannot upload evidence.');
  }

  if (!file) {
    GE();
    throw new Error('File is required for evidence upload.');
  }

  const type = String(file.type || '').toLowerCase();
  const name = String(file.name || '').toLowerCase();
  const isPdf = (type === 'application/pdf') || name.endsWith('.pdf');
  const isImg = type.startsWith('image/') || /\.(jpe?g|png|gif|webp|heic|heif)$/i.test(name);

  if (!isPdf && !isImg) {
    GE();
    throw new Error('Please upload a PDF or image file.');
  }

  L('ENTRY', {
    tsId,
    name: file.name,
    type: file.type,
    size: file.size
  });

  const instanceId = `ts-ev-up-${Date.now()}-${Math.random().toString(36).slice(2)}`;
  const selId = `${instanceId}-type`;
  const otherId = `${instanceId}-other`;
  const previewId = `${instanceId}-preview`;

  const blobUrl = URL.createObjectURL(file);

  const title = `Upload evidence ${String(tsId).slice(0, 8)}â€¦`;

  const bodyHtml = `
    <div class="tabc">
      <div class="card">
        <div class="row">
          <label>Preview</label>
          <div class="controls">
            <iframe
              id="${previewId}"
              src="${blobUrl}"
              style="width:100%;height:460px;border:1px solid var(--line);border-radius:8px;background:#000;"
            ></iframe>
            <div class="mini" style="margin-top:8px;opacity:.85;">
              ${escapeHtml(file.name || 'Evidence file')} (${Math.round((file.size || 0) / 1024)} KB)
            </div>
          </div>
        </div>

        <div class="row" style="margin-top:10px;">
          <label>Evidence Type</label>
          <div class="controls" style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
            <select
              id="${selId}"
              class="input"
              style="min-width:220px;color-scheme:dark;"
            >
              <option value="Timesheet">Timesheet</option>
              <option value="Mileage">Mileage</option>
              <option value="Accommodation">Accommodation</option>
              <option value="Travel">Travel</option>
              <option value="Other">Other</option>
            </select>

            <input
              id="${otherId}"
              type="text"
              class="input"
              placeholder="Enter evidence type"
              style="display:none;min-width:260px;"
              value=""
            />
          </div>
        </div>

        <div class="row" style="margin-top:10px;">
          <label></label>
          <div class="controls">
            <span class="mini" style="opacity:.85;">
              Upload adds a new evidence item to the timesheet. You can view/delete items from the Evidence tab table.
            </span>
          </div>
        </div>
      </div>
    </div>
  `;

  const tabs = [{ key: 'upload', title: 'Evidence' }];

  const cleanup = () => {
    try { URL.revokeObjectURL(blobUrl); } catch {}
  };

  const onSave = async () => {
    const { LOGM, L, GC, GE } = getTsLoggers('[TS][EVIDENCE][UPLOAD_DIALOG][SAVE]');
    GC('onSave (evidence upload dialog)');

    try {
      const sel = document.getElementById(selId);
      const other = document.getElementById(otherId);

      const selVal = sel ? String(sel.value || '').trim() : '';
      let kind = selVal;

      if (selVal.toLowerCase() === 'other') {
        const txt = other ? String(other.value || '').trim() : '';
        if (!txt) {
          alert('Please enter an evidence type.');
          GE();
          return { ok: false };
        }
        kind = txt;
      }

      if (!kind) {
        alert('Please select an evidence type.');
        GE();
        return { ok: false };
      }

      if (typeof uploadTimesheetEvidence !== 'function') {
        throw new Error('uploadTimesheetEvidence is not defined.');
      }

      // âœ… Pull current expected snapshot at the moment of save
      const mc2 = window.modalCtx || {};
      const tsIdNow =
        mc2.data?.timesheet_id ||
        mc2.data?.id ||
        (mc2.timesheetDetails && mc2.timesheetDetails.timesheet && mc2.timesheetDetails.timesheet.timesheet_id) ||
        tsId;

      const expected =
        (mc2.timesheetMeta && mc2.timesheetMeta.expected_timesheet_id) ||
        String(tsIdNow);

      // âœ… Upload evidence (guarded by expected_timesheet_id)
      const up = await uploadTimesheetEvidence(tsIdNow, file, kind, expected);

      const resolvedId =
        (up && (up.current_timesheet_id || up.timesheet_id))
          ? String(up.current_timesheet_id || up.timesheet_id)
          : String(tsIdNow);

      // âœ… Keep modalCtx aligned (if TS is open)
      try {
        if (window.modalCtx?.data) {
          const cur = window.modalCtx.data.timesheet_id || window.modalCtx.data.id || null;
          if (String(cur || '') === String(tsIdNow || '')) {
            window.modalCtx.data.timesheet_id = resolvedId;
            window.modalCtx.data.id = resolvedId;
          }
        }
        if (window.modalCtx?.timesheetMeta && typeof window.modalCtx.timesheetMeta === 'object') {
          window.modalCtx.timesheetMeta.expected_timesheet_id = resolvedId;
          window.modalCtx.timesheetMeta.hasTs = true;
        }
      } catch {}

      // Refresh details best-effort
      try {
        const fresh = await fetchTimesheetDetails(resolvedId);
        window.modalCtx.timesheetDetails = fresh;
      } catch (e) {
        L('refresh details after evidence upload failed (non-fatal)', e);
      }

      // Refresh evidence list + repaint Evidence tab
      try {
        if (typeof refreshTimesheetEvidenceIntoModalState === 'function') {
          await refreshTimesheetEvidenceIntoModalState(resolvedId);
        } else {
          const enc = encodeURIComponent;
          const res = await authFetch(API(`/api/timesheets/${enc(resolvedId)}/evidence`));
          const json = await res.json().catch(() => []);
          const list = Array.isArray(json) ? json : [];

          const normalised = list.map(ev2 => {
            const out = { ...(ev2 || {}) };

            if (typeof out.system !== 'boolean') out.system = false;
            if (typeof out.can_delete !== 'boolean') out.can_delete = !out.system;

            if (!out.uploaded_at_utc && out.created_at) out.uploaded_at_utc = out.created_at;

            return out;
          });

          window.modalCtx = window.modalCtx || {};
          window.modalCtx.timesheetState = window.modalCtx.timesheetState || {};
          window.modalCtx.timesheetState.evidence = normalised;
        }
      } catch (e) {
        L('refresh evidence after upload failed (non-fatal)', e);
      }

      try {
        if (typeof window.__getModalFrame === 'function') {
          const fr = window.__getModalFrame();
          if (fr && fr.entity === 'timesheets') {
            fr._suppressDirty = true;
            await fr.setTab('evidence');
            fr._suppressDirty = false;
            fr._updateButtons && fr._updateButtons();
          }
        }
      } catch (e) {
        L('repaint evidence tab failed (non-fatal)', e);
      }

      // Keep summary row consistent if id rotated
      try {
        if (typeof refreshTimesheetsSummaryAfterRotation === 'function') {
          await refreshTimesheetsSummaryAfterRotation(resolvedId);
        }
      } catch (e) {
        L('summary refresh failed (non-fatal)', e);
      }

      if (window.__toast) window.__toast('Evidence uploaded');

      cleanup();
      GE();
      return { ok: true, saved: { timesheet_id: resolvedId } };
    } catch (err) {
      L('upload failed', err);

      // âœ… Rotation safety: if TS moved, adopt + refetch + repaint, then let user retry
      try {
        if (typeof tsHandleMoved409Modal === 'function') {
          const handled = await tsHandleMoved409Modal(err, {
            tabKey: 'evidence',
            toast: 'This timesheet changed while you were editing. Please review and try again.'
          });
          if (handled) {
            GE();
            return { ok: false };
          }
        }
      } catch {}

      alert(err?.message || 'Failed to upload evidence.');
      GE();
      return { ok: false };
    }
  };

  const onDismiss = () => {
    cleanup();
  };

  showModal(
    title,
    tabs,
    () => bodyHtml,
    onSave,
    false,
    undefined,
    {
      kind: 'timesheet-evidence-replace',
      noParentGate: true,
      forceEdit: true,
      onDismiss
    }
  );

  // Wire show/hide of "Other" textbox after modal renders
  try {
    const sel = document.getElementById(selId);
    const other = document.getElementById(otherId);
    if (sel && !sel.__tsEvTypeWired) {
      sel.__tsEvTypeWired = true;

      const sync = () => {
        const v = String(sel.value || '').trim().toLowerCase();
        const isOther = (v === 'other');
        if (other) {
          other.style.display = isOther ? '' : 'none';
          if (!isOther) other.value = '';
        }
      };

      sel.addEventListener('change', sync);
      sync();
    }
  } catch (e) {
    if (LOGM) L('type dropdown wiring failed (non-fatal)', e);
  }

  GE();
}

async function openTimesheetEvidenceReplaceDialog(file) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][EVIDENCE][DIALOG]');
  GC('openTimesheetEvidenceReplaceDialog');

  const mc = window.modalCtx || {};
  const tsId = mc.data?.timesheet_id || mc.data?.id || null;

  if (!tsId) {
    GE();
    throw new Error('Timesheet context missing; cannot upload evidence.');
  }
  if (!file) {
    GE();
    throw new Error('File is required for evidence upload dialog.');
  }

  const type = String(file.type || '').toLowerCase();
  const name = String(file.name || '').toLowerCase();
  const isPdf = (type === 'application/pdf') || name.endsWith('.pdf');
  const isImg = type.startsWith('image/') || /\.(jpe?g|png|gif|webp|heic|heif)$/i.test(name);

  if (!isPdf && !isImg) {
    GE();
    throw new Error('Please upload a PDF or image file.');
  }

  L('ENTRY', {
    tsId,
    name: file.name,
    type: file.type,
    size: file.size
  });

  const instanceId = `ts-ev-${Date.now()}-${Math.random().toString(36).slice(2)}`;
  const selId = `${instanceId}-type`;
  const otherId = `${instanceId}-other`;
  const previewId = `${instanceId}-preview`;

  const newUrl = URL.createObjectURL(file);

  const title = `Upload evidence ${String(tsId).slice(0, 8)}â€¦`;

  const bodyHtml = `
    <div class="tabc">
      <div class="card">
        <div class="row">
          <label>Preview</label>
          <div class="controls">
            <iframe
              id="${previewId}"
              src="${newUrl}"
              style="width:100%;height:420px;border:1px solid var(--line);border-radius:8px;background:#000;"
            ></iframe>
            <div class="mini" style="margin-top:8px;opacity:.85;">
              ${escapeHtml(file.name || 'Evidence file')} (${Math.round((file.size || 0) / 1024)} KB)
            </div>
          </div>
        </div>

        <div class="row" style="margin-top:10px;">
          <label>Evidence Type</label>
          <div class="controls" style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
            <select
              id="${selId}"
              class="input"
              style="min-width:220px;background:transparent;border:1px solid rgba(255,255,255,.18);"
            >
              <option value="Timesheet">Timesheet</option>
              <option value="Mileage">Mileage</option>
              <option value="Accommodation">Accommodation</option>
              <option value="Travel">Travel</option>
              <option value="Other">Other</option>
            </select>

            <input
              id="${otherId}"
              type="text"
              class="input"
              placeholder="Enter evidence type"
              style="display:none;min-width:260px;background:transparent;border:1px solid rgba(255,255,255,.18);"
              value=""
            />
          </div>
        </div>

        <div class="row" style="margin-top:10px;">
          <label></label>
          <div class="controls">
            <span class="mini" style="opacity:.85;">
              This will add a new evidence item to the timesheet. Use the Evidence tab table to view or delete items later.
            </span>
          </div>
        </div>
      </div>
    </div>
  `;

  const tabs = [{ key: 'upload', title: 'Evidence' }];

  const onSave = async () => {
    const { LOGM, L, GC, GE } = getTsLoggers('[TS][EVIDENCE][DIALOG][SAVE]');
    GC('onSave (evidence upload)');

    try {
      const sel = document.getElementById(selId);
      const other = document.getElementById(otherId);

      const selVal = sel ? String(sel.value || '').trim() : '';
      let kind = selVal;

      if (selVal.toLowerCase() === 'other') {
        const txt = other ? String(other.value || '').trim() : '';
        if (!txt) {
          alert('Please enter an evidence type.');
          GE();
          return { ok: false };
        }
        kind = txt;
      }

      if (!kind) {
        alert('Please select an evidence type.');
        GE();
        return { ok: false };
      }

      // âœ… Re-read the current modal context at save time
      const mc2 = window.modalCtx || {};
      const tsIdNow =
        mc2.data?.timesheet_id ||
        mc2.data?.id ||
        (mc2.timesheetDetails && mc2.timesheetDetails.timesheet && mc2.timesheetDetails.timesheet.timesheet_id) ||
        tsId;

      const expected =
        (mc2.timesheetMeta && mc2.timesheetMeta.expected_timesheet_id) ||
        String(tsIdNow);

      // âœ… Upload evidence (guarded; if stale, backend returns 409 -> we adopt+refresh below)
      const up = await uploadTimesheetEvidence(tsIdNow, file, kind, expected);

      const resolvedId =
        (up && (up.current_timesheet_id || up.timesheet_id))
          ? String(up.current_timesheet_id || up.timesheet_id)
          : String(tsIdNow);

      // âœ… If the timesheet moved, adopt it into modalCtx for correctness
      try {
        if (window.modalCtx && window.modalCtx.data) {
          const cur = window.modalCtx.data.timesheet_id || window.modalCtx.data.id || null;
          if (String(cur || '') === String(tsIdNow || '')) {
            window.modalCtx.data.timesheet_id = resolvedId;
            window.modalCtx.data.id = resolvedId;
          }
        }
        if (window.modalCtx?.timesheetMeta && typeof window.modalCtx.timesheetMeta === 'object') {
          window.modalCtx.timesheetMeta.expected_timesheet_id = resolvedId;
          window.modalCtx.timesheetMeta.hasTs = true;
        }
      } catch {}

      // Refresh details best-effort (keeps action flags, evidence mode etc aligned)
      try {
        const fresh = await fetchTimesheetDetails(resolvedId);
        window.modalCtx.timesheetDetails = fresh;
      } catch (e) {
        L('refresh details after evidence upload failed (non-fatal)', e);
      }

      // âœ… Refresh evidence list in modal state using resolvedId
      try {
        const encTsId = encodeURIComponent(resolvedId);

        if (typeof refreshTimesheetEvidenceIntoModalState === 'function') {
          await refreshTimesheetEvidenceIntoModalState(resolvedId);
        } else {
          const res = await authFetch(API(`/api/timesheets/${encTsId}/evidence`));
          const json = await res.json().catch(() => []);
          const list = Array.isArray(json) ? json : [];

          const normalised = list.map(ev => {
            const out = { ...(ev || {}) };
            if (typeof out.system !== 'boolean') out.system = false;
            if (typeof out.can_delete !== 'boolean') out.can_delete = !out.system;
            if (!out.uploaded_at_utc && out.created_at) out.uploaded_at_utc = out.created_at;
            return out;
          });

          window.modalCtx = window.modalCtx || {};
          window.modalCtx.timesheetState = window.modalCtx.timesheetState || {};
          window.modalCtx.timesheetState.evidence = normalised;
        }
      } catch (err) {
        L('refresh evidence after upload failed (non-fatal)', err);
      }

      // âœ… Keep summary row consistent if id rotated
      try {
        if (typeof refreshTimesheetsSummaryAfterRotation === 'function') {
          await refreshTimesheetsSummaryAfterRotation(resolvedId);
        }
      } catch (e) {
        L('summary refresh failed (non-fatal)', e);
      }

      if (window.__toast) {
        window.__toast('Evidence uploaded');
      }

      try { URL.revokeObjectURL(newUrl); } catch {}

      GE();
      return { ok: true, saved: { timesheet_id: resolvedId } };
    } catch (err) {
      L('uploadTimesheetEvidence failed', err);

      // âœ… Rotation safety: adopt moved current id + refresh + repaint; user can retry
      try {
        if (typeof tsHandleMoved409Modal === 'function') {
          const handled = await tsHandleMoved409Modal(err, {
            tabKey: 'upload',
            toast: 'This timesheet changed while you were editing. Please review and try again.'
          });
          if (handled) {
            GE();
            return { ok: false };
          }
        }
      } catch {}

      alert(err?.message || 'Failed to upload evidence.');
      GE();
      return { ok: false };
    }
  };

  const onDismiss = () => {
    try { URL.revokeObjectURL(newUrl); } catch {}
  };

  showModal(
    title,
    tabs,
    () => bodyHtml,
    onSave,
    false,
    undefined,
    {
      kind: 'timesheet-evidence-replace',
      noParentGate: true,
      forceEdit: true,
      onDismiss
    }
  );

  // Best-effort UI wiring after render
  try {
    const sel = document.getElementById(selId);
    const other = document.getElementById(otherId);
    if (sel && !sel.__tsEvTypeWired) {
      sel.__tsEvTypeWired = true;

      const sync = () => {
        const v = String(sel.value || '').trim().toLowerCase();
        const isOther = (v === 'other');
        if (other) {
          other.style.display = isOther ? '' : 'none';
          if (!isOther) other.value = '';
        }
      };

      sel.addEventListener('change', sync);
      sync();
    }
  } catch {}

  GE();
}



async function refreshTimesheetEvidenceIntoModalState(timesheetId) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][EVIDENCE][REFRESH]');
  GC('refreshTimesheetEvidenceIntoModalState');

  if (!timesheetId) {
    GE();
    throw new Error('refreshTimesheetEvidenceIntoModalState: timesheetId is required');
  }

  const encTsId = encodeURIComponent(String(timesheetId));

  L('ENTRY', { timesheetId });

  try {
    // âœ… Use meta=1 so backend can tell us if the id rotated
    const res = await authFetch(API(`/api/timesheets/${encTsId}/evidence?meta=1`));
    const text = await res.text().catch(() => '');

    if (!res.ok) {
      L('GET evidence failed', { status: res.status, bodyPreview: text.slice(0, 400) });
      throw new Error(text || 'Failed to load timesheet evidence');
    }

    const json = text ? JSON.parse(text) : null;

    // Backward compatible:
    // - legacy: array
    // - meta: { current_timesheet_id, evidence:[...] }
    const currentIdFromApi =
      (json && typeof json === 'object' && !Array.isArray(json) && json.current_timesheet_id)
        ? String(json.current_timesheet_id)
        : null;

    const list =
      Array.isArray(json)
        ? json
        : (json && typeof json === 'object' && Array.isArray(json.evidence))
          ? json.evidence
          : [];

    // If API says the current id differs, adopt it into modal state so future ops hit the right record
    if (currentIdFromApi && String(currentIdFromApi) !== String(timesheetId)) {
      try {
        window.modalCtx ||= {};
        window.modalCtx.data ||= {};
        window.modalCtx.timesheetMeta ||= {};

        window.modalCtx.data.timesheet_id = currentIdFromApi;
        window.modalCtx.data.id = currentIdFromApi;
        window.modalCtx.timesheetMeta.expected_timesheet_id = currentIdFromApi;
      } catch {}

      L('ADOPTED_CURRENT_ID', { from: timesheetId, to: currentIdFromApi });
    }

    // Normalise evidence rows so UI can rely on flags
    const normalised = list.map(ev => {
      const out = { ...(ev || {}) };
      if (typeof out.system !== 'boolean') out.system = false;
      if (typeof out.can_delete !== 'boolean') out.can_delete = !out.system;
      if (!out.uploaded_at_utc && out.created_at) out.uploaded_at_utc = out.created_at;
      return out;
    });

    window.modalCtx = window.modalCtx || {};
    window.modalCtx.timesheetState = window.modalCtx.timesheetState || {};
    window.modalCtx.timesheetState.evidence = normalised;

    // âœ… Provide a lightweight global download helper used by the Evidence tab buttons
    // (kept here so renderTimesheetEvidenceTab can be purely HTML)
    try {
      window.__tsEvidenceDownload = async (evidenceId) => {
        const mc = window.modalCtx || {};
        const evs = mc?.timesheetState?.evidence || [];
        const ev = (Array.isArray(evs) ? evs : []).find(x => String(x?.id || '') === String(evidenceId || ''));
        if (!ev) {
          window.__toast && window.__toast('Evidence item not found');
          return;
        }

        const keyRaw =
          (ev.download_storage_key != null && String(ev.download_storage_key).trim())
            ? String(ev.download_storage_key).trim()
            : (ev.storage_key != null && String(ev.storage_key).trim())
              ? String(ev.storage_key).trim()
              : '';

        const key = keyRaw.replace(/^\/+/, '');
        if (!key) {
          window.__toast && window.__toast('No downloadable file for this evidence item');
          return;
        }

        // presign-download
        const presRes = await authFetch(API('/api/files/presign-download'), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ key })
        });

        const presTxt = await presRes.text().catch(() => '');
        if (!presRes.ok) {
          throw new Error(presTxt || 'Failed to presign download URL');
        }

        const presJson = presTxt ? JSON.parse(presTxt) : {};
        const url = presJson.url || presJson.signed_url || null;
        if (!url) throw new Error('No URL returned from presign-download');

        // Open in new tab
        window.open(url, '_blank', 'noopener,noreferrer');
      };
    } catch {}

    L('OK', { count: normalised.length });
    GE();
    return normalised;
  } catch (err) {
    L('ERROR', err);
    GE();
    throw err;
  }
}


async function getTimesheetPdfUrl(timesheetId) {
  const LOGM = (typeof window.__LOG_MODAL === 'boolean') ? window.__LOG_MODAL : false;
  const L    = (...a) => { if (LOGM) console.log('[TS][PDF][GET]', ...a); };
  const GC   = (label) => { if (LOGM) console.groupCollapsed('[TS][PDF][GET]', label); };
  const GE   = () => { if (LOGM) console.groupEnd(); };

  if (!timesheetId) {
    throw new Error('getTimesheetPdfUrl: timesheetId is required');
  }

  GC('getTimesheetPdfUrl');
  L('START', { timesheetId });

  const encId = encodeURIComponent(timesheetId);
  const pdfMetaUrl = API(`/api/timesheets/${encId}/pdf`);

  let pdfMeta;
  try {
    const res = await authFetch(pdfMetaUrl);
    const text = await res.text();
    if (!res.ok) {
      L('timesheet pdf meta failed', { status: res.status, bodyPreview: text.slice(0, 400) });
      GE();
      return null;
    }
    pdfMeta = text ? JSON.parse(text) : {};
  } catch (err) {
    L('meta fetch error', err);
    GE();
    return null;
  }

  const r2Key = pdfMeta.r2_key || pdfMeta.key || pdfMeta.manual_pdf_r2_key || null;
  if (!r2Key) {
    L('no r2_key in pdfMeta', pdfMeta);
    GE();
    return null;
  }

  L('meta resolved', { r2Key, rotation_degrees: pdfMeta.rotation_degrees });

  // Ask files API for a presigned download URL
  const presignUrl = API(`/api/files/presign-download`);
  let signed;
  try {
    const res = await authFetch(presignUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ key: r2Key })
    });
    const text = await res.text();
    if (!res.ok) {
      L('presign-download failed', { status: res.status, bodyPreview: text.slice(0, 400) });
      GE();
      return null;
    }
    signed = text ? JSON.parse(text) : {};
  } catch (err) {
    L('presign error', err);
    GE();
    return null;
  }

  const url = signed.url || signed.signed_url || null;
  if (!url) {
    L('no URL in presign response', signed);
    GE();
    return null;
  }

  L('RESOLVE OK', { url });
  GE();
  return {
    url,
    r2_key: r2Key,
    rotation_degrees: pdfMeta.rotation_degrees ?? 0,
    meta: pdfMeta
  };
}

async function openTimesheetPdf(timesheetId) {
  const LOGM = (typeof window.__LOG_MODAL === 'boolean') ? window.__LOG_MODAL : false;
  const L    = (...a) => { if (LOGM) console.log('[TS][PDF]', ...a); };
  const GC   = (label) => { if (LOGM) console.groupCollapsed('[TS][PDF]', label); };
  const GE   = () => { if (LOGM) console.groupEnd(); };

  if (!timesheetId) {
    throw new Error('openTimesheetPdf: timesheetId is required');
  }

  GC('openTimesheetPdf');
  L('START', { timesheetId });

  const info = await getTimesheetPdfUrl(timesheetId).catch(err => {
    L('getTimesheetPdfUrl failed', err);
    return null;
  });

  if (!info || !info.url) {
    GE();
    alert('No PDF is available for this timesheet yet.');
    return;
  }

  L('opening window', { url: info.url });
  GE();
  try {
    window.open(info.url, '_blank', 'noopener');
  } catch (err) {
    if (LOGM) console.warn('[TS][PDF] window.open failed', err);
    alert('Unable to open PDF window. Please check your popup blocker.');
  }
}


async function uploadTimesheetEvidence(timesheetId, file, evidenceTypeLabel, expectedTimesheetId) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][EVIDENCE][UPLOAD]');
  GC('uploadTimesheetEvidence');

  if (!timesheetId) {
    GE();
    throw new Error('uploadTimesheetEvidence: timesheetId is required');
  }
  if (!file) {
    GE();
    throw new Error('uploadTimesheetEvidence: file is required');
  }

  const kind = String(evidenceTypeLabel || '').trim();
  if (!kind) {
    GE();
    throw new Error('uploadTimesheetEvidence: evidenceTypeLabel is required');
  }

  const mc = window.modalCtx || {};
  const expected =
    (expectedTimesheetId != null ? String(expectedTimesheetId) : '') ||
    (mc.timesheetMeta && mc.timesheetMeta.expected_timesheet_id) ||
    String(timesheetId);

  const enc = encodeURIComponent;
  const contentType = file.type || 'application/octet-stream';
  const filename    = file.name || 'timesheet-evidence';

  L('ENTRY', { timesheetId, expected_timesheet_id: expected, kind, contentType, filename, size: file.size });

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Timesheet-level path ONLY:
  // 1) /api/files/presign-upload
  // 2) PUT to upload_url
  // 3) POST /api/timesheets/:id/evidence with { kind, display_name, storage_key, expected_timesheet_id }
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // 1) Presign upload (use apiPostJson so errors preserve err.status + err.json)
  let presignJson = null;
  try {
    presignJson = await apiPostJson('/api/files/presign-upload', {
      content_type: contentType,
      filename
    });
  } catch (err) {
    L('files presign-upload error', err);
    GE();
    throw err;
  }

  const uploadUrl = presignJson && presignJson.upload_url ? String(presignJson.upload_url) : null;
  const fileKey   = presignJson && presignJson.key ? String(presignJson.key) : null;
  if (!uploadUrl || !fileKey) {
    GE();
    throw new Error('Presign-upload response missing upload_url or key');
  }

  L('presign OK', { uploadUrl, fileKey });

  // 2) Upload file to R2 (via signed URL) â€” keep as raw fetch (not a CloudTMS API call)
  try {
    const res = await fetch(uploadUrl, {
      method: 'PUT',
      headers: { 'Content-Type': contentType },
      body: file
    });
    if (!res.ok) {
      const text = await res.text().catch(() => '');
      L('upload failed', { status: res.status, bodyPreview: text.slice(0, 400) });
      throw new Error(text || 'Failed to upload timesheet evidence');
    }
  } catch (err) {
    L('upload error', err);
    GE();
    throw err;
  }

  // 3) Record evidence row (guarded: expected_timesheet_id)
  let recordJson = {};
  try {
    const encTsId = enc(timesheetId);
    recordJson = await apiPostJson(`/api/timesheets/${encTsId}/evidence`, {
      kind,
      display_name: file.name || filename,
      storage_key: fileKey,
      expected_timesheet_id: expected
    });
  } catch (err) {
    L('timesheet evidence POST error', err);
    GE();
    throw err;
  }

  const resolvedId =
    (recordJson && (recordJson.current_timesheet_id || recordJson.timesheet_id || recordJson.new_timesheet_id))
      ? String(recordJson.current_timesheet_id || recordJson.timesheet_id || recordJson.new_timesheet_id)
      : String(timesheetId);

  L('UPLOAD OK (timesheet-level, evidence)', { timesheetId, resolvedId, kind, storage_key: fileKey, recordJson });
  GE();
  return { ok: true, storage_key: fileKey, timesheet_id: resolvedId, current_timesheet_id: resolvedId, record: recordJson };
}

async function handleTimesheetEvidenceRemoveClick(ev) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][EVIDENCE][REMOVE]');
  GC('handleTimesheetEvidenceRemoveClick');

  // Local helper to throw with err.status + err.json (so TIMESHEET_MOVED can be handled consistently)
  const apiDeleteJson = async (urlPath, bodyObj) => {
    const url = API(urlPath);
    let res, text = '';
    try {
      res = await authFetch(url, {
        method: 'DELETE',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(bodyObj || {})
      });
      text = await res.text().catch(() => '');
    } catch (e) {
      throw e;
    }

    let j = null;
    try { j = text ? JSON.parse(text) : null; } catch { j = null; }

    if (!res.ok) {
      const err = new Error(
        (j && typeof j === 'object' && (j.message || j.error))
          ? String(j.message || j.error)
          : (text || `HTTP ${res.status}`)
      );
      err.status = res.status;
      err.json = j;
      throw err;
    }

    return (j && typeof j === 'object') ? j : {};
  };

  const btn = ev?.target?.closest?.('[data-evidence-remove]');
  if (!btn) {
    GE();
    return;
  }

  const eid = btn.dataset.evidenceRemove;
  if (!eid) {
    GE();
    return;
  }

  const mc = window.modalCtx || {};
  const tsId =
    mc.data?.timesheet_id ||
    mc.data?.id ||
    (mc.timesheetDetails && mc.timesheetDetails.timesheet && mc.timesheetDetails.timesheet.timesheet_id) ||
    null;

  if (!tsId) {
    GE();
    alert('Timesheet context missing; cannot remove evidence.');
    return;
  }

  const expected =
    (mc.timesheetMeta && mc.timesheetMeta.expected_timesheet_id) ||
    String(tsId);

  // Defensive guard: block system evidence / non-deletable rows
  try {
    const list = Array.isArray(mc?.timesheetState?.evidence) ? mc.timesheetState.evidence : [];
    const item = list.find(x => x && String(x.id) === String(eid)) || null;

    const isSystem = (item && typeof item.system === 'boolean') ? item.system : false;
    const canDelete = (item && typeof item.can_delete === 'boolean') ? item.can_delete : !isSystem;

    if (isSystem || !canDelete) {
      GE();
      alert('This evidence item cannot be deleted.');
      return;
    }
  } catch {
    // If we cannot determine, continue with delete attempt (backend will still enforce)
  }

  const ok = window.confirm('Delete this evidence item?');
  if (!ok) {
    GE();
    return;
  }

  const enc = encodeURIComponent;
  const encTsId = enc(tsId);
  const encEid  = enc(eid);

  L('REMOVE ENTRY', { timesheetId: tsId, expected_timesheet_id: expected, evidenceId: eid });

  try {
    // 1) DELETE the evidence row (guarded)
    const delJson = await apiDeleteJson(
      `/api/timesheets/${encTsId}/evidence/${encEid}`,
      { expected_timesheet_id: expected }
    );

    // NOTE: a rotated/moved TS should return 409 (handled below), but keep this as a safety net
    const resolvedId =
      (delJson && (delJson.current_timesheet_id || delJson.timesheet_id || delJson.new_timesheet_id))
        ? String(delJson.current_timesheet_id || delJson.timesheet_id || delJson.new_timesheet_id)
        : String(tsId);

    // Keep modalCtx identity aligned (best-effort)
    try {
      if (window.modalCtx?.data) {
        const cur = window.modalCtx.data.timesheet_id || window.modalCtx.data.id || null;
        if (String(cur || '') === String(tsId || '')) {
          window.modalCtx.data.timesheet_id = resolvedId;
          window.modalCtx.data.id = resolvedId;
        }
      }
      if (window.modalCtx?.timesheetMeta && typeof window.modalCtx.timesheetMeta === 'object') {
        window.modalCtx.timesheetMeta.expected_timesheet_id = resolvedId;
      }
    } catch {}

    // Refresh details best-effort
    try {
      const fresh = await fetchTimesheetDetails(resolvedId);
      window.modalCtx.timesheetDetails = fresh;
    } catch (e) {
      L('refresh details after evidence delete failed (non-fatal)', e);
    }

    // 2) Refresh evidence list into modal state (canonical helper if present)
    let newEvidence = null;

    if (typeof refreshTimesheetEvidenceIntoModalState === 'function') {
      try {
        newEvidence = await refreshTimesheetEvidenceIntoModalState(resolvedId);
      } catch (e) {
        L('refreshTimesheetEvidenceIntoModalState failed (non-fatal)', e);
        newEvidence = null;
      }
    }

    if (!Array.isArray(newEvidence)) {
      const res2 = await authFetch(API(`/api/timesheets/${encodeURIComponent(resolvedId)}/evidence`));
      const json2 = await res2.json().catch(() => []);
      const list2 = Array.isArray(json2) ? json2 : [];

      newEvidence = list2.map(ev2 => {
        const out = { ...(ev2 || {}) };
        if (typeof out.system !== 'boolean') out.system = false;
        if (typeof out.can_delete !== 'boolean') out.can_delete = !out.system;
        if (!out.uploaded_at_utc && out.created_at) out.uploaded_at_utc = out.created_at;
        return out;
      });
    }

    window.modalCtx = window.modalCtx || {};
    window.modalCtx.timesheetState = window.modalCtx.timesheetState || {};
    window.modalCtx.timesheetState.evidence = Array.isArray(newEvidence) ? newEvidence : [];

    // 3) Repaint Evidence tab if currently visible
    try {
      if (typeof window.__getModalFrame === 'function') {
        const fr = window.__getModalFrame();
        if (fr && fr.entity === 'timesheets' && fr.currentTabKey === 'evidence') {
          fr._suppressDirty = true;
          await fr.setTab('evidence');
          fr._suppressDirty = false;
          fr._updateButtons && fr._updateButtons();
        }
      }
    } catch (e) {
      L('repaint evidence tab failed (non-fatal)', e);
    }

    // Keep summary row consistent if id rotated
    try {
      if (typeof refreshTimesheetsSummaryAfterRotation === 'function') {
        await refreshTimesheetsSummaryAfterRotation(resolvedId);
      }
    } catch (e) {
      L('summary refresh failed (non-fatal)', e);
    }

    if (window.__toast) {
      window.__toast('Evidence removed');
    }
  } catch (err) {
    L('evidence remove error', err);

    // âœ… Rotation safety: adopt moved current id + refresh + repaint (no delete occurs)
    try {
      if (typeof tsHandleMoved409Modal === 'function') {
        const handled = await tsHandleMoved409Modal(err, {
          tabKey: 'evidence',
          toast: 'This timesheet changed while you were editing. Please review and try again.'
        });
        if (handled) {
          GE();
          return;
        }
      }
    } catch {}

    alert(err?.message || 'Failed to remove evidence item.');
  }

  GE();
}


async function authoriseTimesheet(ctxOrId, expectedTimesheetId) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][AUTH]');
  GC('authoriseTimesheet');

  const mc  = window.modalCtx || {};
  const row = (mc.data && mc.data.timesheet_id) ? mc.data : (ctxOrId && ctxOrId.row ? ctxOrId.row : {});
  const tsId = (typeof ctxOrId === 'string') ? ctxOrId : (row.timesheet_id || row.id || mc.data?.id || null);

  if (!tsId) {
    L('ERROR: missing timesheetId');
    GE();
    throw new Error('authoriseTimesheet: timesheetId is required');
  }

  const expected =
    (expectedTimesheetId != null ? String(expectedTimesheetId) : '') ||
    (mc.timesheetMeta && mc.timesheetMeta.expected_timesheet_id) ||
    String(tsId);

  const encId   = encodeURIComponent(tsId);
  const urlPath = `/api/timesheets/${encId}/authorise`;

  const payload = { expected_timesheet_id: expected };

  L('REQUEST', { url: API(urlPath), tsId, payload });

  // âœ… Use apiPostJson so 409 errors preserve err.status + err.json for TIMESHEET_MOVED handling
  const json = await apiPostJson(urlPath, payload);

  L('authorise result', json);

  const newId =
    (json && (json.current_timesheet_id || json.new_timesheet_id || json.timesheet_id))
      ? (json.current_timesheet_id || json.new_timesheet_id || json.timesheet_id)
      : null;

  const resolvedId = (newId && String(newId).trim()) ? String(newId) : String(tsId);

  // Refresh details so Overview, Lines, Finance reflect new status
  let newDetails = mc.timesheetDetails;
  try {
    newDetails = await fetchTimesheetDetails(resolvedId);
    window.modalCtx.timesheetDetails = newDetails;
  } catch (err) {
    L('refresh details failed (non-fatal)', err);
  }

  // Update summary row if present
  const tsfin = newDetails?.tsfin || {};
  const updatedRow = {
    ...(mc.data || row),
    summary_stage: json.summary_stage || mc.data?.summary_stage || 'READY_FOR_INVOICE',
    processing_status: tsfin.processing_status || mc.data?.processing_status,
    total_pay_ex_vat: tsfin.total_pay_ex_vat ?? mc.data?.total_pay_ex_vat,
    total_charge_ex_vat: tsfin.total_charge_ex_vat ?? mc.data?.total_charge_ex_vat,
    margin_ex_vat: tsfin.margin_ex_vat ?? mc.data?.margin_ex_vat,
    timesheet_id: resolvedId,
    id: resolvedId
  };

  window.modalCtx.data = updatedRow;

  // âœ… keep guarded-write expected id aligned
  if (window.modalCtx?.timesheetMeta && typeof window.modalCtx.timesheetMeta === 'object') {
    window.modalCtx.timesheetMeta.expected_timesheet_id = resolvedId;
  }

  try {
    window.__pendingFocus = {
      section: 'timesheets',
      ids: [String(resolvedId)],
      primaryIds: [String(resolvedId)]
    };
  } catch {}

  // âœ… Keep the summary grid consistent
  try {
    if (typeof refreshTimesheetsSummaryAfterRotation === 'function') {
      await refreshTimesheetsSummaryAfterRotation(resolvedId);
    }
  } catch (e) {
    L('summary refresh failed (non-fatal)', e);
  }

  L('UPDATED ROW', updatedRow);
  GE();
  return { ok: true, updatedRow, details: newDetails, json };
}

async function toggleTimesheetPayHold(ctxOrId, onHold, reason = '', expectedTimesheetId) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][PAY-HOLD]');
  GC('toggleTimesheetPayHold');

  const mc  = window.modalCtx || {};
  const row = (mc.data && mc.data.timesheet_id) ? mc.data : (ctxOrId && ctxOrId.row ? ctxOrId.row : {});
  const tsId = (typeof ctxOrId === 'string') ? ctxOrId : (row.timesheet_id || row.id || mc.data?.id || null);

  if (!tsId) {
    L('ERROR: missing timesheetId');
    GE();
    throw new Error('toggleTimesheetPayHold: timesheetId is required');
  }

  const expected =
    (expectedTimesheetId != null ? String(expectedTimesheetId) : '') ||
    (mc.timesheetMeta && mc.timesheetMeta.expected_timesheet_id) ||
    tsId;

  const encId   = encodeURIComponent(tsId);
  const urlPath = `/api/timesheets/${encId}/pay-hold`;

  const payload = { on_hold: !!onHold, expected_timesheet_id: expected };
  if (onHold && reason) payload.reason = reason;

  L('REQUEST', { url: API(urlPath), payload });

  // âœ… FIX: backend route is PATCH, not POST (preserves err.status + err.json for TIMESHEET_MOVED handling upstream)
  const json = await apiPatchJson(urlPath, payload);

  L('pay-hold result', json);

  // Refresh details (use current id if backend returned one)
  const resolvedId =
    (json && (json.current_timesheet_id || json.timesheet_id))
      ? (json.current_timesheet_id || json.timesheet_id)
      : tsId;

  let newDetails = mc.timesheetDetails;
  try {
    newDetails = await fetchTimesheetDetails(resolvedId);
    window.modalCtx.timesheetDetails = newDetails;
  } catch (err) {
    L('refresh details failed (non-fatal)', err);
  }

  const tsfin = newDetails?.tsfin || {};
  const updatedRow = {
    ...(mc.data || row),
    pay_on_hold: !!tsfin.pay_on_hold,
    timesheet_id: resolvedId,
    id: resolvedId
  };

  window.modalCtx.data = updatedRow;

  // If we landed on a new id, keep expected aligned
  if (window.modalCtx?.timesheetMeta) {
    window.modalCtx.timesheetMeta.expected_timesheet_id = resolvedId;
  }

  try {
    window.__pendingFocus = {
      section: 'timesheets',
      ids: [String(resolvedId)],
      primaryIds: [String(resolvedId)]
    };
  } catch {}

  // âœ… Keep the summary grid consistent
  try {
    if (typeof refreshTimesheetsSummaryAfterRotation === 'function') {
      await refreshTimesheetsSummaryAfterRotation(resolvedId);
    }
  } catch (e) {
    L('summary refresh failed (non-fatal)', e);
  }

  L('UPDATED ROW', updatedRow);
  GE();
  return { ok: true, updatedRow, details: newDetails };
}


async function markTimesheetPaid(ctxOrId, expectedTimesheetId, paymentReference) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][MARK-PAID]');
  GC('markTimesheetPaid');

  const mc  = window.modalCtx || {};
  const row = (mc.data && mc.data.timesheet_id) ? mc.data : (ctxOrId && ctxOrId.row ? ctxOrId.row : {});
  const tsId = (typeof ctxOrId === 'string') ? ctxOrId : (row.timesheet_id || row.id || mc.data?.id || null);

  if (!tsId) {
    L('ERROR: missing timesheetId');
    GE();
    throw new Error('markTimesheetPaid: timesheetId is required');
  }

  const expected =
    (expectedTimesheetId != null ? String(expectedTimesheetId) : '') ||
    (mc.timesheetMeta && mc.timesheetMeta.expected_timesheet_id) ||
    tsId;

  const encId   = encodeURIComponent(tsId);
  const urlPath = `/api/timesheets/${encId}/mark-paid`;

  const payload = {
    paid: true,
    expected_timesheet_id: expected
  };
  if (paymentReference != null && String(paymentReference).trim()) {
    payload.payment_reference = String(paymentReference).trim();
  }

  L('REQUEST', { url: API(urlPath), tsId, payload });

  // âœ… FIX: backend route is PATCH, not POST (preserves err.status + err.json for TIMESHEET_MOVED handling upstream)
  const json = await apiPatchJson(urlPath, payload);

  L('mark-paid result', json);

  // Refresh details
  const resolvedId =
    (json && (json.current_timesheet_id || json.timesheet_id))
      ? (json.current_timesheet_id || json.timesheet_id)
      : tsId;

  let newDetails = mc.timesheetDetails;
  try {
    newDetails = await fetchTimesheetDetails(resolvedId);
    window.modalCtx.timesheetDetails = newDetails;
  } catch (err) {
    L('refresh details failed (non-fatal)', err);
  }

  const tsfin = newDetails?.tsfin || {};
  const updatedRow = {
    ...(mc.data || row),
    paid_at_utc: tsfin.paid_at_utc || mc.data?.paid_at_utc,
    summary_stage: 'PAID',
    timesheet_id: resolvedId,
    id: resolvedId
  };

  window.modalCtx.data = updatedRow;

  if (window.modalCtx?.timesheetMeta) {
    window.modalCtx.timesheetMeta.expected_timesheet_id = resolvedId;
  }

  try {
    window.__pendingFocus = {
      section: 'timesheets',
      ids: [String(resolvedId)],
      primaryIds: [String(resolvedId)]
    };
  } catch {}

  // âœ… Keep the summary grid consistent
  try {
    if (typeof refreshTimesheetsSummaryAfterRotation === 'function') {
      await refreshTimesheetsSummaryAfterRotation(resolvedId);
    }
  } catch (e) {
    L('summary refresh failed (non-fatal)', e);
  }

  L('UPDATED ROW', updatedRow);
  GE();
  return { ok: true, updatedRow, details: newDetails };
}





async function updateTimesheetReference(ctxOrId, newReference, expectedTimesheetId) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][REF]');
  GC('updateTimesheetReference');

  const mc  = window.modalCtx || {};
  const row = (mc.data && mc.data.timesheet_id) ? mc.data : (ctxOrId && ctxOrId.row ? ctxOrId.row : {});
  const tsId = (typeof ctxOrId === 'string') ? ctxOrId : (row.timesheet_id || row.id || mc.data?.id || null);

  if (!tsId) {
    L('ERROR: missing timesheetId');
    GE();
    throw new Error('updateTimesheetReference: timesheetId is required');
  }

  const expected =
    (expectedTimesheetId != null ? String(expectedTimesheetId) : '') ||
    (mc.timesheetMeta && mc.timesheetMeta.expected_timesheet_id) ||
    tsId;

  const encId   = encodeURIComponent(tsId);
  const urlPath = `/api/timesheets/${encId}/reference`;

  const reference_number = newReference == null ? '' : String(newReference);
  L('REQUEST', { url: API(urlPath), reference_number, expected_timesheet_id: expected });

  // âœ… Use apiPostJson so 409 errors preserve err.status + err.json for TIMESHEET_MOVED handling upstream
  const json = await apiPostJson(urlPath, { reference_number, expected_timesheet_id: expected });

  L('reference result', json);

  // Refresh details
  const resolvedId =
    (json && (json.current_timesheet_id || json.timesheet_id))
      ? (json.current_timesheet_id || json.timesheet_id)
      : tsId;

  let newDetails = mc.timesheetDetails;
  try {
    newDetails = await fetchTimesheetDetails(resolvedId);
    window.modalCtx.timesheetDetails = newDetails;
  } catch (err) {
    L('refresh details failed (non-fatal)', err);
  }

  const ts = newDetails?.timesheet || {};
  const updatedRow = {
    ...(mc.data || row),
    reference_number: ts.reference_number || reference_number,
    timesheet_id: resolvedId,
    id: resolvedId
  };

  window.modalCtx.data = updatedRow;

  // Keep staged state in sync
  if (mc.timesheetState) {
    mc.timesheetState.reference = updatedRow.reference_number;
  }

  if (window.modalCtx?.timesheetMeta) {
    window.modalCtx.timesheetMeta.expected_timesheet_id = resolvedId;
  }

  // âœ… Keep the summary grid consistent
  try {
    if (typeof refreshTimesheetsSummaryAfterRotation === 'function') {
      await refreshTimesheetsSummaryAfterRotation(resolvedId);
    }
  } catch (e) {
    L('summary refresh failed (non-fatal)', e);
  }

  L('UPDATED ROW', updatedRow);
  GE();
  return { ok: true, updatedRow, details: newDetails };
}


async function updateTimesheetSegmentsPayFlags(ctxOrId, overrides, expectedTimesheetId) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][SEGMENTS]');
  GC('updateTimesheetSegmentsPayFlags');

  const mc  = window.modalCtx || {};
  const row = (mc.data && mc.data.timesheet_id) ? mc.data : (ctxOrId && ctxOrId.row ? ctxOrId.row : {});
  const tsId0 = (typeof ctxOrId === 'string') ? ctxOrId : (row.timesheet_id || row.id || mc.data?.id || null);

  if (!tsId0) {
    L('ERROR: missing timesheetId');
    GE();
    throw new Error('updateTimesheetSegmentsPayFlags: timesheetId is required');
  }

  const expected =
    (expectedTimesheetId != null ? String(expectedTimesheetId) : '') ||
    (mc.timesheetMeta && mc.timesheetMeta.expected_timesheet_id) ||
    tsId0;

  const det = mc.timesheetDetails || {};
  if (!det.isSegmentsMode || !Array.isArray(det.segments)) {
    L('NOT SEGMENTS MODE, no-op', { isSegmentsMode: det.isSegmentsMode });
    GE();
    return { ok: true };
  }

  const overridesMap = overrides || (mc.timesheetState && mc.timesheetState.segmentOverrides) || {};
  const segIds = Object.keys(overridesMap);
  if (!segIds.length) {
    L('no overrides to apply, no-op');
    GE();
    return { ok: true };
  }

  const segmentsPayload = segIds.map(segId => ({
    segment_id: segId,
    exclude_from_pay: !!overridesMap[segId].exclude_from_pay
  }));

  // Guarded TSFIN segments endpoint
  const encId   = encodeURIComponent(tsId0);
  const urlPath = `/api/tsfin/${encId}/segments`;

  L('REQUEST', {
    url: API(urlPath),
    expected_timesheet_id: expected,
    count: segmentsPayload.length,
    segmentsPayload
  });

  // âœ… Use apiPatchJson so 409 errors preserve err.status + err.json for TIMESHEET_MOVED handling upstream
  const json = await apiPatchJson(urlPath, { expected_timesheet_id: expected, segments: segmentsPayload });

  L('segment overrides applied', json);

  // âœ… Adopt current id if backend returned it
  const resolvedId =
    (json && (json.current_timesheet_id || json.timesheet_id))
      ? (json.current_timesheet_id || json.timesheet_id)
      : tsId0;

  // Refresh details using resolved id
  let newDetails = det;
  try {
    newDetails = await fetchTimesheetDetails(resolvedId);
    window.modalCtx.timesheetDetails = newDetails;

    if (window.modalCtx.timesheetState) {
      window.modalCtx.timesheetState.segmentOverrides = {};
    }

    L('details refreshed after segments', {
      newTotalPay: newDetails.tsfin?.total_pay_ex_vat,
      newTotalCharge: newDetails.tsfin?.total_charge_ex_vat
    });
  } catch (err) {
    L('refresh details failed (non-fatal)', err);
  }

  // Update row totals + id
  const tsfin = newDetails?.tsfin || {};
  const updatedRow = {
    ...(mc.data || row),
    total_pay_ex_vat: tsfin.total_pay_ex_vat ?? mc.data?.total_pay_ex_vat,
    total_charge_ex_vat: tsfin.total_charge_ex_vat ?? mc.data?.total_charge_ex_vat,
    margin_ex_vat: tsfin.margin_ex_vat ?? mc.data?.margin_ex_vat,
    timesheet_id: resolvedId,
    id: resolvedId
  };

  window.modalCtx.data = updatedRow;

  // Keep expected aligned to the new current id
  if (window.modalCtx?.timesheetMeta) {
    window.modalCtx.timesheetMeta.expected_timesheet_id = resolvedId;
  }

  try {
    window.__pendingFocus = {
      section: 'timesheets',
      ids: [String(resolvedId)],
      primaryIds: [String(resolvedId)]
    };
  } catch {}

  // âœ… Keep the summary grid consistent
  try {
    if (typeof refreshTimesheetsSummaryAfterRotation === 'function') {
      await refreshTimesheetsSummaryAfterRotation(resolvedId);
    }
  } catch (e) {
    L('summary refresh failed (non-fatal)', e);
  }

  L('UPDATED ROW', updatedRow);
  GE();
  return { ok: true, updatedRow, details: newDetails };
}

async function manualUpsertContractWeek(weekId, payload) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][MANUAL-UPsert]');
  GC('manualUpsertContractWeek');

  if (!weekId) {
    GE();
    throw new Error('manualUpsertContractWeek: weekId is required');
  }

  const mc = window.modalCtx || {};

  // Detect whether this call is operating on an existing timesheet (so expected_timesheet_id should be sent)
  const hasTs =
    !!(payload && payload.expected_timesheet_id != null) ||
    !!(mc.timesheetMeta && mc.timesheetMeta.hasTs) ||
    !!(mc.data && mc.data.timesheet_id) ||
    !!(mc.timesheetDetails && mc.timesheetDetails.timesheet && mc.timesheetDetails.timesheet.timesheet_id);

  // Parse schedule if provided as a JSON string (weekly manual schedule-driven)
  const normaliseScheduleField = (x) => {
    if (x == null) return x;
    if (Array.isArray(x) || typeof x === 'object') return x;
    if (typeof x === 'string') {
      try {
        const p = JSON.parse(x);
        if (Array.isArray(p) || typeof p === 'object') return p;
      } catch {}
    }
    return x;
  };

  // âœ… Ensure expected_timesheet_id is included ONLY when we truly have a timesheet
  const inferredExpected =
    (payload && payload.expected_timesheet_id != null ? String(payload.expected_timesheet_id) : '') ||
    (hasTs ? ((mc.timesheetMeta && mc.timesheetMeta.expected_timesheet_id) || '') : '') ||
    (hasTs ? ((mc.data && mc.data.timesheet_id) || '') : '') ||
    (hasTs ? ((mc.timesheetDetails && mc.timesheetDetails.timesheet && mc.timesheetDetails.timesheet.timesheet_id) || '') : '') ||
    '';

  const safePayload = {
    ...(payload || {})
  };

  if (Object.prototype.hasOwnProperty.call(safePayload, 'actual_schedule_json')) {
    safePayload.actual_schedule_json = normaliseScheduleField(safePayload.actual_schedule_json);
  }

  if (inferredExpected) {
    safePayload.expected_timesheet_id = inferredExpected;
  } else {
    if (Object.prototype.hasOwnProperty.call(safePayload, 'expected_timesheet_id')) {
      delete safePayload.expected_timesheet_id;
    }
  }

  const encId   = encodeURIComponent(weekId);
  const urlPath = `/api/contract-weeks/${encId}/manual-upsert`;

  L('REQUEST', { url: API(urlPath), weekId, payload: safePayload });

  // âœ… Use apiPostJson so 409 errors preserve err.status + err.json for TIMESHEET_MOVED handling upstream
  const json = await apiPostJson(urlPath, safePayload);

  L('RESULT', json);

  // âœ… If backend returns a (new) current timesheet id, align modal ctx + expected + summary
  const resolvedId =
    (json && (json.current_timesheet_id || json.timesheet_id))
      ? (json.current_timesheet_id || json.timesheet_id)
      : null;

  if (resolvedId && window.modalCtx && window.modalCtx.data) {
    window.modalCtx.data = {
      ...(window.modalCtx.data || {}),
      timesheet_id: resolvedId,
      id: resolvedId
    };
    if (window.modalCtx.timesheetMeta) {
      window.modalCtx.timesheetMeta.expected_timesheet_id = resolvedId;
      window.modalCtx.timesheetMeta.hasTs = true;
      window.modalCtx.timesheetMeta.isPlannedWeek = false;
    }
    try {
      if (window.modalCtx.timesheetDetails && window.modalCtx.timesheetDetails.timesheet) {
        window.modalCtx.timesheetDetails.timesheet.timesheet_id = resolvedId;
      }
    } catch {}

    try {
      window.__pendingFocus = {
        section: 'timesheets',
        ids: [String(resolvedId)],
        primaryIds: [String(resolvedId)]
      };
    } catch {}

    try {
      if (typeof refreshTimesheetsSummaryAfterRotation === 'function') {
        await refreshTimesheetsSummaryAfterRotation(resolvedId);
      }
    } catch (e) {
      L('summary refresh failed (non-fatal)', e);
    }
  }

  GE();
  return json;
}





async function deferNhspShift(shiftId, runAtIso = null) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][NHSP-DEFER]');
  GC('deferNhspShift');

  if (!shiftId) {
    L('ERROR: missing shiftId');
    GE();
    throw new Error('deferNhspShift: shiftId is required');
  }

  const encId = encodeURIComponent(shiftId);
  const url   = API(`/api/nhsp/shifts/${encId}/defer`);

  const body = {};
  if (runAtIso) body.run_at = runAtIso;

  L('REQUEST', { url, body });

  let res, text;
  try {
    res  = await authFetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body)
    });
    text = await res.text();
  } catch (err) {
    L('network error', err);
    GE();
    throw err;
  }

  if (!res.ok) {
    L('server error', { status: res.status, bodyPreview: text.slice(0, 400) });
    GE();
    throw new Error(text || `Failed to defer NHSP shift ${shiftId}`);
  }

  let json = {};
  try { json = text ? JSON.parse(text) : {}; } catch (err) {
    L('parse error', err);
  }

  L('defer result', json);
  GE();
  return { ok: true, result: json };
}


async function saveNhspDeferrals(ctxOrId, deferrals) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][NHSP-SAVE]');
  GC('saveNhspDeferrals');

  const mc  = window.modalCtx || {};
  const row = (mc.data && mc.data.timesheet_id) ? mc.data : (ctxOrId && ctxOrId.row ? ctxOrId.row : {});
  const tsId = (typeof ctxOrId === 'string') ? ctxOrId : (row.timesheet_id || row.id || mc.data?.id || null);

  const map = deferrals || (mc.timesheetState && mc.timesheetState.nhspDeferrals) || {};
  const shiftIds = Object.keys(map || {});
  if (!shiftIds.length) {
    L('no NHSP deferrals staged, no-op');
    GE();
    return { ok: true };
  }

  L('staged deferrals', map);

  for (const shiftId of shiftIds) {
    const cfg = map[shiftId] || {};
    const runAtIso = cfg.defer_until_run_after || null;
    try {
      await deferNhspShift(shiftId, runAtIso);
    } catch (err) {
      L('deferNhspShift failed', { shiftId, err });
      GE();
      throw err;
    }
  }

  // After deferring, refresh details so shifts/validations reflect new status
  if (tsId) {
    try {
      const newDetails = await fetchTimesheetDetails(tsId);
      window.modalCtx.timesheetDetails = newDetails;
      if (mc.timesheetState) {
        mc.timesheetState.nhspDeferrals = {};
      }
      L('details refreshed after NHSP deferrals', {
        shiftsCount: (newDetails.shifts || []).length
      });
    } catch (err) {
      L('refresh details failed (non-fatal)', err);
    }
  }

  GE();
  return { ok: true };
}

async function listTimesheetsSummary(filters = {}) {
  window.__listState = window.__listState || {};
  const st = (window.__listState['timesheets'] ||= {
    page: 1,
    pageSize: 50,
    total: null,
    hasMore: false,
    filters: {},
    sort: { key: null, dir: 'asc' }
  });

  const pageRaw     = st.page || 1;
  const pageSizeRaw = st.pageSize || 50;
  const page        = Number(pageRaw) || 1;
  const pageSize    = (pageSizeRaw === 'ALL')
    ? 200
    : Number(pageSizeRaw) || 50;

  const qs = new URLSearchParams();
  qs.set('page', String(page));
  qs.set('page_size', String(pageSize));

  // âœ… Totals must reflect ALL rows matching filters (not just this page)
  qs.set('include_totals', 'true');

  // Work on a safe copy
  const f0 = (filters && typeof filters === 'object') ? filters : {};
  const f = { ...(f0 || {}) };

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Canonical filters:
  // - tools_stage (5-stage classification)
  // - issues_filter (issue category)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  try {
    // Drop removed legacy flags
    if (Object.prototype.hasOwnProperty.call(f, 'client_invoiced')) delete f.client_invoiced;
    if (Object.prototype.hasOwnProperty.call(f, 'needs_attention')) delete f.needs_attention;

    // Migrate legacy stage keys only for safe values
    if (!Object.prototype.hasOwnProperty.call(f, 'tools_stage')) {
      const legacyTsStage = Object.prototype.hasOwnProperty.call(f, 'ts_stage')
        ? String(f.ts_stage || '').trim().toUpperCase()
        : '';
      const legacySumStage = Object.prototype.hasOwnProperty.call(f, 'summary_stage')
        ? String(f.summary_stage || '').trim().toUpperCase()
        : '';

      const legacy = legacyTsStage || legacySumStage;
      if (legacy === 'UNPROCESSED') f.tools_stage = 'UNPROCESSED';
      else if (legacy === 'INVOICED') f.tools_stage = 'INVOICED';
    }

    // Always remove legacy keys from the effective snapshot
    if (Object.prototype.hasOwnProperty.call(f, 'ts_stage')) delete f.ts_stage;
    if (Object.prototype.hasOwnProperty.call(f, 'summary_stage')) delete f.summary_stage;
    if (Object.prototype.hasOwnProperty.call(f, 'processing_status')) delete f.processing_status;

    // Migrate legacy status_code to issues_filter only when it maps cleanly
    if (!Object.prototype.hasOwnProperty.call(f, 'issues_filter')) {
      const sc = Object.prototype.hasOwnProperty.call(f, 'status_code')
        ? String(f.status_code || '').trim().toUpperCase()
        : '';

      if (sc === 'NO_MATCH_ID') f.issues_filter = 'NO_MATCH_ID';
      else if (sc === 'RATE_MISSING') f.issues_filter = 'RATE_MISSING';
      else if (sc === 'PAY_CHAN_MISS') f.issues_filter = 'PAY_CHAN_MISS';
      else if (sc === 'HR_HOURS_MISMATCH') f.issues_filter = 'HR_HOURS_MISMATCH';
      else if (sc === 'READY_FOR_HR') f.issues_filter = 'AWAITING_HR_VALIDATION';
    }

    if (Object.prototype.hasOwnProperty.call(f, 'status_code')) delete f.status_code;

    // Normalise tools_stage
    const allowedStages = new Set([
      'ALL',
      'UNPROCESSED',
      'PROCESSING_DELAYED',
      'AWAITING_AUTHORISATION',
      'AUTHORISED_FOR_INVOICING',
      'INVOICED'
    ]);

    if (Object.prototype.hasOwnProperty.call(f, 'tools_stage')) {
      const ts = String(f.tools_stage || '').trim().toUpperCase();
      if (!ts || !allowedStages.has(ts)) {
        f.tools_stage = 'ALL';
      } else {
        f.tools_stage = ts;
      }
    }
  } catch {
    // non-fatal
    try { delete f.ts_stage; } catch {}
    try { delete f.summary_stage; } catch {}
    try { delete f.processing_status; } catch {}
    try { delete f.client_invoiced; } catch {}
    try { delete f.needs_attention; } catch {}
  }

  // Tools Stage filter
  const toolsStage = String(f.tools_stage || '').toUpperCase();
  if (toolsStage && toolsStage !== 'ALL') qs.set('tools_stage', toolsStage);

  // Issues filter (main summary Issues dropdown)
  const issues = String(f.issues_filter || '').toUpperCase();
  if (issues && issues !== 'ALL') qs.set('issues_filter', issues);

  // Route filter (aggregated: ELECTRONIC / MANUAL / NHSP / HEALTHROSTER / QR)
  const route = String(f.route_type || '').toUpperCase();
  if (route && route !== 'ALL') {
    if (route === 'QR') {
      qs.set('is_qr', 'true');
    } else {
      qs.set('route_type', route);
    }
  }

  // Scope filter
  const scope = String(f.sheet_scope || '').toUpperCase();
  if (scope && scope !== 'ALL') qs.set('sheet_scope', scope);

  // QR status filter (optional)
  const qrStatus = String(f.qr_status || '').toUpperCase();
  if (qrStatus) qs.set('qr_status', qrStatus);

  // Week ending range
  if (f.week_ending_from) qs.set('week_ending_from', String(f.week_ending_from).slice(0, 10));
  if (f.week_ending_to)   qs.set('week_ending_to',   String(f.week_ending_to).slice(0, 10));

  // Tools checkboxes
  if (f.is_adjusted === true)    qs.set('is_adjusted', 'true');
  if (f.is_qr === true)          qs.set('is_qr', 'true');
  if (f.candidate_paid === true) qs.set('candidate_paid', 'true');

  // Power filter passthrough (optional)
  if (f.hr_issue) qs.set('hr_issue', f.hr_issue);

  const sortState = st.sort || { key: null, dir: 'asc' };
  const sortKeyRaw = String(sortState.key || '').toLowerCase();
  const sortDir    = (sortState.dir === 'desc') ? 'desc' : 'asc';

  const sortMap = {
    week_ending_date:          'week_ending_date',
    client_name:               'client_name',
    candidate_name:            'candidate_name',
    tools_stage:               'tools_stage',
    processing_status:         'processing_status_display',
    processing_status_display: 'processing_status_display',
    route_type:                'route_type',
    sheet_scope:               'sheet_scope',
    total_pay_ex_vat:          'total_pay_ex_vat',
    total_charge_ex_vat:       'total_charge_ex_vat',
    margin_ex_vat:             'margin_ex_vat',
    pay:                       'total_pay_ex_vat',
    charge:                    'total_charge_ex_vat',
    margin:                    'margin_ex_vat'
  };

  const orderBy = sortMap[sortKeyRaw] || 'week_ending_date';
  qs.set('order_by', orderBy);
  qs.set('order_dir', sortDir);

  const url = `/api/timesheets/summary?${qs.toString()}`;

  const res  = await authFetch(API(url));
  const text = await res.text();
  if (!res.ok) {
    throw new Error(text || `Failed to fetch timesheets summary (${res.status})`);
  }

  let json;
  try { json = text ? JSON.parse(text) : {}; } catch { json = {}; }

  const rows  = Array.isArray(json.items) ? json.items : (Array.isArray(json.rows) ? json.rows : []);

  // âœ… total: tolerate multiple server keys
  const total =
    (typeof json.total === 'number') ? json.total
    : (typeof json.count === 'number') ? json.count
    : (typeof json.count_all === 'number') ? json.count_all
    : rows.length;

  const totals = (json && typeof json.totals === 'object' && json.totals) ? json.totals : null;

  rows.forEach(r => {
    if (!r.id && r.timesheet_id) {
      r.id = r.timesheet_id;
    } else if (!r.id && !r.timesheet_id && r.contract_week_id) {
      r.id = r.contract_week_id;
    }
  });

  // âœ… hasMore: use total when available (correct), else fallback to "full page" heuristic
  const hasMore =
    (typeof total === 'number')
      ? ((page * pageSize) < total)
      : (rows.length === pageSize);

  st.hasMore = hasMore;
  st.total   = (typeof total === 'number') ? total : null;
  st.totals  = totals;

  // âœ… Persist effective filters WITHOUT legacy keys
  st.filters = { ...(f || {}) };

  return rows;
}



// ======== Switch a timesheet to MANUAL (weekly) ========
async function switchTimesheetToManual(timesheetId, expectedTimesheetId) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][SWITCH-MANUAL]');
  GC('switchTimesheetToManual');

  if (!timesheetId) {
    GE();
    throw new Error('switchTimesheetToManual: timesheetId is required');
  }

  const mc = window.modalCtx || {};
  const expected =
    (expectedTimesheetId != null ? String(expectedTimesheetId) : '') ||
    (mc.timesheetMeta && mc.timesheetMeta.expected_timesheet_id) ||
    String(timesheetId);

  const encId   = encodeURIComponent(timesheetId);
  const urlPath = `/api/timesheets/${encId}/switch-to-manual`;

  const payload = { expected_timesheet_id: expected };

  L('REQUEST', { url: API(urlPath), timesheetId, payload });

  // âœ… Use apiPostJson so 409 errors preserve err.status + err.json for TIMESHEET_MOVED handling
  const json = await apiPostJson(urlPath, payload);

  const newId =
    (json && (json.current_timesheet_id || json.new_timesheet_id || json.timesheet_id))
      ? (json.current_timesheet_id || json.new_timesheet_id || json.timesheet_id)
      : null;

  const resolvedId = (newId && String(newId).trim()) ? String(newId) : String(timesheetId);

  // Refresh details in modal if open on this TS
  try {
    if (window.modalCtx && window.modalCtx.data) {
      const cur = window.modalCtx.data.timesheet_id || window.modalCtx.data.id || null;
      const isSame = String(cur || '') === String(timesheetId || '');

      if (isSame) {
        if (String(resolvedId) !== String(cur || '')) {
          window.modalCtx.data.timesheet_id = resolvedId;
          window.modalCtx.data.id = resolvedId;
        }

        const fresh = await fetchTimesheetDetails(resolvedId);
        window.modalCtx.timesheetDetails = fresh;

        try {
          if (window.modalCtx.data) window.modalCtx.data.submission_mode = 'MANUAL';
        } catch {}

        if (window.modalCtx.timesheetMeta && typeof window.modalCtx.timesheetMeta === 'object') {
          window.modalCtx.timesheetMeta.expected_timesheet_id = resolvedId;
          window.modalCtx.timesheetMeta.hasTs = true;
        }
      }
    }
  } catch {}

  try {
    window.__pendingFocus = {
      section: 'timesheets',
      ids: [String(resolvedId)],
      primaryIds: [String(resolvedId)]
    };
  } catch {}

  // âœ… Keep the summary grid consistent
  try {
    if (typeof refreshTimesheetsSummaryAfterRotation === 'function') {
      await refreshTimesheetsSummaryAfterRotation(resolvedId);
    }
  } catch (e) {
    L('summary refresh failed (non-fatal)', e);
  }

  L('RESULT', { json, resolvedId });
  GE();
  return json;
}

async function revertTimesheetToElectronic(timesheetId, expectedTimesheetId) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][REVERT-ELEC]');
  GC('revertTimesheetToElectronic');

  if (!timesheetId) {
    GE();
    throw new Error('revertTimesheetToElectronic: timesheetId is required');
  }

  const mc = window.modalCtx || {};
  const expected =
    (expectedTimesheetId != null ? String(expectedTimesheetId) : '') ||
    (mc.timesheetMeta && mc.timesheetMeta.expected_timesheet_id) ||
    String(timesheetId);

  const encId   = encodeURIComponent(timesheetId);
  const urlPath = `/api/timesheets/${encId}/revert-to-electronic`;

  const payload = { expected_timesheet_id: expected };

  L('REQUEST', { url: API(urlPath), timesheetId, payload });

  // âœ… Use apiPostJson so 409 errors preserve err.status + err.json for TIMESHEET_MOVED handling
  const json = await apiPostJson(urlPath, payload);

  const newId =
    (json && (json.current_timesheet_id || json.new_timesheet_id || json.timesheet_id))
      ? (json.current_timesheet_id || json.new_timesheet_id || json.timesheet_id)
      : null;

  const resolvedId = (newId && String(newId).trim()) ? String(newId) : String(timesheetId);

  // If modal is open on this TS, refresh using returned current id
  try {
    if (window.modalCtx && window.modalCtx.data) {
      const cur = window.modalCtx.data.timesheet_id || window.modalCtx.data.id || null;
      const isSame = String(cur || '') === String(timesheetId || '');

      if (isSame) {
        if (String(resolvedId) !== String(cur || '')) {
          window.modalCtx.data.timesheet_id = resolvedId;
          window.modalCtx.data.id = resolvedId;
        }

        const fresh = await fetchTimesheetDetails(resolvedId);
        window.modalCtx.timesheetDetails = fresh;

        try {
          if (window.modalCtx.data) window.modalCtx.data.submission_mode = 'ELECTRONIC';
        } catch {}

        if (window.modalCtx.timesheetMeta && typeof window.modalCtx.timesheetMeta === 'object') {
          window.modalCtx.timesheetMeta.expected_timesheet_id = resolvedId;
          window.modalCtx.timesheetMeta.hasTs = true;
        }
      }
    }
  } catch {}

  try {
    window.__pendingFocus = {
      section: 'timesheets',
      ids: [String(resolvedId)],
      primaryIds: [String(resolvedId)]
    };
  } catch {}

  // âœ… Keep the summary grid consistent
  try {
    if (typeof refreshTimesheetsSummaryAfterRotation === 'function') {
      await refreshTimesheetsSummaryAfterRotation(resolvedId);
    }
  } catch (e) {
    L('summary refresh failed (non-fatal)', e);
  }

  L('RESULT', { json, resolvedId });
  GE();
  return json;
}


async function deleteManualTimesheetAndReopenWeek(timesheetId, contractWeekId) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][DELETE-REOPEN]');
  GC('deleteManualTimesheetAndReopenWeek');

  if (!contractWeekId) {
    GE();
    throw new Error('deleteManualTimesheetAndReopenWeek: contractWeekId is required');
  }

  const encWeekId = encodeURIComponent(contractWeekId);
  const urlPath   = `/api/contract-weeks/${encWeekId}/timesheet`;

  const expected =
    window.modalCtx?.timesheetMeta?.expected_timesheet_id ||
    timesheetId ||
    null;

  L('REQUEST', { urlPath, timesheetId, contractWeekId, expected });

  // âœ… Delete with JSON body so backend can guard against rotation
  const json = await apiDeleteJson(urlPath, { expected_timesheet_id: expected });

  L('RESULT', json);
  GE();
  return json;
}


async function deleteTimesheetPermanent(timesheetId, opts = {}) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][DELETE-PERM]');
  GC('deleteTimesheetPermanent');

  // opts:
  // - contractWeekId: if provided and timesheetId is null, we treat this as a planned-week delete
  const contractWeekId = opts && opts.contractWeekId ? String(opts.contractWeekId) : null;

  // Planned-week delete path (no timesheet_id yet)
  if (!timesheetId) {
    if (!contractWeekId) {
      GE();
      throw new Error('deleteTimesheetPermanent: timesheetId is required (or provide opts.contractWeekId for planned-week delete)');
    }

    const encCw = encodeURIComponent(contractWeekId);
    const urlPath = `/api/contract-weeks/${encCw}/delete-planned`;

    L('REQUEST (planned delete)', { urlPath, contractWeekId });

    // Keep behaviour, but use apiPostJson for consistent error shape
    const json = await apiPostJson(urlPath, {});
    L('RESULT (planned delete)', json);
    GE();
    return json;
  }

  // Normal timesheet delete path (âœ… guarded)
  const encId = encodeURIComponent(timesheetId);
  const urlPath = `/api/timesheets/${encId}`;

  const expected =
    window.modalCtx?.timesheetMeta?.expected_timesheet_id ||
    timesheetId;

  L('REQUEST', { urlPath, timesheetId, expected });

  const json = await apiDeleteJson(urlPath, { expected_timesheet_id: expected });

  L('RESULT', json);
  GE();
  return json;
}
async function resendQrTimesheetEmail(timesheetId) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][QR][RESEND]');
  GC('resendQrTimesheetEmail');

  if (!timesheetId) {
    GE();
    throw new Error('resendQrTimesheetEmail: timesheetId is required');
  }

  // Small local toast helper (non-fatal if not present)
  const toast = (msg) => {
    try {
      if (typeof window.toast === 'function') return window.toast(msg);
      if (typeof window.showToast === 'function') return window.showToast(msg);
      if (typeof window.notify === 'function') return window.notify(msg);
      console.log('[TS][TOAST]', msg);
    } catch {}
  };

  const postOnce = async (id, expectedId) => {
    const encId = encodeURIComponent(id);
    const urlPath = `/api/timesheets/${encId}/qr-resend`;
    L('REQUEST', { urlPath, timesheetId: id, expected: expectedId });
    // âœ… Use apiPostJson so 409 carries err.status + err.json (thrown)
    return apiPostJson(urlPath, { expected_timesheet_id: expectedId });
  };

  const adoptMovedId = (movedTo) => {
    try {
      const movedId = movedTo ? String(movedTo) : '';
      if (!movedId) return null;

      const mc = window.modalCtx;
      if (!mc) return movedId;

      mc.data ||= {};
      mc.timesheetMeta ||= {};

      mc.data.timesheet_id = movedId;
      mc.data.id = movedId;
      mc.timesheetMeta.expected_timesheet_id = movedId;

      return movedId;
    } catch {
      return null;
    }
  };

  const expected =
    window.modalCtx?.timesheetMeta?.expected_timesheet_id ||
    timesheetId;

  let json = null;
  let adoptedId = null;

  try {
    // First attempt
    json = await postOnce(timesheetId, expected);
  } catch (err) {
    // Handle a "moved" timesheet (rotation)
    const status = err?.status;
    const ej = err?.json || null;

    const movedTo =
      ej?.current_timesheet_id ||
      ej?.moved_to ||
      ej?.timesheet_id ||
      null;

    const isMoved =
      status === 409 &&
      (
        String(ej?.error || '').toUpperCase() === 'TIMESHEET_MOVED' ||
        String(ej?.code  || '').toUpperCase() === 'TIMESHEET_MOVED' ||
        !!(movedTo && String(movedTo) !== String(timesheetId))
      );

    if (isMoved) {
      adoptedId = adoptMovedId(movedTo) || movedTo;
      if (!adoptedId) {
        GE();
        throw err;
      }

      // Retry once with adopted id
      try {
        json = await postOnce(adoptedId, adoptedId);
      } catch (err2) {
        GE();
        throw err2;
      }
    } else {
      GE();
      throw err;
    }
  }

  // âœ… Defensive adoption on success (if backend returns current_timesheet_id)
  try {
    const movedTo = json?.current_timesheet_id || null;
    if (movedTo) adoptMovedId(movedTo);
  } catch {}

  L('RESULT', json);

  // âœ… Merge backend â€œaction hintsâ€ into modal state immediately (so Overview updates even if details fields lag)
  try {
    const mc = window.modalCtx;
    if (mc) {
      mc.timesheetDetails ||= {};
      const det = mc.timesheetDetails;

      // Ensure nested structures exist
      det.action_flags = (det.action_flags && typeof det.action_flags === 'object') ? det.action_flags : {};
      det.timesheet    = (det.timesheet && typeof det.timesheet === 'object') ? det.timesheet : {};

      // Persist â€œtruthâ€ signals the Overview uses
      if (typeof json?.qr_can_resend_same_hours === 'boolean') {
        det.action_flags.qr_can_resend_same_hours = json.qr_can_resend_same_hours;
      }

      if (json?.qr_last_sent_hash) {
        det.timesheet.qr_last_sent_hash = String(json.qr_last_sent_hash);
      }

      // If backend returned a current_hash, it can be useful for debugging (optional)
      if (json?.current_hash) det.action_flags.qr_current_hash = String(json.current_hash);

      // Keep details' top-level id fields aligned if present
      if (json?.current_timesheet_id) det.current_timesheet_id = String(json.current_timesheet_id);
      if (json?.timesheet_id) det.timesheet_id = String(json.timesheet_id);
    }
  } catch {}

  // -----------------------------
  // âœ… New backend response handling (result: NEW_ISSUED / RESENT / REISSUED)
  // -----------------------------
  try {
    const resultU = String(json?.result || '').toUpperCase();

    const isReissueRequired =
      String(json?.error || '').toUpperCase() === 'QR_CONTENT_CHANGED_REISSUE_REQUIRED' ||
      String(json?.code  || '').toUpperCase() === 'QR_CONTENT_CHANGED_REISSUE_REQUIRED';

    if (isReissueRequired) {
      toast('Hours have changed since the last QR was sent. Please send a new QR timesheet with current hours.');
    } else if (resultU === 'RESENT') {
      toast('QR timesheet resent with current hours.');
    } else if (resultU === 'NEW_ISSUED') {
      toast('New QR timesheet sent with current hours.');
    } else if (resultU === 'REISSUED') {
      toast('New QR timesheet sent with updated hours.');
    } else {
      toast('QR timesheet email queued.');
    }
  } catch {}

  // âœ… Always trigger a refresh/repaint after issuing/resending
  // Prefer to use the id that is now current.
  try {
    const idNow =
      window.modalCtx?.data?.timesheet_id ||
      json?.current_timesheet_id ||
      adoptedId ||
      timesheetId;

    const refresh = ensureTsRefreshAndRepaintOverview();
    if (typeof refresh === 'function') {
      await refresh('overview', idNow);
    } else {
      // Fallback: repaint current tab if helper isn't available
      const fr = window.__getModalFrame?.();
      if (fr?.setTab) {
        if ((fr.currentTabKey || '') === 'overview') await fr.setTab('lines');
        await fr.setTab('overview');
      }
    }
  } catch {}

  GE();
  return json;
}



async function refuseQrHours(timesheetId, expectedTimesheetId) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][QR][REFUSE]');
  GC('refuseQrHours');

  if (!timesheetId) {
    GE();
    throw new Error('refuseQrHours: timesheetId is required');
  }

  const reason = window.prompt('Reason for refusing this timesheet? (This will be emailed to the candidate)', '');
  if (reason == null) {
    GE();
    return { cancelled: true };
  }

  const reasonTrim = String(reason || '').trim();
  if (!reasonTrim) {
    GE();
    throw new Error('Refusal reason is required');
  }

  const mc = window.modalCtx || {};
  const expected =
    (expectedTimesheetId != null ? String(expectedTimesheetId) : '') ||
    (mc.timesheetMeta && mc.timesheetMeta.expected_timesheet_id) ||
    String(timesheetId);

  const encId   = encodeURIComponent(timesheetId);
  const urlPath = `/api/timesheets/${encId}/qr-refuse`;

  const payload = { reason: reasonTrim, expected_timesheet_id: expected };

  L('REQUEST', { url: API(urlPath), timesheetId, reasonPreview: reasonTrim.slice(0, 80), payload: { expected_timesheet_id: expected } });

  // âœ… Use apiPostJson so 409 errors preserve err.status + err.json for TIMESHEET_MOVED handling
  const json = await apiPostJson(urlPath, payload);

  // âœ… If backend produced a new "current" id, adopt it in the open modal
  const newId =
    (json && (json.current_timesheet_id || json.new_timesheet_id || json.timesheet_id))
      ? (json.current_timesheet_id || json.new_timesheet_id || json.timesheet_id)
      : null;

  const resolvedId = (newId && String(newId).trim()) ? String(newId) : String(timesheetId);

  // Refresh details in modal if open
  try {
    if (window.modalCtx && window.modalCtx.data) {
      const cur = window.modalCtx.data.timesheet_id || window.modalCtx.data.id || null;
      const isSame = String(cur || '') === String(timesheetId || '');

      if (isSame) {
        if (String(resolvedId) !== String(cur || '')) {
          window.modalCtx.data.timesheet_id = resolvedId;
          window.modalCtx.data.id = resolvedId;
        }

        // âœ… keep guarded-write expected id aligned
        if (window.modalCtx.timesheetMeta && typeof window.modalCtx.timesheetMeta === 'object') {
          window.modalCtx.timesheetMeta.expected_timesheet_id = resolvedId;
        }

        const fresh = await fetchTimesheetDetails(resolvedId);
        window.modalCtx.timesheetDetails = fresh;
      }
    }
  } catch {}

  try {
    window.__pendingFocus = {
      section: 'timesheets',
      ids: [String(resolvedId)],
      primaryIds: [String(resolvedId)]
    };
  } catch {}

  // âœ… Keep the summary grid consistent (these actions often rotate)
  try {
    if (typeof refreshTimesheetsSummaryAfterRotation === 'function') {
      await refreshTimesheetsSummaryAfterRotation(resolvedId);
    }
  } catch (e) {
    L('summary refresh failed (non-fatal)', e);
  }

  L('RESULT', { json, resolvedId });
  GE();
  return json;
}

async function restoreRevokedQr(timesheetId, kind, expectedTimesheetId) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][QR][RESTORE]');
  GC('restoreRevokedQr');

  if (!timesheetId) {
    GE();
    throw new Error('restoreRevokedQr: timesheetId is required');
  }

  const k = String(kind || '').toUpperCase();
  const restoreKind = (k === 'PENDING' || k === 'SIGNED') ? k : null;
  if (!restoreKind) {
    GE();
    throw new Error('restoreRevokedQr: kind must be PENDING or SIGNED');
  }

  const mc = window.modalCtx || {};
  const expected =
    (expectedTimesheetId != null ? String(expectedTimesheetId) : '') ||
    (mc.timesheetMeta && mc.timesheetMeta.expected_timesheet_id) ||
    String(timesheetId);

  const encId   = encodeURIComponent(timesheetId);
  const urlPath = `/api/timesheets/${encId}/qr-restore`;

  const payload = { kind: restoreKind, expected_timesheet_id: expected };

  L('REQUEST', { url: API(urlPath), timesheetId, payload });

  // âœ… Use apiPostJson so 409 errors preserve err.status + err.json for TIMESHEET_MOVED handling
  const json = await apiPostJson(urlPath, payload);

  const newId =
    (json && (json.current_timesheet_id || json.new_timesheet_id || json.timesheet_id))
      ? (json.current_timesheet_id || json.new_timesheet_id || json.timesheet_id)
      : null;

  const resolvedId = (newId && String(newId).trim()) ? String(newId) : String(timesheetId);

  // Refresh details in modal if open (use NEW current id if provided)
  try {
    if (window.modalCtx && window.modalCtx.data) {
      const cur = window.modalCtx.data.timesheet_id || window.modalCtx.data.id || null;
      const isSame = String(cur || '') === String(timesheetId || '');

      if (isSame) {
        if (String(resolvedId) !== String(cur || '')) {
          window.modalCtx.data.timesheet_id = resolvedId;
          window.modalCtx.data.id = resolvedId;
        }

        // âœ… keep guarded-write expected id aligned
        if (window.modalCtx.timesheetMeta && typeof window.modalCtx.timesheetMeta === 'object') {
          window.modalCtx.timesheetMeta.expected_timesheet_id = resolvedId;
          window.modalCtx.timesheetMeta.hasTs = true;
        }

        const fresh = await fetchTimesheetDetails(resolvedId);
        window.modalCtx.timesheetDetails = fresh;
      }
    }
  } catch {}

  try {
    window.__pendingFocus = {
      section: 'timesheets',
      ids: [String(resolvedId)],
      primaryIds: [String(resolvedId)]
    };
  } catch {}

  // âœ… Keep the summary grid consistent
  try {
    if (typeof refreshTimesheetsSummaryAfterRotation === 'function') {
      await refreshTimesheetsSummaryAfterRotation(resolvedId);
    }
  } catch (e) {
    L('summary refresh failed (non-fatal)', e);
  }

  L('RESULT', { json, resolvedId });
  GE();
  return json;
}


async function allowQrAgain(timesheetId, expectedTimesheetId) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][ALLOW][QR]');
  GC('allowQrAgain');

  if (!timesheetId) {
    GE();
    throw new Error('allowQrAgain: timesheetId is required');
  }

  const ok = window.confirm(
    'Allow QR submission again for this timesheet?\n\n' +
    'This will create a new current version and re-enable the QR route (Scenario 1).'
  );
  if (!ok) {
    GE();
    return { cancelled: true };
  }

  const mc = window.modalCtx || {};
  const expected =
    (expectedTimesheetId != null ? String(expectedTimesheetId) : '') ||
    (mc.timesheetMeta && mc.timesheetMeta.expected_timesheet_id) ||
    String(timesheetId);

  const encId   = encodeURIComponent(timesheetId);
  const urlPath = `/api/timesheets/${encId}/allow-qr-again`;

  const payload = { expected_timesheet_id: expected };

  L('REQUEST', { url: API(urlPath), timesheetId, payload });

  // âœ… Use apiPostJson so 409 errors preserve err.status + err.json for TIMESHEET_MOVED handling
  const json = await apiPostJson(urlPath, payload);

  const newId =
    (json && (json.current_timesheet_id || json.new_timesheet_id || json.timesheet_id))
      ? (json.current_timesheet_id || json.new_timesheet_id || json.timesheet_id)
      : null;

  const resolvedId = (newId && String(newId).trim()) ? String(newId) : String(timesheetId);

  // Refresh details in modal if open (use NEW current id if provided)
  try {
    if (window.modalCtx && window.modalCtx.data) {
      const cur = window.modalCtx.data.timesheet_id || window.modalCtx.data.id || null;
      const isSame = String(cur || '') === String(timesheetId || '');

      if (isSame) {
        if (String(resolvedId) !== String(cur || '')) {
          window.modalCtx.data.timesheet_id = resolvedId;
          window.modalCtx.data.id = resolvedId;
        }

        const fresh = await fetchTimesheetDetails(resolvedId);
        window.modalCtx.timesheetDetails = fresh;

        // âœ… keep guarded-write expected id aligned
        if (window.modalCtx.timesheetMeta && typeof window.modalCtx.timesheetMeta === 'object') {
          window.modalCtx.timesheetMeta.expected_timesheet_id = resolvedId;
          window.modalCtx.timesheetMeta.hasTs = true;
        }
      }
    }
  } catch {}

  try {
    window.__pendingFocus = {
      section: 'timesheets',
      ids: [String(resolvedId)],
      primaryIds: [String(resolvedId)]
    };
  } catch {}

  // âœ… Keep the summary grid consistent (id can change on rotation)
  try {
    if (typeof refreshTimesheetsSummaryAfterRotation === 'function') {
      await refreshTimesheetsSummaryAfterRotation(resolvedId);
    }
  } catch (e) {
    L('summary refresh failed (non-fatal)', e);
  }

  L('RESULT', { json, newId: resolvedId });
  GE();
  return json;
}


async function allowElectronicAgain(timesheetId, expectedTimesheetId) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][ALLOW][ELECTRONIC]');
  GC('allowElectronicAgain');

  if (!timesheetId) {
    GE();
    throw new Error('allowElectronicAgain: timesheetId is required');
  }

  const ok = window.confirm(
    'Allow electronic submission again for this timesheet?\n\n' +
    'This will create a new current ELECTRONIC version. The candidate will need to re-submit signatures/hours.'
  );
  if (!ok) {
    GE();
    return { cancelled: true };
  }

  const mc = window.modalCtx || {};
  const expected =
    (expectedTimesheetId != null ? String(expectedTimesheetId) : '') ||
    (mc.timesheetMeta && mc.timesheetMeta.expected_timesheet_id) ||
    String(timesheetId);

  const encId   = encodeURIComponent(timesheetId);
  const urlPath = `/api/timesheets/${encId}/allow-electronic-again`;

  const payload = { expected_timesheet_id: expected };

  L('REQUEST', { url: API(urlPath), timesheetId, payload });

  // âœ… Use apiPostJson so 409 errors preserve err.status + err.json for TIMESHEET_MOVED handling
  const json = await apiPostJson(urlPath, payload);

  const newId =
    (json && (json.current_timesheet_id || json.new_timesheet_id || json.timesheet_id))
      ? (json.current_timesheet_id || json.new_timesheet_id || json.timesheet_id)
      : null;

  const resolvedId = (newId && String(newId).trim()) ? String(newId) : String(timesheetId);

  // Refresh details in modal if open (use NEW current id if provided)
  try {
    if (window.modalCtx && window.modalCtx.data) {
      const cur = window.modalCtx.data.timesheet_id || window.modalCtx.data.id || null;
      const isSame = String(cur || '') === String(timesheetId || '');

      if (isSame) {
        if (String(resolvedId) !== String(cur || '')) {
          window.modalCtx.data.timesheet_id = resolvedId;
          window.modalCtx.data.id = resolvedId;
        }

        const fresh = await fetchTimesheetDetails(resolvedId);
        window.modalCtx.timesheetDetails = fresh;

        // âœ… keep guarded-write expected id aligned
        if (window.modalCtx.timesheetMeta && typeof window.modalCtx.timesheetMeta === 'object') {
          window.modalCtx.timesheetMeta.expected_timesheet_id = resolvedId;
          window.modalCtx.timesheetMeta.hasTs = true;
        }
      }
    }
  } catch {}

  try {
    window.__pendingFocus = {
      section: 'timesheets',
      ids: [String(resolvedId)],
      primaryIds: [String(resolvedId)]
    };
  } catch {}

  // âœ… Keep the summary grid consistent (id can change on rotation)
  try {
    if (typeof refreshTimesheetsSummaryAfterRotation === 'function') {
      await refreshTimesheetsSummaryAfterRotation(resolvedId);
    }
  } catch (e) {
    L('summary refresh failed (non-fatal)', e);
  }

  L('RESULT', { json, newId: resolvedId });
  GE();
  return json;
}



async function deletePlannedContractWeek(contractWeekId) {
  const { LOGM, L, GC, GE } = getTsLoggers('[TS][DELETE][PLANNED]');
  GC('deletePlannedContractWeek');

  if (!contractWeekId) {
    GE();
    throw new Error('deletePlannedContractWeek: contractWeekId is required');
  }

  const encId = encodeURIComponent(contractWeekId);
  const url = API(`/api/contract-weeks/${encId}/delete-planned`);

  L('REQUEST', { url, contractWeekId });

  let res;
  let text = '';
  try {
    res = await authFetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({})
    });
    text = await res.text().catch(() => '');
  } catch (err) {
    L('network error', err);
    GE();
    throw err;
  }

  if (!res.ok) {
    L('server error', { status: res.status, bodyPreview: (text || '').slice(0, 400) });
    GE();
    throw new Error(text || `Failed to delete planned contract week ${contractWeekId}`);
  }

  let json = {};
  try { json = text ? JSON.parse(text) : {}; } catch {}

  L('RESULT', json);
  GE();
  return json;
}































































// ===== Boot =====
async function renderAll(){
  // seed defaults for first login / first visit to section
  window.__listState = window.__listState || {};
  if (!window.__listState[currentSection]) {
    window.__listState[currentSection] = {
      page: 1,
      pageSize: 50,
      total: null,
      hasMore: false,
      filters: null,
      sort: { key: null, dir: 'asc' }
    };
  }
  renderTopNav();
  renderTools();
  const data = await loadSection();
  renderSummary(data);
}

async function bootstrapApp(){
  // Belt & braces: if loadSession() ran but globals are not mirrored, mirror now
  try {
    if (typeof window !== 'undefined') {
      if (window.SESSION !== SESSION) window.SESSION = SESSION;
      window.__auth = window.__auth || {};
      if (!window.__auth.user && SESSION?.user) window.__auth.user = SESSION.user;
      if (!window.__USER_ID && SESSION?.user?.id) window.__USER_ID = SESSION.user.id;
    }

    // If token exists but user.id is missing, hydrate via /api/me (non-blocking safety)
    if (SESSION?.accessToken && (!SESSION.user || !SESSION.user.id)) {
      try {
        const meRes = await fetch(API('/api/me'), { headers: { 'Authorization': `Bearer ${SESSION.accessToken}` } });
        if (meRes.ok) {
          const meJson = await meRes.json().catch(()=> ({}));
          const profile = meJson && (meJson.user || meJson);
          if (profile && profile.id) {
            saveSession({ ...SESSION, user: profile }); // also re-mirrors globals
          }
        }
      } catch {}
    }
  } catch {}

  ensureSelectionStyles();   // â† ensure the highlight is clearly visible
  renderTopNav();
  renderTools();
  await renderAll();
}


// Initialize
initAuthUI();
if (loadSession()) { scheduleRefresh(); bootstrapApp(); }
else openLogin();
